'use strict';

var miniprogram = require('@galacean/engine/dist/miniprogram');
var engineMiniprogramAdapter = require('@galacean/engine-miniprogram-adapter');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

var requestSize = 0;
function hookRequest() {
    var originalSend = engineMiniprogramAdapter.XMLHttpRequest.prototype.send;
    var cacheMap = new Map();
    function addRequestSize(url, size) {
        if (cacheMap.get(url) == undefined) {
            cacheMap.set(url, size);
            requestSize += size;
        }
    }
    engineMiniprogramAdapter.XMLHttpRequest.prototype.send = function(body) {
        this.addEventListener("load", function() {
            var size = 0;
            if (this.responseType === "" || this.responseType === "text") {
                size = new engineMiniprogramAdapter.Blob([
                    JSON.stringify(this.responseText)
                ]).size;
            } else if (_instanceof(this.response, engineMiniprogramAdapter.Blob)) {
                size = this.response.size;
            } else if (_instanceof(this.response, ArrayBuffer)) {
                size = this.response.byteLength;
            } else if (this.responseType === "json") {
                size = new engineMiniprogramAdapter.Blob([
                    JSON.stringify(this.response)
                ]).size;
            }
            addRequestSize(this.responseURL, size);
        }, false);
        originalSend.call(this, body);
        var originalImageSrc = Object.getOwnPropertyDescriptor(engineMiniprogramAdapter.Image.prototype, "src").set;
        this.originalImageSrc = originalImageSrc;
        Object.defineProperty(engineMiniprogramAdapter.Image.prototype, "src", {
            set: function set(value) {
                var _this = this;
                fetch(value).then(function(response) {
                    if (response.ok) {
                        response.blob().then(function(blob) {
                            addRequestSize(_this.responseURL, blob.size);
                        });
                    }
                });
                originalImageSrc.call(this, value);
            }
        });
    };
}
var RequestHook = /*#__PURE__*/ function() {
    function RequestHook() {
        this._hooked = false;
        this._hooked = true;
    }
    var _proto = RequestHook.prototype;
    _proto.reset = function reset() {
        requestSize = 0;
    };
    _proto.release = function release() {
        if (this._hooked) {
            engineMiniprogramAdapter.XMLHttpRequest.prototype.send = this._originalSend;
            Object.defineProperty(engineMiniprogramAdapter.Image.prototype, "src", {
                set: function set(value) {
                    this.src.call(this, value);
                }
            });
        }
        this._hooked = false;
    };
    _create_class(RequestHook, [
        {
            key: "size",
            get: function get() {
                return formatNumber(requestSize / 1024 / 1024);
            }
        }
    ]);
    return RequestHook;
}();
function formatNumber(num) {
    return Number(num).toFixed(Math.max(6 - num.toString().split(".")[0].length, 0));
}

function log() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    var _Logger;
    (_Logger = miniprogram.Logger).info.apply(_Logger, [].concat([
        "\uD83D\uDE80 [galacean engine--stats]"
    ], args));
}
function errorLog() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    var _Logger;
    (_Logger = miniprogram.Logger).error.apply(_Logger, [].concat([
        "\uD83D\uDE80 [galacean engine-stats]"
    ], args));
}

var DrawCallHook = /*#__PURE__*/ function() {
    function DrawCallHook(gl) {
        this.drawCall = 0;
        this.triangles = 0;
        this.lines = 0;
        this.points = 0;
        this.realDrawElements = gl.drawElements;
        this.realDrawArrays = gl.drawArrays;
        gl.drawElements = this.hookedDrawElements.bind(this);
        gl.drawArrays = this.hookedDrawArrays.bind(this);
        var hasInstancedFunc = this.hasInstancedFunction(gl);
        if (hasInstancedFunc) {
            // @ts-ignore
            this.realDrawElementsInstanced = gl.drawElementsInstanced;
            // @ts-ignore
            this.realDrawArraysInstanced = gl.drawArraysInstanced;
            // @ts-ignore
            gl.drawElementsInstanced = this.hookedDrawElementsInstanced.bind(this);
            // @ts-ignore
            gl.drawArraysInstanced = this.hookedDrawArraysInstanced.bind(this);
        } else {
            var extAngleInstancedArrays = gl.getExtension("ANGLE_instanced_arrays");
            if (extAngleInstancedArrays) {
                this.realDrawElementsInstanced = extAngleInstancedArrays.drawElementsInstancedANGLE;
                this.realDrawArraysInstanced = extAngleInstancedArrays.drawArraysInstancedANGLE;
                extAngleInstancedArrays.drawElementsInstancedANGLE = this.hookedDrawElementsInstanced.bind(this);
                extAngleInstancedArrays.drawArraysInstancedANGLE = this.hookedDrawArraysInstanced.bind(this);
            } else {
                errorLog("GPU Instancing is not supported.");
            }
        }
        this.hooked = true;
        this.gl = gl;
        log("DrawCall is hooked.");
    }
    var _proto = DrawCallHook.prototype;
    _proto.hasInstancedFunction = function hasInstancedFunction(gl) {
        return _instanceof(gl, engineMiniprogramAdapter.WebGL2RenderingContext) || gl.hasOwnProperty("drawElementsInstanced") && gl.hasOwnProperty("drawArraysInstanced");
    };
    _proto.hookedDrawElements = function hookedDrawElements(mode, count, type, offset) {
        this.realDrawElements.call(this.gl, mode, count, type, offset);
        this.update(count, mode);
    };
    _proto.hookedDrawArrays = function hookedDrawArrays(mode, first, count) {
        this.realDrawArrays.call(this.gl, mode, first, count);
        this.update(count, mode);
    };
    _proto.hookedDrawElementsInstanced = function hookedDrawElementsInstanced(mode, count, type, offset, primcount) {
        this.realDrawElementsInstanced.call(this.gl, mode, count, type, offset, primcount);
        this.update(count, mode);
    };
    _proto.hookedDrawArraysInstanced = function hookedDrawArraysInstanced(mode, first, count, primcount) {
        this.realDrawArraysInstanced.call(this.gl, mode, first, count, primcount);
        this.update(count, mode);
    };
    _proto.update = function update(count, mode) {
        var gl = this.gl;
        this.drawCall++;
        switch(mode){
            case gl.TRIANGLES:
                this.triangles += count / 3;
                break;
            case gl.TRIANGLE_STRIP:
            case gl.TRIANGLE_FAN:
                this.triangles += count - 2;
                break;
            case gl.LINES:
                this.lines += count / 2;
                break;
            case gl.LINE_STRIP:
                this.lines += count - 1;
                break;
            case gl.LINE_LOOP:
                this.lines += count;
                break;
            case gl.POINTS:
                this.points += count;
                break;
            default:
                errorLog("Unknown draw mode: " + mode);
                break;
        }
    };
    _proto.reset = function reset() {
        this.drawCall = 0;
        this.triangles = 0;
        this.lines = 0;
        this.points = 0;
    };
    _proto.release = function release() {
        if (this.hooked) {
            var gl = this.gl;
            gl.drawElements = this.realDrawElements;
            gl.drawArrays = this.realDrawArrays;
            var hasInstancedFunc = this.hasInstancedFunction(gl);
            if (hasInstancedFunc) {
                // @ts-ignore
                gl.drawElementsInstanced = this.realDrawElementsInstanced;
                // @ts-ignore
                gl.drawArraysInstanced = this.realDrawArraysInstanced;
            } else {
                var extAngleInstancedArrays = gl.getExtension("ANGLE_instanced_arrays");
                if (extAngleInstancedArrays) {
                    extAngleInstancedArrays.drawElementsInstancedANGLE = this.realDrawElementsInstanced;
                    extAngleInstancedArrays.drawArraysInstancedANGLE = this.realDrawArraysInstanced;
                }
            }
        }
        this.hooked = false;
    };
    return DrawCallHook;
}();

var ShaderHook = /*#__PURE__*/ function() {
    function ShaderHook(gl) {
        this.shaders = 0;
        this.realAttachShader = gl.attachShader;
        this.realDetachShader = gl.detachShader;
        gl.attachShader = this.hookedAttachShader.bind(this);
        gl.detachShader = this.hookedDetachShader.bind(this);
        this.hooked = true;
        this.gl = gl;
        log("Shader is hooked.");
    }
    var _proto = ShaderHook.prototype;
    _proto.hookedAttachShader = function hookedAttachShader(program, shader) {
        this.realAttachShader.call(this.gl, program, shader);
        this.shaders++;
        log("AttachShader:", shader, "shaders: " + this.shaders);
    };
    _proto.hookedDetachShader = function hookedDetachShader(program, shader) {
        this.realDetachShader.call(this.gl, program, shader);
        this.shaders--;
        log("DetachShader. shaders: " + this.shaders);
    };
    _proto.reset = function reset() {
        this.shaders = 0;
    };
    _proto.release = function release() {
        if (this.hooked) {
            this.gl.attachShader = this.realAttachShader;
            this.gl.detachShader = this.realDetachShader;
        }
        this.hooked = false;
    };
    return ShaderHook;
}();

var TextureHook = /*#__PURE__*/ function() {
    function TextureHook(gl) {
        this.textures = 0;
        this.realCreateTexture = gl.createTexture;
        this.realDeleteTexture = gl.deleteTexture;
        gl.createTexture = this.hookedCreateTexture.bind(this);
        gl.deleteTexture = this.hookedDeleteTexture.bind(this);
        this.hooked = true;
        this.gl = gl;
        log("Texture is hooked.");
    }
    var _proto = TextureHook.prototype;
    _proto.hookedCreateTexture = function hookedCreateTexture() {
        var texture = this.realCreateTexture.call(this.gl);
        this.textures++;
        log("CreateTexture:", texture, "textures: " + this.textures);
        return texture;
    };
    _proto.hookedDeleteTexture = function hookedDeleteTexture(texture) {
        this.realDeleteTexture.call(this.gl, texture);
        this.textures--;
        log("DeleteTexture. textures: " + this.textures);
    };
    _proto.reset = function reset() {
        this.textures = 0;
    };
    _proto.release = function release() {
        if (this.hooked) {
            this.gl.createTexture = this.realCreateTexture;
            this.gl.deleteTexture = this.realDeleteTexture;
        }
        this.hooked = false;
    };
    return TextureHook;
}();

/**
 * Hook gl to calculate stats
 */ var Core = /*#__PURE__*/ function() {
    function Core(gl) {
        this.samplingFrames = 60;
        this.samplingIndex = 0;
        this.updateCounter = 0;
        this.updateTime = 0;
        this.gl = gl;
        this.hook(gl);
    }
    var _proto = Core.prototype;
    _proto.hook = function hook(gl) {
        this.drawCallHook = new DrawCallHook(gl);
        this.textureHook = new TextureHook(gl);
        this.shaderHook = new ShaderHook(gl);
        this.requestHook = new RequestHook();
    };
    /**
   * reset draw call hook
   */ _proto.reset = function reset() {
        this.drawCallHook && this.drawCallHook.reset();
    };
    /**
   * release hook
   */ _proto.release = function release() {
        this.drawCallHook && this.drawCallHook.release();
        this.textureHook && this.textureHook.release();
        this.shaderHook && this.shaderHook.release();
    };
    /**
   * update performance data
   */ _proto.update = function update() {
        this.updateCounter++;
        var now = engineMiniprogramAdapter.performance.now();
        if (now - this.updateTime < 1000) {
            return;
        }
        if (this.samplingIndex !== this.samplingFrames) {
            this.reset();
            this.samplingIndex++;
            return;
        }
        this.samplingIndex = 0;
        var data = {
            fps: Math.round(this.updateCounter * 1000 / (now - this.updateTime)),
            memory: engineMiniprogramAdapter.performance.memory && engineMiniprogramAdapter.performance.memory.usedJSHeapSize / 1048576 >> 0,
            drawCall: this.drawCallHook.drawCall,
            triangles: this.drawCallHook.triangles,
            lines: this.drawCallHook.lines,
            points: this.drawCallHook.points,
            textures: this.textureHook.textures,
            size: this.requestHook.size,
            shaders: this.shaderHook.shaders,
            webglContext: engineMiniprogramAdapter.window.hasOwnProperty("WebGL2RenderingContext") && _instanceof(this.gl, engineMiniprogramAdapter.WebGL2RenderingContext) ? "2.0" : "1.0"
        };
        this.reset();
        this.updateCounter = 0;
        this.updateTime = now;
        return data;
    };
    return Core;
}();

var tpl = '\n  <dl>\n    <dt>FPS</dt>\n    <dd>0</dd>\n    <dt>Memory <span class="unit">(MB)</span></dt>\n    <dd>0</dd>\n    <dt>DrawCall</dt>\n    <dd>0</dd>\n    <dt>Triangles</dt>\n    <dd>0</dd>\n    <dt>Textures</dt>\n    <dd>0</dd>\n    <dt>Shaders</dt>\n    <dd>0</dd>\n    <dt>Network Size <span class="unit">(MB)</span></dt>\n    <dd>0</dd>\n    <dt>WebGL</dt>\n    <dd></dd>\n  </dl>\n';
var css = "\n  .gl-perf {\n    pointer-events: none;\n    user-select: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    padding: " + 10 / 7.5 + "vh " + 10 / 7.5 + "vh 0 " + 10 / 7.5 + "vh;\n    background: rgba(0, 0, 0, 0.3);\n    color: #fff;\n    font: " + 10 / 7.5 + "vh arial;\n  }\n\n  .gl-perf dl,\n  .gl-perf dt,\n  .gl-perf dd {\n    padding: 0;\n    margin: 0;\n  }\n\n  .gl-perf dt {\n    color: #fff;\n    text-shadow: #000 0 0 1px;\n  }\n\n  .gl-perf dt .unit{\n    font-size: " + 10 / 7.5 + "vh;\n  }\n\n  .gl-perf dd {\n    font-size: " + 20 / 7.5 + "vh;\n    padding: " + 10 / 7.5 + "vh 0 " + 10 / 7.5 + "vh;\n  }\n";
var Monitor = /*#__PURE__*/ function() {
    function Monitor(gl) {
        this.core = new Core(gl);
        this.items = [];
        this.items = [
            "fps",
            "memory",
            "drawCall",
            "triangles",
            "textures",
            "shaders",
            "size",
            "webglContext"
        ];
        this.createContainer();
        this.update = this.update.bind(this);
    }
    var _proto = Monitor.prototype;
    _proto.createContainer = function createContainer() {
        var container = engineMiniprogramAdapter.document.createElement("div");
        container.classList.add("gl-perf");
        container.innerHTML = tpl;
        container.appendChild(this.createStyle());
        engineMiniprogramAdapter.document.body.appendChild(container);
        this.doms = Array.prototype.slice.apply(container.querySelectorAll("dd"));
        this.container = container;
    };
    _proto.createStyle = function createStyle() {
        var style = engineMiniprogramAdapter.document.createElement("style");
        style.type = "text/css";
        style.appendChild(engineMiniprogramAdapter.document.createTextNode(css));
        return style;
    };
    /**
   * Update per frame
   */ _proto.update = function update() {
        var data = this.core.update();
        if (data) {
            var _this, _loop = function(i, l) {
                var dom = _this.doms[i];
                var item = _this.items[i];
                var value = data[item] || 0;
                // see: http://wilsonpage.co.uk/preventing-layout-thrashing/
                engineMiniprogramAdapter.requestAnimationFrame(function() {
                    dom.innerText = value;
                });
            };
            for(var i = 0, l = this.items.length; i < l; i++)_this = this, _loop(i, l);
        }
    };
    /**
   * reset all hooks
   */ _proto.reset = function reset() {
        this.core.reset();
    };
    /**
   * release all hooks
   */ _proto.release = function release() {
        this.core.release();
    };
    /**
   * destroy the instance
   */ _proto.destroy = function destroy() {
        this.release();
        engineMiniprogramAdapter.document.body.removeChild(this.container);
    };
    return Monitor;
}();

/**
 * Display engine status data such as FPS.
 */ var Stats = /*#__PURE__*/ function(Script) {
    _inherits(Stats, Script);
    function Stats() {
        return Script.apply(this, arguments);
    }
    var _proto = Stats.prototype;
    _proto.onBeginRender = function onBeginRender(camera) {
        this.camera = camera;
        if (!this.monitor) {
            this._setupMonitor();
        }
    };
    _proto.onEndRender = function onEndRender(camera) {
        if (this.monitor) {
            this.monitor.update();
        }
    };
    _proto._setupMonitor = function _setupMonitor() {
        // @ts-ignore
        var gl = this.camera.engine._hardwareRenderer.gl;
        if (gl) {
            this.monitor = new Monitor(gl);
        }
    };
    Stats.hookRequest = function hookRequest1() {
        hookRequest();
    };
    _create_class(Stats, [
        {
            key: "enabled",
            set: function set(value) {
                value ? this._setupMonitor() : this.monitor.destroy();
            }
        }
    ]);
    return Stats;
}(miniprogram.Script);

exports.Core = Core;
exports.Stats = Stats;
