import { ShaderRange, ShaderPosition } from "../common";
import PpSourceMap from "./sourceMap";
import BaseScanner from "../common/BaseScanner";
import { BaseToken } from "../common/BaseToken";
import { EPpToken } from "./constants";
export type OnToken = (token: BaseToken, scanner: PpScanner) => void;
export default class PpScanner extends BaseScanner {
    private static _splitCharacters;
    private macroLvl;
    readonly sourceMap: PpSourceMap;
    readonly file: string;
    readonly blockRange?: ShaderRange;
    constructor(source: string, file?: string, blockRange?: ShaderRange);
    /**
     * Advance to directive
     * @param expandOnToken callback on encountering token.
     */
    scanDirective(expandOnToken?: OnToken): BaseToken<number>;
    /**
     * @param nonLetterChar should not be space
     */
    scanWordsUntilChar(nonLetterChar: string): BaseToken[];
    scanWord(skipNonLetter?: boolean): BaseToken;
    getShaderPosition(offset /** offset from starting point */?: number): ShaderPosition;
    /**
     * @param onToken callback when encounter a token
     * @returns token split by space
     */
    scanToken(onToken?: OnToken): BaseToken | undefined;
    scanQuotedString(): BaseToken<EPpToken.string_const>;
    scanToChar(char: string): void;
    scanMacroBranchChunk(): {
        token: BaseToken<EPpToken.chunk>;
        nextDirective: BaseToken;
    };
    scanPairedBlock(lc: string, rc: string): void;
    /**
     * @returns end ShaderPosition
     */
    scanRemainMacro(): ShaderPosition;
    peekNonSpace(): string;
    scanInteger(): BaseToken<number>;
    /**
     * Skip comments
     */
    scanLineRemain(): BaseToken<number>;
    private _advanceToDirective;
    private _skipComments;
}
