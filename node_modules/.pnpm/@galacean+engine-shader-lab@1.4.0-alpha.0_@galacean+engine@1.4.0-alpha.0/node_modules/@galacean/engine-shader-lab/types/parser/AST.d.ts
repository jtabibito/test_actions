import { BuiltinVariable } from "./builtin";
import { CodeGenVisitor } from "../codeGen";
import { ENonTerminal } from "./GrammarSymbol";
import { BaseToken as Token } from "../common/BaseToken";
import { EKeyword, TokenType, ShaderRange, GalaceanDataType } from "../common";
import SematicAnalyzer from "./SemanticAnalyzer";
import { ShaderData } from "./ShaderInfo";
import { FnSymbol, StructSymbol, VarSymbol } from "./symbolTable";
import { IParamInfo, NodeChild, StructProp, SymbolType } from "./types";
import { ClearableObjectPool, IPoolElement } from "@galacean/engine";
export declare abstract class TreeNode implements IPoolElement {
    /** The non-terminal in grammar. */
    nt: ENonTerminal;
    private _children;
    private _location;
    get children(): NodeChild[];
    get location(): ShaderRange;
    set(loc: ShaderRange, children: NodeChild[], nt: ENonTerminal): void;
    dispose(): void;
    codeGen(visitor: CodeGenVisitor): string;
    semanticAnalyze(sa: SematicAnalyzer): void;
}
export declare namespace ASTNode {
    export type ASTNodePool = ClearableObjectPool<{
        set: (loc: ShaderRange, children: NodeChild[]) => void;
    } & IPoolElement & TreeNode>;
    export function _unwrapToken(node: NodeChild): Token<number>;
    export function get(pool: ASTNodePool, sa: SematicAnalyzer, loc: ShaderRange, children: NodeChild[]): void;
    export class TrivialNode extends TreeNode {
        static pool: ClearableObjectPool<TrivialNode>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ScopeBrace extends TreeNode {
        static pool: ClearableObjectPool<ScopeBrace>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class ScopeEndBrace extends TreeNode {
        static pool: ClearableObjectPool<ScopeEndBrace>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class JumpStatement extends TreeNode {
        static pool: ClearableObjectPool<JumpStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class ConditionOpt extends TreeNode {
        static pool: ClearableObjectPool<ConditionOpt>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ForRestStatement extends TreeNode {
        static pool: ClearableObjectPool<ForRestStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class Condition extends TreeNode {
        static pool: ClearableObjectPool<Condition>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ForInitStatement extends TreeNode {
        static pool: ClearableObjectPool<ForInitStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class IterationStatement extends TreeNode {
        static pool: ClearableObjectPool<IterationStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class SelectionStatement extends TreeNode {
        static pool: ClearableObjectPool<SelectionStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ExpressionStatement extends TreeNode {
        static pool: ClearableObjectPool<ExpressionStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export abstract class ExpressionAstNode extends TreeNode {
        protected _type?: GalaceanDataType;
        set type(t: GalaceanDataType | undefined);
        get type(): GalaceanDataType | undefined;
        set(loc: ShaderRange, children: NodeChild[], nt: ENonTerminal): void;
    }
    export class InitializerList extends ExpressionAstNode {
        static pool: ClearableObjectPool<InitializerList>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class Initializer extends ExpressionAstNode {
        static pool: ClearableObjectPool<Initializer>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class SingleDeclaration extends TreeNode {
        static pool: ClearableObjectPool<SingleDeclaration>;
        typeSpecifier: TypeSpecifier;
        arraySpecifier?: ArraySpecifier;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FullySpecifiedType extends TreeNode {
        static pool: ClearableObjectPool<FullySpecifiedType>;
        get qualifierList(): EKeyword[];
        get typeSpecifier(): TypeSpecifier;
        get type(): GalaceanDataType;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class TypeQualifier extends TreeNode {
        static pool: ClearableObjectPool<TypeQualifier>;
        qualifierList: EKeyword[];
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class SingleTypeQualifier extends TreeNode {
        static pool: ClearableObjectPool<SingleTypeQualifier>;
        qualifier: EKeyword;
        lexeme: string;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    abstract class BasicTypeQualifier extends TreeNode {
        get qualifier(): EKeyword;
        get lexeme(): string;
        set(loc: ShaderRange, children: NodeChild[], nt: ENonTerminal): void;
    }
    export class StorageQualifier extends BasicTypeQualifier {
        static pool: ClearableObjectPool<StorageQualifier>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class PrecisionQualifier extends BasicTypeQualifier {
        static pool: ClearableObjectPool<PrecisionQualifier>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class InterpolationQualifier extends BasicTypeQualifier {
        static pool: ClearableObjectPool<InterpolationQualifier>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class InvariantQualifier extends BasicTypeQualifier {
        static pool: ClearableObjectPool<InvariantQualifier>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class TypeSpecifier extends TreeNode {
        static pool: ClearableObjectPool<TypeSpecifier>;
        get type(): GalaceanDataType;
        get lexeme(): string;
        get arraySize(): number;
        get isCustom(): boolean;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ArraySpecifier extends TreeNode {
        static pool: ClearableObjectPool<ArraySpecifier>;
        get size(): number | undefined;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class IntegerConstantExpressionOperator extends TreeNode {
        static pool: ClearableObjectPool<IntegerConstantExpressionOperator>;
        compute: (a: number, b: number) => number;
        get lexeme(): string;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class IntegerConstantExpression extends TreeNode {
        static pool: ClearableObjectPool<IntegerConstantExpression>;
        value?: number;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class TypeSpecifierNonArray extends TreeNode {
        static pool: ClearableObjectPool<TypeSpecifierNonArray>;
        type: GalaceanDataType;
        lexeme: string;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ExtBuiltinTypeSpecifierNonArray extends TreeNode {
        static pool: ClearableObjectPool<ExtBuiltinTypeSpecifierNonArray>;
        type: TokenType;
        lexeme: string;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class InitDeclaratorList extends TreeNode {
        static pool: ClearableObjectPool<InitDeclaratorList>;
        get typeInfo(): SymbolType;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class IdentifierList extends TreeNode {
        static pool: ClearableObjectPool<IdentifierList>;
        get idList(): Token[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class Declaration extends TreeNode {
        static pool: ClearableObjectPool<Declaration>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionProtoType extends TreeNode {
        static pool: ClearableObjectPool<FunctionProtoType>;
        private get declarator();
        get ident(): Token<number>;
        get returnType(): FullySpecifiedType;
        get parameterList(): IParamInfo[];
        get paramSig(): GalaceanDataType[];
        set(loc: ShaderRange, children: NodeChild[]): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionDeclarator extends TreeNode {
        static pool: ClearableObjectPool<FunctionDeclarator>;
        private get header();
        private get parameterList();
        get ident(): Token<number>;
        get returnType(): FullySpecifiedType;
        get parameterInfoList(): IParamInfo[];
        get paramSig(): GalaceanDataType[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class FunctionHeader extends TreeNode {
        static pool: ClearableObjectPool<FunctionHeader>;
        get ident(): Token;
        get returnType(): FullySpecifiedType;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionParameterList extends TreeNode {
        static pool: ClearableObjectPool<FunctionParameterList>;
        get parameterInfoList(): IParamInfo[];
        get paramSig(): GalaceanDataType[];
        set(loc: ShaderRange, children: NodeChild[]): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class ParameterDeclaration extends TreeNode {
        static pool: ClearableObjectPool<ParameterDeclaration>;
        get typeQualifier(): TypeQualifier;
        private get parameterDeclarator();
        get typeInfo(): SymbolType;
        get ident(): Token<number>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class ParameterDeclarator extends TreeNode {
        static pool: ClearableObjectPool<ParameterDeclarator>;
        get ident(): Token;
        get typeInfo(): SymbolType;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class SimpleStatement extends TreeNode {
        static pool: ClearableObjectPool<SimpleStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class CompoundStatement extends TreeNode {
        static pool: ClearableObjectPool<CompoundStatement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class CompoundStatementNoScope extends TreeNode {
        static pool: ClearableObjectPool<CompoundStatementNoScope>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class Statement extends TreeNode {
        static pool: ClearableObjectPool<Statement>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class StatementList extends TreeNode {
        static pool: ClearableObjectPool<StatementList>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionDefinition extends TreeNode {
        static pool: ClearableObjectPool<FunctionDefinition>;
        get protoType(): FunctionProtoType;
        get statements(): CompoundStatementNoScope;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionCall extends ExpressionAstNode {
        static pool: ClearableObjectPool<FunctionCall>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class FunctionCallGeneric extends ExpressionAstNode {
        static pool: ClearableObjectPool<FunctionCallGeneric>;
        fnSymbol: FnSymbol | StructSymbol | undefined;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class FunctionCallParameterList extends TreeNode {
        static pool: ClearableObjectPool<FunctionCallParameterList>;
        get paramSig(): GalaceanDataType[] | undefined;
        get paramNodes(): AssignmentExpression[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class PrecisionSpecifier extends TreeNode {
        static pool: ClearableObjectPool<PrecisionSpecifier>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class FunctionIdentifier extends TreeNode {
        static pool: ClearableObjectPool<FunctionIdentifier>;
        get ident(): GalaceanDataType;
        get lexeme(): string;
        get isBuiltin(): boolean;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class AssignmentExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<AssignmentExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class AssignmentOperator extends TreeNode {
        static pool: ClearableObjectPool<AssignmentOperator>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class Expression extends ExpressionAstNode {
        static pool: ClearableObjectPool<Expression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class PrimaryExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<PrimaryExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class PostfixExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<PostfixExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class UnaryOperator extends TreeNode {
        static pool: ClearableObjectPool<UnaryOperator>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class UnaryExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<UnaryExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class MultiplicativeExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<MultiplicativeExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class AdditiveExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<AdditiveExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class ShiftExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<ShiftExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class RelationalExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<RelationalExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class EqualityExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<EqualityExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class AndExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<AndExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class ExclusiveOrExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<ExclusiveOrExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class InclusiveOrExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<InclusiveOrExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class LogicalAndExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<LogicalAndExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class LogicalXorExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<LogicalXorExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class LogicalOrExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<LogicalOrExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class ConditionalExpression extends ExpressionAstNode {
        static pool: ClearableObjectPool<ConditionalExpression>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class StructSpecifier extends TreeNode {
        static pool: ClearableObjectPool<StructSpecifier>;
        ident?: Token;
        get propList(): StructProp[];
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export class StructDeclarationList extends TreeNode {
        static pool: ClearableObjectPool<StructDeclarationList>;
        get propList(): StructProp[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class StructDeclaration extends TreeNode {
        static pool: ClearableObjectPool<StructDeclaration>;
        get typeSpecifier(): TypeSpecifier;
        get declaratorList(): StructDeclaratorList;
        get propList(): StructProp[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class StructDeclaratorList extends TreeNode {
        static pool: ClearableObjectPool<StructDeclaratorList>;
        get declaratorList(): StructDeclarator[];
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class StructDeclarator extends TreeNode {
        static pool: ClearableObjectPool<StructDeclarator>;
        get ident(): Token;
        get arraySpecifier(): ArraySpecifier | undefined;
        set(loc: ShaderRange, children: NodeChild[]): void;
    }
    export class VariableDeclaration extends TreeNode {
        static pool: ClearableObjectPool<VariableDeclaration>;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class VariableIdentifier extends TreeNode {
        static pool: ClearableObjectPool<VariableIdentifier>;
        symbolInfo: VarSymbol | BuiltinVariable | null;
        get lexeme(): string;
        get typeInfo(): GalaceanDataType;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
        codeGen(visitor: CodeGenVisitor): string;
    }
    export class GLShaderProgram extends TreeNode {
        static pool: ClearableObjectPool<GLShaderProgram>;
        shaderData: ShaderData;
        set(loc: ShaderRange, children: NodeChild[]): void;
        semanticAnalyze(sa: SematicAnalyzer): void;
    }
    export {};
}
