(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@galacean/engine')) :
    typeof define === 'function' && define.amd ? define(['exports', '@galacean/engine'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Galacean = global.Galacean || {}, global.Galacean.ShaderLab = {}), global.Galacean));
})(this, (function (exports, engine) { 'use strict';

    function _array_like_to_array(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
    }

    function _unsupported_iterable_to_array(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _array_like_to_array(o, minLen);

        var n = Object.prototype.toString.call(o).slice(8, -1);

        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(n);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
    }

    function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

        if (it) return (it = it.call(o)).next.bind(it);
        // Fallback for engines without symbol support
        if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;

            var i = 0;

            return function() {
                if (i >= o.length) return { done: true };

                return { done: false, value: o[i++] };
            };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _set_prototype_of(o, p) {
        _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
            o.__proto__ = p;

            return o;
        };

        return _set_prototype_of(o, p);
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

        if (superClass) _set_prototype_of(subClass, superClass);
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    var ShaderRange = /*#__PURE__*/ function() {
        function ShaderRange() {}
        var _proto = ShaderRange.prototype;
        _proto.set = function set(start, end) {
            this.start = start;
            this.end = end;
        };
        _proto.dispose = function dispose() {
            this.start.dispose();
            this.end.dispose();
        };
        return ShaderRange;
    }();

    var ShaderPosition = /*#__PURE__*/ function() {
        function ShaderPosition() {}
        var _proto = ShaderPosition.prototype;
        _proto.set = function set(index, line, column) {
            this.index = index;
            this.line = line;
            this.column = column;
        };
        _proto.dispose = function dispose() {
            this.index = 0;
            this.line = 0;
            this.column = 0;
        };
        return ShaderPosition;
    }();

    var EKeyword = /*#__PURE__*/ function(EKeyword) {
        EKeyword[EKeyword["ATTRIBUTE"] = 0] = "ATTRIBUTE";
        EKeyword[EKeyword["CONST"] = 1] = "CONST";
        EKeyword[EKeyword["BOOL"] = 2] = "BOOL";
        EKeyword[EKeyword["FLOAT"] = 3] = "FLOAT";
        EKeyword[EKeyword["DOUBLE"] = 4] = "DOUBLE";
        EKeyword[EKeyword["INT"] = 5] = "INT";
        EKeyword[EKeyword["UINT"] = 6] = "UINT";
        EKeyword[EKeyword["BREAK"] = 7] = "BREAK";
        EKeyword[EKeyword["CONTINUE"] = 8] = "CONTINUE";
        EKeyword[EKeyword["DO"] = 9] = "DO";
        EKeyword[EKeyword["ELSE"] = 10] = "ELSE";
        EKeyword[EKeyword["FOR"] = 11] = "FOR";
        EKeyword[EKeyword["IF"] = 12] = "IF";
        EKeyword[EKeyword["WHILE"] = 13] = "WHILE";
        EKeyword[EKeyword["DISCARD"] = 14] = "DISCARD";
        EKeyword[EKeyword["RETURN"] = 15] = "RETURN";
        EKeyword[EKeyword["BVEC2"] = 16] = "BVEC2";
        EKeyword[EKeyword["BVEC3"] = 17] = "BVEC3";
        EKeyword[EKeyword["BVEC4"] = 18] = "BVEC4";
        EKeyword[EKeyword["IVEC2"] = 19] = "IVEC2";
        EKeyword[EKeyword["IVEC3"] = 20] = "IVEC3";
        EKeyword[EKeyword["IVEC4"] = 21] = "IVEC4";
        EKeyword[EKeyword["UVEC2"] = 22] = "UVEC2";
        EKeyword[EKeyword["UVEC3"] = 23] = "UVEC3";
        EKeyword[EKeyword["UVEC4"] = 24] = "UVEC4";
        EKeyword[EKeyword["VEC2"] = 25] = "VEC2";
        EKeyword[EKeyword["VEC3"] = 26] = "VEC3";
        EKeyword[EKeyword["VEC4"] = 27] = "VEC4";
        EKeyword[EKeyword["MAT2"] = 28] = "MAT2";
        EKeyword[EKeyword["MAT3"] = 29] = "MAT3";
        EKeyword[EKeyword["MAT4"] = 30] = "MAT4";
        EKeyword[EKeyword["MAT2X3"] = 31] = "MAT2X3";
        EKeyword[EKeyword["MAT2X4"] = 32] = "MAT2X4";
        EKeyword[EKeyword["MAT3X2"] = 33] = "MAT3X2";
        EKeyword[EKeyword["MAT3X4"] = 34] = "MAT3X4";
        EKeyword[EKeyword["MAT4X2"] = 35] = "MAT4X2";
        EKeyword[EKeyword["MAT4X3"] = 36] = "MAT4X3";
        EKeyword[EKeyword["IN"] = 37] = "IN";
        EKeyword[EKeyword["OUT"] = 38] = "OUT";
        EKeyword[EKeyword["INOUT"] = 39] = "INOUT";
        EKeyword[EKeyword["CENTROID"] = 40] = "CENTROID";
        EKeyword[EKeyword["SAMPLER2D"] = 41] = "SAMPLER2D";
        EKeyword[EKeyword["SAMPLER3D"] = 42] = "SAMPLER3D";
        EKeyword[EKeyword["SAMPLER_CUBE"] = 43] = "SAMPLER_CUBE";
        EKeyword[EKeyword["SAMPLER2D_SHADOW"] = 44] = "SAMPLER2D_SHADOW";
        EKeyword[EKeyword["SAMPLER_CUBE_SHADOW"] = 45] = "SAMPLER_CUBE_SHADOW";
        EKeyword[EKeyword["SAMPLER2D_ARRAY"] = 46] = "SAMPLER2D_ARRAY";
        EKeyword[EKeyword["SAMPLER2D_ARRAY_SHADOW"] = 47] = "SAMPLER2D_ARRAY_SHADOW";
        EKeyword[EKeyword["I_SAMPLER2D"] = 48] = "I_SAMPLER2D";
        EKeyword[EKeyword["I_SAMPLER3D"] = 49] = "I_SAMPLER3D";
        EKeyword[EKeyword["I_SAMPLER_CUBE"] = 50] = "I_SAMPLER_CUBE";
        EKeyword[EKeyword["I_SAMPLER2D_ARRAY"] = 51] = "I_SAMPLER2D_ARRAY";
        EKeyword[EKeyword["U_SAMPLER2D"] = 52] = "U_SAMPLER2D";
        EKeyword[EKeyword["U_SAMPLER3D"] = 53] = "U_SAMPLER3D";
        EKeyword[EKeyword["U_SAMPLER_CUBE"] = 54] = "U_SAMPLER_CUBE";
        EKeyword[EKeyword["U_SAMPLER2D_ARRAY"] = 55] = "U_SAMPLER2D_ARRAY";
        EKeyword[EKeyword["STRUCT"] = 56] = "STRUCT";
        EKeyword[EKeyword["VOID"] = 57] = "VOID";
        EKeyword[EKeyword["TRUE"] = 58] = "TRUE";
        EKeyword[EKeyword["FALSE"] = 59] = "FALSE";
        EKeyword[EKeyword["PRECISION"] = 60] = "PRECISION";
        EKeyword[EKeyword["PRECISE"] = 61] = "PRECISE";
        EKeyword[EKeyword["HIGHP"] = 62] = "HIGHP";
        EKeyword[EKeyword["MEDIUMP"] = 63] = "MEDIUMP";
        EKeyword[EKeyword["LOWP"] = 64] = "LOWP";
        EKeyword[EKeyword["INVARIANT"] = 65] = "INVARIANT";
        EKeyword[EKeyword["SMOOTH"] = 66] = "SMOOTH";
        EKeyword[EKeyword["FLAT"] = 67] = "FLAT";
        EKeyword[EKeyword["NOPERSPECTIVE"] = 68] = "NOPERSPECTIVE";
        // galacean internals
        EKeyword[EKeyword["GS_RenderQueueType"] = 69] = "GS_RenderQueueType";
        EKeyword[EKeyword["GS_BlendState"] = 70] = "GS_BlendState";
        EKeyword[EKeyword["GS_DepthState"] = 71] = "GS_DepthState";
        EKeyword[EKeyword["GS_StencilState"] = 72] = "GS_StencilState";
        EKeyword[EKeyword["GS_RasterState"] = 73] = "GS_RasterState";
        EKeyword[EKeyword["GS_EditorProperties"] = 74] = "GS_EditorProperties";
        EKeyword[EKeyword["GS_EditorMacros"] = 75] = "GS_EditorMacros";
        EKeyword[EKeyword["GS_Editor"] = 76] = "GS_Editor";
        EKeyword[EKeyword["GS_Tags"] = 77] = "GS_Tags";
        EKeyword[EKeyword["GS_ReplacementTag"] = 78] = "GS_ReplacementTag";
        EKeyword[EKeyword["GS_LightMode"] = 79] = "GS_LightMode";
        EKeyword[EKeyword["GS_PipelineStage"] = 80] = "GS_PipelineStage";
        EKeyword[EKeyword["GS_VertexShader"] = 81] = "GS_VertexShader";
        EKeyword[EKeyword["GS_FragmentShader"] = 82] = "GS_FragmentShader";
        EKeyword[EKeyword["GS_SubShader"] = 83] = "GS_SubShader";
        EKeyword[EKeyword["GS_Pass"] = 84] = "GS_Pass";
        EKeyword[EKeyword["GS_BlendFactor"] = 85] = "GS_BlendFactor";
        EKeyword[EKeyword["GS_BlendOperation"] = 86] = "GS_BlendOperation";
        EKeyword[EKeyword["GS_Bool"] = 87] = "GS_Bool";
        EKeyword[EKeyword["GS_Number"] = 88] = "GS_Number";
        EKeyword[EKeyword["GS_Color"] = 89] = "GS_Color";
        EKeyword[EKeyword["GS_CompareFunction"] = 90] = "GS_CompareFunction";
        EKeyword[EKeyword["GS_StencilOperation"] = 91] = "GS_StencilOperation";
        EKeyword[EKeyword["GS_CullMode"] = 92] = "GS_CullMode";
        EKeyword[EKeyword["GS_UsePass"] = 93] = "GS_UsePass";
        return EKeyword;
    }({});

    var KeywordTable = new Map([
        [
            "attribute",
            EKeyword.ATTRIBUTE
        ],
        [
            "const",
            EKeyword.CONST
        ],
        [
            "bool",
            EKeyword.BOOL
        ],
        [
            "float",
            EKeyword.FLOAT
        ],
        [
            "double",
            EKeyword.DOUBLE
        ],
        [
            "int",
            EKeyword.INT
        ],
        [
            "uint",
            EKeyword.UINT
        ],
        [
            "break",
            EKeyword.BREAK
        ],
        [
            "continue",
            EKeyword.CONTINUE
        ],
        [
            "do",
            EKeyword.DO
        ],
        [
            "else",
            EKeyword.ELSE
        ],
        [
            "for",
            EKeyword.FOR
        ],
        [
            "if",
            EKeyword.IF
        ],
        [
            "while",
            EKeyword.WHILE
        ],
        [
            "discard",
            EKeyword.DISCARD
        ],
        [
            "return",
            EKeyword.RETURN
        ],
        [
            "bvec2",
            EKeyword.BVEC2
        ],
        [
            "bvec3",
            EKeyword.BVEC3
        ],
        [
            "bvec4",
            EKeyword.BVEC4
        ],
        [
            "ivec2",
            EKeyword.IVEC2
        ],
        [
            "ivec3",
            EKeyword.IVEC3
        ],
        [
            "ivec4",
            EKeyword.IVEC4
        ],
        [
            "uvec2",
            EKeyword.UVEC2
        ],
        [
            "uvec3",
            EKeyword.UVEC3
        ],
        [
            "uvec4",
            EKeyword.UVEC4
        ],
        [
            "vec2",
            EKeyword.VEC2
        ],
        [
            "vec3",
            EKeyword.VEC3
        ],
        [
            "vec4",
            EKeyword.VEC4
        ],
        [
            "mat2",
            EKeyword.MAT2
        ],
        [
            "mat3",
            EKeyword.MAT3
        ],
        [
            "mat4",
            EKeyword.MAT4
        ],
        [
            "in",
            EKeyword.IN
        ],
        [
            "out",
            EKeyword.OUT
        ],
        [
            "inout",
            EKeyword.INOUT
        ],
        [
            "sampler2D",
            EKeyword.SAMPLER2D
        ],
        [
            "samplerCube",
            EKeyword.SAMPLER_CUBE
        ],
        [
            "sampler3D",
            EKeyword.SAMPLER3D
        ],
        [
            "sampler2DShadow",
            EKeyword.SAMPLER2D_SHADOW
        ],
        [
            "samplerCubeShadow",
            EKeyword.SAMPLER_CUBE_SHADOW
        ],
        [
            "sampler2DArray",
            EKeyword.SAMPLER2D_ARRAY
        ],
        [
            "sampler2DArrayShadow",
            EKeyword.SAMPLER2D_ARRAY_SHADOW
        ],
        [
            "isampler2D",
            EKeyword.I_SAMPLER2D
        ],
        [
            "isampler3D",
            EKeyword.I_SAMPLER3D
        ],
        [
            "isamplerCube",
            EKeyword.I_SAMPLER_CUBE
        ],
        [
            "isampler2DArray",
            EKeyword.I_SAMPLER2D_ARRAY
        ],
        [
            "usampler2D",
            EKeyword.U_SAMPLER2D
        ],
        [
            "usampler3D",
            EKeyword.U_SAMPLER3D
        ],
        [
            "usamplerCube",
            EKeyword.U_SAMPLER_CUBE
        ],
        [
            "usampler2DArray",
            EKeyword.U_SAMPLER2D_ARRAY
        ],
        [
            "struct",
            EKeyword.STRUCT
        ],
        [
            "void",
            EKeyword.VOID
        ],
        [
            "true",
            EKeyword.TRUE
        ],
        [
            "false",
            EKeyword.FALSE
        ],
        [
            "precision",
            EKeyword.PRECISION
        ],
        [
            "precise",
            EKeyword.PRECISE
        ],
        [
            "highp",
            EKeyword.HIGHP
        ],
        [
            "mediump",
            EKeyword.MEDIUMP
        ],
        [
            "lowp",
            EKeyword.LOWP
        ],
        [
            "invariant",
            EKeyword.INVARIANT
        ],
        [
            "flat",
            EKeyword.FLAT
        ],
        [
            "smooth",
            EKeyword.SMOOTH
        ],
        [
            "noperspective",
            EKeyword.NOPERSPECTIVE
        ],
        [
            "centroid",
            EKeyword.CENTROID
        ]
    ]);
    var ETokenType = /*#__PURE__*/ function(ETokenType) {
        ETokenType[ETokenType["ID"] = 1000] = "ID";
        ETokenType[ETokenType["FLOAT_CONSTANT"] = 1001] = "FLOAT_CONSTANT";
        ETokenType[ETokenType["INT_CONSTANT"] = 1002] = "INT_CONSTANT";
        ETokenType[ETokenType["STRING_CONST"] = 1003] = "STRING_CONST";
        /** << */ ETokenType[ETokenType["LEFT_OP"] = 1004] = "LEFT_OP";
        /** \>> */ ETokenType[ETokenType["RIGHT_OP"] = 1005] = "RIGHT_OP";
        /** ++ */ ETokenType[ETokenType["INC_OP"] = 1006] = "INC_OP";
        /** -- */ ETokenType[ETokenType["DEC_OP"] = 1007] = "DEC_OP";
        /** <= */ ETokenType[ETokenType["LE_OP"] = 1008] = "LE_OP";
        /** \>= */ ETokenType[ETokenType["GE_OP"] = 1009] = "GE_OP";
        /** == */ ETokenType[ETokenType["EQ_OP"] = 1010] = "EQ_OP";
        /** != */ ETokenType[ETokenType["NE_OP"] = 1011] = "NE_OP";
        /** && */ ETokenType[ETokenType["AND_OP"] = 1012] = "AND_OP";
        /** || */ ETokenType[ETokenType["OR_OP"] = 1013] = "OR_OP";
        /** ^^ */ ETokenType[ETokenType["XOR_OP"] = 1014] = "XOR_OP";
        /** *= */ ETokenType[ETokenType["MUL_ASSIGN"] = 1015] = "MUL_ASSIGN";
        /** /= */ ETokenType[ETokenType["DIV_ASSIGN"] = 1016] = "DIV_ASSIGN";
        /** += */ ETokenType[ETokenType["ADD_ASSIGN"] = 1017] = "ADD_ASSIGN";
        /** -= */ ETokenType[ETokenType["SUB_ASSIGN"] = 1018] = "SUB_ASSIGN";
        /** %= */ ETokenType[ETokenType["MOD_ASSIGN"] = 1019] = "MOD_ASSIGN";
        /** <<= */ ETokenType[ETokenType["LEFT_ASSIGN"] = 1020] = "LEFT_ASSIGN";
        /** >>= */ ETokenType[ETokenType["RIGHT_ASSIGN"] = 1021] = "RIGHT_ASSIGN";
        /** &= */ ETokenType[ETokenType["AND_ASSIGN"] = 1022] = "AND_ASSIGN";
        /** ^= */ ETokenType[ETokenType["XOR_ASSIGN"] = 1023] = "XOR_ASSIGN";
        /** |= */ ETokenType[ETokenType["OR_ASSIGN"] = 1024] = "OR_ASSIGN";
        /** ( */ ETokenType[ETokenType["LEFT_PAREN"] = 1025] = "LEFT_PAREN";
        /** ) */ ETokenType[ETokenType["RIGHT_PAREN"] = 1026] = "RIGHT_PAREN";
        /** [ */ ETokenType[ETokenType["LEFT_BRACKET"] = 1027] = "LEFT_BRACKET";
        /** ] */ ETokenType[ETokenType["RIGHT_BRACKET"] = 1028] = "RIGHT_BRACKET";
        /** { */ ETokenType[ETokenType["LEFT_BRACE"] = 1029] = "LEFT_BRACE";
        /** } */ ETokenType[ETokenType["RIGHT_BRACE"] = 1030] = "RIGHT_BRACE";
        /** . */ ETokenType[ETokenType["DOT"] = 1031] = "DOT";
        /** , */ ETokenType[ETokenType["COMMA"] = 1032] = "COMMA";
        ETokenType[ETokenType["COLON"] = 1033] = "COLON";
        /** = */ ETokenType[ETokenType["EQUAL"] = 1034] = "EQUAL";
        ETokenType[ETokenType["SEMICOLON"] = 1035] = "SEMICOLON";
        /** ! */ ETokenType[ETokenType["BANG"] = 1036] = "BANG";
        /** \- */ ETokenType[ETokenType["DASH"] = 1037] = "DASH";
        /** ~ */ ETokenType[ETokenType["TILDE"] = 1038] = "TILDE";
        ETokenType[ETokenType["PLUS"] = 1039] = "PLUS";
        /** \* */ ETokenType[ETokenType["STAR"] = 1040] = "STAR";
        /** / */ ETokenType[ETokenType["SLASH"] = 1041] = "SLASH";
        /** % */ ETokenType[ETokenType["PERCENT"] = 1042] = "PERCENT";
        /** < */ ETokenType[ETokenType["LEFT_ANGLE"] = 1043] = "LEFT_ANGLE";
        /** \> */ ETokenType[ETokenType["RIGHT_ANGLE"] = 1044] = "RIGHT_ANGLE";
        ETokenType[ETokenType["VERTICAL_BAR"] = 1045] = "VERTICAL_BAR";
        /** ^ */ ETokenType[ETokenType["CARET"] = 1046] = "CARET";
        /** & */ ETokenType[ETokenType["AMPERSAND"] = 1047] = "AMPERSAND";
        /** ? */ ETokenType[ETokenType["QUESTION"] = 1048] = "QUESTION";
        ETokenType[ETokenType["NOT_WORD"] = 1049] = "NOT_WORD";
        /** ε */ ETokenType[ETokenType["EPSILON"] = 1998] = "EPSILON";
        ETokenType[ETokenType["EOF"] = 1999] = "EOF";
        return ETokenType;
    }({});
    var TypeAny = 3000;

    function _instanceof(left, right) {
        if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
            return !!right[Symbol.hasInstance](left);
        } else return left instanceof right;
    }

    function _is_native_reflect_construct() {
        // Since Reflect.construct can't be properly polyfilled, some
        // implementations (e.g. core-js@2) don't set the correct internal slots.
        // Those polyfills don't allow us to subclass built-ins, so we need to
        // use our fallback implementation.
        try {
            // If the internal slots aren't set, this throws an error similar to
            //   TypeError: this is not a Boolean object.
            var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (_) {}
        return (_is_native_reflect_construct = function() {
            return !!result;
        })();
    }

    function _construct(Parent, args, Class) {
        if (_is_native_reflect_construct()) _construct = Reflect.construct;
        else {
            _construct = function construct(Parent, args, Class) {
                var a = [null];
                a.push.apply(a, args);
                var Constructor = Function.bind.apply(Parent, a);
                var instance = new Constructor();

                if (Class) _set_prototype_of(instance, Class.prototype);

                return instance;
            };
        }

        return _construct.apply(null, arguments);
    }

    function _get_prototype_of(o) {
        _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
        };

        return _get_prototype_of(o);
    }

    function _is_native_function(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrap_native_super(Class) {
        var _cache = typeof Map === "function" ? new Map() : undefined;
        _wrap_native_super = function(Class) {
            if (Class === null || !_is_native_function(Class)) return Class;
            if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
            if (typeof _cache !== "undefined") {
                if (_cache.has(Class)) return _cache.get(Class);
                _cache.set(Class, Wrapper);
            }

            function Wrapper() {
                return _construct(Class, arguments, _get_prototype_of(this).constructor);
            }
            Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });

            return _set_prototype_of(Wrapper, Class);
        };

        return _wrap_native_super(Class);
    }

    var GSError = /*#__PURE__*/ function(Error1) {
        _inherits(GSError, Error1);
        function GSError(name, message, location, source, file) {
            var _this;
            _this = Error1.call(this, message) || this, _this.location = location, _this.source = source, _this.file = file;
            _this.name = name;
            return _this;
        }
        var _proto = GSError.prototype;
        _proto.toString = function toString() {
            var start, end;
            var _this = this, message = _this.message, location = _this.location, source = _this.source;
            if (!source) {
                return message;
            }
            if (_instanceof(location, ShaderPosition)) {
                start = end = location;
            } else {
                start = location.start;
                end = location.end;
            }
            var lines = source.split("\n");
            var diagnosticMessage = this.name + ": " + message + "\n\n";
            var lineSplit = "|···";
            var wrappingLineCount = GSError.wrappingLineCount;
            for(var i = start.line - wrappingLineCount, n = end.line + wrappingLineCount; i <= n; i++){
                var line = lines[i];
                diagnosticMessage += lineSplit + ("" + line + "\n");
                if (i < start.line || i > end.line) continue;
                var remarkStart = 0;
                var remarkEnd = line.length;
                var paddingLength = lineSplit.length;
                if (i === start.line) {
                    remarkStart = start.column;
                    paddingLength += start.column;
                } else if (i === end.line) {
                    remarkEnd = end.column;
                }
                var remarkLength = Math.max(remarkEnd - remarkStart, 1);
                diagnosticMessage += " ".repeat(paddingLength) + "^".repeat(remarkLength) + "\n";
            }
            return diagnosticMessage;
        };
        return GSError;
    }(_wrap_native_super(Error));
    GSError.wrappingLineCount = 2;
    var GSErrorName = /*#__PURE__*/ function(GSErrorName) {
        GSErrorName["PreprocessorError"] = "PreprocessorError";
        GSErrorName["CompilationError"] = "CompilationError";
        GSErrorName["ScannerError"] = "ScannerError";
        return GSErrorName;
    }({});

    var ShaderLabUtils = /*#__PURE__*/ function() {
        function ShaderLabUtils() {}
        ShaderLabUtils.createObjectPool = function createObjectPool(type) {
            var pool = new engine.ClearableObjectPool(type);
            ShaderLabUtils._shaderLabObjectPoolSet.push(pool);
            return pool;
        };
        ShaderLabUtils.clearAllShaderLabObjectPool = function clearAllShaderLabObjectPool() {
            for(var i = 0, n = ShaderLabUtils._shaderLabObjectPoolSet.length; i < n; i++){
                ShaderLabUtils._shaderLabObjectPoolSet[i].clear();
            }
        };
        ShaderLabUtils.createGSError = function createGSError(message, errorName, source, location, file) {
            return new GSError(errorName, message, location, source, file);
        };
        return ShaderLabUtils;
    }();
    ShaderLabUtils._shaderLabObjectPoolSet = [];

    var BaseToken = /*#__PURE__*/ function() {
        function BaseToken() {}
        var _proto = BaseToken.prototype;
        _proto.set = function set(type, lexeme, arg) {
            this.type = type;
            this.lexeme = lexeme;
            if (arg) {
                if (_instanceof(arg, ShaderRange)) {
                    this.location = arg;
                } else {
                    var end = ShaderLab.createPosition(arg.index + lexeme.length, arg.line, arg.column + lexeme.length);
                    this.location = ShaderLab.createRange(arg, end);
                }
            }
        };
        _proto.dispose = function dispose() {};
        return BaseToken;
    }();
    BaseToken.pool = ShaderLabUtils.createObjectPool(BaseToken);
    var EOF = new BaseToken();
    EOF.set(ETokenType.EOF, "/EOF");

    var LexerUtils = /*#__PURE__*/ function() {
        function LexerUtils() {}
        LexerUtils.isNum = function isNum(char) {
            return this.numRegex.test(char);
        };
        LexerUtils.isLetter = function isLetter(char) {
            return this.letterRegex.test(char);
        };
        LexerUtils.isAlpha = function isAlpha(char) {
            return this.alphaRegex.test(char);
        };
        LexerUtils.isNumOrLetter = function isNumOrLetter(char) {
            return this.numOrLetterRegex.test(char);
        };
        LexerUtils.isKeyword = function isKeyword(tt) {
            return tt < ETokenType.ID;
        };
        return LexerUtils;
    }();
    LexerUtils.numRegex = /\d/;
    LexerUtils.letterRegex = /\w/;
    LexerUtils.alphaRegex = /[a-zA-Z_]/;
    LexerUtils.numOrLetterRegex = /(\d|\w)/;

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;

            if ("value" in descriptor) descriptor.writable = true;

            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _create_class(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);

        return Constructor;
    }

    var BaseScanner = /*#__PURE__*/ function() {
        function BaseScanner(source, kws) {
            if (kws === void 0) kws = new Map();
            this._currentIndex = 0;
            this._column = 0;
            this._line = 0;
            this._source = source;
            this._keywordsMap = kws;
        }
        var _proto = BaseScanner.prototype;
        _proto.getCurPosition = function getCurPosition() {
            return ShaderLab.createPosition(this._currentIndex, this._line, this._column);
        };
        _proto.isEnd = function isEnd() {
            return this._currentIndex >= this._source.length;
        };
        _proto.getCurChar = function getCurChar() {
            return this._source[this._currentIndex];
        };
        _proto.advance = function advance(count) {
            if (count === void 0) count = 1;
            for(var i = 0; i < count; i++){
                this._advance();
            }
        };
        _proto._advance = function _advance() {
            if (this.isEnd()) {
                return;
            }
            if (this.getCurChar() === "\n") {
                this._line += 1;
                this._column = 0;
            } else {
                this._column += 1;
            }
            this._currentIndex++;
        };
        _proto.skipSpace = function skipSpace(includeLineBreak) {
            var spaceChars = includeLineBreak ? BaseScanner._spaceCharsWithBreak : BaseScanner._spaceChars;
            var curChar = this.getCurChar();
            while(BaseScanner._checkIsIn(curChar, spaceChars)){
                this._advance();
                curChar = this.getCurChar();
            }
        };
        _proto.skipCommentsAndSpace = function skipCommentsAndSpace() {
            this.skipSpace(true);
            if (this.peek(2) === "//") {
                var start = this.getCurPosition();
                this.advance(2);
                // single line comments
                while(this.getCurChar() !== "\n")this._advance();
                this.skipCommentsAndSpace();
                return ShaderLab.createRange(start, this.getCurPosition());
            } else if (this.peek(2) === "/*") {
                var start1 = this.getCurPosition();
                this.advance(2);
                //  multi-line comments
                while(this.peek(2) !== "*/" && !this.isEnd())this._advance();
                this.advance(2);
                this.skipCommentsAndSpace();
                return ShaderLab.createRange(start1, this.getCurPosition());
            }
        };
        _proto.peek = function peek(to) {
            var offset = this._currentIndex;
            return this._source.substring(offset, offset + to);
        };
        _proto.scanText = function scanText(text) {
            this.skipCommentsAndSpace();
            var peek = this.peek(text.length);
            if (peek !== text) {
                this.throwError(this.getCurPosition(), 'Expect text "' + text + '", but got "' + peek + '"');
            }
            this.advance(text.length);
        };
        _proto.throwError = function throwError(pos) {
            for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                msgs[_key - 1] = arguments[_key];
            }
            var error = ShaderLabUtils.createGSError(msgs.join(" "), GSErrorName.ScannerError, this._source, pos);
            throw error;
        };
        _proto.scanPairedText = function scanPairedText(left, right, balanced, skipLeading) {
            if (balanced === void 0) balanced = false;
            if (skipLeading === void 0) skipLeading = false;
            if (!skipLeading) {
                this.scanText(left);
            }
            var start = this._currentIndex;
            var level = balanced ? 1 : 0;
            while(this.peek(right.length) !== right || level !== 0){
                if (this.isEnd()) return;
                if (balanced) {
                    if (this.peek(left.length) === left) {
                        level += 1;
                        this.advance(left.length);
                        continue;
                    } else if (this.peek(right.length) === right) {
                        level -= 1;
                        if (level === 0) break;
                        this.advance(right.length);
                        continue;
                    }
                }
                this.advance(right.length);
            }
            this.advance(right.length);
            return this._source.substring(start, this._currentIndex - right.length);
        };
        _proto.scanToken = function scanToken(onToken, splitCharRegex) {
            if (splitCharRegex === void 0) splitCharRegex = /\w/;
            this.skipCommentsAndSpace();
            var start = this.getCurPosition();
            if (this.isEnd()) return;
            while(splitCharRegex.test(this.getCurChar()) && !this.isEnd())this._advance();
            var end = this.getCurPosition();
            if (start.index === end.index) {
                this._advance();
                var token = BaseToken.pool.get();
                token.set(ETokenType.NOT_WORD, this._source[start.index], start);
                onToken == null ? void 0 : onToken(token, this);
                return token;
            }
            var lexeme = this._source.substring(start.index, end.index);
            var _this__keywordsMap_get;
            var tokenType = (_this__keywordsMap_get = this._keywordsMap.get(lexeme)) != null ? _this__keywordsMap_get : ETokenType.ID;
            var range = ShaderLab.createRange(start, end);
            var token1 = BaseToken.pool.get();
            token1.set(tokenType, lexeme, range);
            onToken == null ? void 0 : onToken(token1, this);
            return token1;
        };
        BaseScanner._checkIsIn = function _checkIsIn(checked, chars) {
            for(var i = 0; i < chars.length; i++){
                if (checked === chars[i]) {
                    return true;
                }
                continue;
            }
            return false;
        };
        _create_class(BaseScanner, [
            {
                key: "current",
                get: function get() {
                    return this._currentIndex;
                }
            },
            {
                key: "source",
                get: function get() {
                    return this._source;
                }
            },
            {
                key: "line",
                get: function get() {
                    return this._line;
                }
            },
            {
                key: "column",
                get: function get() {
                    return this._column;
                }
            }
        ]);
        return BaseScanner;
    }();
    BaseScanner._spaceCharsWithBreak = [
        " ",
        "\t",
        "\n"
    ];
    BaseScanner._spaceChars = [
        " ",
        "\t"
    ];

    /**
     * The Lexer of ShaderLab Compiler
     */ var Lexer = /*#__PURE__*/ function(BaseScanner) {
        _inherits(Lexer, BaseScanner);
        function Lexer() {
            return BaseScanner.apply(this, arguments) || this;
        }
        var _proto = Lexer.prototype;
        _proto.reset = function reset(source) {
            this._source = source;
            this._currentIndex = 0;
            this._line = this._column = 0;
        };
        _proto.tokenize = function tokenize() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        if (!!this.isEnd()) return [
                            3,
                            2
                        ];
                        return [
                            4,
                            this.scanToken()
                        ];
                    case 1:
                        _state.sent();
                        return [
                            3,
                            0
                        ];
                    case 2:
                        return [
                            2,
                            EOF
                        ];
                }
            });
        };
        _proto.skipSpace = function skipSpace() {
            while(/\s/.test(this.getCurChar())){
                this.advance();
            }
        };
        _proto.scanToken = function scanToken() {
            this.skipCommentsAndSpace();
            if (this.isEnd()) {
                return EOF;
            }
            if (LexerUtils.isAlpha(this.getCurChar())) {
                return this._scanWord();
            }
            if (LexerUtils.isNum(this.getCurChar())) {
                return this._scanNum();
            }
            var start = this._getPosition();
            var token = BaseToken.pool.get();
            switch(this.getCurChar()){
                case "<":
                    this.advance();
                    if (this.getCurChar() === "<") {
                        this.advance();
                        if (this.getCurChar() === "=") {
                            this.advance();
                            token.set(ETokenType.LEFT_ASSIGN, "<<=", start);
                            break;
                        }
                        token.set(ETokenType.LEFT_OP, "<<", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.LE_OP, "<=", start);
                        break;
                    }
                    token.set(ETokenType.LEFT_ANGLE, "<", start);
                    break;
                case ">":
                    this.advance();
                    if (this.getCurChar() === ">") {
                        this.advance();
                        if (this.getCurChar() === "=") {
                            this.advance();
                            token.set(ETokenType.RIGHT_ASSIGN, ">>=", start);
                            break;
                        }
                        token.set(ETokenType.RIGHT_OP, ">>", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.GE_OP, ">=", start);
                        break;
                    }
                    token.set(ETokenType.RIGHT_ANGLE, ">", start);
                    break;
                case "+":
                    this.advance();
                    if (this.getCurChar() === "+") {
                        this.advance();
                        token.set(ETokenType.INC_OP, "++", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.ADD_ASSIGN, "+=", start);
                        break;
                    }
                    token.set(ETokenType.PLUS, "+", start);
                    break;
                case "-":
                    this.advance();
                    if (this.getCurChar() === "-") {
                        this.advance();
                        token.set(ETokenType.DEC_OP, "--", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.SUB_ASSIGN, "-=", start);
                        break;
                    }
                    token.set(ETokenType.DASH, "-", start);
                    break;
                case "=":
                    this.advance();
                    if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.EQ_OP, "==", start);
                        break;
                    }
                    token.set(ETokenType.EQUAL, "=", start);
                    break;
                case "!":
                    this.advance();
                    if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.NE_OP, "!=", start);
                        break;
                    }
                    token.set(ETokenType.BANG, "!", start);
                    break;
                case "&":
                    this.advance();
                    if (this.getCurChar() === "&") {
                        this.advance();
                        token.set(ETokenType.AND_OP, "&&", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.ADD_ASSIGN, "&=", start);
                        break;
                    }
                    token.set(ETokenType.AMPERSAND, "&", start);
                    break;
                case "|":
                    this.advance();
                    if (this.getCurChar() === "|") {
                        this.advance();
                        token.set(ETokenType.OR_OP, "||", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.OR_ASSIGN, "|=", start);
                        break;
                    }
                    token.set(ETokenType.VERTICAL_BAR, "|", start);
                    break;
                case "^":
                    this.advance();
                    if (this.getCurChar() === "^") {
                        this.advance();
                        token.set(ETokenType.XOR_OP, "^^", start);
                        break;
                    } else if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.XOR_ASSIGN, "^=", start);
                        break;
                    }
                    token.set(ETokenType.CARET, "^", start);
                    break;
                case "*":
                    this.advance();
                    if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.MUL_ASSIGN, "*=", start);
                        break;
                    }
                    token.set(ETokenType.STAR, "*", start);
                    break;
                case "/":
                    this.advance();
                    if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.DIV_ASSIGN, "/=", start);
                        break;
                    }
                    token.set(ETokenType.SLASH, "/", start);
                    break;
                case "%":
                    this.advance();
                    if (this.getCurChar() === "=") {
                        this.advance();
                        token.set(ETokenType.MOD_ASSIGN, "%=", start);
                        break;
                    }
                    token.set(ETokenType.PERCENT, "%", start);
                    break;
                case "(":
                    this.advance();
                    token.set(ETokenType.LEFT_PAREN, "(", start);
                    break;
                case ")":
                    this.advance();
                    token.set(ETokenType.RIGHT_PAREN, ")", start);
                    break;
                case "{":
                    this.advance();
                    token.set(ETokenType.LEFT_BRACE, "{", start);
                    break;
                case "}":
                    this.advance();
                    token.set(ETokenType.RIGHT_BRACE, "}", start);
                    break;
                case "[":
                    this.advance();
                    token.set(ETokenType.LEFT_BRACKET, "[", start);
                    break;
                case "]":
                    this.advance();
                    token.set(ETokenType.RIGHT_BRACKET, "]", start);
                    break;
                case ".":
                    this.advance();
                    if (LexerUtils.isNum(this.getCurChar())) {
                        return this._scanNumAfterDot();
                    }
                    token.set(ETokenType.DOT, ".", start);
                    break;
                case ",":
                    this.advance();
                    token.set(ETokenType.COMMA, ",", start);
                    break;
                case ":":
                    this.advance();
                    token.set(ETokenType.COLON, ":", start);
                    return token;
                case ";":
                    this.advance();
                    token.set(ETokenType.SEMICOLON, ";", start);
                    break;
                case "~":
                    this.advance();
                    token.set(ETokenType.TILDE, "~", start);
                    break;
                case "?":
                    this.advance();
                    token.set(ETokenType.QUESTION, "?", start);
                    break;
                case '"':
                    this.advance();
                    return this._scanStringConst();
                default:
                    this.throwError(this.getCurPosition(), "Unexpected character " + this.getCurChar());
            }
            return token;
        };
        _proto._scanStringConst = function _scanStringConst() {
            var start = this._getPosition();
            var buffer = [];
            while(this.getCurChar() !== '"'){
                buffer.push(this.getCurChar());
                this.advance();
            }
            this.advance();
            var range = ShaderLab.createRange(start, this._getPosition());
            var token = BaseToken.pool.get();
            token.set(ETokenType.STRING_CONST, buffer.join(""), range);
            return token;
        };
        _proto._scanNumAfterDot = function _scanNumAfterDot() {
            var buffer = [
                "."
            ];
            while(LexerUtils.isNum(this.getCurChar())){
                buffer.push(this.getCurChar());
                this.advance();
            }
            var token = BaseToken.pool.get();
            token.set(ETokenType.FLOAT_CONSTANT, buffer.join(""), this._getPosition(1));
            return token;
        };
        _proto._getPosition = function _getPosition(offset /** offset from starting point */ ) {
            if (offset === void 0) offset = 0;
            return ShaderLab.createPosition(this.current - offset, this._line, this._column - offset);
        };
        _proto._scanWord = function _scanWord() {
            var buffer = [
                this.getCurChar()
            ];
            var start = this._getPosition();
            this.advance();
            while(LexerUtils.isLetter(this.getCurChar())){
                buffer.push(this.getCurChar());
                this.advance();
            }
            var word = buffer.join("");
            var kt = KeywordTable.get(word);
            if (kt) {
                var token = BaseToken.pool.get();
                token.set(kt, word, start);
                return token;
            }
            var token1 = BaseToken.pool.get();
            token1.set(ETokenType.ID, word, start);
            return token1;
        };
        _proto._scanNum = function _scanNum() {
            var buffer = [];
            while(LexerUtils.isNum(this.getCurChar())){
                buffer.push(this.getCurChar());
                this.advance();
            }
            if (this.getCurChar() === ".") {
                buffer.push(this.getCurChar());
                this.advance();
                while(LexerUtils.isNum(this.getCurChar())){
                    buffer.push(this.getCurChar());
                    this.advance();
                }
                this._scanFloatSuffix(buffer);
                var token = BaseToken.pool.get();
                token.set(ETokenType.FLOAT_CONSTANT, buffer.join(""), this._getPosition(buffer.length));
                return token;
            } else {
                if (this.getCurChar() === "e" || this.getCurChar() === "E") {
                    this._scanFloatSuffix(buffer);
                    var token1 = BaseToken.pool.get();
                    token1.set(ETokenType.FLOAT_CONSTANT, buffer.join(""), this._getPosition(buffer.length));
                    return token1;
                } else {
                    this._scanIntegerSuffix(buffer);
                    var token2 = BaseToken.pool.get();
                    token2.set(ETokenType.INT_CONSTANT, buffer.join(""), this._getPosition(buffer.length));
                    return token2;
                }
            }
        };
        _proto._scanFloatSuffix = function _scanFloatSuffix(buffer) {
            if (this.getCurChar() === "e" || this.getCurChar() === "E") {
                buffer.push(this.getCurChar());
                this.advance();
                if (this.getCurChar() === "+" || this.getCurChar() === "-") {
                    buffer.push(this.getCurChar());
                    this.advance();
                }
                if (!LexerUtils.isNum(this.getCurChar())) this.throwError(this.getCurPosition(), "lexing error, invalid exponent suffix.");
                while(LexerUtils.isNum(this.getCurChar())){
                    buffer.push(this.getCurChar());
                    this.advance();
                }
            }
            if (this.getCurChar() === "f" || this.getCurChar() === "F") {
                buffer.push(this.getCurChar());
                this.advance();
            }
        };
        _proto._scanIntegerSuffix = function _scanIntegerSuffix(buffer) {
            if (this.getCurChar() === "u" || this.getCurChar() === "U") {
                buffer.push(this.getCurChar());
                this.advance();
            }
        };
        return Lexer;
    }(BaseScanner);

    var EAction = /*#__PURE__*/ function(EAction) {
        EAction[EAction["Shift"] = 0] = "Shift";
        EAction[EAction["Reduce"] = 1] = "Reduce";
        EAction[EAction["Accept"] = 2] = "Accept";
        return EAction;
    }({});

    var ShaderData = function ShaderData() {
        this.globalPrecisions = [];
    };

    var SymbolDataType = function SymbolDataType(type, typeLexeme, arraySpecifier) {
        this.type = type;
        this.typeLexeme = typeLexeme;
        this.arraySpecifier = arraySpecifier;
    };

    var ESymbolType = /*#__PURE__*/ function(ESymbolType) {
        ESymbolType[ESymbolType["VAR"] = 0] = "VAR";
        ESymbolType[ESymbolType["FN"] = 1] = "FN";
        ESymbolType[ESymbolType["STRUCT"] = 2] = "STRUCT";
        return ESymbolType;
    }({});
    var SymbolInfo = function SymbolInfo(ident, symbolType, astNode, dataType) {
        this.ident = ident;
        this.symbolType = symbolType;
        this.astNode = astNode;
        this.dataType = dataType;
    };

    var FnSymbol = /*#__PURE__*/ function(SymbolInfo) {
        _inherits(FnSymbol, SymbolInfo);
        function FnSymbol(lexeme, astNode) {
            var type = new SymbolDataType(astNode.protoType.returnType.type, astNode.protoType.returnType.typeSpecifier.lexeme);
            return SymbolInfo.call(this, lexeme, ESymbolType.FN, astNode, type) || this;
        }
        return FnSymbol;
    }(SymbolInfo);

    var StructSymbol = /*#__PURE__*/ function(SymbolInfo) {
        _inherits(StructSymbol, SymbolInfo);
        function StructSymbol(lexeme, astNode) {
            return SymbolInfo.call(this, lexeme, ESymbolType.STRUCT, astNode) || this;
        }
        return StructSymbol;
    }(SymbolInfo);

    /**
     * The base class of `SymbolTable`
     */ var BaseSymbolTable = /*#__PURE__*/ function() {
        function BaseSymbolTable() {
            this._table = new Map();
        }
        var _proto = BaseSymbolTable.prototype;
        _proto.insert = function insert(sm) {
            var _this__table_get;
            var entry = (_this__table_get = this._table.get(sm.ident)) != null ? _this__table_get : [];
            for(var i = 0; i < entry.length; i++){
                if (this.symbolEqualCheck(entry[i], sm)) {
                    engine.Logger.warn("replace symbol:", sm.ident);
                    entry[i] = sm;
                    return;
                }
            }
            entry.push(sm);
            this._table.set(sm.ident, entry);
        };
        _proto.lookup = function lookup(sm) {
            var _this__table_get;
            var entry = (_this__table_get = this._table.get(sm.ident)) != null ? _this__table_get : [];
            for(var _iterator = _create_for_of_iterator_helper_loose(entry), _step; !(_step = _iterator()).done;){
                var item = _step.value;
                if (this.symbolEqualCheck(item, sm)) return item;
            }
        };
        return BaseSymbolTable;
    }();
    var SymbolTableStack = /*#__PURE__*/ function() {
        function SymbolTableStack() {
            this._stack = [];
        }
        var _proto = SymbolTableStack.prototype;
        _proto.newScope = function newScope(scope) {
            this._stack.push(scope);
        };
        _proto.clear = function clear() {
            this._stack.length = 0;
        };
        _proto.dropScope = function dropScope() {
            this._stack.pop();
        };
        _proto.insert = function insert(sm) {
            this._scope.insert(sm);
        };
        _proto.lookup = function lookup(sm) {
            for(var i = this._stack.length - 1; i >= 0; i--){
                var scope = this._stack[i];
                var ret = scope.lookup(sm);
                if (ret) return ret;
            }
        };
        _create_class(SymbolTableStack, [
            {
                key: "_scope",
                get: function get() {
                    return this._stack[this._stack.length - 1];
                }
            }
        ]);
        return SymbolTableStack;
    }();

    var SymbolTable$1 = /*#__PURE__*/ function(BaseSymbolTable) {
        _inherits(SymbolTable, BaseSymbolTable);
        function SymbolTable() {
            return BaseSymbolTable.apply(this, arguments) || this;
        }
        var _proto = SymbolTable.prototype;
        _proto.symbolEqualCheck = function symbolEqualCheck(exist, newSymbol) {
            if (exist.symbolType !== newSymbol.symbolType) return false;
            if (newSymbol.symbolType === ESymbolType.FN) {
                if (!newSymbol.astNode && !newSymbol.signature) return true;
                var existParams = exist.astNode.protoType.paramSig;
                var _newSymbol_signature;
                var newSymbolParams = (_newSymbol_signature = newSymbol.signature) != null ? _newSymbol_signature : newSymbol.astNode.protoType.paramSig;
                if (existParams.length !== newSymbolParams.length) return false;
                for(var i = 0; i < existParams.length; i++){
                    if (existParams[i] === TypeAny || newSymbolParams[i] === TypeAny) continue;
                    if (existParams[i] !== newSymbolParams[i]) return false;
                }
            }
            return true;
        };
        _proto.getAllFnSymbols = function getAllFnSymbols(fnIdent) {
            var _this__table_get;
            var entries = (_this__table_get = this._table.get(fnIdent)) != null ? _this__table_get : [];
            return entries.filter(function(item) {
                return item.symbolType === ESymbolType.FN;
            });
        };
        return SymbolTable;
    }(BaseSymbolTable);

    var VarSymbol = /*#__PURE__*/ function(SymbolInfo) {
        _inherits(VarSymbol, SymbolInfo);
        function VarSymbol(ident, dataType, isGlobalVariable, initAst) {
            var _this;
            _this = SymbolInfo.call(this, ident, ESymbolType.VAR, initAst, dataType) || this;
            _this.isGlobalVariable = isGlobalVariable;
            return _this;
        }
        return VarSymbol;
    }(SymbolInfo);

    var SematicAnalyzer = /*#__PURE__*/ function() {
        function SematicAnalyzer() {
            this.semanticStack = [];
            this.acceptRule = undefined;
            this.symbolTable = new SymbolTableStack();
            this._shaderData = new ShaderData();
            this.errors = [];
            this._translationRuleTable = new Map();
            this.newScope();
        }
        var _proto = SematicAnalyzer.prototype;
        _proto.reset = function reset() {
            this.semanticStack.length = 0;
            this._shaderData = new ShaderData();
            this.symbolTable.clear();
            this.newScope();
            this.errors.length = 0;
        };
        _proto.newScope = function newScope() {
            var scope = new SymbolTable$1();
            this.symbolTable.newScope(scope);
        };
        _proto.dropScope = function dropScope() {
            return this.symbolTable.dropScope();
        };
        _proto.addTranslationRule = function addTranslationRule(pid, rule) {
            this._translationRuleTable.set(pid, rule);
        };
        _proto.getTranslationRule = function getTranslationRule(pid) {
            return this._translationRuleTable.get(pid);
        };
        _proto.error = function error(loc) {
            for(var _len = arguments.length, param = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                param[_key - 1] = arguments[_key];
            }
            var err = new GSError(GSErrorName.CompilationError, param.join(""), loc, ShaderLab._processingPassText);
            this.errors.push(err);
            return err;
        };
        _create_class(SematicAnalyzer, [
            {
                key: "shaderData",
                get: function get() {
                    return this._shaderData;
                }
            }
        ]);
        return SematicAnalyzer;
    }();

    var ENonTerminal = /*#__PURE__*/ function(ENonTerminal) {
        ENonTerminal[ENonTerminal["START"] = 2000] = "START";
        // galacean
        ENonTerminal[ENonTerminal["gs_shader_program"] = 2001] = "gs_shader_program";
        // glsl
        ENonTerminal[ENonTerminal["global_declaration"] = 2002] = "global_declaration";
        ENonTerminal[ENonTerminal["variable_declaration"] = 2003] = "variable_declaration";
        ENonTerminal[ENonTerminal["array_specifier_list"] = 2004] = "array_specifier_list";
        ENonTerminal[ENonTerminal["array_specifier"] = 2005] = "array_specifier";
        ENonTerminal[ENonTerminal["ext_builtin_type_specifier_nonarray"] = 2006] = "ext_builtin_type_specifier_nonarray";
        ENonTerminal[ENonTerminal["precision_specifier"] = 2007] = "precision_specifier";
        ENonTerminal[ENonTerminal["variable_identifier"] = 2008] = "variable_identifier";
        ENonTerminal[ENonTerminal["variable_identifier_node"] = 2009] = "variable_identifier_node";
        ENonTerminal[ENonTerminal["primary_expression"] = 2010] = "primary_expression";
        ENonTerminal[ENonTerminal["postfix_expression"] = 2011] = "postfix_expression";
        ENonTerminal[ENonTerminal["integer_expression"] = 2012] = "integer_expression";
        ENonTerminal[ENonTerminal["function_call"] = 2013] = "function_call";
        ENonTerminal[ENonTerminal["function_call_generic"] = 2014] = "function_call_generic";
        ENonTerminal[ENonTerminal["function_call_header_no_parameters"] = 2015] = "function_call_header_no_parameters";
        ENonTerminal[ENonTerminal["function_call_header_with_parameters"] = 2016] = "function_call_header_with_parameters";
        ENonTerminal[ENonTerminal["function_call_parameter_list"] = 2017] = "function_call_parameter_list";
        ENonTerminal[ENonTerminal["function_call_header"] = 2018] = "function_call_header";
        ENonTerminal[ENonTerminal["function_identifier"] = 2019] = "function_identifier";
        ENonTerminal[ENonTerminal["constructor_identifier"] = 2020] = "constructor_identifier";
        ENonTerminal[ENonTerminal["unary_expression"] = 2021] = "unary_expression";
        ENonTerminal[ENonTerminal["unary_operator"] = 2022] = "unary_operator";
        ENonTerminal[ENonTerminal["multiplicative_expression"] = 2023] = "multiplicative_expression";
        ENonTerminal[ENonTerminal["additive_expression"] = 2024] = "additive_expression";
        ENonTerminal[ENonTerminal["shift_expression"] = 2025] = "shift_expression";
        ENonTerminal[ENonTerminal["relational_expression"] = 2026] = "relational_expression";
        ENonTerminal[ENonTerminal["equality_expression"] = 2027] = "equality_expression";
        ENonTerminal[ENonTerminal["and_expression"] = 2028] = "and_expression";
        ENonTerminal[ENonTerminal["inclusive_or_expression"] = 2029] = "inclusive_or_expression";
        ENonTerminal[ENonTerminal["exclusive_or_expression"] = 2030] = "exclusive_or_expression";
        ENonTerminal[ENonTerminal["logical_and_expression"] = 2031] = "logical_and_expression";
        ENonTerminal[ENonTerminal["logical_xor_expression"] = 2032] = "logical_xor_expression";
        ENonTerminal[ENonTerminal["logical_or_expression"] = 2033] = "logical_or_expression";
        ENonTerminal[ENonTerminal["conditional_expression"] = 2034] = "conditional_expression";
        ENonTerminal[ENonTerminal["assignment_expression"] = 2035] = "assignment_expression";
        ENonTerminal[ENonTerminal["assignment_operator"] = 2036] = "assignment_operator";
        ENonTerminal[ENonTerminal["expression"] = 2037] = "expression";
        ENonTerminal[ENonTerminal["integer_constant_expression"] = 2038] = "integer_constant_expression";
        ENonTerminal[ENonTerminal["integer_constant_expression_operator"] = 2039] = "integer_constant_expression_operator";
        ENonTerminal[ENonTerminal["declaration"] = 2040] = "declaration";
        ENonTerminal[ENonTerminal["function_prototype"] = 2041] = "function_prototype";
        ENonTerminal[ENonTerminal["function_declarator"] = 2042] = "function_declarator";
        ENonTerminal[ENonTerminal["function_header_with_parameters"] = 2043] = "function_header_with_parameters";
        ENonTerminal[ENonTerminal["function_header"] = 2044] = "function_header";
        ENonTerminal[ENonTerminal["function_parameter_list"] = 2045] = "function_parameter_list";
        ENonTerminal[ENonTerminal["parameter_declarator"] = 2046] = "parameter_declarator";
        ENonTerminal[ENonTerminal["parameter_declaration"] = 2047] = "parameter_declaration";
        ENonTerminal[ENonTerminal["parameter_qualifier"] = 2048] = "parameter_qualifier";
        ENonTerminal[ENonTerminal["parameter_type_specifier"] = 2049] = "parameter_type_specifier";
        ENonTerminal[ENonTerminal["init_declarator_list"] = 2050] = "init_declarator_list";
        ENonTerminal[ENonTerminal["single_declaration"] = 2051] = "single_declaration";
        ENonTerminal[ENonTerminal["fully_specified_type"] = 2052] = "fully_specified_type";
        ENonTerminal[ENonTerminal["type_qualifier"] = 2053] = "type_qualifier";
        ENonTerminal[ENonTerminal["single_type_qualifier"] = 2054] = "single_type_qualifier";
        ENonTerminal[ENonTerminal["storage_qualifier"] = 2055] = "storage_qualifier";
        ENonTerminal[ENonTerminal["precision_qualifier"] = 2056] = "precision_qualifier";
        ENonTerminal[ENonTerminal["interpolation_qualifier"] = 2057] = "interpolation_qualifier";
        ENonTerminal[ENonTerminal["invariant_qualifier"] = 2058] = "invariant_qualifier";
        ENonTerminal[ENonTerminal["type_specifier"] = 2059] = "type_specifier";
        ENonTerminal[ENonTerminal["type_specifier_nonarray"] = 2060] = "type_specifier_nonarray";
        ENonTerminal[ENonTerminal["type_specifier_no_prec"] = 2061] = "type_specifier_no_prec";
        ENonTerminal[ENonTerminal["basic_type"] = 2062] = "basic_type";
        ENonTerminal[ENonTerminal["struct_specifier"] = 2063] = "struct_specifier";
        ENonTerminal[ENonTerminal["struct_declaration_list"] = 2064] = "struct_declaration_list";
        ENonTerminal[ENonTerminal["struct_declaration"] = 2065] = "struct_declaration";
        ENonTerminal[ENonTerminal["struct_declarator_list"] = 2066] = "struct_declarator_list";
        ENonTerminal[ENonTerminal["struct_declarator"] = 2067] = "struct_declarator";
        ENonTerminal[ENonTerminal["identifier_list"] = 2068] = "identifier_list";
        ENonTerminal[ENonTerminal["decl_identifier"] = 2069] = "decl_identifier";
        ENonTerminal[ENonTerminal["initializer"] = 2070] = "initializer";
        ENonTerminal[ENonTerminal["initializer_list"] = 2071] = "initializer_list";
        ENonTerminal[ENonTerminal["declaration_statement"] = 2072] = "declaration_statement";
        ENonTerminal[ENonTerminal["simple_statement"] = 2073] = "simple_statement";
        ENonTerminal[ENonTerminal["compound_statement_no_scope"] = 2074] = "compound_statement_no_scope";
        ENonTerminal[ENonTerminal["statement_with_scope"] = 2075] = "statement_with_scope";
        ENonTerminal[ENonTerminal["compound_statement"] = 2076] = "compound_statement";
        ENonTerminal[ENonTerminal["statement"] = 2077] = "statement";
        ENonTerminal[ENonTerminal["statement_list"] = 2078] = "statement_list";
        ENonTerminal[ENonTerminal["iteration_statement_no_new_scope"] = 2079] = "iteration_statement_no_new_scope";
        ENonTerminal[ENonTerminal["expression_statement"] = 2080] = "expression_statement";
        ENonTerminal[ENonTerminal["selection_statement"] = 2081] = "selection_statement";
        ENonTerminal[ENonTerminal["selection_rest_statement"] = 2082] = "selection_rest_statement";
        ENonTerminal[ENonTerminal["condition"] = 2083] = "condition";
        ENonTerminal[ENonTerminal["conditionopt"] = 2084] = "conditionopt";
        ENonTerminal[ENonTerminal["iteration_statement"] = 2085] = "iteration_statement";
        ENonTerminal[ENonTerminal["for_init_statement"] = 2086] = "for_init_statement";
        ENonTerminal[ENonTerminal["for_rest_statement"] = 2087] = "for_rest_statement";
        ENonTerminal[ENonTerminal["jump_statement"] = 2088] = "jump_statement";
        ENonTerminal[ENonTerminal["external_declaration"] = 2089] = "external_declaration";
        ENonTerminal[ENonTerminal["function_definition"] = 2090] = "function_definition";
        ENonTerminal[ENonTerminal["field_selection"] = 2091] = "field_selection";
        ENonTerminal[ENonTerminal["bool_constant"] = 2092] = "bool_constant";
        ENonTerminal[ENonTerminal["function_identifier_node"] = 2093] = "function_identifier_node";
        ENonTerminal[ENonTerminal["typename_identifier_node"] = 2094] = "typename_identifier_node";
        ENonTerminal[ENonTerminal["scope_brace"] = 2095] = "scope_brace";
        ENonTerminal[ENonTerminal["scope_end_brace"] = 2096] = "scope_end_brace";
        ENonTerminal[ENonTerminal["_ignore"] = 2097] = "_ignore";
        return ENonTerminal;
    }({});

    var Production = function Production(goal, derivation) {
        this.goal = goal;
        this.derivation = derivation;
        this.id = Production._id++;
        Production.pool.set(this.id, this);
    };
    Production._id = 0;
    Production.pool = new Map();

    var Grammar = /*#__PURE__*/ function() {
        function Grammar(start, productions) {
            this.startSymbol = start;
            productions.unshift(new Production(ENonTerminal.START, [
                start
            ]));
            this.productions = productions;
        }
        var _proto = Grammar.prototype;
        _proto.getProductionList = function getProductionList(nonTerminal) {
            return this.productions.filter(function(item) {
                return item.goal === nonTerminal;
            });
        };
        _proto.isNullableNT = function isNullableNT(NT) {
            return this.productions.find(function(item) {
                return item.goal === NT && item.derivation[0] === ETokenType.EPSILON;
            });
        };
        _proto.getProductionByID = function getProductionByID(pid) {
            return Production.pool.get(pid);
        };
        Grammar.create = function create(start, productions) {
            var _ps = productions.map(function(gsl) {
                return new Production(gsl[0], gsl.slice(1));
            });
            return new Grammar(start, _ps);
        };
        return Grammar;
    }();

    var EShaderStage = /*#__PURE__*/ function(EShaderStage) {
        EShaderStage[EShaderStage["VERTEX"] = 0] = "VERTEX";
        EShaderStage[EShaderStage["FRAGMENT"] = 1] = "FRAGMENT";
        EShaderStage[EShaderStage["ALL"] = 2] = "ALL";
        return EShaderStage;
    }({});

    function isGenericType(t) {
        return t >= 200 && t <= 213;
    }
    var BuiltinFunctionTable = new Map();
    var BuiltinFunction = /*#__PURE__*/ function() {
        function BuiltinFunction(ident, returnType, scope) {
            for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
                args[_key - 3] = arguments[_key];
            }
            this.ident = ident;
            this._returnType = returnType;
            this.args = args;
            this.scope = scope;
        }
        BuiltinFunction.getReturnType = function getReturnType(fn, genType) {
            if (!isGenericType(fn._returnType)) return fn._returnType;
            return genType;
        };
        BuiltinFunction._create = function _create(ident, returnType) {
            for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
                args[_key - 2] = arguments[_key];
            }
            var fn = _construct(BuiltinFunction, [].concat([
                ident,
                returnType,
                EShaderStage.ALL
            ], args));
            var _BuiltinFunctionTable_get;
            var list = (_BuiltinFunctionTable_get = BuiltinFunctionTable.get(ident)) != null ? _BuiltinFunctionTable_get : [];
            list.push(fn);
            BuiltinFunctionTable.set(ident, list);
        };
        BuiltinFunction._createWithScop = function _createWithScop(ident, returnType, scope) {
            for(var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
                args[_key - 3] = arguments[_key];
            }
            var fn = _construct(BuiltinFunction, [].concat([
                ident,
                returnType,
                scope
            ], args));
            var _BuiltinFunctionTable_get;
            var list = (_BuiltinFunctionTable_get = BuiltinFunctionTable.get(ident)) != null ? _BuiltinFunctionTable_get : [];
            list.push(fn);
            BuiltinFunctionTable.set(ident, list);
        };
        BuiltinFunction.getFn = function getFn(ident) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            var list = BuiltinFunctionTable.get(ident);
            var realType = TypeAny;
            if (list == null ? void 0 : list.length) {
                var fun = list.find(function(item) {
                    if (item.args.length !== args.length) return false;
                    var genType = 0;
                    for(var i = 0; i < args.length; i++){
                        if (args[i] === TypeAny) continue;
                        realType = args[i];
                        if (isGenericType(item.args[i])) {
                            if (genType === 0) {
                                genType = args[i];
                                continue;
                            } else {
                                realType = genType;
                            }
                        }
                        if (args[i] === TypeAny) continue;
                        if (args[i] !== realType) return false;
                    }
                    return true;
                });
                if (fun) return {
                    fun: fun,
                    genType: realType
                };
            }
        };
        return BuiltinFunction;
    }();
    BuiltinFunction._create("radians", 200, 200);
    BuiltinFunction._create("degrees", 200, 200);
    BuiltinFunction._create("sin", 200, 200);
    BuiltinFunction._create("cos", 200, 200);
    BuiltinFunction._create("tan", 200, 200);
    BuiltinFunction._create("asin", 200, 200);
    BuiltinFunction._create("acos", 200, 200);
    BuiltinFunction._create("atan", 200, 200, 200);
    BuiltinFunction._create("atan", 200, 200);
    BuiltinFunction._create("sinh", 200, 200);
    BuiltinFunction._create("cosh", 200, 200);
    BuiltinFunction._create("tanh", 200, 200);
    BuiltinFunction._create("asinh", 200, 200);
    BuiltinFunction._create("acosh", 200, 200);
    BuiltinFunction._create("atanh", 200, 200);
    BuiltinFunction._create("pow", 200, 200, 200);
    BuiltinFunction._create("exp", 200, 200);
    BuiltinFunction._create("log", 200, 200);
    BuiltinFunction._create("exp2", 200, 200);
    BuiltinFunction._create("log2", 200, 200);
    BuiltinFunction._create("sqrt", 200, 200);
    BuiltinFunction._create("inversesqrt", 200, 200);
    BuiltinFunction._create("abs", 200, 200);
    BuiltinFunction._create("abs", 201, 201);
    BuiltinFunction._create("sign", 200, 200);
    BuiltinFunction._create("sign", 201, 201);
    BuiltinFunction._create("floor", 200, 200);
    BuiltinFunction._create("trunc", 200, 200);
    BuiltinFunction._create("round", 200, 200);
    BuiltinFunction._create("roundEven", 200, 200);
    BuiltinFunction._create("ceil", 200, 200);
    BuiltinFunction._create("fract", 200, 200);
    BuiltinFunction._create("mod", 200, 200, EKeyword.FLOAT);
    BuiltinFunction._create("mod", 200, 200, 200);
    BuiltinFunction._create("min", 200, 200, 200);
    BuiltinFunction._create("min", 200, 200, EKeyword.FLOAT);
    BuiltinFunction._create("min", 201, 201, 201);
    BuiltinFunction._create("min", 201, 201, EKeyword.INT);
    BuiltinFunction._create("min", 202, 202, 202);
    BuiltinFunction._create("min", 202, 202, EKeyword.UINT);
    BuiltinFunction._create("max", 200, 200, 200);
    BuiltinFunction._create("max", 200, 200, EKeyword.FLOAT);
    BuiltinFunction._create("max", 201, 201, 201);
    BuiltinFunction._create("max", 201, 201, EKeyword.INT);
    BuiltinFunction._create("clamp", 200, 200, 200, 200);
    BuiltinFunction._create("clamp", 200, 200, EKeyword.FLOAT, EKeyword.FLOAT);
    BuiltinFunction._create("clamp", 201, 201, 201, 201);
    BuiltinFunction._create("clamp", 201, 201, EKeyword.INT, EKeyword.INT);
    BuiltinFunction._create("clamp", 202, 202, 202, 202);
    BuiltinFunction._create("clamp", 202, 202, EKeyword.UINT, EKeyword.UINT);
    BuiltinFunction._create("mix", 200, 200, 200, 200);
    BuiltinFunction._create("mix", 200, 200, 200, EKeyword.FLOAT);
    BuiltinFunction._create("mix", 200, 200, 200, 203);
    BuiltinFunction._create("step", 200, 200, 200);
    BuiltinFunction._create("step", 200, EKeyword.FLOAT, 200);
    BuiltinFunction._create("smoothstep", 200, 200, 200, 200);
    BuiltinFunction._create("smoothstep", 200, EKeyword.FLOAT, EKeyword.FLOAT, 200);
    BuiltinFunction._create("isnan", 203, 200);
    BuiltinFunction._create("isinf", 203, 200);
    BuiltinFunction._create("floatBitsToInt", 200, 200);
    BuiltinFunction._create("floatBitsToUint", 202, 200);
    BuiltinFunction._create("intBitsToFloat", 200, 201);
    BuiltinFunction._create("uintBitsToFloat", 200, 202);
    BuiltinFunction._create("packSnorm2x16", EKeyword.UINT, EKeyword.VEC2);
    BuiltinFunction._create("unpackSnorm2x16", EKeyword.VEC2, EKeyword.UINT);
    BuiltinFunction._create("packUnorm2x16", EKeyword.UINT, EKeyword.VEC2);
    BuiltinFunction._create("unpackUnorm2x16", EKeyword.VEC2, EKeyword.UINT);
    BuiltinFunction._create("packHalf2x16", EKeyword.UINT, EKeyword.VEC2);
    BuiltinFunction._create("unpackHalf2x16", EKeyword.VEC2, EKeyword.UINT);
    BuiltinFunction._create("length", EKeyword.FLOAT, 200);
    BuiltinFunction._create("distance", EKeyword.FLOAT, 200, 200);
    BuiltinFunction._create("dot", EKeyword.FLOAT, 200, 200);
    BuiltinFunction._create("cross", EKeyword.VEC3, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("normalize", 200, 200);
    BuiltinFunction._create("faceforward", 200, 200, 200, 200);
    BuiltinFunction._create("reflect", 200, 200, 200);
    BuiltinFunction._create("refract", 200, 200, 200, EKeyword.FLOAT);
    BuiltinFunction._create("matrixCompMult", 204, 204, 204);
    BuiltinFunction._create("outerProduct", EKeyword.MAT2, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("outerProduct", EKeyword.MAT3, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("outerProduct", EKeyword.MAT4, EKeyword.VEC4, EKeyword.VEC4);
    BuiltinFunction._create("outerProduct", EKeyword.MAT2X3, EKeyword.VEC3, EKeyword.VEC2);
    BuiltinFunction._create("outerProduct", EKeyword.MAT3X2, EKeyword.VEC2, EKeyword.VEC3);
    BuiltinFunction._create("outerProduct", EKeyword.MAT2X4, EKeyword.VEC4, EKeyword.VEC2);
    BuiltinFunction._create("outerProduct", EKeyword.MAT4X2, EKeyword.VEC2, EKeyword.VEC4);
    BuiltinFunction._create("outerProduct", EKeyword.MAT3X4, EKeyword.VEC4, EKeyword.VEC3);
    BuiltinFunction._create("outerProduct", EKeyword.MAT4X3, EKeyword.VEC3, EKeyword.VEC4);
    BuiltinFunction._create("transpose", EKeyword.MAT2, EKeyword.MAT2);
    BuiltinFunction._create("transpose", EKeyword.MAT3, EKeyword.MAT3);
    BuiltinFunction._create("transpose", EKeyword.MAT4, EKeyword.MAT4);
    BuiltinFunction._create("transpose", EKeyword.MAT2X3, EKeyword.MAT3X2);
    BuiltinFunction._create("transpose", EKeyword.MAT3X2, EKeyword.MAT2X3);
    BuiltinFunction._create("transpose", EKeyword.MAT4X2, EKeyword.MAT2X4);
    BuiltinFunction._create("transpose", EKeyword.MAT2X4, EKeyword.MAT4X2);
    BuiltinFunction._create("transpose", EKeyword.MAT3X4, EKeyword.MAT4X3);
    BuiltinFunction._create("transpose", EKeyword.MAT4X3, EKeyword.MAT3X4);
    BuiltinFunction._create("determinant", EKeyword.FLOAT, EKeyword.MAT2);
    BuiltinFunction._create("determinant", EKeyword.FLOAT, EKeyword.MAT3);
    BuiltinFunction._create("determinant", EKeyword.FLOAT, EKeyword.MAT4);
    BuiltinFunction._create("inverse", EKeyword.MAT2, EKeyword.MAT2);
    BuiltinFunction._create("inverse", EKeyword.MAT3, EKeyword.MAT3);
    BuiltinFunction._create("inverse", EKeyword.MAT4, EKeyword.MAT4);
    BuiltinFunction._create("lessThan", 205, 208, 208);
    BuiltinFunction._create("lessThan", 205, 206, 206);
    BuiltinFunction._create("lessThan", 205, 207, 207);
    BuiltinFunction._create("lessThanEqual", 205, 208, 208);
    BuiltinFunction._create("lessThanEqual", 205, 206, 206);
    BuiltinFunction._create("lessThanEqual", 205, 207, 207);
    BuiltinFunction._create("greaterThan", 205, 208, 208);
    BuiltinFunction._create("greaterThan", 205, 206, 206);
    BuiltinFunction._create("greaterThan", 205, 207, 207);
    BuiltinFunction._create("greaterThanEqual", 205, 208, 208);
    BuiltinFunction._create("greaterThanEqual", 205, 206, 206);
    BuiltinFunction._create("greaterThanEqual", 205, 207, 207);
    BuiltinFunction._create("equal", 205, 208, 208);
    BuiltinFunction._create("equal", 205, 206, 206);
    BuiltinFunction._create("equal", 205, 207, 207);
    BuiltinFunction._create("equal", 205, 205, 205);
    BuiltinFunction._create("notEqual", 205, 208, 208);
    BuiltinFunction._create("notEqual", 205, 206, 206);
    BuiltinFunction._create("notEqual", 205, 207, 207);
    BuiltinFunction._create("notEqual", 205, 205, 205);
    BuiltinFunction._create("any", EKeyword.BOOL, 205);
    BuiltinFunction._create("all", EKeyword.BOOL, 205);
    BuiltinFunction._create("not", 205, 205);
    BuiltinFunction._create("textureSize", EKeyword.IVEC2, 210, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC3, 211, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC2, 212, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC2, EKeyword.SAMPLER2D_SHADOW, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC2, EKeyword.SAMPLER_CUBE_SHADOW, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC3, 213, EKeyword.INT);
    BuiltinFunction._create("textureSize", EKeyword.IVEC3, EKeyword.SAMPLER2D_ARRAY_SHADOW, EKeyword.INT);
    BuiltinFunction._create("texture2D", EKeyword.SAMPLER2D, EKeyword.VEC2);
    BuiltinFunction._create("texture2D", EKeyword.SAMPLER2D, EKeyword.VEC2, EKeyword.FLOAT);
    BuiltinFunction._create("texture", 209, 210, EKeyword.VEC2, EKeyword.FLOAT);
    BuiltinFunction._create("texture", 209, 210, EKeyword.VEC2);
    BuiltinFunction._create("texture", 209, 211, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("texture", 209, 211, EKeyword.VEC3);
    BuiltinFunction._create("texture", 209, 212, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("texture", 209, 212, EKeyword.VEC3);
    BuiltinFunction._create("texture", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("texture", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3);
    BuiltinFunction._create("texture", EKeyword.FLOAT, EKeyword.SAMPLER_CUBE_SHADOW, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("texture", EKeyword.FLOAT, EKeyword.SAMPLER_CUBE_SHADOW, EKeyword.VEC4);
    BuiltinFunction._create("texture", 209, EKeyword.SAMPLER2D_ARRAY, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("texture", 209, EKeyword.SAMPLER2D_ARRAY, EKeyword.VEC3);
    BuiltinFunction._create("texture", EKeyword.FLOAT, EKeyword.SAMPLER2D_ARRAY_SHADOW, EKeyword.VEC4);
    BuiltinFunction._create("textureProj", 209, 210, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureProj", 209, 210, EKeyword.VEC3);
    BuiltinFunction._create("textureProj", 209, 210, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProj", 209, 210, EKeyword.VEC4);
    BuiltinFunction._create("textureProj", 209, 211, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProj", 209, 211, EKeyword.VEC4);
    BuiltinFunction._create("textureProj", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProj", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4);
    BuiltinFunction._create("textureLod", 209, 210, EKeyword.VEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureLod", 209, 211, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureLod", 209, 212, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureLod", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureLod", 209, 213, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureCube", EKeyword.SAMPLER_CUBE, EKeyword.VEC3);
    BuiltinFunction._create("textureCube", EKeyword.SAMPLER_CUBE, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureCubeLod", EKeyword.SAMPLER_CUBE, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureOffset", 209, 210, EKeyword.VEC2, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureOffset", 209, 210, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureOffset", 209, 211, EKeyword.VEC3, EKeyword.IVEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureOffset", 209, 211, EKeyword.VEC3, EKeyword.IVEC3);
    BuiltinFunction._create("textureOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.IVEC2);
    BuiltinFunction._create("textureOffset", 209, 213, EKeyword.VEC3, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureOffset", 209, 213, EKeyword.VEC3, EKeyword.IVEC2);
    BuiltinFunction._create("texelFetch", 209, 210, EKeyword.IVEC2, EKeyword.INT);
    BuiltinFunction._create("texelFetch", 209, 211, EKeyword.IVEC3, EKeyword.INT);
    BuiltinFunction._create("texelFetch", 209, 213, EKeyword.IVEC3, EKeyword.INT);
    BuiltinFunction._create("texelFetchOffset", 209, 210, EKeyword.IVEC2, EKeyword.INT, EKeyword.IVEC2);
    BuiltinFunction._create("texelFetchOffset", 209, 211, EKeyword.IVEC3, EKeyword.INT, EKeyword.IVEC3);
    BuiltinFunction._create("texelFetchOffset", 209, 213, EKeyword.IVEC3, EKeyword.INT, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjOffset", 209, 210, EKeyword.VEC3, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjOffset", 209, 210, EKeyword.VEC3, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjOffset", 209, 210, EKeyword.VEC4, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjOffset", 209, 210, EKeyword.VEC4, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjOffset", 209, 211, EKeyword.VEC4, EKeyword.IVEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjOffset", 209, 211, EKeyword.VEC4, EKeyword.IVEC3);
    BuiltinFunction._create("textureProjOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.IVEC2, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.IVEC2);
    BuiltinFunction._create("textureLodOffset", 209, 210, EKeyword.VEC2, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureLodOffset", 209, 211, EKeyword.VEC3, EKeyword.FLOAT, EKeyword.IVEC3);
    BuiltinFunction._create("textureLodOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureLodOffset", 209, 213, EKeyword.VEC3, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjLod", 209, 210, EKeyword.VEC3, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjLod", 209, 210, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjLod", 209, 211, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjLod", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.FLOAT);
    BuiltinFunction._create("textureProjLodOffset", 209, 210, EKeyword.VEC3, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjLodOffset", 209, 210, EKeyword.VEC4, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjLodOffset", 209, 211, EKeyword.VEC4, EKeyword.FLOAT, EKeyword.IVEC3);
    BuiltinFunction._create("textureProjLodOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.FLOAT, EKeyword.IVEC2);
    BuiltinFunction._create("textureGrad", 209, 210, EKeyword.VEC2, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureGrad", 209, 211, EKeyword.VEC3, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("textureGrad", 209, 212, EKeyword.VEC3, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("textureGrad", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureGrad", EKeyword.FLOAT, EKeyword.SAMPLER_CUBE_SHADOW, EKeyword.VEC4, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("textureGrad", 209, 213, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureGrad", EKeyword.FLOAT, EKeyword.SAMPLER2D_ARRAY_SHADOW, EKeyword.VEC4, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureGradOffset", 209, 210, EKeyword.VEC2, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureGradOffset", 209, 211, EKeyword.VEC3, EKeyword.VEC3, EKeyword.VEC3, EKeyword.IVEC3);
    BuiltinFunction._create("textureGradOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureGradOffset", 209, 213, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureGradOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_ARRAY_SHADOW, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjGrad", 209, 210, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureProjGrad", 209, 210, EKeyword.VEC4, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureProjGrad", 209, 211, EKeyword.VEC4, EKeyword.VEC3, EKeyword.VEC3);
    BuiltinFunction._create("textureProjGrad", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.VEC2, EKeyword.VEC2);
    BuiltinFunction._create("textureProjGradOffset", 209, 210, EKeyword.VEC3, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjGradOffset", 209, 210, EKeyword.VEC4, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._create("textureProjGradOffset", 209, 211, EKeyword.VEC4, EKeyword.VEC3, EKeyword.VEC3, EKeyword.IVEC3);
    BuiltinFunction._create("textureProjGradOffset", EKeyword.FLOAT, EKeyword.SAMPLER2D_SHADOW, EKeyword.VEC4, EKeyword.VEC2, EKeyword.VEC2, EKeyword.IVEC2);
    BuiltinFunction._createWithScop("dFdx", 200, EShaderStage.FRAGMENT, 200);
    BuiltinFunction._createWithScop("dFdy", 200, EShaderStage.FRAGMENT, 200);
    BuiltinFunction._createWithScop("fwidth", 200, EShaderStage.FRAGMENT, 200);

    var BuiltinVariableTable = new Map();
    var BuiltinVariable = /*#__PURE__*/ function() {
        function BuiltinVariable(type, lexeme, scope) {
            this.type = type;
            this.lexeme = lexeme;
            this.scope = scope;
        }
        BuiltinVariable.createVariable = function createVariable(lexeme, type, scope) {
            if (scope === void 0) scope = EShaderStage.ALL;
            var item = new BuiltinVariable(type, lexeme, scope);
            BuiltinVariableTable.set(lexeme, item);
        };
        BuiltinVariable.getVar = function getVar(ident) {
            return BuiltinVariableTable.get(ident);
        };
        return BuiltinVariable;
    }();
    BuiltinVariable.createVariable("gl_VertexID", EKeyword.INT, EShaderStage.VERTEX);
    BuiltinVariable.createVariable("gl_InstanceID", EKeyword.INT, EShaderStage.VERTEX);
    BuiltinVariable.createVariable("gl_Position", EKeyword.VEC4, EShaderStage.VERTEX);
    BuiltinVariable.createVariable("gl_PointSize", EKeyword.FLOAT, EShaderStage.VERTEX);
    BuiltinVariable.createVariable("gl_FragCoord", EKeyword.VEC4, EShaderStage.FRAGMENT);
    BuiltinVariable.createVariable("gl_FrontFacing", EKeyword.BOOL, EShaderStage.FRAGMENT);
    BuiltinVariable.createVariable("gl_FragDepth", EKeyword.FLOAT, EShaderStage.FRAGMENT);
    BuiltinVariable.createVariable("gl_PointCoord", EKeyword.VEC2, EShaderStage.FRAGMENT);
    BuiltinVariable.createVariable("gl_FragColor", EKeyword.VEC4, EShaderStage.FRAGMENT);
    BuiltinVariable.createVariable("gl_MaxVertexAttribs", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxVertexUniformVectors", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxVertexOutputVectors", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxFragmentInputVectors", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxVertexTextureImageUnits", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxCombinedTextureImageUnits", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxTextureImageUnits", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxFragmentUniformVectors", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxDrawBuffers", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MinProgramTexelOffset", EKeyword.INT);
    BuiltinVariable.createVariable("gl_MaxProgramTexelOffset", EKeyword.INT);

    var StateItem = /*#__PURE__*/ function() {
        function StateItem(production, position, lookahead) {
            this._needReInfer = true;
            this.production = production;
            this.position = position;
            this.lookaheadSet = new Set();
            for(var _iterator = _create_for_of_iterator_helper_loose(lookahead), _step; !(_step = _iterator()).done;){
                var la = _step.value;
                this.lookaheadSet.add(la);
            }
            this.id = StateItem._id++;
        }
        var _proto = StateItem.prototype;
        _proto.addLookahead = function addLookahead(ts) {
            for(var _iterator = _create_for_of_iterator_helper_loose(ts), _step; !(_step = _iterator()).done;){
                var t = _step.value;
                if (this.lookaheadSet.has(t)) continue;
                this.lookaheadSet.add(t);
                this.needReInfer = true;
            }
        };
        _proto.symbolByOffset = function symbolByOffset(offset) {
            return this.production.derivation[this.position + offset];
        };
        _proto.canReduce = function canReduce() {
            if (this.position > this.production.derivation.length - 1) return true;
            else {
                for(var i = this.position; i < this.production.derivation.length; i++){
                    if (this.production.derivation[i] !== ETokenType.EPSILON) return false;
                }
                return true;
            }
        };
        _proto.advance = function advance() {
            if (this.canReduce()) throw "Error: advance reduce-able parsing state item";
            return new StateItem(this.production, this.position + 1, this.lookaheadSet);
        };
        _proto.toString = function toString() {
            var coreItem = this.production.derivation.map(function(item) {
                return GrammarUtils.toString(item);
            });
            var _coreItem_this_position;
            coreItem[this.position] = "." + ((_coreItem_this_position = coreItem[this.position]) != null ? _coreItem_this_position : "");
            return ENonTerminal[this.production.goal] + " :=> " + coreItem.join("|") + " ;" + Array.from(this.lookaheadSet).map(function(item) {
                return GrammarUtils.toString(item);
            }).join("/");
        };
        _create_class(StateItem, [
            {
                key: "needReInfer",
                get: function get() {
                    return this._needReInfer;
                },
                set: function set(v) {
                    this._needReInfer = v;
                }
            },
            {
                key: "curSymbol",
                get: function get() {
                    return this.production.derivation[this.position];
                }
            },
            {
                key: "nextSymbol",
                get: function get() {
                    return this.production.derivation[this.position + 1];
                }
            }
        ]);
        return StateItem;
    }();
    StateItem._id = 0;

    var State = /*#__PURE__*/ function() {
        function State(cores) {
            this.closured = false;
            this._stateItemPool = new Map();
            this.id = State._id++;
            this._items = new Set([].concat(cores));
            this.cores = new Set([].concat(cores));
            for(var _iterator = _create_for_of_iterator_helper_loose(cores), _step; !(_step = _iterator()).done;){
                var it = _step.value;
                var itemMapKey = this.getStateItemMapKey(it.production, it.position);
                this._stateItemPool.set(itemMapKey, it);
            }
            State.pool.set(this.id, this);
        }
        var _proto = State.prototype;
        // TODO: any optimization?
        _proto.getStateItemMapKey = function getStateItemMapKey(production, position) {
            return production.id + "," + position;
        };
        _proto.createStateItem = function createStateItem(production, position, lookaheadSet) {
            if (lookaheadSet === void 0) lookaheadSet = new Set();
            var mapId = this.getStateItemMapKey(production, position);
            var item = this._stateItemPool.get(mapId);
            if (item) {
                for(var _iterator = _create_for_of_iterator_helper_loose(lookaheadSet), _step; !(_step = _iterator()).done;){
                    var la = _step.value;
                    if (item.lookaheadSet.has(la)) continue;
                    item.lookaheadSet.add(la);
                    item.needReInfer = true;
                }
                return item;
            }
            var newItem = new StateItem(production, position, lookaheadSet);
            this._stateItemPool.set(mapId, newItem);
            return newItem;
        };
        State.create = function create(cores) {
            var cacheKey = this.getMapKey(cores);
            var state = this.closureMap.get(cacheKey);
            if (state) {
                for(var _iterator = _create_for_of_iterator_helper_loose(cores), _step; !(_step = _iterator()).done;){
                    var core = _step.value;
                    // merge lookahead
                    state.createStateItem(core.production, core.position, core.lookaheadSet);
                }
                return state;
            }
            var newState = new State(cores);
            this.closureMap.set(cacheKey, newState);
            return newState;
        };
        // TODO: any optimization?
        State.getMapKey = function getMapKey(cores) {
            return cores.map(function(item) {
                return item.production.id + "," + item.position;
            }).join(";");
        };
        _create_class(State, [
            {
                key: "items",
                get: function get() {
                    return this._items;
                }
            },
            {
                key: "needReInfer",
                get: function get() {
                    for(var _iterator = _create_for_of_iterator_helper_loose(this.cores), _step; !(_step = _iterator()).done;){
                        var core = _step.value;
                        if (core.needReInfer) return true;
                    }
                    return false;
                }
            }
        ]);
        return State;
    }();
    State.closureMap = new Map();
    State.pool = new Map();
    State._id = 0;

    var ParserUtils = /*#__PURE__*/ function() {
        function ParserUtils() {}
        ParserUtils.unwrapNodeByType = function unwrapNodeByType(node, type) {
            var child = node.children[0];
            if (_instanceof(child, BaseToken)) return;
            if (child.nt === type) return child;
            return ParserUtils.unwrapNodeByType(child, type);
        };
        /**
       * Check if type `tb` is compatible with type `ta`.
       */ ParserUtils.typeCompatible = function typeCompatible(ta, tb) {
            if (tb == undefined) return true;
            if (ta === EKeyword.INT) {
                return ta === tb || tb === EKeyword.UINT;
            }
            return ta === tb;
        };
        ParserUtils.toString = function toString(sm) {
            if (this.isTerminal(sm)) {
                var _ETokenType_sm;
                return (_ETokenType_sm = ETokenType[sm]) != null ? _ETokenType_sm : EKeyword[sm];
            }
            return ENonTerminal[sm];
        };
        ParserUtils.isTerminal = function isTerminal(sm) {
            return sm < ENonTerminal.START;
        };
        /**
       * @internal
       */ ParserUtils.printStatePool = function printStatePool(logPath) {
            var output = "";
            console.log("========== Parser Pool ==========");
            var count = 0;
            for(var _iterator = _create_for_of_iterator_helper_loose(State.pool.values()), _step; !(_step = _iterator()).done;){
                var state = _step.value;
                count++;
                var tmp = "";
                tmp += ("" + state.id + ": \n").padEnd(4);
                for(var _iterator1 = _create_for_of_iterator_helper_loose(state.items), _step1; !(_step1 = _iterator1()).done;){
                    var psItem = _step1.value;
                    tmp += "     " + psItem.toString() + "\n";
                }
                output += tmp;
            }
            console.log("state count:", count);
            console.log(output);
        };
        return ParserUtils;
    }();

    var SymbolType = function SymbolType(type, typeLexeme, arraySpecifier) {
        this.type = type;
        this.arraySpecifier = arraySpecifier;
        this.typeLexeme = typeLexeme;
    };
    var StructProp = function StructProp(type, ident) {
        this.typeInfo = type;
        this.ident = ident;
    };

    var TreeNode = /*#__PURE__*/ function() {
        function TreeNode() {}
        var _proto = TreeNode.prototype;
        _proto.set = function set(loc, children, nt) {
            this.nt = nt;
            this._location = loc;
            this._children = children;
        };
        _proto.dispose = function dispose() {};
        // Visitor pattern interface for code generation
        _proto.codeGen = function codeGen(visitor) {
            return visitor.defaultCodeGen(this.children);
        };
        _proto.semanticAnalyze = function semanticAnalyze(sa) {};
        _create_class(TreeNode, [
            {
                key: "children",
                get: function get() {
                    return this._children;
                }
            },
            {
                key: "location",
                get: function get() {
                    return this._location;
                }
            }
        ]);
        return TreeNode;
    }();
    (function(ASTNode) {
        function _unwrapToken(node) {
            if (_instanceof(node, BaseToken)) {
                return node;
            }
            throw "not token";
        }
        ASTNode._unwrapToken = _unwrapToken;
        function get(pool, sa, loc, children) {
            var node = pool.get();
            node.set(loc, children);
            node.semanticAnalyze(sa);
            sa.semanticStack.push(node);
        }
        ASTNode.get = get;
        var TrivialNode = /*#__PURE__*/ function(TreeNode) {
            _inherits(TrivialNode, TreeNode);
            function TrivialNode() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = TrivialNode.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal._ignore);
            };
            return TrivialNode;
        }(TreeNode);
        TrivialNode.pool = ShaderLabUtils.createObjectPool(TrivialNode);
        ASTNode.TrivialNode = TrivialNode;
        var ScopeBrace = /*#__PURE__*/ function(TreeNode) {
            _inherits(ScopeBrace, TreeNode);
            function ScopeBrace() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ScopeBrace.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.scope_brace);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                sa.newScope();
            };
            return ScopeBrace;
        }(TreeNode);
        ScopeBrace.pool = ShaderLabUtils.createObjectPool(ScopeBrace);
        ASTNode.ScopeBrace = ScopeBrace;
        var ScopeEndBrace = /*#__PURE__*/ function(TreeNode) {
            _inherits(ScopeEndBrace, TreeNode);
            function ScopeEndBrace() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ScopeEndBrace.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.scope_end_brace);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                sa.dropScope();
            };
            return ScopeEndBrace;
        }(TreeNode);
        ScopeEndBrace.pool = ShaderLabUtils.createObjectPool(ScopeEndBrace);
        ASTNode.ScopeEndBrace = ScopeEndBrace;
        var JumpStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(JumpStatement, TreeNode);
            function JumpStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = JumpStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.jump_statement);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (ASTNode._unwrapToken(this.children[0]).type === EKeyword.RETURN) ;
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitJumpStatement(this);
            };
            return JumpStatement;
        }(TreeNode);
        JumpStatement.pool = ShaderLabUtils.createObjectPool(JumpStatement);
        ASTNode.JumpStatement = JumpStatement;
        var ConditionOpt = /*#__PURE__*/ function(TreeNode) {
            _inherits(ConditionOpt, TreeNode);
            function ConditionOpt() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ConditionOpt.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.conditionopt);
            };
            return ConditionOpt;
        }(TreeNode);
        ConditionOpt.pool = ShaderLabUtils.createObjectPool(ConditionOpt);
        ASTNode.ConditionOpt = ConditionOpt;
        var ForRestStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(ForRestStatement, TreeNode);
            function ForRestStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ForRestStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.for_rest_statement);
            };
            return ForRestStatement;
        }(TreeNode);
        ForRestStatement.pool = ShaderLabUtils.createObjectPool(ForRestStatement);
        ASTNode.ForRestStatement = ForRestStatement;
        var Condition = /*#__PURE__*/ function(TreeNode) {
            _inherits(Condition, TreeNode);
            function Condition() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = Condition.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.condition);
            };
            return Condition;
        }(TreeNode);
        Condition.pool = ShaderLabUtils.createObjectPool(Condition);
        ASTNode.Condition = Condition;
        var ForInitStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(ForInitStatement, TreeNode);
            function ForInitStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ForInitStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.for_init_statement);
            };
            return ForInitStatement;
        }(TreeNode);
        ForInitStatement.pool = ShaderLabUtils.createObjectPool(ForInitStatement);
        ASTNode.ForInitStatement = ForInitStatement;
        var IterationStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(IterationStatement, TreeNode);
            function IterationStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = IterationStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.iteration_statement);
            };
            return IterationStatement;
        }(TreeNode);
        IterationStatement.pool = ShaderLabUtils.createObjectPool(IterationStatement);
        ASTNode.IterationStatement = IterationStatement;
        var SelectionStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(SelectionStatement, TreeNode);
            function SelectionStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = SelectionStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.selection_statement);
            };
            return SelectionStatement;
        }(TreeNode);
        SelectionStatement.pool = ShaderLabUtils.createObjectPool(SelectionStatement);
        ASTNode.SelectionStatement = SelectionStatement;
        var ExpressionStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(ExpressionStatement, TreeNode);
            function ExpressionStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ExpressionStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.expression_statement);
            };
            return ExpressionStatement;
        }(TreeNode);
        ExpressionStatement.pool = ShaderLabUtils.createObjectPool(ExpressionStatement);
        ASTNode.ExpressionStatement = ExpressionStatement;
        var ExpressionAstNode = /*#__PURE__*/ function(TreeNode) {
            _inherits(ExpressionAstNode, TreeNode);
            function ExpressionAstNode() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ExpressionAstNode.prototype;
            _proto.set = function set(loc, children, nt) {
                TreeNode.prototype.set.call(this, loc, children, nt);
                this._type = undefined;
            };
            _create_class(ExpressionAstNode, [
                {
                    key: "type",
                    get: function get() {
                        var _this__type;
                        return (_this__type = this._type) != null ? _this__type : TypeAny;
                    },
                    set: function set(t) {
                        this._type = t;
                    }
                }
            ]);
            return ExpressionAstNode;
        }(TreeNode);
        ASTNode.ExpressionAstNode = ExpressionAstNode;
        var InitializerList = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(InitializerList, ExpressionAstNode);
            function InitializerList() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = InitializerList.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.initializer_list);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var init = this.children[0];
                this.type = init.type;
            };
            return InitializerList;
        }(ExpressionAstNode);
        InitializerList.pool = ShaderLabUtils.createObjectPool(InitializerList);
        ASTNode.InitializerList = InitializerList;
        var Initializer = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(Initializer, ExpressionAstNode);
            function Initializer() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = Initializer.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.initializer);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = this.children[1].type;
                }
            };
            return Initializer;
        }(ExpressionAstNode);
        Initializer.pool = ShaderLabUtils.createObjectPool(Initializer);
        ASTNode.Initializer = Initializer;
        var SingleDeclaration = /*#__PURE__*/ function(TreeNode) {
            _inherits(SingleDeclaration, TreeNode);
            function SingleDeclaration() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = SingleDeclaration.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.single_declaration);
                this.typeSpecifier = undefined;
                this.arraySpecifier = undefined;
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var fullyType = this.children[0];
                var id = this.children[1];
                this.typeSpecifier = fullyType.typeSpecifier;
                var sm;
                if (this.children.length === 2 || this.children.length === 4) {
                    var symbolType = new SymbolType(fullyType.type, fullyType.typeSpecifier.lexeme);
                    var initializer = this.children[3];
                    sm = new VarSymbol(id.lexeme, symbolType, false, initializer);
                } else {
                    var arraySpecifier = this.children[2];
                    this.arraySpecifier = arraySpecifier;
                    var symbolType1 = new SymbolType(fullyType.type, fullyType.typeSpecifier.lexeme, arraySpecifier);
                    var initializer1 = this.children[4];
                    sm = new VarSymbol(id.lexeme, symbolType1, false, initializer1);
                }
                sa.symbolTable.insert(sm);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitSingleDeclaration(this);
            };
            return SingleDeclaration;
        }(TreeNode);
        SingleDeclaration.pool = ShaderLabUtils.createObjectPool(SingleDeclaration);
        ASTNode.SingleDeclaration = SingleDeclaration;
        var FullySpecifiedType = /*#__PURE__*/ function(TreeNode) {
            _inherits(FullySpecifiedType, TreeNode);
            function FullySpecifiedType() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FullySpecifiedType.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.fully_specified_type);
            };
            _create_class(FullySpecifiedType, [
                {
                    key: "qualifierList",
                    get: function get() {
                        if (this.children.length > 1) {
                            return this.children[0].qualifierList;
                        }
                    }
                },
                {
                    key: "typeSpecifier",
                    get: function get() {
                        return this.children.length === 1 ? this.children[0] : this.children[1];
                    }
                },
                {
                    key: "type",
                    get: function get() {
                        return this.typeSpecifier.type;
                    }
                }
            ]);
            return FullySpecifiedType;
        }(TreeNode);
        FullySpecifiedType.pool = ShaderLabUtils.createObjectPool(FullySpecifiedType);
        ASTNode.FullySpecifiedType = FullySpecifiedType;
        var TypeQualifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(TypeQualifier, TreeNode);
            function TypeQualifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = TypeQualifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.type_qualifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length > 1) {
                    this.qualifierList = [].concat(this.children[0].qualifierList, [
                        this.children[1].qualifier
                    ]);
                } else {
                    this.qualifierList = [
                        this.children[0].qualifier
                    ];
                }
            };
            return TypeQualifier;
        }(TreeNode);
        TypeQualifier.pool = ShaderLabUtils.createObjectPool(TypeQualifier);
        ASTNode.TypeQualifier = TypeQualifier;
        var SingleTypeQualifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(SingleTypeQualifier, TreeNode);
            function SingleTypeQualifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = SingleTypeQualifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.single_type_qualifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var child = this.children[0];
                if (_instanceof(child, BaseToken)) {
                    this.qualifier = child.type;
                    this.lexeme = child.lexeme;
                } else {
                    this.qualifier = child.qualifier;
                    this.lexeme = child.lexeme;
                }
            };
            return SingleTypeQualifier;
        }(TreeNode);
        SingleTypeQualifier.pool = ShaderLabUtils.createObjectPool(SingleTypeQualifier);
        ASTNode.SingleTypeQualifier = SingleTypeQualifier;
        var BasicTypeQualifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(BasicTypeQualifier, TreeNode);
            function BasicTypeQualifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = BasicTypeQualifier.prototype;
            _proto.set = function set(loc, children, nt) {
                TreeNode.prototype.set.call(this, loc, children, nt);
            };
            _create_class(BasicTypeQualifier, [
                {
                    key: "qualifier",
                    get: function get() {
                        return this.children[0].type;
                    }
                },
                {
                    key: "lexeme",
                    get: function get() {
                        return this.children[0].lexeme;
                    }
                }
            ]);
            return BasicTypeQualifier;
        }(TreeNode);
        var StorageQualifier = /*#__PURE__*/ function(BasicTypeQualifier) {
            _inherits(StorageQualifier, BasicTypeQualifier);
            function StorageQualifier() {
                return BasicTypeQualifier.apply(this, arguments) || this;
            }
            var _proto = StorageQualifier.prototype;
            _proto.set = function set(loc, children) {
                BasicTypeQualifier.prototype.set.call(this, loc, children, ENonTerminal.storage_qualifier);
            };
            return StorageQualifier;
        }(BasicTypeQualifier);
        StorageQualifier.pool = ShaderLabUtils.createObjectPool(StorageQualifier);
        ASTNode.StorageQualifier = StorageQualifier;
        var PrecisionQualifier = /*#__PURE__*/ function(BasicTypeQualifier) {
            _inherits(PrecisionQualifier, BasicTypeQualifier);
            function PrecisionQualifier() {
                return BasicTypeQualifier.apply(this, arguments) || this;
            }
            var _proto = PrecisionQualifier.prototype;
            _proto.set = function set(loc, children) {
                BasicTypeQualifier.prototype.set.call(this, loc, children, ENonTerminal.precision_qualifier);
            };
            return PrecisionQualifier;
        }(BasicTypeQualifier);
        PrecisionQualifier.pool = ShaderLabUtils.createObjectPool(PrecisionQualifier);
        ASTNode.PrecisionQualifier = PrecisionQualifier;
        var InterpolationQualifier = /*#__PURE__*/ function(BasicTypeQualifier) {
            _inherits(InterpolationQualifier, BasicTypeQualifier);
            function InterpolationQualifier() {
                return BasicTypeQualifier.apply(this, arguments) || this;
            }
            var _proto = InterpolationQualifier.prototype;
            _proto.set = function set(loc, children) {
                BasicTypeQualifier.prototype.set.call(this, loc, children, ENonTerminal.interpolation_qualifier);
            };
            return InterpolationQualifier;
        }(BasicTypeQualifier);
        InterpolationQualifier.pool = ShaderLabUtils.createObjectPool(InterpolationQualifier);
        ASTNode.InterpolationQualifier = InterpolationQualifier;
        var InvariantQualifier = /*#__PURE__*/ function(BasicTypeQualifier) {
            _inherits(InvariantQualifier, BasicTypeQualifier);
            function InvariantQualifier() {
                return BasicTypeQualifier.apply(this, arguments) || this;
            }
            var _proto = InvariantQualifier.prototype;
            _proto.set = function set(loc, children) {
                BasicTypeQualifier.prototype.set.call(this, loc, children, ENonTerminal.invariant_qualifier);
            };
            return InvariantQualifier;
        }(BasicTypeQualifier);
        InvariantQualifier.pool = ShaderLabUtils.createObjectPool(InvariantQualifier);
        ASTNode.InvariantQualifier = InvariantQualifier;
        var TypeSpecifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(TypeSpecifier, TreeNode);
            function TypeSpecifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = TypeSpecifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.type_specifier);
            };
            _create_class(TypeSpecifier, [
                {
                    key: "type",
                    get: function get() {
                        return this.children[0].type;
                    }
                },
                {
                    key: "lexeme",
                    get: function get() {
                        return this.children[0].lexeme;
                    }
                },
                {
                    key: "arraySize",
                    get: function get() {
                        var _this_children_, _this_children;
                        return (_this_children = this.children) == null ? void 0 : (_this_children_ = _this_children[1]) == null ? void 0 : _this_children_.size;
                    }
                },
                {
                    key: "isCustom",
                    get: function get() {
                        return typeof this.type === "string";
                    }
                }
            ]);
            return TypeSpecifier;
        }(TreeNode);
        TypeSpecifier.pool = ShaderLabUtils.createObjectPool(TypeSpecifier);
        ASTNode.TypeSpecifier = TypeSpecifier;
        var ArraySpecifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(ArraySpecifier, TreeNode);
            function ArraySpecifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ArraySpecifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.array_specifier);
            };
            _create_class(ArraySpecifier, [
                {
                    key: "size",
                    get: function get() {
                        var integerConstantExpr = this.children[1];
                        return integerConstantExpr.value;
                    }
                }
            ]);
            return ArraySpecifier;
        }(TreeNode);
        ArraySpecifier.pool = ShaderLabUtils.createObjectPool(ArraySpecifier);
        ASTNode.ArraySpecifier = ArraySpecifier;
        var IntegerConstantExpressionOperator = /*#__PURE__*/ function(TreeNode) {
            _inherits(IntegerConstantExpressionOperator, TreeNode);
            function IntegerConstantExpressionOperator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = IntegerConstantExpressionOperator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.integer_constant_expression_operator);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var operator = this.children[0];
                switch(operator.type){
                    case ETokenType.PLUS:
                        this.compute = function(a, b) {
                            return a + b;
                        };
                        break;
                    case ETokenType.DASH:
                        this.compute = function(a, b) {
                            return a - b;
                        };
                        break;
                    case ETokenType.STAR:
                        this.compute = function(a, b) {
                            return a * b;
                        };
                        break;
                    case ETokenType.SLASH:
                        this.compute = function(a, b) {
                            return a / b;
                        };
                        break;
                    case ETokenType.PERCENT:
                        this.compute = function(a, b) {
                            return a % b;
                        };
                        break;
                    default:
                        sa.error(operator.location, "not implemented operator " + operator.lexeme);
                }
            };
            _create_class(IntegerConstantExpressionOperator, [
                {
                    key: "lexeme",
                    get: function get() {
                        return this.children[0].lexeme;
                    }
                }
            ]);
            return IntegerConstantExpressionOperator;
        }(TreeNode);
        IntegerConstantExpressionOperator.pool = ShaderLabUtils.createObjectPool(IntegerConstantExpressionOperator);
        ASTNode.IntegerConstantExpressionOperator = IntegerConstantExpressionOperator;
        var IntegerConstantExpression = /*#__PURE__*/ function(TreeNode) {
            _inherits(IntegerConstantExpression, TreeNode);
            function IntegerConstantExpression() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = IntegerConstantExpression.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.integer_constant_expression);
                this.value = undefined;
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    var child = this.children[0];
                    if (_instanceof(child, BaseToken)) {
                        this.value = Number(child.lexeme);
                    } else {
                        var id = child;
                        if (!id.symbolInfo) {
                            sa.error(id.location, "Undeclared symbol:", id.lexeme);
                        }
                        if (!ParserUtils.typeCompatible(EKeyword.INT, id.typeInfo)) {
                            sa.error(id.location, "Invalid integer.");
                            return;
                        }
                    }
                }
            };
            return IntegerConstantExpression;
        }(TreeNode);
        IntegerConstantExpression.pool = ShaderLabUtils.createObjectPool(IntegerConstantExpression);
        ASTNode.IntegerConstantExpression = IntegerConstantExpression;
        var TypeSpecifierNonArray = /*#__PURE__*/ function(TreeNode) {
            _inherits(TypeSpecifierNonArray, TreeNode);
            function TypeSpecifierNonArray() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = TypeSpecifierNonArray.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.type_specifier_nonarray);
                var tt = children[0];
                if (_instanceof(tt, BaseToken)) {
                    this.type = tt.lexeme;
                    this.lexeme = tt.lexeme;
                } else {
                    this.type = tt.type;
                    this.lexeme = tt.lexeme;
                }
            };
            return TypeSpecifierNonArray;
        }(TreeNode);
        TypeSpecifierNonArray.pool = ShaderLabUtils.createObjectPool(TypeSpecifierNonArray);
        ASTNode.TypeSpecifierNonArray = TypeSpecifierNonArray;
        var ExtBuiltinTypeSpecifierNonArray = /*#__PURE__*/ function(TreeNode) {
            _inherits(ExtBuiltinTypeSpecifierNonArray, TreeNode);
            function ExtBuiltinTypeSpecifierNonArray() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ExtBuiltinTypeSpecifierNonArray.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.ext_builtin_type_specifier_nonarray);
                var token = this.children[0];
                this.type = token.type;
                this.lexeme = token.lexeme;
            };
            return ExtBuiltinTypeSpecifierNonArray;
        }(TreeNode);
        ExtBuiltinTypeSpecifierNonArray.pool = ShaderLabUtils.createObjectPool(ExtBuiltinTypeSpecifierNonArray);
        ASTNode.ExtBuiltinTypeSpecifierNonArray = ExtBuiltinTypeSpecifierNonArray;
        var InitDeclaratorList = /*#__PURE__*/ function(TreeNode) {
            _inherits(InitDeclaratorList, TreeNode);
            function InitDeclaratorList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = InitDeclaratorList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.init_declarator_list);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var sm;
                if (this.children.length === 3 || this.children.length === 5) {
                    var id = this.children[2];
                    sm = new VarSymbol(id.lexeme, this.typeInfo, false, this);
                    sa.symbolTable.insert(sm);
                } else if (this.children.length === 4 || this.children.length === 6) {
                    var typeInfo = this.typeInfo;
                    var arraySpecifier = this.children[3];
                    if (typeInfo.arraySpecifier && arraySpecifier) {
                        sa.error(arraySpecifier.location, "Array of array is not supported.");
                    }
                    typeInfo.arraySpecifier = arraySpecifier;
                    var id1 = this.children[2];
                    sm = new VarSymbol(id1.lexeme, typeInfo, false, this);
                    sa.symbolTable.insert(sm);
                }
            };
            _create_class(InitDeclaratorList, [
                {
                    key: "typeInfo",
                    get: function get() {
                        if (this.children.length === 1) {
                            var singleDecl = this.children[0];
                            return new SymbolType(singleDecl.typeSpecifier.type, singleDecl.typeSpecifier.lexeme, singleDecl.arraySpecifier);
                        }
                        var initDeclList = this.children[0];
                        return initDeclList.typeInfo;
                    }
                }
            ]);
            return InitDeclaratorList;
        }(TreeNode);
        InitDeclaratorList.pool = ShaderLabUtils.createObjectPool(InitDeclaratorList);
        ASTNode.InitDeclaratorList = InitDeclaratorList;
        var IdentifierList = /*#__PURE__*/ function(TreeNode) {
            _inherits(IdentifierList, TreeNode);
            function IdentifierList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = IdentifierList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.identifier_list);
            };
            _create_class(IdentifierList, [
                {
                    key: "idList",
                    get: function get() {
                        if (this.children.length === 2) {
                            return [
                                this.children[1]
                            ];
                        }
                        return [].concat(this.children[0].idList, [
                            this.children[2]
                        ]);
                    }
                }
            ]);
            return IdentifierList;
        }(TreeNode);
        IdentifierList.pool = ShaderLabUtils.createObjectPool(IdentifierList);
        ASTNode.IdentifierList = IdentifierList;
        var Declaration = /*#__PURE__*/ function(TreeNode) {
            _inherits(Declaration, TreeNode);
            function Declaration() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = Declaration.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.declaration);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitDeclaration(this);
            };
            return Declaration;
        }(TreeNode);
        Declaration.pool = ShaderLabUtils.createObjectPool(Declaration);
        ASTNode.Declaration = Declaration;
        var FunctionProtoType = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionProtoType, TreeNode);
            function FunctionProtoType() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionProtoType.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_prototype);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionProtoType(this);
            };
            _create_class(FunctionProtoType, [
                {
                    key: "declarator",
                    get: function get() {
                        return this.children[0];
                    }
                },
                {
                    key: "ident",
                    get: function get() {
                        return this.declarator.ident;
                    }
                },
                {
                    key: "returnType",
                    get: function get() {
                        return this.declarator.returnType;
                    }
                },
                {
                    key: "parameterList",
                    get: function get() {
                        return this.declarator.parameterInfoList;
                    }
                },
                {
                    key: "paramSig",
                    get: function get() {
                        return this.declarator.paramSig;
                    }
                }
            ]);
            return FunctionProtoType;
        }(TreeNode);
        FunctionProtoType.pool = ShaderLabUtils.createObjectPool(FunctionProtoType);
        ASTNode.FunctionProtoType = FunctionProtoType;
        var FunctionDeclarator = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionDeclarator, TreeNode);
            function FunctionDeclarator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionDeclarator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_declarator);
            };
            _create_class(FunctionDeclarator, [
                {
                    key: "header",
                    get: function get() {
                        return this.children[0];
                    }
                },
                {
                    key: "parameterList",
                    get: function get() {
                        return this.children[1];
                    }
                },
                {
                    key: "ident",
                    get: function get() {
                        return this.header.ident;
                    }
                },
                {
                    key: "returnType",
                    get: function get() {
                        return this.header.returnType;
                    }
                },
                {
                    key: "parameterInfoList",
                    get: function get() {
                        var _this_parameterList;
                        return (_this_parameterList = this.parameterList) == null ? void 0 : _this_parameterList.parameterInfoList;
                    }
                },
                {
                    key: "paramSig",
                    get: function get() {
                        var _this_parameterList;
                        return (_this_parameterList = this.parameterList) == null ? void 0 : _this_parameterList.paramSig;
                    }
                }
            ]);
            return FunctionDeclarator;
        }(TreeNode);
        FunctionDeclarator.pool = ShaderLabUtils.createObjectPool(FunctionDeclarator);
        ASTNode.FunctionDeclarator = FunctionDeclarator;
        var FunctionHeader = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionHeader, TreeNode);
            function FunctionHeader() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionHeader.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_header);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                sa.newScope();
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionHeader(this);
            };
            _create_class(FunctionHeader, [
                {
                    key: "ident",
                    get: function get() {
                        return this.children[1];
                    }
                },
                {
                    key: "returnType",
                    get: function get() {
                        return this.children[0];
                    }
                }
            ]);
            return FunctionHeader;
        }(TreeNode);
        FunctionHeader.pool = ShaderLabUtils.createObjectPool(FunctionHeader);
        ASTNode.FunctionHeader = FunctionHeader;
        var FunctionParameterList = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionParameterList, TreeNode);
            function FunctionParameterList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionParameterList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_parameter_list);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionParameterList(this);
            };
            _create_class(FunctionParameterList, [
                {
                    key: "parameterInfoList",
                    get: function get() {
                        if (this.children.length === 1) {
                            var decl = this.children[0];
                            return [
                                {
                                    ident: decl.ident,
                                    typeInfo: decl.typeInfo,
                                    astNode: decl
                                }
                            ];
                        }
                        var list = this.children[0];
                        var decl1 = this.children[2];
                        return [].concat(list.parameterInfoList, [
                            {
                                ident: decl1.ident,
                                typeInfo: decl1.typeInfo,
                                astNode: decl1
                            }
                        ]);
                    }
                },
                {
                    key: "paramSig",
                    get: function get() {
                        if (this.children.length === 1) {
                            var decl = this.children[0];
                            return [
                                decl.typeInfo.type
                            ];
                        } else {
                            var list = this.children[0];
                            var decl1 = this.children[2];
                            return list.paramSig.concat([
                                decl1.typeInfo.type
                            ]);
                        }
                    }
                }
            ]);
            return FunctionParameterList;
        }(TreeNode);
        FunctionParameterList.pool = ShaderLabUtils.createObjectPool(FunctionParameterList);
        ASTNode.FunctionParameterList = FunctionParameterList;
        var ParameterDeclaration = /*#__PURE__*/ function(TreeNode) {
            _inherits(ParameterDeclaration, TreeNode);
            function ParameterDeclaration() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ParameterDeclaration.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.parameter_declaration);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var declarator;
                if (this.children.length === 1) {
                    declarator = this.children[0];
                } else {
                    declarator = this.children[1];
                }
                var varSymbol = new VarSymbol(declarator.ident.lexeme, declarator.typeInfo, false, this);
                sa.symbolTable.insert(varSymbol);
            };
            _create_class(ParameterDeclaration, [
                {
                    key: "typeQualifier",
                    get: function get() {
                        if (this.children.length === 2) return this.children[0];
                    }
                },
                {
                    key: "parameterDeclarator",
                    get: function get() {
                        if (this.children.length === 1) return this.children[0];
                        return this.children[1];
                    }
                },
                {
                    key: "typeInfo",
                    get: function get() {
                        return this.parameterDeclarator.typeInfo;
                    }
                },
                {
                    key: "ident",
                    get: function get() {
                        return this.parameterDeclarator.ident;
                    }
                }
            ]);
            return ParameterDeclaration;
        }(TreeNode);
        ParameterDeclaration.pool = ShaderLabUtils.createObjectPool(ParameterDeclaration);
        ASTNode.ParameterDeclaration = ParameterDeclaration;
        var ParameterDeclarator = /*#__PURE__*/ function(TreeNode) {
            _inherits(ParameterDeclarator, TreeNode);
            function ParameterDeclarator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = ParameterDeclarator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.parameter_declarator);
            };
            _create_class(ParameterDeclarator, [
                {
                    key: "ident",
                    get: function get() {
                        return this.children[1];
                    }
                },
                {
                    key: "typeInfo",
                    get: function get() {
                        var typeSpecifier = this.children[0];
                        var arraySpecifier = this.children[2];
                        return new SymbolType(typeSpecifier.type, typeSpecifier.lexeme, arraySpecifier);
                    }
                }
            ]);
            return ParameterDeclarator;
        }(TreeNode);
        ParameterDeclarator.pool = ShaderLabUtils.createObjectPool(ParameterDeclarator);
        ASTNode.ParameterDeclarator = ParameterDeclarator;
        var SimpleStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(SimpleStatement, TreeNode);
            function SimpleStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = SimpleStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.simple_statement);
            };
            return SimpleStatement;
        }(TreeNode);
        SimpleStatement.pool = ShaderLabUtils.createObjectPool(SimpleStatement);
        ASTNode.SimpleStatement = SimpleStatement;
        var CompoundStatement = /*#__PURE__*/ function(TreeNode) {
            _inherits(CompoundStatement, TreeNode);
            function CompoundStatement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = CompoundStatement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.compound_statement);
            };
            return CompoundStatement;
        }(TreeNode);
        CompoundStatement.pool = ShaderLabUtils.createObjectPool(CompoundStatement);
        ASTNode.CompoundStatement = CompoundStatement;
        var CompoundStatementNoScope = /*#__PURE__*/ function(TreeNode) {
            _inherits(CompoundStatementNoScope, TreeNode);
            function CompoundStatementNoScope() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = CompoundStatementNoScope.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.compound_statement_no_scope);
            };
            return CompoundStatementNoScope;
        }(TreeNode);
        CompoundStatementNoScope.pool = ShaderLabUtils.createObjectPool(CompoundStatementNoScope);
        ASTNode.CompoundStatementNoScope = CompoundStatementNoScope;
        var Statement = /*#__PURE__*/ function(TreeNode) {
            _inherits(Statement, TreeNode);
            function Statement() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = Statement.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.statement);
            };
            return Statement;
        }(TreeNode);
        Statement.pool = ShaderLabUtils.createObjectPool(Statement);
        ASTNode.Statement = Statement;
        var StatementList = /*#__PURE__*/ function(TreeNode) {
            _inherits(StatementList, TreeNode);
            function StatementList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StatementList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.statement_list);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitStatementList(this);
            };
            return StatementList;
        }(TreeNode);
        StatementList.pool = ShaderLabUtils.createObjectPool(StatementList);
        ASTNode.StatementList = StatementList;
        var FunctionDefinition = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionDefinition, TreeNode);
            function FunctionDefinition() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionDefinition.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_definition);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                sa.dropScope();
                var sm = new FnSymbol(this.protoType.ident.lexeme, this);
                sa.symbolTable.insert(sm);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionDefinition(this);
            };
            _create_class(FunctionDefinition, [
                {
                    key: "protoType",
                    get: function get() {
                        return this.children[0];
                    }
                },
                {
                    key: "statements",
                    get: function get() {
                        return this.children[1];
                    }
                }
            ]);
            return FunctionDefinition;
        }(TreeNode);
        FunctionDefinition.pool = ShaderLabUtils.createObjectPool(FunctionDefinition);
        ASTNode.FunctionDefinition = FunctionDefinition;
        var FunctionCall = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(FunctionCall, ExpressionAstNode);
            function FunctionCall() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = FunctionCall.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.function_call);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                this.type = this.children[0].type;
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionCall(this);
            };
            return FunctionCall;
        }(ExpressionAstNode);
        FunctionCall.pool = ShaderLabUtils.createObjectPool(FunctionCall);
        ASTNode.FunctionCall = FunctionCall;
        var FunctionCallGeneric = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(FunctionCallGeneric, ExpressionAstNode);
            function FunctionCallGeneric() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = FunctionCallGeneric.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.function_call_generic);
                this.fnSymbol = undefined;
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var functionIdentifier = this.children[0];
                if (functionIdentifier.isBuiltin) {
                    this.type = functionIdentifier.ident;
                } else {
                    var _BuiltinFunction;
                    var _fnSymbol_dataType;
                    var fnIdent = functionIdentifier.ident;
                    var paramSig;
                    if (this.children.length === 4) {
                        var paramList = this.children[2];
                        if (_instanceof(paramList, FunctionCallParameterList)) {
                            paramSig = paramList.paramSig;
                        }
                    }
                    var builtinFn = (_BuiltinFunction = BuiltinFunction).getFn.apply(_BuiltinFunction, [].concat([
                        fnIdent
                    ], paramSig != null ? paramSig : []));
                    if (builtinFn) {
                        this.type = BuiltinFunction.getReturnType(builtinFn.fun, builtinFn.genType);
                        return;
                    }
                    var fnSymbol = sa.symbolTable.lookup({
                        ident: fnIdent,
                        symbolType: ESymbolType.FN,
                        signature: paramSig
                    });
                    if (!fnSymbol) {
                        sa.error(this.location, "No overload function type found: ", functionIdentifier.ident);
                        return;
                    }
                    this.type = fnSymbol == null ? void 0 : (_fnSymbol_dataType = fnSymbol.dataType) == null ? void 0 : _fnSymbol_dataType.type;
                    this.fnSymbol = fnSymbol;
                }
            };
            return FunctionCallGeneric;
        }(ExpressionAstNode);
        FunctionCallGeneric.pool = ShaderLabUtils.createObjectPool(FunctionCallGeneric);
        ASTNode.FunctionCallGeneric = FunctionCallGeneric;
        var FunctionCallParameterList = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionCallParameterList, TreeNode);
            function FunctionCallParameterList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionCallParameterList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_call_parameter_list);
            };
            _create_class(FunctionCallParameterList, [
                {
                    key: "paramSig",
                    get: function get() {
                        if (this.children.length === 1) {
                            var expr = this.children[0];
                            if (expr.type == undefined) return [
                                TypeAny
                            ];
                            return [
                                expr.type
                            ];
                        } else {
                            var list = this.children[0];
                            var decl = this.children[2];
                            if (list.paramSig == undefined || decl.type == undefined) {
                                return [
                                    TypeAny
                                ];
                            } else {
                                return list.paramSig.concat([
                                    decl.type
                                ]);
                            }
                        }
                    }
                },
                {
                    key: "paramNodes",
                    get: function get() {
                        if (this.children.length === 1) {
                            return [
                                this.children[0]
                            ];
                        } else {
                            var list = this.children[0];
                            var decl = this.children[2];
                            return list.paramNodes.concat([
                                decl
                            ]);
                        }
                    }
                }
            ]);
            return FunctionCallParameterList;
        }(TreeNode);
        FunctionCallParameterList.pool = ShaderLabUtils.createObjectPool(FunctionCallParameterList);
        ASTNode.FunctionCallParameterList = FunctionCallParameterList;
        var PrecisionSpecifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(PrecisionSpecifier, TreeNode);
            function PrecisionSpecifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = PrecisionSpecifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.precision_specifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                sa.shaderData.globalPrecisions.push(this);
            };
            return PrecisionSpecifier;
        }(TreeNode);
        PrecisionSpecifier.pool = ShaderLabUtils.createObjectPool(PrecisionSpecifier);
        ASTNode.PrecisionSpecifier = PrecisionSpecifier;
        var FunctionIdentifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(FunctionIdentifier, TreeNode);
            function FunctionIdentifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = FunctionIdentifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.function_identifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {};
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitFunctionIdentifier(this);
            };
            _create_class(FunctionIdentifier, [
                {
                    key: "ident",
                    get: function get() {
                        var ty = this.children[0];
                        return ty.type;
                    }
                },
                {
                    key: "lexeme",
                    get: function get() {
                        var ty = this.children[0];
                        return ty.lexeme;
                    }
                },
                {
                    key: "isBuiltin",
                    get: function get() {
                        return typeof this.ident !== "string";
                    }
                }
            ]);
            return FunctionIdentifier;
        }(TreeNode);
        FunctionIdentifier.pool = ShaderLabUtils.createObjectPool(FunctionIdentifier);
        ASTNode.FunctionIdentifier = FunctionIdentifier;
        var AssignmentExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(AssignmentExpression, ExpressionAstNode);
            function AssignmentExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = AssignmentExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.assignment_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    var expr = this.children[0];
                    var _expr_type;
                    this.type = (_expr_type = expr.type) != null ? _expr_type : TypeAny;
                } else {
                    var expr1 = this.children[2];
                    var _expr_type1;
                    this.type = (_expr_type1 = expr1.type) != null ? _expr_type1 : TypeAny;
                }
            };
            return AssignmentExpression;
        }(ExpressionAstNode);
        AssignmentExpression.pool = ShaderLabUtils.createObjectPool(AssignmentExpression);
        ASTNode.AssignmentExpression = AssignmentExpression;
        var AssignmentOperator = /*#__PURE__*/ function(TreeNode) {
            _inherits(AssignmentOperator, TreeNode);
            function AssignmentOperator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = AssignmentOperator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.assignment_operator);
            };
            return AssignmentOperator;
        }(TreeNode);
        AssignmentOperator.pool = ShaderLabUtils.createObjectPool(AssignmentOperator);
        ASTNode.AssignmentOperator = AssignmentOperator;
        var Expression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(Expression, ExpressionAstNode);
            function Expression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = Expression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    var expr = this.children[0];
                    this.type = expr.type;
                } else {
                    var expr1 = this.children[2];
                    this.type = expr1.type;
                }
            };
            return Expression;
        }(ExpressionAstNode);
        Expression.pool = ShaderLabUtils.createObjectPool(Expression);
        ASTNode.Expression = Expression;
        var PrimaryExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(PrimaryExpression, ExpressionAstNode);
            function PrimaryExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = PrimaryExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.primary_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    var id = this.children[0];
                    if (_instanceof(id, VariableIdentifier)) {
                        var _id_typeInfo;
                        this.type = (_id_typeInfo = id.typeInfo) != null ? _id_typeInfo : TypeAny;
                    } else {
                        switch(id.type){
                            case ETokenType.INT_CONSTANT:
                                this._type = EKeyword.INT;
                                break;
                            case ETokenType.FLOAT_CONSTANT:
                                this.type = EKeyword.FLOAT;
                                break;
                            case EKeyword.TRUE:
                            case EKeyword.FALSE:
                                this.type = EKeyword.BOOL;
                                break;
                        }
                    }
                } else {
                    var expression = this.children[1];
                    this.type = expression.type;
                }
            };
            return PrimaryExpression;
        }(ExpressionAstNode);
        PrimaryExpression.pool = ShaderLabUtils.createObjectPool(PrimaryExpression);
        ASTNode.PrimaryExpression = PrimaryExpression;
        var PostfixExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(PostfixExpression, ExpressionAstNode);
            function PostfixExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = PostfixExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.postfix_expression);
                if (this.children.length === 1) {
                    var child = this.children[0];
                    this.type = child.type;
                }
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitPostfixExpression(this);
            };
            return PostfixExpression;
        }(ExpressionAstNode);
        PostfixExpression.pool = ShaderLabUtils.createObjectPool(PostfixExpression);
        ASTNode.PostfixExpression = PostfixExpression;
        var UnaryOperator = /*#__PURE__*/ function(TreeNode) {
            _inherits(UnaryOperator, TreeNode);
            function UnaryOperator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = UnaryOperator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.unary_operator);
            };
            return UnaryOperator;
        }(TreeNode);
        UnaryOperator.pool = ShaderLabUtils.createObjectPool(UnaryOperator);
        ASTNode.UnaryOperator = UnaryOperator;
        var UnaryExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(UnaryExpression, ExpressionAstNode);
            function UnaryExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = UnaryExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.unary_expression);
                this.type = this.children[0].type;
            };
            return UnaryExpression;
        }(ExpressionAstNode);
        UnaryExpression.pool = ShaderLabUtils.createObjectPool(UnaryExpression);
        ASTNode.UnaryExpression = UnaryExpression;
        var MultiplicativeExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(MultiplicativeExpression, ExpressionAstNode);
            function MultiplicativeExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = MultiplicativeExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.multiplicative_expression);
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    var exp1 = this.children[0];
                    var exp2 = this.children[2];
                    if (exp1.type === exp2.type) {
                        this.type = exp1.type;
                    }
                }
            };
            return MultiplicativeExpression;
        }(ExpressionAstNode);
        MultiplicativeExpression.pool = ShaderLabUtils.createObjectPool(MultiplicativeExpression);
        ASTNode.MultiplicativeExpression = MultiplicativeExpression;
        var AdditiveExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(AdditiveExpression, ExpressionAstNode);
            function AdditiveExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = AdditiveExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.additive_expression);
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    var exp1 = this.children[0];
                    var exp2 = this.children[2];
                    if (exp1.type === exp2.type) {
                        this.type = exp1.type;
                    }
                }
            };
            return AdditiveExpression;
        }(ExpressionAstNode);
        AdditiveExpression.pool = ShaderLabUtils.createObjectPool(AdditiveExpression);
        ASTNode.AdditiveExpression = AdditiveExpression;
        var ShiftExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(ShiftExpression, ExpressionAstNode);
            function ShiftExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = ShiftExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.shift_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var expr = this.children[0];
                this.type = expr.type;
            };
            return ShiftExpression;
        }(ExpressionAstNode);
        ShiftExpression.pool = ShaderLabUtils.createObjectPool(ShiftExpression);
        ASTNode.ShiftExpression = ShiftExpression;
        var RelationalExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(RelationalExpression, ExpressionAstNode);
            function RelationalExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = RelationalExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.relational_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.BOOL;
                }
            };
            return RelationalExpression;
        }(ExpressionAstNode);
        RelationalExpression.pool = ShaderLabUtils.createObjectPool(RelationalExpression);
        ASTNode.RelationalExpression = RelationalExpression;
        var EqualityExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(EqualityExpression, ExpressionAstNode);
            function EqualityExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = EqualityExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.equality_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.BOOL;
                }
            };
            return EqualityExpression;
        }(ExpressionAstNode);
        EqualityExpression.pool = ShaderLabUtils.createObjectPool(EqualityExpression);
        ASTNode.EqualityExpression = EqualityExpression;
        var AndExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(AndExpression, ExpressionAstNode);
            function AndExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = AndExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.and_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.UINT;
                }
            };
            return AndExpression;
        }(ExpressionAstNode);
        AndExpression.pool = ShaderLabUtils.createObjectPool(AndExpression);
        ASTNode.AndExpression = AndExpression;
        var ExclusiveOrExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(ExclusiveOrExpression, ExpressionAstNode);
            function ExclusiveOrExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = ExclusiveOrExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.exclusive_or_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.UINT;
                }
            };
            return ExclusiveOrExpression;
        }(ExpressionAstNode);
        ExclusiveOrExpression.pool = ShaderLabUtils.createObjectPool(ExclusiveOrExpression);
        ASTNode.ExclusiveOrExpression = ExclusiveOrExpression;
        var InclusiveOrExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(InclusiveOrExpression, ExpressionAstNode);
            function InclusiveOrExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = InclusiveOrExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.inclusive_or_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.UINT;
                }
            };
            return InclusiveOrExpression;
        }(ExpressionAstNode);
        InclusiveOrExpression.pool = ShaderLabUtils.createObjectPool(InclusiveOrExpression);
        ASTNode.InclusiveOrExpression = InclusiveOrExpression;
        var LogicalAndExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(LogicalAndExpression, ExpressionAstNode);
            function LogicalAndExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = LogicalAndExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.logical_and_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.BOOL;
                }
            };
            return LogicalAndExpression;
        }(ExpressionAstNode);
        LogicalAndExpression.pool = ShaderLabUtils.createObjectPool(LogicalAndExpression);
        ASTNode.LogicalAndExpression = LogicalAndExpression;
        var LogicalXorExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(LogicalXorExpression, ExpressionAstNode);
            function LogicalXorExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = LogicalXorExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.logical_xor_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.BOOL;
                }
            };
            return LogicalXorExpression;
        }(ExpressionAstNode);
        LogicalXorExpression.pool = ShaderLabUtils.createObjectPool(LogicalXorExpression);
        ASTNode.LogicalXorExpression = LogicalXorExpression;
        var LogicalOrExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(LogicalOrExpression, ExpressionAstNode);
            function LogicalOrExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = LogicalOrExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.logical_or_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                } else {
                    this.type = EKeyword.BOOL;
                }
            };
            return LogicalOrExpression;
        }(ExpressionAstNode);
        LogicalOrExpression.pool = ShaderLabUtils.createObjectPool(LogicalOrExpression);
        ASTNode.LogicalOrExpression = LogicalOrExpression;
        var ConditionalExpression = /*#__PURE__*/ function(ExpressionAstNode) {
            _inherits(ConditionalExpression, ExpressionAstNode);
            function ConditionalExpression() {
                return ExpressionAstNode.apply(this, arguments) || this;
            }
            var _proto = ConditionalExpression.prototype;
            _proto.set = function set(loc, children) {
                ExpressionAstNode.prototype.set.call(this, loc, children, ENonTerminal.conditional_expression);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 1) {
                    this.type = this.children[0].type;
                }
            };
            return ConditionalExpression;
        }(ExpressionAstNode);
        ConditionalExpression.pool = ShaderLabUtils.createObjectPool(ConditionalExpression);
        ASTNode.ConditionalExpression = ConditionalExpression;
        var StructSpecifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(StructSpecifier, TreeNode);
            function StructSpecifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StructSpecifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.struct_specifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                if (this.children.length === 6) {
                    this.ident = this.children[1];
                    sa.symbolTable.insert(new StructSymbol(this.ident.lexeme, this));
                }
            };
            _create_class(StructSpecifier, [
                {
                    key: "propList",
                    get: function get() {
                        var declList = this.children.length === 6 ? this.children[3] : this.children[2];
                        return declList.propList;
                    }
                }
            ]);
            return StructSpecifier;
        }(TreeNode);
        StructSpecifier.pool = ShaderLabUtils.createObjectPool(StructSpecifier);
        ASTNode.StructSpecifier = StructSpecifier;
        var StructDeclarationList = /*#__PURE__*/ function(TreeNode) {
            _inherits(StructDeclarationList, TreeNode);
            function StructDeclarationList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StructDeclarationList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.struct_declaration_list);
            };
            _create_class(StructDeclarationList, [
                {
                    key: "propList",
                    get: function get() {
                        if (this.children.length === 1) {
                            return this.children[0].propList;
                        }
                        var list = this.children[0];
                        var decl = this.children[1];
                        return [
                            list.propList,
                            decl.propList
                        ].flat();
                    }
                }
            ]);
            return StructDeclarationList;
        }(TreeNode);
        StructDeclarationList.pool = ShaderLabUtils.createObjectPool(StructDeclarationList);
        ASTNode.StructDeclarationList = StructDeclarationList;
        var StructDeclaration = /*#__PURE__*/ function(TreeNode) {
            _inherits(StructDeclaration, TreeNode);
            function StructDeclaration() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StructDeclaration.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.struct_declaration);
            };
            _create_class(StructDeclaration, [
                {
                    key: "typeSpecifier",
                    get: function get() {
                        if (this.children.length === 3) {
                            return this.children[0];
                        }
                        return this.children[1];
                    }
                },
                {
                    key: "declaratorList",
                    get: function get() {
                        if (this.children.length === 3) {
                            return this.children[1];
                        }
                        return this.children[2];
                    }
                },
                {
                    key: "propList",
                    get: function get() {
                        var ret = [];
                        for(var i = 0; i < this.declaratorList.declaratorList.length; i++){
                            var declarator = this.declaratorList.declaratorList[i];
                            var typeInfo = new SymbolType(this.typeSpecifier.type, this.typeSpecifier.lexeme, declarator.arraySpecifier);
                            var prop = new StructProp(typeInfo, declarator.ident);
                            ret.push(prop);
                        }
                        return ret;
                    }
                }
            ]);
            return StructDeclaration;
        }(TreeNode);
        StructDeclaration.pool = ShaderLabUtils.createObjectPool(StructDeclaration);
        ASTNode.StructDeclaration = StructDeclaration;
        var StructDeclaratorList = /*#__PURE__*/ function(TreeNode) {
            _inherits(StructDeclaratorList, TreeNode);
            function StructDeclaratorList() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StructDeclaratorList.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.struct_declarator_list);
            };
            _create_class(StructDeclaratorList, [
                {
                    key: "declaratorList",
                    get: function get() {
                        if (this.children.length === 1) {
                            return [
                                this.children[0]
                            ];
                        } else {
                            var list = this.children[0];
                            return [].concat(list.declaratorList, [
                                this.children[1]
                            ]);
                        }
                    }
                }
            ]);
            return StructDeclaratorList;
        }(TreeNode);
        StructDeclaratorList.pool = ShaderLabUtils.createObjectPool(StructDeclaratorList);
        ASTNode.StructDeclaratorList = StructDeclaratorList;
        var StructDeclarator = /*#__PURE__*/ function(TreeNode) {
            _inherits(StructDeclarator, TreeNode);
            function StructDeclarator() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = StructDeclarator.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.struct_declarator);
            };
            _create_class(StructDeclarator, [
                {
                    key: "ident",
                    get: function get() {
                        return this.children[0];
                    }
                },
                {
                    key: "arraySpecifier",
                    get: function get() {
                        return this.children[1];
                    }
                }
            ]);
            return StructDeclarator;
        }(TreeNode);
        StructDeclarator.pool = ShaderLabUtils.createObjectPool(StructDeclarator);
        ASTNode.StructDeclarator = StructDeclarator;
        var VariableDeclaration = /*#__PURE__*/ function(TreeNode) {
            _inherits(VariableDeclaration, TreeNode);
            function VariableDeclaration() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = VariableDeclaration.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.variable_declaration);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var type = this.children[0];
                var ident = this.children[1];
                var sm;
                sm = new VarSymbol(ident.lexeme, new SymbolType(type.type, type.typeSpecifier.lexeme), true, this);
                sa.symbolTable.insert(sm);
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitGlobalVariableDeclaration(this);
            };
            return VariableDeclaration;
        }(TreeNode);
        VariableDeclaration.pool = ShaderLabUtils.createObjectPool(VariableDeclaration);
        ASTNode.VariableDeclaration = VariableDeclaration;
        var VariableIdentifier = /*#__PURE__*/ function(TreeNode) {
            _inherits(VariableIdentifier, TreeNode);
            function VariableIdentifier() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = VariableIdentifier.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.variable_identifier);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                var token = this.children[0];
                var builtinVar = BuiltinVariable.getVar(token.lexeme);
                if (builtinVar) {
                    this.symbolInfo = builtinVar;
                    return;
                }
                this.symbolInfo = sa.symbolTable.lookup({
                    ident: token.lexeme,
                    symbolType: ESymbolType.VAR
                });
                if (!this.symbolInfo) {
                    sa.error(this.location, "undeclared identifier:", token.lexeme);
                }
            };
            _proto.codeGen = function codeGen(visitor) {
                return visitor.visitVariableIdentifier(this);
            };
            _create_class(VariableIdentifier, [
                {
                    key: "lexeme",
                    get: function get() {
                        return this.children[0].lexeme;
                    }
                },
                {
                    key: "typeInfo",
                    get: function get() {
                        var _this_symbolInfo;
                        if (_instanceof(this.symbolInfo, VarSymbol)) return this.symbolInfo.dataType.type;
                        return (_this_symbolInfo = this.symbolInfo) == null ? void 0 : _this_symbolInfo.type;
                    }
                }
            ]);
            return VariableIdentifier;
        }(TreeNode);
        VariableIdentifier.pool = ShaderLabUtils.createObjectPool(VariableIdentifier);
        ASTNode.VariableIdentifier = VariableIdentifier;
        var GLShaderProgram = /*#__PURE__*/ function(TreeNode) {
            _inherits(GLShaderProgram, TreeNode);
            function GLShaderProgram() {
                return TreeNode.apply(this, arguments) || this;
            }
            var _proto = GLShaderProgram.prototype;
            _proto.set = function set(loc, children) {
                TreeNode.prototype.set.call(this, loc, children, ENonTerminal.gs_shader_program);
            };
            _proto.semanticAnalyze = function semanticAnalyze(sa) {
                this.shaderData = sa.shaderData;
                this.shaderData.symbolTable = sa.symbolTable._scope;
            };
            return GLShaderProgram;
        }(TreeNode);
        GLShaderProgram.pool = ShaderLabUtils.createObjectPool(GLShaderProgram);
        ASTNode.GLShaderProgram = GLShaderProgram;
    })(ASTNode || (ASTNode = {}));
    var ASTNode;

    var GrammarUtils = /*#__PURE__*/ function() {
        function GrammarUtils() {}
        GrammarUtils.isTerminal = function isTerminal(sm) {
            return sm < ENonTerminal.START;
        };
        GrammarUtils.toString = function toString(sm) {
            if (this.isTerminal(sm)) {
                var _ETokenType_sm;
                return (_ETokenType_sm = ETokenType[sm]) != null ? _ETokenType_sm : EKeyword[sm];
            }
            return ENonTerminal[sm];
        };
        GrammarUtils.createProductionWithOptions = function createProductionWithOptions(goal, options, /** the ast node */ astTypePool) {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(options), _step; !(_step = _iterator()).done;){
                var opt = _step.value;
                ret.push([
                    [].concat([
                        goal
                    ], opt),
                    function(sa) {
                        for(var _len = arguments.length, children = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                            children[_key - 1] = arguments[_key];
                        }
                        if (!children[0]) return;
                        var start = children[0].location.start;
                        var end = children[children.length - 1].location.end;
                        var location = ShaderLab.createRange(start, end);
                        ASTNode.get(astTypePool != null ? astTypePool : ASTNode.TrivialNode.pool, sa, location, children);
                    }
                ]);
            }
            return ret;
        };
        GrammarUtils.createProductionOptions = function createProductionOptions(common, position, opts) {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(opts), _step; !(_step = _iterator()).done;){
                var opt = _step.value;
                var _list, _list1;
                var list = common.slice(0, position);
                (_list = list).push.apply(_list, [].concat(opt));
                (_list1 = list).push.apply(_list1, [].concat(common.slice(position)));
                ret.push(list);
            }
            return ret;
        };
        GrammarUtils.addMapSetItem = function addMapSetItem(map, k, v) {
            var _map_get;
            var set = (_map_get = map.get(k)) != null ? _map_get : new Set();
            set.add(v);
            map.set(k, set);
        };
        GrammarUtils.isSubSet = function isSubSet(sa, sb) {
            for(var _iterator = _create_for_of_iterator_helper_loose(sa), _step; !(_step = _iterator()).done;){
                var item = _step.value;
                if (!sb.has(item)) return false;
            }
            return true;
        };
        GrammarUtils.isActionEqual = function isActionEqual(a, b) {
            return a.action === b.action && a.target === b.target;
        };
        GrammarUtils.printAction = function printAction(actionInfo) {
            return "<Action: " + EAction[actionInfo.action] + " -> " + (actionInfo.action === EAction.Reduce ? Production.pool.get(actionInfo.target) : "State " + actionInfo.target) + ">";
        };
        GrammarUtils.printProduction = function printProduction(production) {
            var deriv = production.derivation.map(function(gs) {
                return GrammarUtils.toString(gs);
            }).join("|");
            return ENonTerminal[production.goal] + " :=> " + deriv;
        };
        return GrammarUtils;
    }();

    // Context Free Grammar of Galacean ShaderLab
    var productionAndRules = [].concat(GrammarUtils.createProductionWithOptions(ENonTerminal.gs_shader_program, [
        [
            ENonTerminal.global_declaration
        ],
        [
            ENonTerminal.gs_shader_program,
            ENonTerminal.global_declaration
        ]
    ], ASTNode.GLShaderProgram.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.global_declaration, [
        [
            ENonTerminal.precision_specifier
        ],
        [
            ENonTerminal.variable_declaration
        ],
        [
            ENonTerminal.struct_specifier
        ],
        [
            ENonTerminal.function_definition
        ]
    ]), GrammarUtils.createProductionWithOptions(ENonTerminal.variable_declaration, [
        [
            EKeyword.GS_RenderQueueType,
            ETokenType.ID,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ENonTerminal.array_specifier,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.VariableDeclaration.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.ext_builtin_type_specifier_nonarray, [
        [
            EKeyword.VOID
        ],
        [
            EKeyword.FLOAT
        ],
        [
            EKeyword.BOOL
        ],
        [
            EKeyword.INT
        ],
        [
            EKeyword.UINT
        ],
        [
            EKeyword.VEC2
        ],
        [
            EKeyword.VEC3
        ],
        [
            EKeyword.VEC4
        ],
        [
            EKeyword.BVEC2
        ],
        [
            EKeyword.BVEC3
        ],
        [
            EKeyword.BVEC4
        ],
        [
            EKeyword.IVEC2
        ],
        [
            EKeyword.IVEC3
        ],
        [
            EKeyword.IVEC4
        ],
        [
            EKeyword.UVEC2
        ],
        [
            EKeyword.UVEC3
        ],
        [
            EKeyword.UVEC4
        ],
        [
            EKeyword.MAT2
        ],
        [
            EKeyword.MAT3
        ],
        [
            EKeyword.MAT4
        ],
        [
            EKeyword.MAT2X3
        ],
        [
            EKeyword.MAT2X4
        ],
        [
            EKeyword.MAT3X2
        ],
        [
            EKeyword.MAT3X4
        ],
        [
            EKeyword.MAT4X2
        ],
        [
            EKeyword.MAT4X3
        ],
        [
            EKeyword.SAMPLER2D
        ],
        [
            EKeyword.SAMPLER3D
        ],
        [
            EKeyword.SAMPLER_CUBE
        ],
        [
            EKeyword.SAMPLER2D_SHADOW
        ],
        [
            EKeyword.SAMPLER_CUBE_SHADOW
        ],
        [
            EKeyword.SAMPLER2D_ARRAY
        ],
        [
            EKeyword.SAMPLER2D_ARRAY_SHADOW
        ],
        [
            EKeyword.I_SAMPLER2D
        ],
        [
            EKeyword.I_SAMPLER3D
        ],
        [
            EKeyword.I_SAMPLER_CUBE
        ],
        [
            EKeyword.I_SAMPLER2D_ARRAY
        ],
        [
            EKeyword.U_SAMPLER2D
        ],
        [
            EKeyword.U_SAMPLER3D
        ],
        [
            EKeyword.U_SAMPLER_CUBE
        ],
        [
            EKeyword.U_SAMPLER2D_ARRAY
        ]
    ], ASTNode.ExtBuiltinTypeSpecifierNonArray.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.type_specifier_nonarray, [
        [
            ETokenType.ID
        ],
        [
            ENonTerminal.ext_builtin_type_specifier_nonarray
        ]
    ], ASTNode.TypeSpecifierNonArray.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.fully_specified_type, [
        [
            ENonTerminal.type_specifier
        ],
        [
            ENonTerminal.type_qualifier,
            ENonTerminal.type_specifier
        ]
    ], ASTNode.FullySpecifiedType.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.type_specifier, [
        [
            ENonTerminal.type_specifier_nonarray
        ],
        [
            ENonTerminal.ext_builtin_type_specifier_nonarray,
            ENonTerminal.array_specifier
        ]
    ], ASTNode.TypeSpecifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.type_qualifier, [
        [
            ENonTerminal.single_type_qualifier
        ],
        [
            ENonTerminal.type_qualifier,
            ENonTerminal.single_type_qualifier
        ]
    ], ASTNode.TypeQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.single_type_qualifier, [
        [
            ENonTerminal.storage_qualifier
        ],
        [
            ENonTerminal.precision_qualifier
        ],
        [
            ENonTerminal.interpolation_qualifier
        ],
        [
            ENonTerminal.invariant_qualifier
        ],
        [
            EKeyword.PRECISE
        ]
    ], ASTNode.SingleTypeQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.storage_qualifier, [
        [
            EKeyword.CONST
        ],
        [
            EKeyword.IN
        ],
        [
            EKeyword.INOUT
        ],
        [
            EKeyword.OUT
        ],
        [
            EKeyword.CENTROID
        ]
    ], ASTNode.StorageQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.interpolation_qualifier, [
        [
            EKeyword.SMOOTH
        ],
        [
            EKeyword.FLAT
        ]
    ], ASTNode.InterpolationQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.invariant_qualifier, [
        [
            EKeyword.INVARIANT
        ]
    ], ASTNode.InvariantQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.precision_qualifier, [
        [
            EKeyword.HIGHP
        ],
        [
            EKeyword.MEDIUMP
        ],
        [
            EKeyword.LOWP
        ]
    ], ASTNode.PrecisionQualifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.struct_specifier, [
        [
            EKeyword.STRUCT,
            ETokenType.ID,
            ETokenType.LEFT_BRACE,
            ENonTerminal.struct_declaration_list,
            ETokenType.RIGHT_BRACE,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.STRUCT,
            ETokenType.LEFT_BRACE,
            ENonTerminal.struct_declaration_list,
            ETokenType.RIGHT_BRACE,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.StructSpecifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.struct_declaration_list, [
        [
            ENonTerminal.struct_declaration
        ],
        [
            ENonTerminal.struct_declaration_list,
            ENonTerminal.struct_declaration
        ]
    ], ASTNode.StructDeclarationList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.struct_declaration, [
        [
            ENonTerminal.type_specifier,
            ENonTerminal.struct_declarator_list,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.type_qualifier,
            ENonTerminal.type_specifier,
            ENonTerminal.struct_declarator_list,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.StructDeclaration.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.struct_declarator_list, [
        [
            ENonTerminal.struct_declarator
        ],
        [
            ENonTerminal.struct_declarator_list,
            ETokenType.COMMA,
            ENonTerminal.struct_declarator
        ]
    ], ASTNode.StructDeclaratorList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.struct_declarator, [
        [
            ETokenType.ID
        ],
        [
            ETokenType.ID,
            ENonTerminal.array_specifier
        ]
    ], ASTNode.StructDeclarator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.array_specifier, [
        [
            ETokenType.LEFT_BRACKET,
            ETokenType.RIGHT_BRACKET
        ],
        [
            ETokenType.LEFT_BRACKET,
            ENonTerminal.integer_constant_expression,
            ETokenType.RIGHT_BRACKET
        ]
    ], ASTNode.ArraySpecifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.integer_constant_expression_operator, [
        [
            ETokenType.PLUS
        ],
        [
            ETokenType.DASH
        ],
        [
            ETokenType.STAR
        ],
        [
            ETokenType.SLASH
        ],
        [
            ETokenType.PERCENT
        ]
    ], ASTNode.IntegerConstantExpressionOperator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.integer_constant_expression, [
        [
            ENonTerminal.variable_identifier
        ],
        [
            ETokenType.INT_CONSTANT
        ],
        [
            ENonTerminal.integer_constant_expression,
            ENonTerminal.integer_constant_expression_operator,
            ETokenType.INT_CONSTANT
        ],
        [
            ENonTerminal.integer_constant_expression,
            ENonTerminal.integer_constant_expression_operator,
            ENonTerminal.variable_identifier
        ]
    ], ASTNode.IntegerConstantExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.conditional_expression, [
        [
            ENonTerminal.logical_or_expression
        ],
        [
            ENonTerminal.logical_or_expression,
            ETokenType.QUESTION,
            ENonTerminal.expression,
            ETokenType.COLON,
            ENonTerminal.assignment_expression
        ]
    ], ASTNode.ConditionalExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.logical_or_expression, [
        [
            ENonTerminal.logical_xor_expression
        ],
        [
            ENonTerminal.logical_or_expression,
            ETokenType.OR_OP,
            ENonTerminal.logical_xor_expression
        ]
    ], ASTNode.LogicalOrExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.logical_xor_expression, [
        [
            ENonTerminal.logical_and_expression
        ],
        [
            ENonTerminal.logical_xor_expression,
            ETokenType.XOR_OP,
            ENonTerminal.logical_and_expression
        ]
    ], ASTNode.LogicalXorExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.logical_and_expression, [
        [
            ENonTerminal.inclusive_or_expression
        ],
        [
            ENonTerminal.logical_and_expression,
            ETokenType.AND_OP,
            ENonTerminal.inclusive_or_expression
        ]
    ], ASTNode.LogicalAndExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.inclusive_or_expression, [
        [
            ENonTerminal.exclusive_or_expression
        ],
        [
            ENonTerminal.inclusive_or_expression,
            ETokenType.VERTICAL_BAR,
            ENonTerminal.exclusive_or_expression
        ]
    ], ASTNode.InclusiveOrExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.exclusive_or_expression, [
        [
            ENonTerminal.and_expression
        ],
        [
            ENonTerminal.exclusive_or_expression,
            ETokenType.CARET,
            ENonTerminal.and_expression
        ]
    ], ASTNode.ExclusiveOrExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.and_expression, [
        [
            ENonTerminal.equality_expression
        ],
        [
            ENonTerminal.and_expression,
            ETokenType.AMPERSAND,
            ENonTerminal.equality_expression
        ]
    ], ASTNode.AndExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.equality_expression, [
        [
            ENonTerminal.relational_expression
        ],
        [
            ENonTerminal.equality_expression,
            ETokenType.EQ_OP,
            ENonTerminal.relational_expression
        ],
        [
            ENonTerminal.equality_expression,
            ETokenType.NE_OP,
            ENonTerminal.relational_expression
        ]
    ], ASTNode.EqualityExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.relational_expression, [
        [
            ENonTerminal.shift_expression
        ],
        [
            ENonTerminal.relational_expression,
            ETokenType.LEFT_ANGLE,
            ENonTerminal.shift_expression
        ],
        [
            ENonTerminal.relational_expression,
            ETokenType.RIGHT_ANGLE,
            ENonTerminal.shift_expression
        ],
        [
            ENonTerminal.relational_expression,
            ETokenType.LE_OP,
            ENonTerminal.shift_expression
        ],
        [
            ENonTerminal.relational_expression,
            ETokenType.GE_OP,
            ENonTerminal.shift_expression
        ]
    ], ASTNode.RelationalExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.shift_expression, [
        [
            ENonTerminal.additive_expression
        ],
        [
            ENonTerminal.shift_expression,
            ETokenType.LEFT_OP,
            ENonTerminal.additive_expression
        ],
        [
            ENonTerminal.shift_expression,
            ETokenType.RIGHT_OP,
            ENonTerminal.additive_expression
        ]
    ], ASTNode.ShiftExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.additive_expression, [
        [
            ENonTerminal.multiplicative_expression
        ],
        [
            ENonTerminal.additive_expression,
            ETokenType.PLUS,
            ENonTerminal.multiplicative_expression
        ],
        [
            ENonTerminal.additive_expression,
            ETokenType.DASH,
            ENonTerminal.multiplicative_expression
        ]
    ], ASTNode.AdditiveExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.multiplicative_expression, [
        [
            ENonTerminal.unary_expression
        ],
        [
            ENonTerminal.multiplicative_expression,
            ETokenType.STAR,
            ENonTerminal.unary_expression
        ],
        [
            ENonTerminal.multiplicative_expression,
            ETokenType.SLASH,
            ENonTerminal.unary_expression
        ],
        [
            ENonTerminal.multiplicative_expression,
            ETokenType.PERCENT,
            ENonTerminal.unary_expression
        ]
    ], ASTNode.MultiplicativeExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.unary_expression, [
        [
            ENonTerminal.postfix_expression
        ],
        [
            ETokenType.INC_OP,
            ENonTerminal.unary_expression
        ],
        [
            ETokenType.DEC_OP,
            ENonTerminal.unary_expression
        ],
        [
            ENonTerminal.unary_operator,
            ENonTerminal.unary_expression
        ]
    ], ASTNode.UnaryExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.unary_operator, [
        [
            ETokenType.PLUS
        ],
        [
            ETokenType.DASH
        ],
        [
            ETokenType.BANG
        ],
        [
            ETokenType.TILDE
        ]
    ], ASTNode.UnaryOperator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.postfix_expression, [
        [
            ENonTerminal.primary_expression
        ],
        [
            ENonTerminal.postfix_expression,
            ETokenType.LEFT_BRACKET,
            ENonTerminal.expression,
            ETokenType.RIGHT_BRACKET
        ],
        [
            ENonTerminal.function_call
        ],
        [
            ENonTerminal.postfix_expression,
            ETokenType.DOT,
            ETokenType.ID
        ],
        [
            ENonTerminal.postfix_expression,
            ETokenType.DOT,
            ENonTerminal.function_call
        ],
        [
            ENonTerminal.postfix_expression,
            ETokenType.INC_OP
        ],
        [
            ENonTerminal.postfix_expression,
            ETokenType.DEC_OP
        ]
    ], ASTNode.PostfixExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.primary_expression, [
        [
            ENonTerminal.variable_identifier
        ],
        [
            ETokenType.INT_CONSTANT
        ],
        [
            ETokenType.FLOAT_CONSTANT
        ],
        [
            EKeyword.TRUE
        ],
        [
            EKeyword.FALSE
        ],
        [
            ETokenType.LEFT_PAREN,
            ENonTerminal.expression,
            ETokenType.RIGHT_PAREN
        ]
    ], ASTNode.PrimaryExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.expression, [
        [
            ENonTerminal.assignment_expression
        ],
        [
            ENonTerminal.expression,
            ETokenType.COMMA,
            ENonTerminal.assignment_expression
        ]
    ], ASTNode.Expression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.assignment_expression, [
        [
            ENonTerminal.conditional_expression
        ],
        [
            ENonTerminal.unary_expression,
            ENonTerminal.assignment_operator,
            ENonTerminal.assignment_expression
        ]
    ], ASTNode.AssignmentExpression.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.assignment_operator, [
        [
            ETokenType.EQUAL
        ],
        [
            ETokenType.MUL_ASSIGN
        ],
        [
            ETokenType.DIV_ASSIGN
        ],
        [
            ETokenType.MOD_ASSIGN
        ],
        [
            ETokenType.ADD_ASSIGN
        ],
        [
            ETokenType.SUB_ASSIGN
        ],
        [
            ETokenType.LEFT_ASSIGN
        ],
        [
            ETokenType.RIGHT_ASSIGN
        ],
        [
            ETokenType.AND_ASSIGN
        ],
        [
            ETokenType.XOR_ASSIGN
        ],
        [
            ETokenType.OR_ASSIGN
        ]
    ], ASTNode.AssignmentOperator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_call, [
        [
            ENonTerminal.function_call_generic
        ]
    ], ASTNode.FunctionCall.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_call_generic, [
        [
            ENonTerminal.function_identifier,
            ETokenType.LEFT_PAREN,
            ENonTerminal.function_call_parameter_list,
            ETokenType.RIGHT_PAREN
        ],
        [
            ENonTerminal.function_identifier,
            ETokenType.LEFT_PAREN,
            ETokenType.RIGHT_PAREN
        ],
        [
            ENonTerminal.function_identifier,
            EKeyword.VOID,
            ETokenType.RIGHT_PAREN
        ]
    ], ASTNode.FunctionCallGeneric.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_call_parameter_list, [
        [
            ENonTerminal.assignment_expression
        ],
        [
            ENonTerminal.function_call_parameter_list,
            ETokenType.COMMA,
            ENonTerminal.assignment_expression
        ]
    ], ASTNode.FunctionCallParameterList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_identifier, [
        [
            ENonTerminal.type_specifier
        ]
    ], ASTNode.FunctionIdentifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_definition, [
        [
            ENonTerminal.function_prototype,
            ENonTerminal.compound_statement_no_scope
        ]
    ], ASTNode.FunctionDefinition.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_prototype, [
        [
            ENonTerminal.function_declarator,
            ETokenType.RIGHT_PAREN
        ]
    ], ASTNode.FunctionProtoType.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_declarator, [
        [
            ENonTerminal.function_header
        ],
        [
            ENonTerminal.function_header,
            ENonTerminal.function_parameter_list
        ]
    ], ASTNode.FunctionDeclarator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_header, [
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ETokenType.LEFT_PAREN
        ]
    ], ASTNode.FunctionHeader.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.function_parameter_list, [
        [
            ENonTerminal.parameter_declaration
        ],
        [
            ENonTerminal.function_parameter_list,
            ETokenType.COMMA,
            ENonTerminal.parameter_declaration
        ]
    ], ASTNode.FunctionParameterList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.parameter_declaration, [
        [
            ENonTerminal.type_qualifier,
            ENonTerminal.parameter_declarator
        ],
        [
            ENonTerminal.parameter_declarator
        ]
    ], ASTNode.ParameterDeclaration.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.parameter_declarator, [
        [
            ENonTerminal.type_specifier,
            ETokenType.ID
        ],
        [
            ENonTerminal.type_specifier,
            ETokenType.ID,
            ENonTerminal.array_specifier
        ]
    ], ASTNode.ParameterDeclarator.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.statement_list, [
        [
            ENonTerminal.statement
        ],
        [
            ENonTerminal.statement_list,
            ENonTerminal.statement
        ]
    ], ASTNode.StatementList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.statement, [
        [
            ENonTerminal.compound_statement
        ],
        [
            ENonTerminal.simple_statement
        ]
    ], ASTNode.Statement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.compound_statement_no_scope, [
        [
            ETokenType.LEFT_BRACE,
            ETokenType.RIGHT_BRACE
        ],
        [
            ETokenType.LEFT_BRACE,
            ENonTerminal.statement_list,
            ETokenType.RIGHT_BRACE
        ]
    ], ASTNode.CompoundStatementNoScope.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.compound_statement, [
        [
            ETokenType.LEFT_BRACE,
            ETokenType.RIGHT_BRACE
        ],
        [
            ENonTerminal.scope_brace,
            ENonTerminal.statement_list,
            ENonTerminal.scope_end_brace
        ]
    ], ASTNode.CompoundStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.simple_statement, [
        [
            ENonTerminal.declaration
        ],
        [
            ENonTerminal.expression_statement
        ],
        [
            ENonTerminal.selection_statement
        ],
        [
            ENonTerminal.iteration_statement
        ],
        [
            ENonTerminal.jump_statement
        ]
    ], ASTNode.SimpleStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.declaration, [
        [
            ENonTerminal.function_prototype,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.init_declarator_list,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.PRECISION,
            ENonTerminal.precision_qualifier,
            ENonTerminal.ext_builtin_type_specifier_nonarray,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.type_qualifier,
            ETokenType.ID,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.type_qualifier,
            ETokenType.ID,
            ENonTerminal.identifier_list,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.Declaration.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.identifier_list, [
        [
            ETokenType.COMMA,
            ETokenType.ID
        ],
        [
            ENonTerminal.identifier_list,
            ETokenType.COMMA,
            ETokenType.ID
        ]
    ], ASTNode.IdentifierList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.init_declarator_list, [
        [
            ENonTerminal.single_declaration
        ],
        [
            ENonTerminal.init_declarator_list,
            ETokenType.COMMA,
            ETokenType.ID
        ],
        [
            ENonTerminal.init_declarator_list,
            ETokenType.COMMA,
            ETokenType.ID,
            ENonTerminal.array_specifier
        ],
        [
            ENonTerminal.init_declarator_list,
            ETokenType.COMMA,
            ETokenType.ID,
            ENonTerminal.array_specifier,
            ETokenType.EQUAL,
            ENonTerminal.initializer
        ],
        [
            ENonTerminal.init_declarator_list,
            ETokenType.COMMA,
            ETokenType.ID,
            ETokenType.EQUAL,
            ENonTerminal.initializer
        ]
    ], ASTNode.InitDeclaratorList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.single_declaration, [
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ENonTerminal.array_specifier
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ENonTerminal.array_specifier,
            ETokenType.EQUAL,
            ENonTerminal.initializer
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ETokenType.EQUAL,
            ENonTerminal.initializer
        ]
    ], ASTNode.SingleDeclaration.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.initializer, [
        [
            ENonTerminal.assignment_expression
        ],
        [
            ETokenType.LEFT_BRACE,
            ENonTerminal.initializer_list,
            ETokenType.RIGHT_BRACE
        ]
    ], ASTNode.Initializer.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.initializer_list, [
        [
            ENonTerminal.initializer
        ],
        [
            ENonTerminal.initializer_list,
            ETokenType.COMMA,
            ENonTerminal.initializer
        ]
    ], ASTNode.InitializerList.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.expression_statement, [
        [
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.expression,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.ExpressionStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.selection_statement, [
        [
            EKeyword.IF,
            ETokenType.LEFT_PAREN,
            ENonTerminal.expression,
            ETokenType.RIGHT_PAREN,
            ENonTerminal.statement
        ],
        [
            EKeyword.IF,
            ETokenType.LEFT_PAREN,
            ENonTerminal.expression,
            ETokenType.RIGHT_PAREN,
            ENonTerminal.statement,
            EKeyword.ELSE,
            ENonTerminal.statement
        ]
    ], ASTNode.SelectionStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.iteration_statement, [
        [
            EKeyword.WHILE,
            ETokenType.LEFT_PAREN,
            ENonTerminal.condition,
            ETokenType.RIGHT_PAREN,
            ENonTerminal.statement
        ],
        [
            EKeyword.FOR,
            ETokenType.LEFT_PAREN,
            ENonTerminal.for_init_statement,
            ENonTerminal.for_rest_statement,
            ETokenType.RIGHT_PAREN,
            ENonTerminal.statement
        ]
    ], ASTNode.IterationStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.precision_specifier, [
        [
            EKeyword.PRECISION,
            ENonTerminal.precision_qualifier,
            ENonTerminal.ext_builtin_type_specifier_nonarray,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.PrecisionSpecifier.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.for_init_statement, [
        [
            ENonTerminal.expression_statement
        ],
        [
            ENonTerminal.declaration
        ]
    ], ASTNode.ForInitStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.condition, [
        [
            ENonTerminal.expression
        ],
        [
            ENonTerminal.fully_specified_type,
            ETokenType.ID,
            ETokenType.EQUAL,
            ENonTerminal.initializer
        ]
    ], ASTNode.Condition.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.for_rest_statement, [
        [
            ENonTerminal.conditionopt,
            ETokenType.SEMICOLON
        ],
        [
            ENonTerminal.conditionopt,
            ETokenType.SEMICOLON,
            ENonTerminal.expression
        ]
    ], ASTNode.ForRestStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.conditionopt, [
        [
            ETokenType.EPSILON
        ],
        [
            ENonTerminal.condition
        ]
    ], ASTNode.ConditionOpt.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.jump_statement, [
        [
            EKeyword.CONTINUE,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.BREAK,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.RETURN,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.RETURN,
            ENonTerminal.expression,
            ETokenType.SEMICOLON
        ],
        [
            EKeyword.DISCARD,
            ETokenType.SEMICOLON
        ]
    ], ASTNode.JumpStatement.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.scope_brace, [
        [
            ETokenType.LEFT_BRACE
        ]
    ], ASTNode.ScopeBrace.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.scope_end_brace, [
        [
            ETokenType.RIGHT_BRACE
        ]
    ], ASTNode.ScopeEndBrace.pool), GrammarUtils.createProductionWithOptions(ENonTerminal.variable_identifier, [
        [
            ETokenType.ID
        ]
    ], ASTNode.VariableIdentifier.pool));
    var createGrammar = function() {
        return Grammar.create(ENonTerminal.gs_shader_program, productionAndRules.map(function(item) {
            return item[0];
        }));
    };
    var addTranslationRule = function(sa) {
        for(var i = 0; i < productionAndRules.length; i++){
            var rule = productionAndRules[i][1];
            if (rule) {
                sa.addTranslationRule(i, rule);
            }
        }
    };

    /**
     * The [LALR1](https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/140%20LALR%20Parsing.pdf) Parser generator
     */ var LALR1 = /*#__PURE__*/ function() {
        function LALR1(grammar) {
            this.firstSetMap = new Map();
            this.followSetMap = new Map();
            this.actionTable = new Map();
            this.gotoTable = new Map();
            /** For circle detect */ this._firstSetNTStack = [];
            this.grammar = grammar;
        }
        var _proto = LALR1.prototype;
        _proto.generate = function generate() {
            this.computeFirstSet();
            this.buildStateTable();
        };
        _proto.buildStateTable = function buildStateTable() {
            var startStateItemCore = [
                new StateItem(this.grammar.productions[0], 0, [
                    ETokenType.EOF
                ])
            ];
            var startState = State.create(startStateItemCore);
            this._extendState(startState);
        };
        _proto._extendState = function _extendState(state) {
            if (!state.needReInfer) return;
            this._closure(state);
            var newStates = this._inferNextState(state);
            for(var _iterator = _create_for_of_iterator_helper_loose(newStates), _step; !(_step = _iterator()).done;){
                var ns = _step.value;
                this._extendState(ns);
            }
        };
        _proto._closure = function _closure(state) {
            for(var _iterator = _create_for_of_iterator_helper_loose(state.cores), _step; !(_step = _iterator()).done;){
                var core = _step.value;
                if (!core.canReduce()) {
                    this._extendStateItem(state, core);
                }
            }
            state.closured = true;
            return state;
        };
        _proto._extendStateItem = function _extendStateItem(state, item) {
            if (GrammarUtils.isTerminal(item.curSymbol)) return;
            var productionList = this.grammar.getProductionList(item.curSymbol);
            if (item.nextSymbol) {
                var newLookaheadSet = new Set();
                var lastFirstSet;
                var terminalExist = false;
                // when A :=> a.BC, a;  ==》 B :=> .xy, First(Ca)
                // newLookAhead = First(Ca)
                for(var i = 1, nextSymbol = item.symbolByOffset(1); !!nextSymbol; nextSymbol = item.symbolByOffset(++i)){
                    if (GrammarUtils.isTerminal(nextSymbol)) {
                        newLookaheadSet.add(nextSymbol);
                        terminalExist = true;
                        break;
                    }
                    lastFirstSet = this.firstSetMap.get(nextSymbol);
                    for(var _iterator = _create_for_of_iterator_helper_loose(lastFirstSet), _step; !(_step = _iterator()).done;){
                        var t = _step.value;
                        newLookaheadSet.add(t);
                    }
                    if (!lastFirstSet.has(ETokenType.EPSILON)) break;
                }
                if (!terminalExist && (lastFirstSet == null ? void 0 : lastFirstSet.has(ETokenType.EPSILON))) {
                    for(var _iterator1 = _create_for_of_iterator_helper_loose(item.lookaheadSet), _step1; !(_step1 = _iterator1()).done;){
                        var t1 = _step1.value;
                        newLookaheadSet.add(t1);
                    }
                }
                for(var _iterator2 = _create_for_of_iterator_helper_loose(productionList), _step2; !(_step2 = _iterator2()).done;){
                    var production = _step2.value;
                    var newItem = state.createStateItem(production, 0);
                    if (!state.items.has(newItem) || !GrammarUtils.isSubSet(newLookaheadSet, newItem.lookaheadSet)) {
                        state.items.add(newItem);
                        newItem.addLookahead(newLookaheadSet);
                        this._extendStateItem(state, newItem);
                    }
                }
            } else {
                for(var _iterator3 = _create_for_of_iterator_helper_loose(productionList), _step3; !(_step3 = _iterator3()).done;){
                    var production1 = _step3.value;
                    var newItem1 = state.createStateItem(production1, 0);
                    if (!state.items.has(newItem1) || !GrammarUtils.isSubSet(item.lookaheadSet, newItem1.lookaheadSet)) {
                        state.items.add(newItem1);
                        newItem1.addLookahead(item.lookaheadSet);
                        this._extendStateItem(state, newItem1);
                    }
                }
            }
        };
        _proto._inferNextState = function _inferNextState(state) {
            var coreMap = new Map();
            var _this_actionTable_get;
            var stateActionTable = (_this_actionTable_get = this.actionTable.get(state.id)) != null ? _this_actionTable_get : new Map();
            var _this_gotoTable_get;
            var stateGotoTable = (_this_gotoTable_get = this.gotoTable.get(state.id)) != null ? _this_gotoTable_get : new Map();
            this.actionTable.set(state.id, stateActionTable);
            this.gotoTable.set(state.id, stateGotoTable);
            for(var _iterator = _create_for_of_iterator_helper_loose(state.items), _step; !(_step = _iterator()).done;){
                var stateItem = _step.value;
                if (stateItem.canReduce()) {
                    var action = void 0;
                    if (stateItem.production.goal !== ENonTerminal.START) {
                        action = {
                            action: EAction.Reduce,
                            target: stateItem.production.id
                        };
                    } else {
                        action = {
                            action: EAction.Accept
                        };
                    }
                    for(var _iterator1 = _create_for_of_iterator_helper_loose(stateItem.lookaheadSet), _step1; !(_step1 = _iterator1()).done;){
                        var t = _step1.value;
                        this._addAction(stateActionTable, t, action);
                    }
                } else {
                    var nextItem = stateItem.advance();
                    GrammarUtils.addMapSetItem(coreMap, stateItem.curSymbol, nextItem);
                }
                stateItem.needReInfer = false;
            }
            var newStates = new Set();
            for(var _iterator2 = _create_for_of_iterator_helper_loose(coreMap.entries()), _step2; !(_step2 = _iterator2()).done;){
                var _step_value = _step2.value, gs = _step_value[0], cores = _step_value[1];
                var newState = State.create(Array.from(cores));
                if (GrammarUtils.isTerminal(gs)) {
                    this._addAction(stateActionTable, gs, {
                        action: EAction.Shift,
                        target: newState.id
                    });
                } else {
                    stateGotoTable.set(gs, newState.id);
                }
                newStates.add(newState);
            }
            return newStates;
        };
        /** Resolve shift-reduce/reduce-reduce conflict detect */ _proto._addAction = function _addAction(table, terminal, action) {
            var exist = table.get(terminal);
            if (exist && !GrammarUtils.isActionEqual(exist, action)) {
                // Resolve dangling else ambiguity
                if (terminal === EKeyword.ELSE && exist.action === EAction.Shift && action.action === EAction.Reduce) {
                    return;
                } else {
                    console.warn("conflict detect: <Terminal " + GrammarUtils.toString(terminal) + ">", GrammarUtils.printAction(exist), " -> ", GrammarUtils.printAction(action));
                }
            }
            table.set(terminal, action);
        };
        // https://people.cs.pitt.edu/~jmisurda/teaching/cs1622/handouts/cs1622-first_and_follow.pdf
        _proto.computeFirstSet = function computeFirstSet() {
            for(var _iterator = _create_for_of_iterator_helper_loose(this.grammar.productions.slice(1)), _step; !(_step = _iterator()).done;){
                var production = _step.value;
                this._computeFirstSetForNT(production.goal);
            }
        };
        _proto._computeFirstSetForNT = function _computeFirstSetForNT(NT) {
            // circle detect
            var idx = this._firstSetNTStack.findIndex(function(item) {
                return item === NT;
            });
            if (idx !== -1) {
                var computingFS = this.firstSetMap.get(NT);
                var len = this._firstSetNTStack.length;
                for(var i = len - 1; i > idx; i--){
                    var curNT = this._firstSetNTStack[i];
                    this.firstSetMap.set(curNT, computingFS);
                }
                return computingFS;
            }
            this._firstSetNTStack.push(NT);
            var productionList = this.grammar.getProductionList(NT);
            var firstSet = new Set();
            this.firstSetMap.set(NT, firstSet);
            if (this.grammar.isNullableNT(NT)) firstSet.add(ETokenType.EPSILON);
            for(var _iterator = _create_for_of_iterator_helper_loose(productionList), _step; !(_step = _iterator()).done;){
                var production = _step.value;
                var i1 = 0;
                for(; i1 < production.derivation.length; i1++){
                    var gs = production.derivation[i1];
                    if (GrammarUtils.isTerminal(gs)) {
                        firstSet.add(gs);
                        break;
                    }
                    var succeedFirstSet = this._computeFirstSetForNT(gs);
                    for(var _iterator1 = _create_for_of_iterator_helper_loose(succeedFirstSet), _step1; !(_step1 = _iterator1()).done;){
                        var item = _step1.value;
                        if (item !== ETokenType.EPSILON) firstSet.add(item);
                    }
                    if (!this.grammar.isNullableNT(gs)) break;
                }
                if (i1 === production.derivation.length) firstSet.add(ETokenType.EPSILON);
            }
            this._firstSetNTStack.pop();
            return firstSet;
        };
        return LALR1;
    }();

    /**
     * The syntax parser and sematic analyzer of `ShaderLab` compiler
     */ var ShaderTargetParser = /*#__PURE__*/ function() {
        function ShaderTargetParser(actionTable, gotoTable, grammar) {
            this._traceBackStack = [];
            this.actionTable = actionTable;
            this.gotoTable = gotoTable;
            this.grammar = grammar;
            this.sematicAnalyzer = new SematicAnalyzer();
        }
        var _proto = ShaderTargetParser.prototype;
        _proto.parse = function parse(tokens) {
            this.sematicAnalyzer.reset();
            var start = performance.now();
            var _this = this, traceBackStack = _this._traceBackStack, sematicAnalyzer = _this.sematicAnalyzer;
            traceBackStack.push(0);
            var nextToken = tokens.next();
            var loopCount = 0;
            while(true){
                loopCount += 1;
                var token = nextToken.value;
                var actionInfo = this.stateActionTable.get(token.type);
                if ((actionInfo == null ? void 0 : actionInfo.action) === EAction.Shift) {
                    traceBackStack.push(token, actionInfo.target);
                    nextToken = tokens.next();
                } else if ((actionInfo == null ? void 0 : actionInfo.action) === EAction.Accept) {
                    engine.Logger.info("[pass compilation - parser] Accept! State automata run " + loopCount + " times! cost time " + (performance.now() - start) + "ms");
                    sematicAnalyzer.acceptRule == null ? void 0 : sematicAnalyzer.acceptRule.call(sematicAnalyzer, sematicAnalyzer);
                    return sematicAnalyzer.semanticStack.pop();
                } else if ((actionInfo == null ? void 0 : actionInfo.action) === EAction.Reduce) {
                    var target = actionInfo.target;
                    var reduceProduction = this.grammar.getProductionByID(target);
                    var translationRule = sematicAnalyzer.getTranslationRule(reduceProduction.id);
                    var values = [];
                    for(var i = reduceProduction.derivation.length - 1; i >= 0; i--){
                        if (reduceProduction.derivation[i] === ETokenType.EPSILON) continue;
                        traceBackStack.pop();
                        var token1 = traceBackStack.pop();
                        if (_instanceof(token1, BaseToken)) {
                            values.unshift(token1);
                        } else {
                            var astNode = sematicAnalyzer.semanticStack.pop();
                            values.unshift(astNode);
                        }
                    }
                    translationRule == null ? void 0 : translationRule.apply(void 0, [].concat([
                        sematicAnalyzer
                    ], values));
                    var gotoTable = this.stateGotoTable;
                    traceBackStack.push(reduceProduction.goal);
                    var nextState = gotoTable == null ? void 0 : gotoTable.get(reduceProduction.goal);
                    traceBackStack.push(nextState);
                    continue;
                } else {
                    var error = ShaderLabUtils.createGSError("Unexpected token " + token.lexeme, GSErrorName.CompilationError, ShaderLab._processingPassText, token.location);
                    this.sematicAnalyzer.errors.push(error);
                    return null;
                }
            }
        };
        _proto._printStack = function _printStack(nextToken) {
            var str = "";
            for(var i = 0; i < this._traceBackStack.length - 1; i++){
                var state = this._traceBackStack[i++];
                var token = this._traceBackStack[i];
                var _token_lexeme;
                str += "State" + state + " - " + ((_token_lexeme = token.lexeme) != null ? _token_lexeme : ParserUtils.toString(token)) + "; ";
            }
            str += "State" + this._traceBackStack[this._traceBackStack.length - 1] + " --- " + nextToken.lexeme;
            engine.Logger.info(str);
        };
        ShaderTargetParser.create = function create() {
            if (!this._singleton) {
                var grammar = createGrammar();
                var generator = new LALR1(grammar);
                generator.generate();
                this._singleton = new ShaderTargetParser(generator.actionTable, generator.gotoTable, grammar);
                addTranslationRule(this._singleton.sematicAnalyzer);
            }
            return this._singleton;
        };
        _create_class(ShaderTargetParser, [
            {
                key: "curState",
                get: function get() {
                    return this._traceBackStack[this._traceBackStack.length - 1];
                }
            },
            {
                key: "stateActionTable",
                get: function get() {
                    return this.actionTable.get(this.curState);
                }
            },
            {
                key: "stateGotoTable",
                get: function get() {
                    return this.gotoTable.get(this.curState);
                }
            },
            {
                key: "errors",
                get: /** @internal */ function get() {
                    return this.sematicAnalyzer.errors;
                }
            }
        ]);
        return ShaderTargetParser;
    }();

    function _type_of(obj) {
        "@swc/helpers - typeof";

        return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }

    var MacroDefine = /*#__PURE__*/ function() {
        function MacroDefine(macro, body, location, args) {
            this.macro = macro;
            this.body = body;
            this.location = location;
            this.args = args;
            if (args) {
                this._argsLexemes = this.args.map(function(item) {
                    return item.lexeme;
                });
                this._replaceRegex = new RegExp("\\b(" + this._argsLexemes.join("|") + ")\\b", "g");
            }
        }
        var _proto = MacroDefine.prototype;
        _proto.expandFunctionBody = function expandFunctionBody(args) {
            var _this = this;
            var _this_args;
            if (args.length !== ((_this_args = this.args) == null ? void 0 : _this_args.length)) {
                throw ShaderLabUtils.createGSError("mismatched function macro", GSErrorName.PreprocessorError, "", this.location);
            }
            return this.body.lexeme.replace(this._replaceRegex, function(m) {
                return args[_this._argsLexemes.indexOf(m)];
            });
        };
        _create_class(MacroDefine, [
            {
                key: "isFunction",
                get: function get() {
                    var _this_args;
                    return !!((_this_args = this.args) == null ? void 0 : _this_args.length);
                }
            }
        ]);
        return MacroDefine;
    }();

    var EPpToken = /*#__PURE__*/ function(EPpToken) {
        EPpToken[EPpToken["id"] = 0] = "id";
        EPpToken[EPpToken["line_remain"] = 1] = "line_remain";
        EPpToken[EPpToken["chunk"] = 2] = "chunk";
        EPpToken[EPpToken["int_constant"] = 3] = "int_constant";
        EPpToken[EPpToken["string_const"] = 4] = "string_const";
        /** \>> */ EPpToken[EPpToken["right_op"] = 5] = "right_op";
        /** << */ EPpToken[EPpToken["left_op"] = 6] = "left_op";
        EPpToken[EPpToken["left_paren"] = 7] = "left_paren";
        EPpToken[EPpToken["right_paren"] = 8] = "right_paren";
        /** \>= */ EPpToken[EPpToken["ge"] = 9] = "ge";
        /** <= */ EPpToken[EPpToken["le"] = 10] = "le";
        /** == */ EPpToken[EPpToken["eq"] = 11] = "eq";
        /** != */ EPpToken[EPpToken["neq"] = 12] = "neq";
        /** && */ EPpToken[EPpToken["and"] = 13] = "and";
        /** || */ EPpToken[EPpToken["or"] = 14] = "or";
        /** < */ EPpToken[EPpToken["left_angle"] = 15] = "left_angle";
        /** \> */ EPpToken[EPpToken["right_angle"] = 16] = "right_angle";
        /** \* */ EPpToken[EPpToken["star"] = 17] = "star";
        /** + */ EPpToken[EPpToken["plus"] = 18] = "plus";
        /** \- */ EPpToken[EPpToken["dash"] = 19] = "dash";
        /** ! */ EPpToken[EPpToken["bang"] = 20] = "bang";
        /** \/ */ EPpToken[EPpToken["slash"] = 21] = "slash";
        /** % */ EPpToken[EPpToken["percent"] = 22] = "percent";
        EPpToken[EPpToken["EOF"] = 100] = "EOF";
        return EPpToken;
    }({});
    var EPpKeyword = /*#__PURE__*/ function(EPpKeyword) {
        EPpKeyword[EPpKeyword["define"] = 101] = "define";
        EPpKeyword[EPpKeyword["undef"] = 102] = "undef";
        EPpKeyword[EPpKeyword["if"] = 103] = "if";
        EPpKeyword[EPpKeyword["ifdef"] = 104] = "ifdef";
        EPpKeyword[EPpKeyword["ifndef"] = 105] = "ifndef";
        EPpKeyword[EPpKeyword["else"] = 106] = "else";
        EPpKeyword[EPpKeyword["elif"] = 107] = "elif";
        EPpKeyword[EPpKeyword["endif"] = 108] = "endif";
        EPpKeyword[EPpKeyword["include"] = 109] = "include";
        EPpKeyword[EPpKeyword["defined"] = 110] = "defined";
        return EPpKeyword;
    }({});
    var PpKeyword = new Map([
        [
            "#define",
            101
        ],
        [
            "#undef",
            102
        ],
        [
            "#if",
            103
        ],
        [
            "#ifdef",
            104
        ],
        [
            "#ifndef",
            105
        ],
        [
            "#else",
            106
        ],
        [
            "#elif",
            107
        ],
        [
            "#endif",
            108
        ],
        [
            "#include",
            109
        ],
        [
            "defined",
            110
        ]
    ]);

    var BlockInfo = function BlockInfo(sourceFile, rangeInFile, sourceMap) {
        this.sourceFile = sourceFile != null ? sourceFile : "__main__";
        this.rangeInFile = rangeInFile;
        this.sourceMap = sourceMap;
    };
    var MapRange = /*#__PURE__*/ function() {
        function MapRange(sourceBlock, rangeInBlock, generatedLoc) {
            this.sourceLoc = {
                block: sourceBlock,
                rangeInBlock: rangeInBlock
            };
            this.generatedLoc = generatedLoc;
        }
        var _proto = MapRange.prototype;
        _proto.getSourceIndex = function getSourceIndex(generatedIdx) {
            var _block_rangeInFile;
            var _this_sourceLoc = this.sourceLoc, block = _this_sourceLoc.block, rangeInBlock = _this_sourceLoc.rangeInBlock;
            if (block.sourceMap) {
                if (block.sourceFile !== "__main__") return block.sourceMap.map(generatedIdx - this.generatedLoc.start);
                else if (rangeInBlock) {
                    var _block_rangeInFile1;
                    var _block_rangeInFile_start_index;
                    return {
                        sourceFile: block.sourceFile,
                        index: ((_block_rangeInFile_start_index = (_block_rangeInFile1 = block.rangeInFile) == null ? void 0 : _block_rangeInFile1.start.index) != null ? _block_rangeInFile_start_index : 0) + rangeInBlock.start.index
                    };
                }
            }
            var _block_rangeInFile_start_index1;
            return {
                index: generatedIdx - this.generatedLoc.start + rangeInBlock.start.index + ((_block_rangeInFile_start_index1 = (_block_rangeInFile = block.rangeInFile) == null ? void 0 : _block_rangeInFile.start.index) != null ? _block_rangeInFile_start_index1 : 0),
                sourceFile: this.sourceLoc.block.sourceFile
            };
        };
        return MapRange;
    }();
    var PpSourceMap = /*#__PURE__*/ function() {
        function PpSourceMap() {
            this.mapRanges = [];
        }
        var _proto = PpSourceMap.prototype;
        _proto.addMapRange = function addMapRange(mapRange) {
            this.mapRanges.push(mapRange);
        };
        /**
       * @returns index
       */ _proto.map = function map(index) {
            var curRange;
            for(var _iterator = _create_for_of_iterator_helper_loose(this.mapRanges), _step; !(_step = _iterator()).done;){
                var range = _step.value;
                var generatedLoc = range.generatedLoc;
                if (PpSourceMap.rangeContains(generatedLoc, index)) {
                    return range.getSourceIndex(index);
                } else if (range.generatedLoc.start < index) {
                    curRange = range;
                    continue;
                } else {
                    break;
                }
            }
            if (!curRange) return {
                sourceFile: "__main__",
                index: index
            };
            return {
                index: index - curRange.generatedLoc.end + curRange.sourceLoc.rangeInBlock.end.index,
                sourceFile: curRange.sourceLoc.block.sourceFile
            };
        };
        PpSourceMap.rangeContains = function rangeContains(range, index) {
            return range.start <= index && range.end > index;
        };
        return PpSourceMap;
    }();

    var PpUtils = /*#__PURE__*/ function() {
        function PpUtils() {}
        PpUtils.expand = function expand(segments, source, sourceMap) {
            var ret = [];
            var startIdx = 0;
            var generatedIdx = 0;
            for(var _iterator = _create_for_of_iterator_helper_loose(segments), _step; !(_step = _iterator()).done;){
                var seg = _step.value;
                var originSlice = source.slice(startIdx, seg.rangeInBlock.start.index);
                ret.push(originSlice, seg.replace);
                var generatedIdxEnd = generatedIdx + originSlice.length + seg.replace.length;
                var mapRange = new MapRange(seg.block, seg.rangeInBlock, {
                    start: generatedIdx + originSlice.length,
                    end: generatedIdxEnd
                });
                sourceMap == null ? void 0 : sourceMap.addMapRange(mapRange);
                startIdx = seg.rangeInBlock.end.index;
                generatedIdx = generatedIdxEnd;
            }
            ret.push(source.slice(startIdx));
            return ret.join("");
        };
        PpUtils.assembleSegments = function assembleSegments(segments, source) {
            var ret = [];
            var startIdx = 0;
            for(var _iterator = _create_for_of_iterator_helper_loose(segments), _step; !(_step = _iterator()).done;){
                var seg = _step.value;
                var originSlice = source.slice(startIdx, seg.range.start.index);
                ret.push(originSlice, seg.replace);
                startIdx = seg.range.end.index;
            }
            ret.push(source.slice(startIdx));
            return ret.join("");
        };
        return PpUtils;
    }();

    var PpScanner = /*#__PURE__*/ function(BaseScanner) {
        _inherits(PpScanner, BaseScanner);
        function PpScanner(source, file, blockRange) {
            if (file === void 0) file = "__main__";
            var _this;
            _this = BaseScanner.call(this, source) || this, _this.macroLvl = 0, _this.sourceMap = new PpSourceMap();
            _this.file = file;
            _this.blockRange = blockRange;
            return _this;
        }
        var _proto = PpScanner.prototype;
        /**
       * Advance to directive
       * @param expandOnToken callback on encountering token.
       */ _proto.scanDirective = function scanDirective(expandOnToken) {
            var directive = this._advanceToDirective(expandOnToken);
            if ([
                EPpKeyword.if,
                EPpKeyword.ifdef,
                EPpKeyword.ifndef
            ].includes(directive == null ? void 0 : directive.type)) {
                this.macroLvl += 1;
            } else if ((directive == null ? void 0 : directive.type) === EPpKeyword.endif) {
                this.macroLvl -= 1;
            }
            return directive;
        };
        /**
       * @param nonLetterChar should not be space
       */ _proto.scanWordsUntilChar = function scanWordsUntilChar(nonLetterChar) {
            var ret = [];
            while(true){
                this.skipSpace(true);
                if (LexerUtils.isLetter(this.getCurChar())) {
                    ret.push(this.scanWord());
                } else if (this.getCurChar() === nonLetterChar) {
                    this.advance();
                    return ret;
                } else {
                    this.advance();
                }
            }
        };
        _proto.scanWord = function scanWord(skipNonLetter) {
            if (skipNonLetter === void 0) skipNonLetter = false;
            if (skipNonLetter) {
                while(!LexerUtils.isLetter(this.getCurChar()) && !this.isEnd()){
                    this.advance();
                }
            } else {
                this.skipSpace(true);
            }
            if (this.isEnd()) return EOF;
            var start = this._currentIndex;
            while(LexerUtils.isLetter(this.getCurChar()) && !this.isEnd()){
                this.advance();
            }
            var end = this._currentIndex;
            var word = this._source.slice(start, end);
            if (end === start) {
                this.throwError(this.getShaderPosition(), "no word found.");
            }
            var kw = PpKeyword.get(word);
            if (kw) {
                var token = BaseToken.pool.get();
                token.set(kw, word, this.getShaderPosition());
                return token;
            }
            var token1 = BaseToken.pool.get();
            token1.set(EPpToken.id, word, this.getShaderPosition(word.length));
            return token1;
        };
        _proto.getShaderPosition = function getShaderPosition(offset /** offset from starting point */ ) {
            if (offset === void 0) offset = 0;
            return ShaderLab.createPosition(this._currentIndex - offset, this.line, this.column - offset);
        };
        /**
       * @param onToken callback when encounter a token
       * @returns token split by space
       */ _proto.scanToken = function scanToken(onToken) {
            this.skipSpace(true);
            this._skipComments();
            if (this.isEnd()) {
                return;
            }
            var start = this._currentIndex;
            while(PpScanner._splitCharacters.test(this.getCurChar()) && !this.isEnd()){
                this._advance();
            }
            // Not advance
            if (start === this._currentIndex) {
                this._advance();
                return this.scanToken(onToken);
            }
            var lexeme = this._source.slice(start, this._currentIndex);
            var ret = BaseToken.pool.get();
            ret.set(PpKeyword.has(lexeme) ? PpKeyword.get(lexeme) : EPpToken.id, lexeme, this.getShaderPosition(this._currentIndex - start));
            onToken == null ? void 0 : onToken(ret, this);
            return ret;
        };
        _proto.scanQuotedString = function scanQuotedString() {
            this.skipSpace(true);
            if (this.getCurChar() !== '"') {
                this.throwError(this.getShaderPosition(), "unexpected char, expected '\"'");
            }
            var ShaderPosition = this.getShaderPosition();
            this._advance();
            var start = this._currentIndex;
            while(this.getCurChar() !== '"' && !this.isEnd())this._advance();
            if (this.isEnd()) {
                this.throwError(this.getShaderPosition(), "unexpected char, expected '\"'");
            }
            var word = this._source.slice(start, this._currentIndex);
            var token = BaseToken.pool.get();
            token.set(EPpToken.string_const, word, ShaderPosition);
            return token;
        };
        _proto.scanToChar = function scanToChar(char) {
            var source = this._source;
            while(source[this._currentIndex] !== char && !this.isEnd()){
                this.advance();
            }
        };
        _proto.scanMacroBranchChunk = function scanMacroBranchChunk() {
            var start = this._currentIndex;
            var ShaderPosition = this.getShaderPosition();
            var startLvl = this.macroLvl;
            var directive = this.scanDirective();
            while(true){
                if (directive.type === EPpKeyword.endif && startLvl - 1 === this.macroLvl) break;
                else if ([
                    EPpKeyword.elif,
                    EPpKeyword.else
                ].includes(directive.type) && startLvl === this.macroLvl) break;
                directive = this.scanDirective();
            }
            var chunk = this._source.slice(start, this._currentIndex - directive.lexeme.length - 1);
            var token = BaseToken.pool.get();
            token.set(EPpToken.chunk, chunk, ShaderPosition);
            return {
                token: token,
                nextDirective: directive
            };
        };
        _proto.scanPairedBlock = function scanPairedBlock(lc, rc) {
            this.scanToChar(lc);
            var level = 0;
            var source = this._source;
            do {
                var curChar = source[this._currentIndex];
                if (curChar === lc) {
                    level++;
                } else if (curChar === rc) {
                    level--;
                }
                this._advance();
            }while (level > 0);
        };
        /**
       * @returns end ShaderPosition
       */ _proto.scanRemainMacro = function scanRemainMacro() {
            var startLvl = this.macroLvl;
            var directive = this.scanDirective();
            while(!this.isEnd() && (directive.type !== EPpKeyword.endif || startLvl - 1 !== this.macroLvl)){
                directive = this.scanDirective();
            }
            return this.getShaderPosition();
        };
        _proto.peekNonSpace = function peekNonSpace() {
            var current = this._currentIndex;
            while(/\s/.test(this._source[current])){
                current += 1;
            }
            return this._source[current];
        };
        _proto.scanInteger = function scanInteger() {
            var start = this._currentIndex;
            while(LexerUtils.isNum(this.getCurChar())){
                this.advance();
            }
            if (this._currentIndex === start) {
                this.throwError(this.getShaderPosition(), "no integer found");
            }
            var integer = this._source.slice(start, this._currentIndex);
            var token = BaseToken.pool.get();
            token.set(EPpToken.int_constant, integer, this.getShaderPosition());
            return token;
        };
        /**
       * Skip comments
       */ _proto.scanLineRemain = function scanLineRemain() {
            this.skipSpace(false);
            var start = this._currentIndex;
            var comments = [];
            while(this.getCurChar() !== "\n"){
                if (this.isEnd()) {
                    var line = this._source.slice(start, this._currentIndex);
                    var token = BaseToken.pool.get();
                    token.set(EPpToken.line_remain, line, this.getShaderPosition(line.length));
                    return token;
                }
                this.advance();
                var commentRange = this._skipComments();
                if (commentRange) {
                    commentRange.start.index -= start;
                    commentRange.end.index -= start;
                    comments.push(commentRange);
                }
            }
            var line1 = this._source.slice(start, this._currentIndex);
            if (comments.length) {
                // filter comments
                line1 = PpUtils.assembleSegments(comments.map(function(item) {
                    return {
                        range: item,
                        replace: ""
                    };
                }), line1);
            }
            var token1 = BaseToken.pool.get();
            token1.set(EPpToken.line_remain, line1, this.getShaderPosition(line1.length));
            return token1;
        };
        _proto._advanceToDirective = function _advanceToDirective(onToken) {
            while(true){
                var token = this.scanToken(onToken);
                if (token == null ? void 0 : token.lexeme.startsWith("#")) return token;
                if (this.isEnd()) return;
            }
        };
        _proto._skipComments = function _skipComments() {
            if (this.peek(2) === "//") {
                var start = this.getShaderPosition();
                // single line comments
                while(this.getCurChar() !== "\n" && !this.isEnd()){
                    this._advance();
                }
                return ShaderLab.createRange(start, this.getCurPosition());
            } else if (this.peek(2) === "/*") {
                var start1 = this.getShaderPosition();
                //  multi-line comments
                this.advance(2);
                while(this.peek(2) !== "*/" && !this.isEnd()){
                    this._advance();
                }
                this.advance(2);
                return ShaderLab.createRange(start1, this.getShaderPosition());
            }
        };
        return PpScanner;
    }(BaseScanner);
    PpScanner._splitCharacters = /[\w#.]/;

    /** @internal */ var PpParser = /*#__PURE__*/ function() {
        function PpParser() {}
        PpParser.reset = function reset(includeMap, basePathForIncludeKey) {
            this._definedMacros.clear();
            this._expandSegmentsStack.length = 0;
            this._expandSegmentsStack.push([]);
            this._branchMacros.clear();
            this.addPredefinedMacro("GL_ES");
            this._includeMap = includeMap;
            this._basePathForIncludeKey = basePathForIncludeKey;
            this._errors.length = 0;
        };
        PpParser.addPredefinedMacro = function addPredefinedMacro(macro, value) {
            var tk = BaseToken.pool.get();
            tk.set(EPpToken.id, macro);
            var macroBody;
            if (value) {
                macroBody = BaseToken.pool.get();
                macroBody.set(EPpToken.id, value);
            }
            this._definedMacros.set(macro, new MacroDefine(tk, macroBody));
        };
        PpParser.parse = function parse(scanner) {
            while(!scanner.isEnd()){
                var directive = scanner.scanDirective(this._onToken.bind(this));
                if (scanner.isEnd()) break;
                switch(directive.type){
                    case EPpKeyword.define:
                        this._parseDefine(scanner);
                        break;
                    case EPpKeyword.undef:
                        this._parseUndef(scanner);
                        break;
                    case EPpKeyword.if:
                        this._parseIf(scanner);
                        break;
                    case EPpKeyword.ifndef:
                        this._parseIfNdef(scanner);
                        break;
                    case EPpKeyword.ifdef:
                        this._parseIfDef(scanner);
                        break;
                    case EPpKeyword.include:
                        this._parseInclude(scanner);
                        break;
                }
            }
            if (this._errors.length > 0) return null;
            return PpUtils.expand(this.expandSegments, scanner.source, scanner.sourceMap);
        };
        PpParser.reportError = function reportError(loc, message, source, file) {
            var error = ShaderLabUtils.createGSError(message, GSErrorName.PreprocessorError, source, loc, file);
            this._errors.push(error);
        };
        PpParser._parseInclude = function _parseInclude(scanner) {
            var start = scanner.getShaderPosition(8);
            scanner.skipSpace(true);
            var id = scanner.scanQuotedString();
            var includedPath;
            // builtin path
            if (id.lexeme[0] !== ".") {
                includedPath = id.lexeme;
            } else {
                // relative path
                // @ts-ignore
                includedPath = new URL(id.lexeme, this._basePathForIncludeKey).href.substring(engine.ShaderPass._shaderRootPath.length);
            }
            scanner.scanToChar("\n");
            var end = scanner.getShaderPosition();
            var chunk = this._includeMap[includedPath];
            if (!chunk) {
                this.reportError(id.location, 'Shader slice "' + includedPath + '" not founded.', scanner.source, scanner.file);
                return;
            }
            var range = ShaderLab.createRange(start, end);
            var expanded = this._expandMacroChunk(chunk, range, id.lexeme);
            var block = new BlockInfo(id.lexeme, undefined, expanded.sourceMap);
            this.expandSegments.push({
                block: block,
                rangeInBlock: range,
                replace: expanded.content
            });
        };
        PpParser._parseIfDef = function _parseIfDef(scanner) {
            var start = scanner.current - 6;
            var id = scanner.scanWord();
            this._addEmptyReplace(scanner, start);
            this._branchMacros.add(id.lexeme);
            var macro = this._definedMacros.get(id.lexeme);
            scanner.skipSpace(true);
            var _scanner_scanMacroBranchChunk = scanner.scanMacroBranchChunk(), bodyChunk = _scanner_scanMacroBranchChunk.token, nextDirective = _scanner_scanMacroBranchChunk.nextDirective;
            if (!!macro) {
                var end = nextDirective.type === EPpKeyword.endif ? scanner.getShaderPosition() : scanner.scanRemainMacro();
                var expanded = this._expandMacroChunk(bodyChunk.lexeme, bodyChunk.location, scanner);
                var block = new BlockInfo(scanner.file, scanner.blockRange, expanded.sourceMap);
                var range = ShaderLab.createRange(bodyChunk.location.start, end);
                this.expandSegments.push({
                    block: block,
                    rangeInBlock: range,
                    replace: expanded.content
                });
                return;
            }
            this.expandSegments.pop();
            this._addEmptyReplace(scanner, start);
            this._parseMacroBranch(nextDirective.type, scanner);
        };
        PpParser._parseMacroBranch = function _parseMacroBranch(directive, scanner) {
            if (directive === EPpKeyword.endif) {
                return;
            }
            var start = scanner.current;
            if (directive === EPpKeyword.else) {
                var _scanner_scanMacroBranchChunk = scanner.scanMacroBranchChunk(), elseChunk = _scanner_scanMacroBranchChunk.token;
                var expanded = this._expandMacroChunk(elseChunk.lexeme, elseChunk.location, scanner);
                var block = new BlockInfo(scanner.file, scanner.blockRange, expanded.sourceMap);
                var startPosition = ShaderLab.createPosition(start);
                var range = ShaderLab.createRange(startPosition, scanner.getShaderPosition());
                this.expandSegments.push({
                    block: block,
                    rangeInBlock: range,
                    replace: expanded.content
                });
            } else if (directive === EPpKeyword.elif) {
                var constantExpr = this._parseConstantExpression(scanner);
                var _scanner_scanMacroBranchChunk1 = scanner.scanMacroBranchChunk(), bodyChunk = _scanner_scanMacroBranchChunk1.token, nextDirective = _scanner_scanMacroBranchChunk1.nextDirective;
                if (!!constantExpr) {
                    var end = nextDirective.type === EPpKeyword.endif ? scanner.current : scanner.scanRemainMacro().index;
                    var expanded1 = this._expandMacroChunk(bodyChunk.lexeme, bodyChunk.location, scanner);
                    var block1 = new BlockInfo(scanner.file, scanner.blockRange, expanded1.sourceMap);
                    var startPosition1 = ShaderLab.createPosition(start);
                    var endPosition = ShaderLab.createPosition(end);
                    var range1 = ShaderLab.createRange(startPosition1, endPosition);
                    this.expandSegments.push({
                        block: block1,
                        rangeInBlock: range1,
                        replace: expanded1.content
                    });
                } else {
                    var block2 = new BlockInfo(scanner.file, scanner.blockRange);
                    var startPosition2 = ShaderLab.createPosition(start);
                    var endPosition1 = ShaderLab.createPosition(scanner.current);
                    var range2 = ShaderLab.createRange(startPosition2, endPosition1);
                    this.expandSegments.push({
                        block: block2,
                        rangeInBlock: range2,
                        replace: ""
                    });
                    this._parseMacroBranch(nextDirective.type, scanner);
                }
            }
        };
        PpParser._parseConstantExpression = function _parseConstantExpression(scanner) {
            scanner.skipSpace(true);
            return this._parseLogicalOrExpression(scanner);
        };
        PpParser._parseLogicalOrExpression = function _parseLogicalOrExpression(scanner) {
            var operand1 = this._parseLogicalAndExpression(scanner);
            var operator = scanner.peek(2);
            if (operator && operator === "||") {
                scanner.advance(2);
                scanner.skipSpace(false);
                var operand2 = this._parseLogicalOrExpression(scanner);
                return operand1 || operand2;
            }
            return operand1;
        };
        PpParser._parseLogicalAndExpression = function _parseLogicalAndExpression(scanner) {
            var operand1 = this._parseEqualityExpression(scanner);
            var operator = scanner.peek(2);
            if (operator && operator === "&&") {
                scanner.advance(2);
                scanner.skipSpace(false);
                var operand2 = this._parseLogicalAndExpression(scanner);
                return operand1 && operand2;
            }
            return operand1;
        };
        PpParser._parseEqualityExpression = function _parseEqualityExpression(scanner) {
            var operand1 = this._parseRelationalExpression(scanner);
            var operator = scanner.peek(2);
            if (operator && [
                "==",
                "!="
            ].includes(operator)) {
                scanner.advance(2);
                scanner.skipSpace(false);
                var operand2 = this._parseEqualityExpression(scanner);
                switch(operator){
                    case "==":
                        return operand1 === operand2;
                    case "!=":
                        return operand1 !== operand2;
                }
            }
            return operand1;
        };
        PpParser._parseRelationalExpression = function _parseRelationalExpression(scanner) {
            var operand1 = this._parseShiftExpression(scanner);
            var operator = scanner.peek(2);
            if (operator[1] !== "=") operator = operator[0];
            if (operator && [
                ">",
                "<",
                ">=",
                "<="
            ].includes(operator)) {
                var opPos = scanner.getShaderPosition();
                scanner.advance(operator.length);
                scanner.skipSpace(false);
                var operand2 = this._parseRelationalExpression(scanner);
                if ((typeof operand1 === "undefined" ? "undefined" : _type_of(operand1)) !== (typeof operand2 === "undefined" ? "undefined" : _type_of(operand2)) && typeof operand1 !== "number") {
                    this.reportError(opPos, "invalid operator in relation expression.", scanner.source, scanner.file);
                    return;
                }
                switch(operator){
                    case ">":
                        return operand1 > operand2;
                    case "<":
                        return operand1 < operand2;
                    case ">=":
                        return operand1 >= operand2;
                    case "<=":
                        return operand1 <= operand2;
                }
            }
            return operand1;
        };
        PpParser._parseShiftExpression = function _parseShiftExpression(scanner) {
            var operand1 = this._parseAdditiveExpression(scanner);
            var operator = scanner.peek(2);
            if (operator && [
                ">>",
                "<<"
            ].includes(operator)) {
                var opPos = scanner.getShaderPosition();
                scanner.advance(2);
                scanner.skipSpace(false);
                var operand2 = this._parseShiftExpression(scanner);
                if ((typeof operand1 === "undefined" ? "undefined" : _type_of(operand1)) !== (typeof operand2 === "undefined" ? "undefined" : _type_of(operand2)) && typeof operand1 !== "number") {
                    this.reportError(opPos, "invalid operator in shift expression.", scanner.source, scanner.file);
                    return;
                }
                switch(operator){
                    case ">>":
                        return operand1 >> operand2;
                    case "<<":
                        return operand1 << operand2;
                }
            }
            return operand1;
        };
        PpParser._parseAdditiveExpression = function _parseAdditiveExpression(scanner) {
            var operand1 = this._parseMulticativeExpression(scanner);
            if ([
                ">",
                "<"
            ].includes(scanner.getCurChar())) {
                var opPos = scanner.getShaderPosition();
                scanner.advance();
                var operator = scanner.getCurChar();
                scanner.skipSpace(false);
                var operand2 = this._parseAdditiveExpression(scanner);
                if ((typeof operand1 === "undefined" ? "undefined" : _type_of(operand1)) !== (typeof operand2 === "undefined" ? "undefined" : _type_of(operand2)) && typeof operand1 !== "number") {
                    this.reportError(opPos, "invalid operator.", scanner.source, scanner.file);
                    return false;
                }
                switch(operator){
                    case "+":
                        return operand1 + operand2;
                    case "-":
                        return operand1 - operand2;
                }
            }
            return operand1;
        };
        PpParser._parseMulticativeExpression = function _parseMulticativeExpression(scanner) {
            var operand1 = this._parseUnaryExpression(scanner);
            scanner.skipSpace(false);
            if ([
                "*",
                "/",
                "%"
            ].includes(scanner.getCurChar())) {
                var opPos = scanner.getShaderPosition();
                var operator = scanner.getCurChar();
                scanner.skipSpace(false);
                var operand2 = this._parseMulticativeExpression(scanner);
                if ((typeof operand1 === "undefined" ? "undefined" : _type_of(operand1)) !== (typeof operand2 === "undefined" ? "undefined" : _type_of(operand2)) && typeof operand1 !== "number") {
                    this.reportError(opPos, "invalid operator.", scanner.source, scanner.file);
                    return;
                }
                switch(operator){
                    case "*":
                        return operand1 * operand2;
                    case "/":
                        return operand1 / operand2;
                    case "%":
                        return operand1 % operand2;
                }
            }
            return operand1;
        };
        PpParser._parseUnaryExpression = function _parseUnaryExpression(scanner) {
            var operator = scanner.getCurChar();
            if ([
                "+",
                "-",
                "!"
            ].includes(operator)) {
                scanner.advance();
                var opPos = scanner.getShaderPosition();
                var parenExpr = this._parseParenthesisExpression(scanner);
                if (operator === "!" && typeof parenExpr !== "boolean" || operator !== "!" && typeof parenExpr !== "number") {
                    this.reportError(opPos, "invalid operator.", scanner.source, scanner.file);
                }
                switch(operator){
                    case "+":
                        return parenExpr;
                    case "-":
                        return -parenExpr;
                    case "!":
                        return !parenExpr;
                }
            }
            return this._parseParenthesisExpression(scanner);
        };
        PpParser._parseParenthesisExpression = function _parseParenthesisExpression(scanner) {
            if (scanner.getCurChar() === "(") {
                scanner.advance();
                scanner.skipSpace(false);
                var ret = this._parseConstantExpression(scanner);
                scanner.scanToChar(")");
                scanner.advance();
                return ret;
            }
            return this._parseConstant(scanner);
        };
        PpParser._parseConstant = function _parseConstant(scanner) {
            if (LexerUtils.isAlpha(scanner.getCurChar())) {
                var id = scanner.scanWord();
                if (id.type === EPpKeyword.defined) {
                    var withParen = scanner.peekNonSpace() === "(";
                    var macro = scanner.scanWord(true);
                    if (withParen) {
                        scanner.scanToChar(")");
                        scanner.advance();
                    }
                    this._branchMacros.add(macro.lexeme);
                    return !!this._definedMacros.get(macro.lexeme);
                } else {
                    var macro1 = this._definedMacros.get(id.lexeme);
                    if (!macro1) {
                        return false;
                    }
                    if (macro1.isFunction) {
                        this.reportError(id.location, "invalid function macro usage", scanner.source, scanner.file);
                    }
                    var value = Number(macro1.body.lexeme);
                    if (!Number.isInteger(value)) {
                        this.reportError(id.location, "invalid const macro: " + id.lexeme, scanner.source, scanner.file);
                    }
                    this._branchMacros.add(id.lexeme);
                    return value;
                }
            } else if (LexerUtils.isNum(scanner.getCurChar())) {
                var integer = scanner.scanInteger();
                return Number(integer.lexeme);
            } else {
                this.reportError(scanner.getShaderPosition(), "invalid token: " + scanner.getCurChar(), scanner.source, scanner.file);
            }
        };
        PpParser._expandMacroChunk = function _expandMacroChunk(chunk, loc, scannerOrFile) {
            this._expandSegmentsStack.push([]);
            var scanner;
            if (typeof scannerOrFile === "string") {
                scanner = new PpScanner(chunk, scannerOrFile);
            } else {
                scanner = new PpScanner(chunk, scannerOrFile.file, loc);
            }
            var ret = this.parse(scanner);
            this._expandSegmentsStack.pop();
            return {
                content: ret,
                sourceMap: scanner.sourceMap
            };
        };
        PpParser._parseIfNdef = function _parseIfNdef(scanner) {
            var start = scanner.current - 7;
            var id = scanner.scanWord();
            this._addEmptyReplace(scanner, start);
            this._branchMacros.add(id.lexeme);
            var macro = this._definedMacros.get(id.lexeme);
            var _scanner_scanMacroBranchChunk = scanner.scanMacroBranchChunk(), bodyChunk = _scanner_scanMacroBranchChunk.token, nextDirective = _scanner_scanMacroBranchChunk.nextDirective;
            if (!macro) {
                var end = nextDirective.type === EPpKeyword.endif ? scanner.getShaderPosition() : scanner.scanRemainMacro();
                var expanded = this._expandMacroChunk(bodyChunk.lexeme, bodyChunk.location, scanner);
                var blockInfo = new BlockInfo(scanner.file, scanner.blockRange, expanded.sourceMap);
                var range = ShaderLab.createRange(bodyChunk.location.start, end);
                this.expandSegments.push({
                    block: blockInfo,
                    rangeInBlock: range,
                    replace: expanded.content
                });
                return;
            }
            this.expandSegments.pop();
            this._addEmptyReplace(scanner, start);
            this._parseMacroBranch(nextDirective.type, scanner);
        };
        PpParser._addEmptyReplace = function _addEmptyReplace(scanner, start) {
            var block = new BlockInfo(scanner.file, scanner.blockRange);
            var startPosition = ShaderLab.createPosition(start);
            var endPosition = scanner.getCurPosition();
            var range = ShaderLab.createRange(startPosition, endPosition);
            this.expandSegments.push({
                block: block,
                rangeInBlock: range,
                replace: ""
            });
        };
        PpParser._parseIf = function _parseIf(scanner) {
            var start = scanner.current - 3;
            var constantExpr = this._parseConstantExpression(scanner);
            this._addEmptyReplace(scanner, start);
            var _scanner_scanMacroBranchChunk = scanner.scanMacroBranchChunk(), bodyChunk = _scanner_scanMacroBranchChunk.token, nextDirective = _scanner_scanMacroBranchChunk.nextDirective;
            if (!!constantExpr) {
                var end = nextDirective.type === EPpKeyword.endif ? scanner.getShaderPosition() : scanner.scanRemainMacro();
                var expanded = this._expandMacroChunk(bodyChunk.lexeme, bodyChunk.location, scanner);
                var block = new BlockInfo(scanner.file, scanner.blockRange, expanded.sourceMap);
                var range = ShaderLab.createRange(bodyChunk.location.start, end);
                this.expandSegments.push({
                    block: block,
                    rangeInBlock: range,
                    replace: expanded.content
                });
                return;
            }
            this.expandSegments.pop();
            this._addEmptyReplace(scanner, start);
            this._parseMacroBranch(nextDirective.type, scanner);
        };
        PpParser._parseDefine = function _parseDefine(scanner) {
            var start = scanner.getShaderPosition(7);
            var macro = scanner.scanWord();
            var end = macro.location.end;
            if (this._definedMacros.get(macro.lexeme) && macro.lexeme.startsWith("GL_")) {
                this.reportError(macro.location, "redefined macro: " + macro.lexeme, scanner.source, scanner.file);
            }
            var macroArgs;
            if (scanner.getCurChar() === "(") {
                macroArgs = scanner.scanWordsUntilChar(")");
                end = scanner.getShaderPosition();
            }
            var macroBody = scanner.scanLineRemain();
            var range = ShaderLab.createRange(start, end);
            var macroDefine = new MacroDefine(macro, macroBody, range, macroArgs);
            this._definedMacros.set(macro.lexeme, macroDefine);
            var block = new BlockInfo(scanner.file, scanner.blockRange);
            this.expandSegments.push({
                block: block,
                rangeInBlock: ShaderLab.createRange(start, scanner.getCurPosition()),
                replace: ""
            });
        };
        PpParser._parseUndef = function _parseUndef(scanner) {
            var start = scanner.current - 6;
            var macro = scanner.scanWord();
            var block = new BlockInfo(scanner.file, scanner.blockRange);
            var startPosition = ShaderLab.createPosition(start);
            var range = ShaderLab.createRange(startPosition, scanner.getCurPosition());
            this.expandSegments.push({
                block: block,
                rangeInBlock: range,
                replace: ""
            });
            this._definedMacros.delete(macro.lexeme);
        };
        PpParser._onToken = function _onToken(token, scanner) {
            var macro = this._definedMacros.get(token.lexeme);
            if (macro) {
                var replace = macro.body.lexeme;
                if (macro.isFunction) {
                    scanner.scanToChar("(");
                    scanner.advance();
                    // extract parameters
                    var args = [];
                    var curLvl = 1;
                    var curIdx = scanner.current;
                    while(true){
                        if (scanner.getCurChar() === "(") curLvl += 1;
                        else if (scanner.getCurChar() === ")") {
                            curLvl -= 1;
                            if (curLvl === 0) break;
                        } else if (scanner.getCurChar() === "," && curLvl === 1) {
                            args.push(scanner.source.slice(curIdx, scanner.current));
                            curIdx = scanner.current + 1;
                        }
                        scanner.advance();
                    }
                    args.push(scanner.source.slice(curIdx, scanner.current));
                    scanner.advance();
                    var range = ShaderLab.createRange(token.location.start, scanner.getCurPosition());
                    replace = macro.expandFunctionBody(args);
                    var expanded = this._expandMacroChunk(replace, range, scanner);
                    var block = new BlockInfo(scanner.file, scanner.blockRange, expanded.sourceMap);
                    var blockRange = ShaderLab.createRange(token.location.start, scanner.getCurPosition());
                    this.expandSegments.push({
                        block: block,
                        rangeInBlock: blockRange,
                        replace: expanded.content
                    });
                } else {
                    var expanded1 = this._expandMacroChunk(replace, token.location, scanner);
                    var block1 = new BlockInfo(scanner.file, scanner.blockRange, expanded1.sourceMap);
                    var range1 = ShaderLab.createRange(token.location.start, token.location.end);
                    this.expandSegments.push({
                        block: block1,
                        rangeInBlock: range1,
                        replace: expanded1.content
                    });
                }
            }
        };
        _create_class(PpParser, null, [
            {
                key: "expandSegments",
                get: function get() {
                    return this._expandSegmentsStack[this._expandSegmentsStack.length - 1];
                }
            }
        ]);
        return PpParser;
    }();
    PpParser._definedMacros = new Map();
    PpParser._expandSegmentsStack = [
        []
    ];
    /** Referenced by branch macro or defined operator */ PpParser._branchMacros = new Set();
    PpParser._errors = [];

    /** @internal */ var Preprocessor = /*#__PURE__*/ function() {
        function Preprocessor() {}
        /**
       * Reset the parser of `Preprocessor`
       * @param basePathForIncludeKey - the base path to resolve the relative path of `#include` directive
       */ Preprocessor.reset = function reset(includeMap, basePathForIncludeKey) {
            PpParser.reset(includeMap, basePathForIncludeKey);
        };
        /**
       * Should call it after reset.
       */ Preprocessor.process = function process(source) {
            this.baseScanner = new PpScanner(source);
            return PpParser.parse(this.baseScanner);
        };
        Preprocessor.addPredefinedMacro = function addPredefinedMacro(macro, value) {
            PpParser.addPredefinedMacro(macro, value);
        };
        Preprocessor.convertSourceIndex = function convertSourceIndex(index) {
            return this.baseScanner.sourceMap.map(index);
        };
        return Preprocessor;
    }();

    /** @internal */ var VisitorContext = /*#__PURE__*/ function() {
        function VisitorContext() {
            this.attributeList = [];
            this.attributeStructs = [];
            this._referencedAttributeList = Object.create(null);
            this._referencedGlobals = Object.create(null);
            this._referencedVaryingList = Object.create(null);
        }
        var _proto = VisitorContext.prototype;
        _proto.reset = function reset() {
            this.attributeList.length = 0;
            this.attributeStructs.length = 0;
            this._referencedAttributeList = Object.create(null);
            this._referencedGlobals = Object.create(null);
            this._referencedVaryingList = Object.create(null);
        };
        _proto.isAttributeStruct = function isAttributeStruct(type) {
            return this.attributeStructs.findIndex(function(item) {
                return item.ident.lexeme === type;
            }) !== -1;
        };
        _proto.isVaryingStruct = function isVaryingStruct(type) {
            var _this_varyingStruct_ident, _this_varyingStruct;
            return ((_this_varyingStruct = this.varyingStruct) == null ? void 0 : (_this_varyingStruct_ident = _this_varyingStruct.ident) == null ? void 0 : _this_varyingStruct_ident.lexeme) === type;
        };
        _proto.referenceAttribute = function referenceAttribute(ident) {
            if (this._referencedAttributeList[ident.lexeme]) return;
            var prop = this.attributeList.find(function(item) {
                return item.ident.lexeme === ident.lexeme;
            });
            if (!prop) {
                return ShaderLabUtils.createGSError("referenced attribute not found: " + ident.lexeme, GSErrorName.CompilationError, ShaderLab._processingPassText, ident.location);
            }
            this._referencedAttributeList[ident.lexeme] = prop;
        };
        _proto.referenceVarying = function referenceVarying(ident) {
            var _this_varyingStruct;
            if (this._referencedVaryingList[ident.lexeme]) return;
            var prop = (_this_varyingStruct = this.varyingStruct) == null ? void 0 : _this_varyingStruct.propList.find(function(item) {
                return item.ident.lexeme === ident.lexeme;
            });
            if (!prop) {
                return ShaderLabUtils.createGSError("referenced varying not found: " + ident.lexeme, GSErrorName.CompilationError, ShaderLab._processingPassText, ident.location);
            }
            this._referencedVaryingList[ident.lexeme] = prop;
        };
        _proto.referenceGlobal = function referenceGlobal(ident, type) {
            if (this._referencedGlobals[ident]) return;
            if (type === ESymbolType.FN) {
                var fnEntries = this._passSymbolTable.getAllFnSymbols(ident);
                for(var i = 0; i < fnEntries.length; i++){
                    var key = i === 0 ? ident : ident + i;
                    this._referencedGlobals[key] = fnEntries[i];
                }
                return;
            }
            var sm = this.passSymbolTable.lookup({
                ident: ident,
                symbolType: type
            });
            if (sm) {
                this._referencedGlobals[ident] = sm;
            }
        };
        VisitorContext.reset = function reset() {
            if (!this._singleton) {
                this._singleton = new VisitorContext();
            }
            this._singleton.reset();
        };
        _create_class(VisitorContext, [
            {
                key: "passSymbolTable",
                get: function get() {
                    return this._passSymbolTable;
                }
            }
        ], [
            {
                key: "context",
                get: function get() {
                    return this._singleton;
                }
            }
        ]);
        return VisitorContext;
    }();

    /**
     * @internal
     * The code generator
     */ var CodeGenVisitor = /*#__PURE__*/ function() {
        function CodeGenVisitor() {
            this.errors = [];
        }
        var _proto = CodeGenVisitor.prototype;
        _proto.defaultCodeGen = function defaultCodeGen(children) {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){
                var child = _step.value;
                if (_instanceof(child, BaseToken)) {
                    ret.push(child.lexeme);
                } else {
                    ret.push(child.codeGen(this));
                }
            }
            return ret.join(" ");
        };
        _proto.visitPostfixExpression = function visitPostfixExpression(node) {
            if (node.children.length === 3) {
                var context = VisitorContext.context;
                var postExpr = node.children[0];
                var prop = node.children[2];
                if (_instanceof(prop, BaseToken)) {
                    if (context.isAttributeStruct(postExpr.type)) {
                        var error = context.referenceAttribute(prop);
                        if (error) {
                            this.errors.push(error);
                        }
                        return prop.lexeme;
                    } else if (context.isVaryingStruct(postExpr.type)) {
                        var error1 = context.referenceVarying(prop);
                        if (error1) {
                            this.errors.push(error1);
                        }
                        return prop.lexeme;
                    }
                    return postExpr.codeGen(this) + "." + prop.lexeme;
                } else {
                    return postExpr.codeGen(this) + "." + prop.codeGen(this);
                }
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitVariableIdentifier = function visitVariableIdentifier(node) {
            if (_instanceof(node.symbolInfo, VarSymbol) && node.symbolInfo.isGlobalVariable) {
                VisitorContext.context.referenceGlobal(node.lexeme, ESymbolType.VAR);
            }
            return node.lexeme;
        };
        _proto.visitFunctionCall = function visitFunctionCall(node) {
            var call = node.children[0];
            if (_instanceof(call.fnSymbol, FnSymbol)) {
                VisitorContext.context.referenceGlobal(call.fnSymbol.ident, ESymbolType.FN);
                var paramList = call.children[2];
                var paramInfoList = call.fnSymbol.astNode.protoType.parameterList;
                if (_instanceof(paramList, ASTNode.FunctionCallParameterList)) {
                    var plainParams = [];
                    var params = paramList.paramNodes;
                    for(var i = 0; i < params.length; i++){
                        if (!VisitorContext.context.isAttributeStruct(paramInfoList[i].typeInfo.typeLexeme) && !VisitorContext.context.isVaryingStruct(paramInfoList[i].typeInfo.typeLexeme)) {
                            plainParams.push(params[i].codeGen(this));
                        }
                    }
                    return call.fnSymbol.ident + "(" + plainParams.join(", ") + ")";
                }
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitStatementList = function visitStatementList(node) {
            var children = node.children;
            if (node.children.length === 1) {
                return children[0].codeGen(this);
            } else {
                return children[0].codeGen(this) + "\n" + children[1].codeGen(this);
            }
        };
        _proto.visitSingleDeclaration = function visitSingleDeclaration(node) {
            var type = node.typeSpecifier.type;
            if (typeof type === "string") {
                VisitorContext.context.referenceGlobal(type, ESymbolType.STRUCT);
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitGlobalVariableDeclaration = function visitGlobalVariableDeclaration(node) {
            var fullType = node.children[0];
            if (_instanceof(fullType, ASTNode.FullySpecifiedType) && fullType.typeSpecifier.isCustom) {
                VisitorContext.context.referenceGlobal(fullType.type, ESymbolType.STRUCT);
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitDeclaration = function visitDeclaration(node) {
            var _VisitorContext_context_varyingStruct_ident, _VisitorContext_context_varyingStruct;
            var child = node.children[0];
            if (_instanceof(child, ASTNode.InitDeclaratorList) && child.typeInfo.typeLexeme === ((_VisitorContext_context_varyingStruct = VisitorContext.context.varyingStruct) == null ? void 0 : (_VisitorContext_context_varyingStruct_ident = _VisitorContext_context_varyingStruct.ident) == null ? void 0 : _VisitorContext_context_varyingStruct_ident.lexeme)) {
                return "";
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitFunctionProtoType = function visitFunctionProtoType(node) {
            VisitorContext.context._curFn = node;
            return this.defaultCodeGen(node.children);
        };
        _proto.visitFunctionDefinition = function visitFunctionDefinition(node) {
            VisitorContext.context._curFn = undefined;
            return this.defaultCodeGen(node.children);
        };
        _proto.visitFunctionParameterList = function visitFunctionParameterList(node) {
            var _this = this;
            var params = node.parameterInfoList;
            return params.filter(function(item) {
                return !VisitorContext.context.isAttributeStruct(item.typeInfo.typeLexeme) && !VisitorContext.context.isVaryingStruct(item.typeInfo.typeLexeme);
            }).map(function(item) {
                return item.astNode.codeGen(_this);
            }).join(", ");
        };
        _proto.visitFunctionHeader = function visitFunctionHeader(node) {
            var returnType = node.returnType.typeSpecifier.lexeme;
            if (VisitorContext.context.isAttributeStruct(returnType) || VisitorContext.context.isVaryingStruct(returnType)) return "void " + node.ident.lexeme + "(";
            return this.defaultCodeGen(node.children);
        };
        _proto.visitJumpStatement = function visitJumpStatement(node) {
            var cmd = node.children[0];
            if (cmd.type === EKeyword.RETURN) {
                var expr = node.children[1];
                if (_instanceof(expr, ASTNode.Expression)) {
                    var _VisitorContext_context_varyingStruct_ident, _VisitorContext_context_varyingStruct, _VisitorContext_context_varyingStruct_ident1, _VisitorContext_context_varyingStruct1;
                    var returnVar = ParserUtils.unwrapNodeByType(expr, ENonTerminal.variable_identifier);
                    if ((returnVar == null ? void 0 : returnVar.typeInfo) === ((_VisitorContext_context_varyingStruct = VisitorContext.context.varyingStruct) == null ? void 0 : (_VisitorContext_context_varyingStruct_ident = _VisitorContext_context_varyingStruct.ident) == null ? void 0 : _VisitorContext_context_varyingStruct_ident.lexeme)) {
                        return "";
                    }
                    var returnFnCall = ParserUtils.unwrapNodeByType(expr, ENonTerminal.function_call);
                    if ((returnFnCall == null ? void 0 : returnFnCall.type) === ((_VisitorContext_context_varyingStruct1 = VisitorContext.context.varyingStruct) == null ? void 0 : (_VisitorContext_context_varyingStruct_ident1 = _VisitorContext_context_varyingStruct1.ident) == null ? void 0 : _VisitorContext_context_varyingStruct_ident1.lexeme)) {
                        return "" + expr.codeGen(this) + ";";
                    }
                }
            }
            return this.defaultCodeGen(node.children);
        };
        _proto.visitFunctionIdentifier = function visitFunctionIdentifier(node) {
            return this.defaultCodeGen(node.children);
        };
        _proto._reportError = function _reportError(loc, message) {
            this.errors.push(new GSError(GSErrorName.CompilationError, message, loc, ShaderLab._processingPassText));
        };
        return CodeGenVisitor;
    }();

    var defaultPrecision = "\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp int;\n#else\n  precision mediump float;\n  precision mediump int;\n#endif\n";
    /**
     * @internal
     */ var GLESVisitor = /*#__PURE__*/ function(CodeGenVisitor) {
        _inherits(GLESVisitor, CodeGenVisitor);
        function GLESVisitor() {
            var _this;
            _this = CodeGenVisitor.apply(this, arguments) || this, _this._versionText = "", _this._extensions = "";
            return _this;
        }
        var _proto = GLESVisitor.prototype;
        _proto.visitShaderProgram = function visitShaderProgram(node, vertexEntry, fragmentEntry) {
            this.errors.length = 0;
            VisitorContext.reset();
            VisitorContext.context._passSymbolTable = node.shaderData.symbolTable;
            return {
                vertex: this.vertexMain(vertexEntry, node.shaderData),
                fragment: this._fragmentMain(fragmentEntry, node.shaderData)
            };
        };
        _proto.vertexMain = function vertexMain(entry, data) {
            var symbolTable = data.symbolTable;
            var fnSymbol = symbolTable.lookup({
                ident: entry,
                symbolType: ESymbolType.FN
            });
            if (!(fnSymbol == null ? void 0 : fnSymbol.astNode)) throw "no entry function found: " + entry;
            var fnNode = fnSymbol.astNode;
            VisitorContext.context.stage = EShaderStage.VERTEX;
            var returnType = fnNode.protoType.returnType;
            if (typeof returnType.type === "string") {
                var varyStruct = symbolTable.lookup({
                    ident: returnType.type,
                    symbolType: ESymbolType.STRUCT
                });
                if (!varyStruct) {
                    this._reportError(returnType.location, "invalid varying struct: " + returnType.type);
                } else {
                    VisitorContext.context.varyingStruct = varyStruct.astNode;
                }
            } else if (returnType.type !== EKeyword.VOID) {
                this._reportError(returnType.location, "main entry can only return struct.");
            }
            var paramList = fnNode.protoType.parameterList;
            if (paramList == null ? void 0 : paramList.length) {
                for(var _iterator = _create_for_of_iterator_helper_loose(paramList), _step; !(_step = _iterator()).done;){
                    var paramInfo = _step.value;
                    if (typeof paramInfo.typeInfo.type === "string") {
                        var structSymbol = symbolTable.lookup({
                            ident: paramInfo.typeInfo.type,
                            symbolType: ESymbolType.STRUCT
                        });
                        if (!structSymbol) {
                            this._reportError(paramInfo.astNode.location, 'Not found attribute struct "' + paramInfo.typeInfo.type + '".');
                            continue;
                        }
                        VisitorContext.context.attributeStructs.push(structSymbol.astNode);
                        for(var _iterator1 = _create_for_of_iterator_helper_loose(structSymbol.astNode.propList), _step1; !(_step1 = _iterator1()).done;){
                            var prop = _step1.value;
                            VisitorContext.context.attributeList.push(prop);
                        }
                    } else {
                        VisitorContext.context.attributeList.push(paramInfo);
                    }
                }
            }
            var statements = fnNode.statements.codeGen(this);
            var globalText = this._getGlobalText(data);
            var attributeDeclare = this.getAttributeDeclare();
            var varyingDeclare = this.getVaryingDeclare();
            var globalCode = [].concat(globalText, attributeDeclare, varyingDeclare).sort(function(a, b) {
                return a.index - b.index;
            }).map(function(item) {
                return item.text;
            }).join("\n");
            VisitorContext.context.reset();
            return this._versionText + "\n" + globalCode + "\n\nvoid main() " + statements;
        };
        _proto._fragmentMain = function _fragmentMain(entry, data) {
            var symbolTable = data.symbolTable;
            var fnSymbol = symbolTable.lookup({
                ident: entry,
                symbolType: ESymbolType.FN
            });
            if (!(fnSymbol == null ? void 0 : fnSymbol.astNode)) throw "no entry function found: " + entry;
            var fnNode = fnSymbol.astNode;
            VisitorContext.context.stage = EShaderStage.FRAGMENT;
            var statements = fnNode.statements.codeGen(this);
            var globalText = this._getGlobalText(data);
            var varyingDeclare = this.getVaryingDeclare();
            var globalCode = [].concat(globalText, varyingDeclare).sort(function(a, b) {
                return a.index - b.index;
            }).map(function(item) {
                return item.text;
            }).join("\n");
            VisitorContext.context.reset();
            return this._versionText + "\n" + this._extensions + "\n" + defaultPrecision + "\n" + globalCode + "\n\nvoid main() " + statements;
        };
        _proto._getGlobalText = function _getGlobalText(data, textList, lastLength, _serialized) {
            if (textList === void 0) textList = [];
            if (lastLength === void 0) lastLength = 0;
            if (_serialized === void 0) _serialized = new Set();
            var _referencedGlobals = VisitorContext.context._referencedGlobals;
            if (lastLength === Object.keys(_referencedGlobals).length) {
                for(var _iterator = _create_for_of_iterator_helper_loose(data.globalPrecisions), _step; !(_step = _iterator()).done;){
                    var precision = _step.value;
                    textList.push({
                        text: precision.codeGen(this),
                        index: precision.location.start.index
                    });
                }
                return textList;
            }
            lastLength = Object.keys(_referencedGlobals).length;
            for(var ident in _referencedGlobals){
                var sm = _referencedGlobals[ident];
                if (_serialized.has(ident)) continue;
                _serialized.add(ident);
                if (_instanceof(sm, SymbolInfo)) {
                    if (sm.symbolType === ESymbolType.VAR) {
                        textList.push({
                            text: "uniform " + sm.astNode.codeGen(this),
                            index: sm.astNode.location.start.index
                        });
                    } else {
                        textList.push({
                            text: sm.astNode.codeGen(this),
                            index: sm.astNode.location.start.index
                        });
                    }
                } else {
                    textList.push({
                        text: sm.codeGen(this),
                        index: sm.location.start.index
                    });
                }
            }
            return this._getGlobalText(data, textList, lastLength, _serialized);
        };
        return GLESVisitor;
    }(CodeGenVisitor);

    var GLES100Visitor = /*#__PURE__*/ function(GLESVisitor) {
        _inherits(GLES100Visitor, GLESVisitor);
        function GLES100Visitor() {
            var _this;
            _this = GLESVisitor.apply(this, arguments) || this, _this._versionText = "#version 100", _this._extensions = [
                "GL_EXT_shader_texture_lod",
                "GL_OES_standard_derivatives",
                "GL_EXT_draw_buffers",
                "GL_EXT_frag_depth"
            ].map(function(e) {
                return "#extension " + e + " : enable\n";
            }).join("");
            return _this;
        }
        var _proto = GLES100Visitor.prototype;
        _proto.getAttributeDeclare = function getAttributeDeclare() {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.values(VisitorContext.context._referencedAttributeList)), _step; !(_step = _iterator()).done;){
                var item = _step.value;
                ret.push({
                    text: "attribute " + item.typeInfo.typeLexeme + " " + item.ident.lexeme + ";",
                    index: item.ident.location.start.index
                });
            }
            return ret;
        };
        _proto.getVaryingDeclare = function getVaryingDeclare() {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.values(VisitorContext.context._referencedVaryingList)), _step; !(_step = _iterator()).done;){
                var item = _step.value;
                ret.push({
                    text: "varying " + item.typeInfo.typeLexeme + " " + item.ident.lexeme + ";",
                    index: item.ident.location.start.index
                });
            }
            return ret;
        };
        GLES100Visitor.getVisitor = function getVisitor() {
            if (!this._singleton) {
                this._singleton = new GLES100Visitor();
            }
            return this._singleton;
        };
        return GLES100Visitor;
    }(GLESVisitor);

    var V3_GL_FragColor = "GS_glFragColor";
    var GLES300Visitor = /*#__PURE__*/ function(GLESVisitor) {
        _inherits(GLES300Visitor, GLESVisitor);
        function GLES300Visitor() {
            var _this;
            _this = GLESVisitor.apply(this, arguments) || this, _this._versionText = "#version 300 es";
            return _this;
        }
        var _proto = GLES300Visitor.prototype;
        _proto.getAttributeDeclare = function getAttributeDeclare() {
            var ret = [];
            for(var _iterator = _create_for_of_iterator_helper_loose(Object.values(VisitorContext.context._referencedAttributeList)), _step; !(_step = _iterator()).done;){
                var item = _step.value;
                ret.push({
                    text: "in " + item.typeInfo.typeLexeme + " " + item.ident.lexeme + ";",
                    index: item.ident.location.start.index
                });
            }
            return ret;
        };
        _proto.getVaryingDeclare = function getVaryingDeclare() {
            var ret = [];
            var qualifier = VisitorContext.context.stage === EShaderStage.FRAGMENT ? "in" : "out";
            var values = Object.values(VisitorContext.context._referencedVaryingList);
            for(var i = 0; i < values.length; i++){
                var item = values[i];
                var _item_qualifier;
                ret.push({
                    text: ((_item_qualifier = item.qualifier) != null ? _item_qualifier : qualifier) + " " + item.typeInfo.typeLexeme + " " + item.ident.lexeme + ";",
                    index: item.ident.location.start.index
                });
            }
            return ret;
        };
        _proto.visitFunctionIdentifier = function visitFunctionIdentifier(node) {
            var typeSpecifier = node.children[0];
            if (typeSpecifier.children.length !== 1) {
                return this.defaultCodeGen(node.children);
            }
            var ident = node.lexeme;
            if (node.ident === "texture2D" || node.ident === "textureCube") {
                ident = "texture";
            } else if (node.ident === "texture2DProj") {
                ident = "textureProj";
            } else if (VisitorContext.context.stage === EShaderStage.FRAGMENT) {
                switch(node.ident){
                    case "texture2DLodEXT":
                    case "textureCubeLodEXT":
                        ident = "textureLod";
                        break;
                    case "texture2DGradEXT":
                    case "textureCubeGradEXT":
                        ident = "textureGrad";
                        break;
                    case "texture2DProjLodEXT":
                        ident = "textureProjLod";
                        break;
                    case "texture2DProjGradEXT":
                        ident = "textureProjGrad";
                        break;
                    case "gl_FragDepthEXT":
                        ident = "gl_FragDepth";
                        break;
                }
            }
            return ident;
        };
        _proto.visitVariableIdentifier = function visitVariableIdentifier(node) {
            if (VisitorContext.context.stage === EShaderStage.FRAGMENT && node.lexeme === "gl_FragColor") {
                if (!VisitorContext.context._referencedVaryingList[V3_GL_FragColor]) {
                    var token = BaseToken.pool.get();
                    token.set(ETokenType.ID, V3_GL_FragColor, ShaderLab.createPosition(0, 0, 0));
                    VisitorContext.context._referencedVaryingList[V3_GL_FragColor] = {
                        ident: token,
                        typeInfo: new SymbolType(EKeyword.VEC4, "vec4"),
                        qualifier: "out",
                        astNode: node
                    };
                }
                return V3_GL_FragColor;
            }
            return GLESVisitor.prototype.visitVariableIdentifier.call(this, node);
        };
        GLES300Visitor.getVisitor = function getVisitor() {
            if (!this._singleton) {
                this._singleton = new GLES300Visitor();
            }
            return this._singleton;
        };
        return GLES300Visitor;
    }(GLESVisitor);

    function _extends() {
        _extends = Object.assign || function assign(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
            }

            return target;
        };

        return _extends.apply(this, arguments);
    }

    var KeywordMap = new Map([
        [
            "RenderQueueType",
            EKeyword.GS_RenderQueueType
        ],
        [
            "BlendState",
            EKeyword.GS_BlendState
        ],
        [
            "DepthState",
            EKeyword.GS_DepthState
        ],
        [
            "StencilState",
            EKeyword.GS_StencilState
        ],
        [
            "RasterState",
            EKeyword.GS_RasterState
        ],
        [
            "EditorProperties",
            EKeyword.GS_EditorProperties
        ],
        [
            "EditorMacros",
            EKeyword.GS_EditorMacros
        ],
        [
            "Editor",
            EKeyword.GS_Editor
        ],
        [
            "Tags",
            EKeyword.GS_Tags
        ],
        [
            "VertexShader",
            EKeyword.GS_VertexShader
        ],
        [
            "FragmentShader",
            EKeyword.GS_FragmentShader
        ],
        [
            "SubShader",
            EKeyword.GS_SubShader
        ],
        [
            "Pass",
            EKeyword.GS_Pass
        ],
        [
            "BlendFactor",
            EKeyword.GS_BlendFactor
        ],
        [
            "BlendOperation",
            EKeyword.GS_BlendOperation
        ],
        [
            "Bool",
            EKeyword.GS_Bool
        ],
        [
            "Number",
            EKeyword.GS_Number
        ],
        [
            "CompareFunction",
            EKeyword.GS_CompareFunction
        ],
        [
            "StencilOperation",
            EKeyword.GS_StencilOperation
        ],
        [
            "CullMode",
            EKeyword.GS_CullMode
        ],
        [
            "true",
            EKeyword.TRUE
        ],
        [
            "false",
            EKeyword.FALSE
        ],
        [
            "UsePass",
            EKeyword.GS_UsePass
        ],
        [
            "Color",
            EKeyword.GS_Color
        ]
    ]);

    var Scanner = /*#__PURE__*/ function(BaseScanner) {
        _inherits(Scanner, BaseScanner);
        function Scanner(source, kws) {
            if (kws === void 0) kws = new Map();
            return BaseScanner.call(this, source, kws) || this;
        }
        var _proto = Scanner.prototype;
        /**
       * split by space
       */ _proto.scanWord = function scanWord() {
            this.skipCommentsAndSpace();
            var start = this._currentIndex;
            while(/\S/.test(this.getCurChar()) && !this.isEnd())this._advance();
            return this._source.substring(start, this._currentIndex);
        };
        _proto.scanNumber = function scanNumber() {
            this.skipCommentsAndSpace();
            var start = this._currentIndex;
            while(/[0-9]/.test(this.getCurChar()))this._advance();
            if (this.getCurChar() === ".") {
                this._advance();
                while(/[0-9]/.test(this.getCurChar()))this._advance();
            }
            return Number(this._source.substring(start, this._currentIndex));
        };
        _proto.scanToCharacter = function scanToCharacter(char) {
            while(this.getCurChar() !== char && !this.isEnd()){
                this._advance();
            }
            this._advance();
        };
        return Scanner;
    }(BaseScanner);

    var SymbolTable = /*#__PURE__*/ function(BaseSymbolTable) {
        _inherits(SymbolTable, BaseSymbolTable);
        function SymbolTable() {
            return BaseSymbolTable.apply(this, arguments) || this;
        }
        var _proto = SymbolTable.prototype;
        _proto.symbolEqualCheck = function symbolEqualCheck(s1, s2) {
            return s1.type === s2.type;
        };
        return SymbolTable;
    }(BaseSymbolTable);

    var EngineType = [
        EKeyword.GS_RenderQueueType,
        EKeyword.GS_BlendFactor,
        EKeyword.GS_BlendOperation,
        EKeyword.GS_Bool,
        EKeyword.GS_Number,
        EKeyword.GS_Color,
        EKeyword.GS_CompareFunction,
        EKeyword.GS_StencilOperation,
        EKeyword.GS_CullMode
    ];
    var RenderStateType = [
        EKeyword.GS_BlendState,
        EKeyword.GS_DepthState,
        EKeyword.GS_RasterState,
        EKeyword.GS_StencilState
    ];
    /**
     * @internal
     */ var ShaderContentParser = /*#__PURE__*/ function() {
        function ShaderContentParser() {}
        ShaderContentParser._isRenderStateDeclarator = function _isRenderStateDeclarator(token) {
            return RenderStateType.includes(token.type);
        };
        ShaderContentParser._isEngineType = function _isEngineType(token) {
            return EngineType.includes(token.type);
        };
        ShaderContentParser.reset = function reset() {
            this._errors.length = 0;
            this._symbolTable.clear();
            this._newScope();
        };
        ShaderContentParser.parse = function parse(source) {
            var start = performance.now();
            var scanner = new Scanner(source, KeywordMap);
            var ret = {
                subShaders: [],
                globalContents: [],
                renderStates: {
                    constantMap: {},
                    variableMap: {}
                }
            };
            scanner.scanText("Shader");
            ret.name = scanner.scanPairedText('"', '"');
            scanner.scanText("{");
            scanner.skipCommentsAndSpace();
            this._parseShaderStatements(ret, scanner);
            var shaderGlobalStatements = ret.globalContents;
            var shaderRenderStates = ret.renderStates;
            for(var i = 0; i < ret.subShaders.length; i++){
                var subShader = ret.subShaders[i];
                var curSubShaderGlobalStatements = shaderGlobalStatements.concat(subShader.globalContents);
                var constMap = _extends({}, shaderRenderStates.constantMap, subShader.renderStates.constantMap);
                var variableMap = _extends({}, shaderRenderStates.variableMap, subShader.renderStates.variableMap);
                for(var i1 = 0; i1 < subShader.passes.length; i1++){
                    var pass = subShader.passes[i1];
                    Object.assign(pass.renderStates.constantMap, constMap);
                    Object.assign(pass.renderStates.variableMap, variableMap);
                    if (pass.isUsePass) continue;
                    // @ts-ignore
                    var passGlobalStatements = curSubShaderGlobalStatements.concat(pass.globalContents);
                    pass.contents = passGlobalStatements.map(function(item) {
                        return item.content;
                    }).join("\n");
                }
            }
            engine.Logger.info("[content compilation] cost time " + (performance.now() - start) + "ms");
            return ret;
        };
        ShaderContentParser._parseShaderStatements = function _parseShaderStatements(ret, scanner) {
            var braceLevel = 1;
            var start = scanner.getCurPosition();
            while(true){
                var word = scanner.scanToken();
                switch(word.type){
                    case EKeyword.GS_SubShader:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        var subShader = this._parseSubShader(scanner);
                        ret.subShaders.push(subShader);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_EditorProperties:
                    case EKeyword.GS_EditorMacros:
                    case EKeyword.GS_Editor:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        scanner.scanPairedText("{", "}", true);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_RenderQueueType:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        this._parseRenderQueueAssignment(ret, scanner);
                        start = scanner.getCurPosition();
                        break;
                    case ETokenType.NOT_WORD:
                        if (word.lexeme === "{") braceLevel += 1;
                        else if (word.lexeme === "}") {
                            braceLevel -= 1;
                            if (braceLevel === 0) {
                                this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                                this._symbolTable.dropScope();
                                return;
                            }
                        }
                    default:
                        if (ShaderContentParser._isRenderStateDeclarator(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseRenderStateDeclarationOrAssignment(ret, word, scanner);
                            start = scanner.getCurPosition();
                            break;
                        } else if (ShaderContentParser._isEngineType(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseVariableDeclaration(word.type, scanner);
                            start = scanner.getCurPosition();
                            break;
                        }
                }
            }
        };
        ShaderContentParser._parseRenderStateDeclarationOrAssignment = function _parseRenderStateDeclarationOrAssignment(ret, stateToken, scanner) {
            var ident = scanner.scanToken();
            var isDeclaration;
            if (ident.type === ETokenType.ID) {
                isDeclaration = true;
                scanner.scanText("{");
            } else if (ident.lexeme === "{") {
                isDeclaration = false;
            } else if (ident.lexeme === "=") {
                var variable = scanner.scanToken();
                scanner.scanText(";");
                var sm = this._symbolTable.lookup({
                    type: stateToken.type,
                    ident: variable.lexeme
                });
                if (!(sm == null ? void 0 : sm.value)) {
                    var error = ShaderLabUtils.createGSError('Invalid "' + stateToken.lexeme + '" variable: ' + variable.lexeme, GSErrorName.CompilationError, scanner.source, variable.location);
                    this._errors.push(error);
                    return;
                }
                var renderState = sm.value;
                Object.assign(ret.renderStates.constantMap, renderState.constantMap);
                Object.assign(ret.renderStates.variableMap, renderState.variableMap);
                return;
            }
            var renderState1 = this._parseRenderStatePropList(stateToken.lexeme, scanner);
            if (isDeclaration) {
                this._symbolTable.insert({
                    ident: ident.lexeme,
                    type: stateToken.type,
                    value: renderState1
                });
            } else {
                Object.assign(ret.renderStates.constantMap, renderState1.constantMap);
                Object.assign(ret.renderStates.variableMap, renderState1.variableMap);
            }
        };
        ShaderContentParser._parseVariableDeclaration = function _parseVariableDeclaration(type, scanner) {
            var token = scanner.scanToken();
            scanner.scanText(";");
            this._symbolTable.insert({
                type: token.type,
                ident: token.lexeme
            });
        };
        ShaderContentParser._newScope = function _newScope() {
            var symbolTable = new SymbolTable();
            this._symbolTable.newScope(symbolTable);
        };
        ShaderContentParser._parseRenderStatePropList = function _parseRenderStatePropList(state, scanner) {
            var ret = {
                constantMap: {},
                variableMap: {}
            };
            while(scanner.getCurChar() !== "}"){
                this._parseRenderStatePropItem(ret, state, scanner);
                scanner.skipCommentsAndSpace();
            }
            scanner._advance();
            return ret;
        };
        ShaderContentParser._parseRenderStatePropItem = function _parseRenderStatePropItem(ret, state, scanner) {
            var renderStateProp = scanner.scanToken().lexeme;
            var op = scanner.scanToken();
            if (state === "BlendState" && renderStateProp !== "BlendColor" && renderStateProp !== "AlphaToCoverage") {
                var idx = 0;
                if (op.lexeme === "[") {
                    idx = scanner.scanNumber();
                    scanner.scanText("]");
                    scanner.scanText("=");
                } else if (op.lexeme !== "=") {
                    var error = ShaderLabUtils.createGSError("Invalid syntax, expect character '=', but got " + op.lexeme, GSErrorName.CompilationError, scanner.source, scanner.getCurPosition());
                    this._errors.push(error);
                    scanner.scanToCharacter(";");
                    return;
                }
                renderStateProp += idx;
            }
            renderStateProp = state + renderStateProp;
            var renderStateElementKey = engine.RenderStateDataKey[renderStateProp];
            if (renderStateElementKey == undefined) {
                var error1 = ShaderLabUtils.createGSError("Invalid render state element " + renderStateProp, GSErrorName.CompilationError, scanner.source, scanner.getCurPosition());
                this._errors.push(error1);
                scanner.scanToCharacter(";");
                return;
            }
            scanner.skipCommentsAndSpace();
            var value;
            if (/[0-9.]/.test(scanner.getCurChar())) {
                value = scanner.scanNumber();
            } else {
                var token = scanner.scanToken();
                if (token.type === EKeyword.TRUE) value = true;
                else if (token.type === EKeyword.FALSE) value = false;
                else if (token.type === EKeyword.GS_Color) {
                    scanner.scanText("(");
                    var args = [];
                    while(true){
                        args.push(scanner.scanNumber());
                        scanner.skipCommentsAndSpace();
                        var peek = scanner.peek(1);
                        if (peek === ")") {
                            scanner._advance();
                            break;
                        }
                        scanner.scanText(",");
                    }
                    value = _construct(engine.Color, [].concat(args));
                } else if (scanner.getCurChar() === ".") {
                    var _ShaderContentParser__engineType_token_lexeme;
                    scanner._advance();
                    var engineTypeProp = scanner.scanToken();
                    value = (_ShaderContentParser__engineType_token_lexeme = ShaderContentParser._engineType[token.lexeme]) == null ? void 0 : _ShaderContentParser__engineType_token_lexeme[engineTypeProp.lexeme];
                    if (value == undefined) {
                        var error2 = ShaderLabUtils.createGSError("Invalid engine constant: " + token.lexeme + "." + engineTypeProp.lexeme, GSErrorName.CompilationError, scanner.source, engineTypeProp.location);
                        this._errors.push(error2);
                        scanner.scanToCharacter(";");
                        return;
                    }
                } else {
                    value = token.lexeme;
                }
            }
            scanner.scanText(";");
            if (typeof value === "string") {
                ret.variableMap[renderStateElementKey] = value;
            } else {
                ret.constantMap[renderStateElementKey] = value;
            }
        };
        ShaderContentParser._parseRenderQueueAssignment = function _parseRenderQueueAssignment(ret, scanner) {
            scanner.scanText("=");
            var word = scanner.scanToken();
            scanner.scanText(";");
            var value = ShaderContentParser._engineType.RenderQueueType[word.lexeme];
            var key = engine.RenderStateDataKey.RenderQueueType;
            if (value == undefined) {
                ret.renderStates.variableMap[key] = word.lexeme;
            } else {
                ret.renderStates.constantMap[key] = value;
            }
        };
        ShaderContentParser._addGlobalStatement = function _addGlobalStatement(ret, scanner, start, offset) {
            if (scanner.current > start.index + offset) {
                ret.globalContents.push({
                    range: {
                        start: start,
                        end: _extends({}, scanner.getCurPosition(), {
                            index: scanner.current - offset - 1
                        })
                    },
                    content: scanner.source.substring(start.index, scanner.current - offset - 1)
                });
            }
        };
        ShaderContentParser._parseSubShader = function _parseSubShader(scanner) {
            this._newScope();
            var ret = {
                passes: [],
                globalContents: [],
                renderStates: {
                    constantMap: {},
                    variableMap: {}
                },
                tags: {}
            };
            var braceLevel = 1;
            ret.name = scanner.scanPairedText('"', '"');
            scanner.scanText("{");
            scanner.skipCommentsAndSpace();
            var start = scanner.getCurPosition();
            while(true){
                var word = scanner.scanToken();
                switch(word.type){
                    case EKeyword.GS_Pass:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        var pass = this._parsePass(scanner);
                        ret.passes.push(pass);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_RenderQueueType:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        this._parseRenderQueueAssignment(ret, scanner);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_UsePass:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        var name = scanner.scanPairedText('"', '"');
                        // @ts-ignore
                        ret.passes.push({
                            name: name,
                            isUsePass: true,
                            renderStates: {
                                constantMap: {},
                                variableMap: {}
                            },
                            tags: {}
                        });
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_Tags:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        this._parseTags(ret, scanner);
                        start = scanner.getCurPosition();
                        break;
                    case ETokenType.NOT_WORD:
                        if (word.lexeme === "{") braceLevel += 1;
                        else if (word.lexeme === "}") {
                            braceLevel -= 1;
                            if (braceLevel === 0) {
                                this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                                this._symbolTable.dropScope();
                                return ret;
                            }
                        }
                    default:
                        if (ShaderContentParser._isRenderStateDeclarator(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseRenderStateDeclarationOrAssignment(ret, word, scanner);
                            start = scanner.getCurPosition();
                            break;
                        } else if (ShaderContentParser._isEngineType(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseVariableDeclaration(word.type, scanner);
                            start = scanner.getCurPosition();
                            break;
                        }
                }
            }
        };
        ShaderContentParser._parseTags = function _parseTags(ret, scanner) {
            scanner.scanText("{");
            while(true){
                var ident = scanner.scanToken();
                scanner.scanText("=");
                var value = scanner.scanPairedText('"', '"');
                scanner.skipCommentsAndSpace();
                ret.tags[ident.lexeme] = value;
                if (scanner.peek(1) === "}") {
                    scanner._advance();
                    return;
                }
                scanner.scanText(",");
            }
        };
        ShaderContentParser._parsePass = function _parsePass(scanner) {
            this._newScope();
            var ret = {
                globalContents: [],
                renderStates: {
                    constantMap: {},
                    variableMap: {}
                },
                tags: {}
            };
            ret.name = scanner.scanPairedText('"', '"');
            scanner.scanText("{");
            var braceLevel = 1;
            scanner.skipCommentsAndSpace();
            var start = scanner.getCurPosition();
            while(true){
                var word = scanner.scanToken();
                switch(word.type){
                    case EKeyword.GS_RenderQueueType:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        this._parseRenderQueueAssignment(ret, scanner);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_Tags:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        this._parseTags(ret, scanner);
                        start = scanner.getCurPosition();
                        break;
                    case EKeyword.GS_VertexShader:
                    case EKeyword.GS_FragmentShader:
                        this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                        scanner.scanText("=");
                        var entry = scanner.scanToken();
                        if (ret[word.lexeme]) {
                            var error = ShaderLabUtils.createGSError("reassign main entry", GSErrorName.CompilationError, scanner.source, scanner.getCurPosition());
                            engine.Logger.error(error.toString());
                            throw error;
                        }
                        var key = word.type === EKeyword.GS_VertexShader ? "vertexEntry" : "fragmentEntry";
                        ret[key] = entry.lexeme;
                        scanner.scanText(";");
                        start = scanner.getCurPosition();
                        break;
                    case ETokenType.NOT_WORD:
                        if (word.lexeme === "{") braceLevel += 1;
                        else if (word.lexeme === "}") {
                            braceLevel -= 1;
                            if (braceLevel === 0) {
                                this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                                this._symbolTable.dropScope();
                                return ret;
                            }
                        }
                    default:
                        if (ShaderContentParser._isRenderStateDeclarator(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseRenderStateDeclarationOrAssignment(ret, word, scanner);
                            start = scanner.getCurPosition();
                            break;
                        } else if (ShaderContentParser._isEngineType(word)) {
                            this._addGlobalStatement(ret, scanner, start, word.lexeme.length);
                            this._parseVariableDeclaration(word.type, scanner);
                            start = scanner.getCurPosition();
                            break;
                        }
                }
            }
        };
        return ShaderContentParser;
    }();
    ShaderContentParser._engineType = {
        RenderQueueType: engine.RenderQueueType,
        CompareFunction: engine.CompareFunction,
        StencilOperation: engine.StencilOperation,
        BlendOperation: engine.BlendOperation,
        BlendFactor: engine.BlendFactor,
        CullMode: engine.CullMode
    };
    ShaderContentParser._errors = [];
    ShaderContentParser._symbolTable = new SymbolTableStack();

    /** @internal */ var ShaderLab = /*#__PURE__*/ function() {
        function ShaderLab() {
            /** Retrieve the compilation errors */ this.errors = [];
        }
        var _proto = ShaderLab.prototype;
        _proto._parseShaderPass = function _parseShaderPass(source, vertexEntry, fragmentEntry, macros, backend, platformMacros, basePathForIncludeKey) {
            Preprocessor.reset(engine.ShaderLib, basePathForIncludeKey);
            for(var _iterator = _create_for_of_iterator_helper_loose(macros), _step; !(_step = _iterator()).done;){
                var macro = _step.value;
                Preprocessor.addPredefinedMacro(macro.name, macro.value);
            }
            for(var i = 0; i < platformMacros.length; i++){
                Preprocessor.addPredefinedMacro(platformMacros[i]);
            }
            var preprocessorStart = performance.now();
            var ppdContent = Preprocessor.process(source);
            if (PpParser._errors.length > 0) {
                for(var _iterator1 = _create_for_of_iterator_helper_loose(PpParser._errors), _step1; !(_step1 = _iterator1()).done;){
                    var err = _step1.value;
                    this.errors.push(err);
                }
                this._logErrors();
                return undefined;
            }
            engine.Logger.info("[pass compilation - preprocessor]  cost time " + (performance.now() - preprocessorStart) + "ms");
            var lexer = new Lexer(ppdContent);
            var tokens = lexer.tokenize();
            var parser = ShaderLab._parser;
            ShaderLab._processingPassText = ppdContent;
            var program = parser.parse(tokens);
            for(var _iterator2 = _create_for_of_iterator_helper_loose(parser.errors), _step2; !(_step2 = _iterator2()).done;){
                var err1 = _step2.value;
                this.errors.push(err1);
            }
            if (!program) {
                this._logErrors();
                return undefined;
            }
            var codeGen = backend === engine.ShaderPlatformTarget.GLES100 ? GLES100Visitor.getVisitor() : GLES300Visitor.getVisitor();
            var start = performance.now();
            var ret = codeGen.visitShaderProgram(program, vertexEntry, fragmentEntry);
            engine.Logger.info("[CodeGen] cost time: " + (performance.now() - start) + "ms");
            ShaderLab._processingPassText = undefined;
            for(var _iterator3 = _create_for_of_iterator_helper_loose(codeGen.errors), _step3; !(_step3 = _iterator3()).done;){
                var err2 = _step3.value;
                this.errors.push(err2);
            }
            this._logErrors();
            return ret;
        };
        _proto._parseShaderContent = function _parseShaderContent(shaderSource) {
            ShaderLabUtils.clearAllShaderLabObjectPool();
            ShaderContentParser.reset();
            var ret = ShaderContentParser.parse(shaderSource);
            this.errors.length = 0;
            for(var _iterator = _create_for_of_iterator_helper_loose(ShaderContentParser._errors), _step; !(_step = _iterator()).done;){
                var error = _step.value;
                this.errors.push(error);
            }
            return ret;
        };
        /**
       * @internal
       */ _proto._logErrors = function _logErrors() {
            var errors = this.errors;
            if (errors.length === 0 || !engine.Logger.isEnabled) return;
            engine.Logger.error("" + errors.length + " errors occur!");
            for(var _iterator = _create_for_of_iterator_helper_loose(errors), _step; !(_step = _iterator()).done;){
                var err = _step.value;
                engine.Logger.error(err.toString());
            }
        };
        ShaderLab.createPosition = function createPosition(index, line, column) {
            var position = this._shaderPositionPool.get();
            position.set(index, line, column);
            return position;
        };
        ShaderLab.createRange = function createRange(start, end) {
            var range = this._shaderRangePool.get();
            range.set(start, end);
            return range;
        };
        return ShaderLab;
    }();
    ShaderLab._parser = ShaderTargetParser.create();
    ShaderLab._shaderPositionPool = ShaderLabUtils.createObjectPool(ShaderPosition);
    ShaderLab._shaderRangePool = ShaderLabUtils.createObjectPool(ShaderRange);

    //@ts-ignore
    var version = "1.4.0-alpha.0";
    var mode = "Release";
    mode = "Verbose";
    console.log("Galacean ShaderLab version: " + version + ". mode: " + mode);

    exports.GSError = GSError;
    exports.GSErrorName = GSErrorName;
    exports.Preprocessor = Preprocessor;
    exports.ShaderLab = ShaderLab;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=browser.verbose.js.map
