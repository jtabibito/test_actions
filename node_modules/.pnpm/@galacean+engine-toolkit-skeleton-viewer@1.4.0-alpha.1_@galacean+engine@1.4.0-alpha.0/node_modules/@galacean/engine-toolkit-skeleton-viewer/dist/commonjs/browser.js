'use strict';

var engine = require('@galacean/engine');

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/**
 * Skeleton visualization.
 * @example
 * rootEntity.addComponent(SkeletonViewer);
 */ var SkeletonViewer = /*#__PURE__*/ function(Script) {
    _inherits(SkeletonViewer, Script);
    function SkeletonViewer(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        /** Distance from connector to bone, [0~1]. */ _this.midStep = 0.2;
        /** The scale of the linker. */ _this.midWidthScale = 0.1;
        /** Ball size. */ _this.ballSize = 0.25;
        /** Skeleton Decrease Factor. */ _this.scaleFactor = 0.85;
        /** The min color.  */ _this.colorMin = new engine.Color(0.35, 0.35, 0.35, 1);
        /** The max color. */ _this.colorMax = new engine.Color(0.7, 0.7, 0.7, 1);
        _this._debugMesh = [];
        var engine$1 = entity.engine;
        if (!materialMap.get(engine$1)) {
            var material = new engine.Material(entity.engine, engine.Shader.find("skeleton-viewer"));
            material.renderState.rasterState.depthBias = -100000000;
            material.renderState.renderQueueType = engine.RenderQueueType.Transparent;
            materialMap.set(engine$1, material);
        }
        _this._material = materialMap.get(engine$1);
        _this._material.shaderData.setColor("u_colorMin", _this.colorMin);
        _this._material.shaderData.setColor("u_colorMax", _this.colorMax);
        var skinnedMeshRenderers = [];
        _this.entity.getComponentsIncludeChildren(engine.SkinnedMeshRenderer, skinnedMeshRenderers);
        for(var i = 0; i < skinnedMeshRenderers.length; i++){
            var renderer = skinnedMeshRenderers[i];
            if (renderer.skin) {
                _this._showSkeleton(renderer);
            }
        }
        return _this;
    }
    var _proto = SkeletonViewer.prototype;
    _proto.onDestroy = function onDestroy() {
        for(var i = 0, length = this._debugMesh.length; i < length; i++){
            this._debugMesh[i].destroy();
        }
        this._debugMesh.length = 0;
    };
    _proto.onEnable = function onEnable() {
        for(var i = 0, length = this._debugMesh.length; i < length; i++){
            this._debugMesh[i].enabled = true;
        }
    };
    _proto.onDisable = function onDisable() {
        for(var i = 0, length = this._debugMesh.length; i < length; i++){
            this._debugMesh[i].enabled = false;
        }
    };
    _proto._createSpur = function _createSpur(direction) {
        var mesh = new engine.ModelMesh(this.engine);
        var length = direction.length();
        var midLength = this.midStep * length;
        var midHalfWidth = length * this.midWidthScale;
        var positions = new Array(24);
        var normals = new Array(24);
        var matrix = new engine.Matrix();
        var quaternion = new engine.Quaternion();
        engine.Matrix.lookAt(new engine.Vector3(0, 0, 0), direction, new engine.Vector3(0, 1, 0), matrix);
        matrix.getRotation(quaternion).invert();
        var vertex = [
            new engine.Vector3(midHalfWidth, -midHalfWidth, -midLength).transformByQuat(quaternion),
            new engine.Vector3(midHalfWidth, midHalfWidth, -midLength).transformByQuat(quaternion),
            new engine.Vector3(-midHalfWidth, midHalfWidth, -midLength).transformByQuat(quaternion),
            new engine.Vector3(-midHalfWidth, -midHalfWidth, -midLength).transformByQuat(quaternion),
            new engine.Vector3(0, 0, -length).transformByQuat(quaternion),
            new engine.Vector3(0, 0, 0)
        ];
        positions[0] = new engine.Vector3(0, 0, 0);
        positions[1] = vertex[0].clone();
        positions[2] = vertex[1].clone();
        positions[3] = new engine.Vector3(0, 0, 0);
        positions[4] = vertex[1].clone();
        positions[5] = vertex[2].clone();
        positions[6] = new engine.Vector3(0, 0, 0);
        positions[7] = vertex[2].clone();
        positions[8] = vertex[3].clone();
        positions[9] = new engine.Vector3(0, 0, 0);
        positions[10] = vertex[3].clone();
        positions[11] = vertex[0].clone();
        positions[12] = vertex[0].clone();
        positions[13] = vertex[4].clone();
        positions[14] = vertex[1].clone();
        positions[15] = vertex[1].clone();
        positions[16] = vertex[4].clone();
        positions[17] = vertex[2].clone();
        positions[18] = vertex[2].clone();
        positions[19] = vertex[4].clone();
        positions[20] = vertex[3].clone();
        positions[21] = vertex[3].clone();
        positions[22] = vertex[4].clone();
        positions[23] = vertex[0].clone();
        normals[0] = normals[1] = normals[2] = new engine.Vector3(1, 0, 1).transformByQuat(quaternion);
        normals[3] = normals[4] = normals[5] = new engine.Vector3(0, 1, 1).transformByQuat(quaternion);
        normals[6] = normals[7] = normals[8] = new engine.Vector3(-1, 0, 1).transformByQuat(quaternion);
        normals[9] = normals[10] = normals[11] = new engine.Vector3(0, -1, 1).transformByQuat(quaternion);
        normals[12] = normals[13] = normals[14] = new engine.Vector3(1, 0, -1).transformByQuat(quaternion);
        normals[15] = normals[16] = normals[17] = new engine.Vector3(0, 1, -1).transformByQuat(quaternion);
        normals[18] = normals[19] = normals[20] = new engine.Vector3(-1, 0, -1).transformByQuat(quaternion);
        normals[21] = normals[22] = normals[23] = new engine.Vector3(0, -1, -1).transformByQuat(quaternion);
        var bounds = mesh.bounds;
        var min = bounds.min, max = bounds.max;
        min.set(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        max.set(-Number.NEGATIVE_INFINITY, -Number.NEGATIVE_INFINITY, -Number.NEGATIVE_INFINITY);
        for(var i = 0; i < 6; i++){
            var position = vertex[i];
            engine.Vector3.min(min, position, min);
            engine.Vector3.max(max, position, max);
        }
        mesh.setPositions(positions);
        mesh.setNormals(normals);
        mesh.uploadData(true);
        mesh.addSubMesh(0, 24);
        return mesh;
    };
    _proto._showSkeleton = function _showSkeleton(renderer) {
        var bones = renderer.bones;
        var spheres = [];
        var maxLength = 0;
        for(var i = 0; i < bones.length; i++){
            var bone = bones[i];
            var anchorPoint = bone.transform.worldPosition;
            // 球
            var entity = bone.createChild();
            var _$renderer = entity.addComponent(engine.MeshRenderer);
            _$renderer.receiveShadows = false;
            _$renderer.castShadows = false;
            _$renderer.mesh = engine.PrimitiveMesh.createSphere(this.engine, this.ballSize, 16);
            _$renderer.setMaterial(this._material);
            _$renderer.priority = 1;
            spheres.push([
                entity,
                bone
            ]);
            this._debugMesh.push(_$renderer);
            // 连接体
            for(var j = 0; j < bone.children.length; j++){
                var child = bone.children[j];
                var childPoint = child.transform.worldPosition;
                var absoluteDirection = childPoint.clone().subtract(anchorPoint);
                var direction = child.transform.position;
                var distance = absoluteDirection.length();
                if (distance > maxLength) {
                    maxLength = distance;
                }
                var entity1 = bone;
                var _$renderer1 = entity1.addComponent(engine.MeshRenderer);
                _$renderer1.receiveShadows = false;
                _$renderer1.castShadows = false;
                _$renderer1.setMaterial(this._material);
                _$renderer1.mesh = this._createSpur(direction);
                _$renderer1.priority = 1;
                this._debugMesh.push(_$renderer1);
            }
        }
        // change size of ball
        for(var i1 = 0; i1 < spheres.length; i1++){
            var sphere = spheres[i1][0];
            var joint = spheres[i1][1];
            var base = joint;
            var count = 0;
            while(base.parent){
                count++;
                base = base.parent;
            }
            var scale = 0.5 * maxLength * Math.pow(this.scaleFactor, count);
            var worldScale = sphere.transform.lossyWorldScale;
            sphere.transform.setScale(scale / worldScale.x, scale / worldScale.y, scale / worldScale.z);
        }
    };
    return SkeletonViewer;
}(engine.Script);
engine.Shader.create("skeleton-viewer", "\n  attribute vec3 POSITION;\n  attribute vec3 NORMAL;\n\n  uniform mat4 renderer_MVPMat;\n  uniform mat4 renderer_NormalMat;\n\n  varying vec3 v_normal;\n\n  void main(){\n      gl_Position = renderer_MVPMat * vec4( POSITION , 1.0 );;\n      v_normal = normalize( mat3(renderer_NormalMat) * NORMAL );\n  }", "\n      uniform vec3 u_colorMin;\n      uniform vec3 u_colorMax;\n      varying vec3 v_normal;\n\n      void main(){\n        float ndl = dot(v_normal, vec3(0, 1, 0)) * 0.5 + 0.5;\n        vec3 diffuse = mix(u_colorMin, u_colorMax, ndl);\n        gl_FragColor = vec4(diffuse, 1.0);\n      }\n      ");
var materialMap = new Map();

exports.SkeletonViewer = SkeletonViewer;
//# sourceMappingURL=browser.js.map
