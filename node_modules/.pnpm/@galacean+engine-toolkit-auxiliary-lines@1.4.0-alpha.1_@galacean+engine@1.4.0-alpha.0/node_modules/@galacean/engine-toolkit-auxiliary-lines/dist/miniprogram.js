'use strict';

var miniprogram = require('@galacean/engine/dist/miniprogram');

function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$1(o, p);
}

function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$1(subClass, superClass);
}

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

miniprogram.ShaderProperty.getByName("u_lightDir");
miniprogram.ShaderProperty.getByName("u_planarHeight");
miniprogram.ShaderProperty.getByName("u_planarShadowColor");
miniprogram.ShaderProperty.getByName("u_planarShadowFalloff");
var planarShadow = new miniprogram.ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ", "\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");
miniprogram.Shader.create("planarShadowShader", [
    miniprogram.Shader.find("pbr").subShaders[0].passes[0],
    planarShadow
]);

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}

miniprogram.ShaderProperty.getByName("u_far");
miniprogram.ShaderProperty.getByName("u_near");
miniprogram.ShaderProperty.getByName("u_primaryScale");
miniprogram.ShaderProperty.getByName("u_secondaryScale");
miniprogram.ShaderProperty.getByName("u_gridIntensity");
miniprogram.ShaderProperty.getByName("u_axisIntensity");
miniprogram.ShaderProperty.getByName("u_flipProgress");
miniprogram.ShaderProperty.getByName("u_fade");
miniprogram.Shader.create("grid", "\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}", "\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");

var vertexSource$2 = "\n  attribute vec3 POSITION;\n  attribute vec2 TEXCOORD_0;\n  attribute vec4 COLOR_0;\n  uniform mat4 renderer_MVPMat;\n  \n  uniform float u_time;\n  uniform vec2 u_foam_speed; \n  uniform vec2 u_distorsion_speed; \n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  varying vec4 v_color;\n      \n  void main() {\n    gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    waterTexCoords = TEXCOORD_0 + vec2(u_foam_speed.x * u_time, u_foam_speed.y * u_time);\n    normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));\n    v_color = COLOR_0; \n  }\n  ";
var fragmentSource$2 = "\n  #include <common>\n  varying vec4 v_color;\n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  uniform sampler2D material_NormalTexture;\n  uniform sampler2D u_foamTex;\n  uniform vec3 u_foamColor;\n  uniform vec2 u_foam_param;\n  uniform float u_distorsion_amount;\n  void main() {  \n    vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n    vec4 waterTex = texture2D(u_foamTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n    float alphaComp = v_color.r * waterTex.r * u_foam_param.x;\n    float alpha = pow(alphaComp,2.0);\n    alpha = smoothstep(0.5 - u_foam_param.y, 0.5+ u_foam_param.y, alpha);\n    alpha = saturate(alpha);\n    \n    gl_FragColor = vec4(u_foamColor.rgb, alpha);\n  }\n  ";
miniprogram.Shader.create("water-ripple", vertexSource$2, fragmentSource$2);
miniprogram.ShaderProperty.getByName("u_foamColor");
miniprogram.ShaderProperty.getByName("u_foam_speed");
miniprogram.ShaderProperty.getByName("u_foam_param");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_foamTex");

var vertexSource$1 = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n\n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_distorsion_speed; \n    \n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * sin(u_time), u_water_speed.y * cos(u_time));\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));     \n      \n      v_color = COLOR_0;\n    }\n    ";
var fragmentSource$1 = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_edgeTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {\n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 edgeTex = texture2D(u_edgeTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      float edge = pow((v_color.r + edgeTex.r) * v_color.r, 2.0);\n      edge = saturate(1.0 - smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edge));\n      vec4 finalCol = mix(waterTex, u_edgeColor, edge);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water", vertexSource$1, fragmentSource$1);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_edgeTex");

var vertexSource = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ";
var fragmentSource = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water-fall", vertexSource, fragmentSource);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_waterfall_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_waterfallTex");
miniprogram.ShaderProperty.getByName("u_edgeNoiseTex");

var fragment = "\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n";

var vertex = "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n";

miniprogram.Shader.create("bake-pbr", vertex, fragment);
miniprogram.ShaderProperty.getByName("u_lightMapTexture");
miniprogram.ShaderProperty.getByName("u_lightMapIntensity");

/**
 * plain color Material. don't effected by light and fog.
 */ var PlainColorMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(PlainColorMaterial, BaseMaterial);
    function PlainColorMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, miniprogram.Shader.find("plain-color")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.setColor(PlainColorMaterial._baseColorProp, new miniprogram.Color(1, 1, 1, 1));
        _this.renderState.rasterState.cullMode = miniprogram.CullMode.Off;
        return _this;
    }
    var _proto = PlainColorMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new PlainColorMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class(PlainColorMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PlainColorMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PlainColorMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return PlainColorMaterial;
}(miniprogram.BaseMaterial);
miniprogram.Shader.create("plain-color", "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n\nvoid main() {\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n}\n", "\n#include <common>\n\nuniform vec4 material_BaseColor;\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n     #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n}\n");

/**
 * Wireframe primitive.
 */ var WireframePrimitive = /*#__PURE__*/ function() {
    function WireframePrimitive() {}
    /**
   * Store cuboid wireframe mesh data.
   * The origin located in center of cuboid.
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCuboidWireframe = function createCuboidWireframe(width, height, depth, positions, positionOffset, indices, indicesOffset) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var offset = positionOffset;
        // Up
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        // Down
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Left
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Right
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        // Front
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Back
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Up
        indices[indicesOffset++] = positionOffset;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset;
        // Down
        indices[indicesOffset++] = positionOffset + 4;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 4;
        // Left
        indices[indicesOffset++] = positionOffset + 8;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 8;
        // Right
        indices[indicesOffset++] = positionOffset + 12;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 12;
        // Front
        indices[indicesOffset++] = positionOffset + 16;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 16;
        // Back
        indices[indicesOffset++] = positionOffset + 20;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 20;
    };
    /**
   * Store sphere wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - Sphere radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createSphereWireframe = function createSphereWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // X
        WireframePrimitive.createCircleWireframe(radius, 0, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount * 2, indices, indicesOffset + WireframePrimitive.circleIndexCount * 2);
    };
    /**
   * Store cone wireframe mesh data.
   * The origin located in top of cone.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createConeWireframe = function createConeWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, -height, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(-radius, -height, 0);
        positions[offset++].set(radius, -height, 0);
        positions[offset++].set(0, -height, radius);
        positions[offset++].set(0, -height, -radius);
        indicesOffset += WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 4;
    };
    /**
   * Store unbound cylinder wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - The radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createUnboundCylinderWireframe = function createUnboundCylinderWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        var height = 5;
        WireframePrimitive._shift.set(0, 0, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        indicesOffset += WireframePrimitive.circleIndexCount;
        for(var i = 0; i < 8; i++){
            var radian = miniprogram.MathUtil.degreeToRadian(45 * i);
            positions[offset++].set(radius * Math.cos(radian), 0, radius * Math.sin(radian));
            positions[offset++].set(radius * Math.cos(radian), -height, radius * Math.sin(radian));
            indices[indicesOffset + i * 2] = indexBegin + 2 * i;
            indices[indicesOffset + i * 2 + 1] = indexBegin + 2 * i + 1;
        }
    };
    /**
   * Store capsule wireframe mesh data.
   * The origin located in center of capsule.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCapsuleWireframe = function createCapsuleWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        var vertexCount = WireframePrimitive.circleVertexCount;
        var halfHeight = height / 2;
        // Y-Top
        WireframePrimitive._shift.set(0, halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y-Bottom
        WireframePrimitive._shift.set(0, -halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + vertexCount, indices, indicesOffset + circleIndicesCount);
        // X-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 2, positions, positionOffset + vertexCount * 2, indices, indicesOffset + circleIndicesCount * 2);
        // Z-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 0, positions, positionOffset + vertexCount * 3, indices, indicesOffset + circleIndicesCount * 2 + WireframePrimitive.ellipticIndexCount);
    };
    /**
   * Store circle wireframe mesh data.
   * @param radius - The radius
   * @param axis - The default direction
   * @param shift - The default shift
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCircleWireframe = function createCircleWireframe(radius, axis, shift, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(shift.x, radius * Math.cos(thetaDelta) + shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, radius * Math.sin(thetaDelta) + shift.y, shift.z);
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store elliptic wireframe mesh data.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createEllipticWireframe = function createEllipticWireframe(radius, height, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta) + height, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta), height, radius * Math.sin(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta), radius * Math.sin(thetaDelta) + height, 0);
                    break;
            }
            if (i == vertexCount / 2) {
                height = -height;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store frustum wireframe mesh data.
   * The origin located in the center of cap.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param angle - The angle of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createFrustumWireframe = function createFrustumWireframe(radius, height, angle, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        WireframePrimitive._shift.set(0, 0, -height);
        var radian = miniprogram.MathUtil.degreeToRadian(angle);
        var dirTanA = Math.tan(radian);
        var bottomRadius = radius + dirTanA * height;
        WireframePrimitive.createCircleWireframe(bottomRadius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        var indexBegin = positionOffset + 2 * WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(0, 0, -height);
        positions[offset++].set(radius, 0, 0);
        positions[offset++].set(bottomRadius, 0, -height);
        positions[offset++].set(-radius, 0, 0);
        positions[offset++].set(-bottomRadius, 0, -height);
        positions[offset++].set(0, radius, 0);
        positions[offset++].set(0, bottomRadius, -height);
        positions[offset++].set(0, -radius, 0);
        positions[offset++].set(0, -bottomRadius, -height);
        indicesOffset += 2 * WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin + 4;
        indices[indicesOffset++] = indexBegin + 5;
        indices[indicesOffset++] = indexBegin + 6;
        indices[indicesOffset++] = indexBegin + 7;
        indices[indicesOffset++] = indexBegin + 8;
        indices[indicesOffset++] = indexBegin + 9;
    };
    /**
   * Store hemisphere wireframe mesh data.
   * @param radius - The radius of hemisphere
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createHemisphereWireframe = function createHemisphereWireframe(radius, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount / 2;
        var twoPi = Math.PI;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount + 1; i++){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta), 0, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta), radius * Math.cos(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(-radius * Math.cos(thetaDelta), 0, -radius * Math.sin(thetaDelta));
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            }
        }
        indicesOffset += WireframePrimitive.circleVertexCount;
        for(var i1 = 0; i1 < vertexCount + 1; i1++){
            var v1 = i1 * countReciprocal;
            var thetaDelta1 = v1 * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta1), radius * Math.cos(thetaDelta1), 0);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta1), radius * Math.sin(thetaDelta1), 0);
                    break;
                case 2:
                    positions[offset++].set(0, -radius * Math.cos(thetaDelta1), -radius * Math.sin(thetaDelta1));
                    break;
            }
            var globalIndex1 = i1 + positionOffset + vertexCount + 1;
            if (i1 < vertexCount) {
                indices[indicesOffset + 2 * i1] = globalIndex1;
                indices[indicesOffset + 2 * i1 + 1] = globalIndex1 + 1;
            }
        }
        WireframePrimitive._shift.set(0, 0, 0);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount + 2, indices, indicesOffset + WireframePrimitive.circleVertexCount);
    };
    _create_class$1(WireframePrimitive, null, [
        {
            key: "cuboidIndexCount",
            get: /**
   * Get cuboid wire frame index count.
   */ function get() {
                return 48;
            }
        },
        {
            key: "cuboidPositionCount",
            get: /**
   * Get cuboid wire frame position count.
   */ function get() {
                return 24;
            }
        },
        {
            key: "sphereIndexCount",
            get: /**
   * Get sphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 3;
            }
        },
        {
            key: "spherePositionCount",
            get: /**
   * Get sphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount * 3;
            }
        },
        {
            key: "coneIndexCount",
            get: /**
   * Get cone wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 8;
            }
        },
        {
            key: "conePositionCount",
            get: /**
   * Get cone wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 5;
            }
        },
        {
            key: "unboundCylinderIndexCount",
            get: /**
   * Get unbound cylinder wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 16;
            }
        },
        {
            key: "unboundCylinderPositionCount",
            get: /**
   * Get unbound cylinder wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 16;
            }
        },
        {
            key: "capsuleIndexCount",
            get: /**
   * Get capsule wire frame index count.
   */ function get() {
                return (WireframePrimitive.circleIndexCount + WireframePrimitive.ellipticIndexCount) * 2;
            }
        },
        {
            key: "capsulePositionCount",
            get: /**
   * Get capsule wire frame position count.
   */ function get() {
                return (WireframePrimitive.circlePositionCount + WireframePrimitive.ellipticPositionCount) * 2;
            }
        },
        {
            key: "circleIndexCount",
            get: /**
   * Get circle wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "circlePositionCount",
            get: /**
   * Get circle wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "ellipticIndexCount",
            get: /**
   * Get elliptic wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "ellipticPositionCount",
            get: /**
   * Get elliptic wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "frustumIndexCount",
            get: /**
   * Get frustum wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 2 + 10;
            }
        },
        {
            key: "frustumPositionCount",
            get: /**
   * Get frustum wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + 10;
            }
        },
        {
            key: "hemisphereIndexCount",
            get: /**
   * Get hemisphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + WireframePrimitive.circleIndexCount;
            }
        },
        {
            key: "hemispherePositionCount",
            get: /**
   * Get hemisphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount + 2 + WireframePrimitive.circlePositionCount;
            }
        }
    ]);
    return WireframePrimitive;
}();
WireframePrimitive._shift = new miniprogram.Vector3();
/** global settings for vertex count */ WireframePrimitive.circleVertexCount = 40;

exports.WireframeManager = /*#__PURE__*/ function(Script) {
    _inherits$1(WireframeManager, Script);
    function WireframeManager() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._cameraPositions = [
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3(),
            new miniprogram.Vector3()
        ];
        _this._localPositions = [];
        _this._globalPositions = [];
        _this._indices = null;
        _this._indicesCount = 0;
        _this._boundsIndicesCount = 0;
        _this._wireframeRenderers = [];
        _this._wireframeElements = [];
        return _this;
    }
    var _proto = WireframeManager.prototype;
    /**
   * Clear all wireframe.
   */ _proto.clear = function clear() {
        this._wireframeRenderers.length = 0;
        this._wireframeElements.length = 0;
        this._localPositions.length = 0;
        this._globalPositions.length = 0;
        this._indicesCount = 0;
        this._mesh.subMesh.count = 0;
    };
    /**
   * Create auxiliary mesh for entity.
   * @param entity - The entity
   * @param includeChildren - whether include child entity(default is true)
   */ _proto.addEntityWireframe = function addEntityWireframe(entity, includeChildren) {
        if (includeChildren === void 0) includeChildren = true;
        if (includeChildren) {
            var components = new Array();
            entity.getComponentsIncludeChildren(miniprogram.Camera, components);
            for(var i = 0, n = components.length; i < n; i++){
                this.addCameraWireframe(components[i]);
            }
            var componentsOffset = components.length;
            entity.getComponentsIncludeChildren(miniprogram.SpotLight, components);
            for(var i1 = componentsOffset, n1 = components.length; i1 < n1; i1++){
                this.addSpotLightWireframe(components[i1]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(miniprogram.DirectLight, components);
            for(var i2 = componentsOffset, n2 = components.length; i2 < n2; i2++){
                this.addDirectLightWireframe(components[i2]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(miniprogram.PointLight, components);
            for(var i3 = componentsOffset, n3 = components.length; i3 < n3; i3++){
                this.addPointLightWireframe(components[i3]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(miniprogram.Collider, components);
            for(var i4 = componentsOffset, n4 = components.length; i4 < n4; i4++){
                this.addCollideWireframe(components[i4]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(miniprogram.ParticleRenderer, components);
            for(var i5 = componentsOffset, n5 = components.length; i5 < n5; i5++){
                this.addParticleRendererEmissionShapeWireframe(components[i5]);
            }
        } else {
            var camera = entity.getComponent(miniprogram.Camera);
            camera && this.addCameraWireframe(camera);
            var spotLight = entity.getComponent(miniprogram.SpotLight);
            spotLight && this.addSpotLightWireframe(spotLight);
            var directLight = entity.getComponent(miniprogram.DirectLight);
            directLight && this.addDirectLightWireframe(directLight);
            var pointLight = entity.getComponent(miniprogram.PointLight);
            pointLight && this.addPointLightWireframe(pointLight);
            var collider = entity.getComponent(miniprogram.Collider);
            collider && this.addCollideWireframe(collider);
            var particle = entity.getComponent(miniprogram.ParticleRenderer);
            particle && this.addParticleRendererEmissionShapeWireframe(particle);
        }
    };
    /**
   * Create auxiliary mesh for camera.
   * @param camera - The Camera
   */ _proto.addCameraWireframe = function addCameraWireframe(camera) {
        var transform = camera.entity.transform;
        var inverseProj = camera.projectionMatrix.clone();
        inverseProj.invert();
        var localPositions = this._localPositions;
        var positionsOffset = localPositions.length;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
        var ndcPosition = WireframeManager._ndcPosition;
        // front
        for(var i = 0; i < 4; i++){
            var newPosition = this._cameraPositions[i];
            newPosition.copyFrom(ndcPosition[i]);
            newPosition.transformCoordinate(inverseProj);
            localPositions.push(newPosition);
        }
        // back
        for(var i1 = 0; i1 < 4; i1++){
            var newPosition1 = this._cameraPositions[i1 + 4];
            newPosition1.copyFrom(ndcPosition[i1]);
            newPosition1.z = 1;
            newPosition1.transformCoordinate(inverseProj);
            localPositions.push(newPosition1);
        }
        this._growthIndexMemory(24);
        var indices = this._indices;
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset; // front
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 7; // link
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 4; // back
    };
    /**
   * Create auxiliary mesh for spot light.
   * @param light - The SpotLight
   */ _proto.addSpotLightWireframe = function addSpotLightWireframe(light) {
        var height = light.distance;
        var radius = Math.tan(light.angle / 2) * height;
        var positionsOffset = this._localPositions.length;
        var coneIndicesCount = WireframePrimitive.coneIndexCount;
        this._growthIndexMemory(coneIndicesCount);
        this._growthPosition(WireframePrimitive.conePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createConeWireframe(radius, height, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += coneIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for point light.
   * @param light - The PointLight
   */ _proto.addPointLightWireframe = function addPointLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(light.distance, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for directional light.
   * @param light - The DirectLight
   */ _proto.addDirectLightWireframe = function addDirectLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var unboundCylinderIndicesCount = WireframePrimitive.unboundCylinderIndexCount;
        this._growthIndexMemory(unboundCylinderIndicesCount);
        this._growthPosition(WireframePrimitive.unboundCylinderPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createUnboundCylinderWireframe(1, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += unboundCylinderIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for renderer axis-aligned boundingbox.
   * @param renderer - The Renderer
   */ _proto.addRendererWireframe = function addRendererWireframe(renderer) {
        this._boundsIndicesCount += WireframePrimitive.cuboidIndexCount;
        this._wireframeRenderers.push(renderer);
    };
    /**
   * Create auxiliary mesh for collider.
   * @param collider - The Collider
   */ _proto.addCollideWireframe = function addCollideWireframe(collider) {
        var shapes = collider.shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            var shape = shapes[i];
            if (_instanceof(shape, miniprogram.BoxColliderShape)) {
                this.addBoxColliderShapeWireframe(shape);
            } else if (_instanceof(shape, miniprogram.SphereColliderShape)) {
                this.addSphereColliderShapeWireframe(shape);
            } else if (_instanceof(shape, miniprogram.CapsuleColliderShape)) {
                this.addCapsuleColliderShapeWireframe(shape);
            }
        }
    };
    /**
   * Create auxiliary mesh for box collider shape.
   * @param shape - The BoxColliderShape
   */ _proto.addBoxColliderShapeWireframe = function addBoxColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, size = shape.size;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(worldScale.x * size.x, worldScale.y * size.y, worldScale.z * size.z, localPositions, positionsOffset, indices, this._indicesCount);
        miniprogram.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        miniprogram.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for sphere collider shape.
   * @param shape - The SphereColliderShape
   */ _proto.addSphereColliderShapeWireframe = function addSphereColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, radius = shape.radius;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(Math.max(worldScale.x, worldScale.y, worldScale.z) * radius, localPositions, positionsOffset, indices, this._indicesCount);
        miniprogram.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        miniprogram.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for capsule collider shape.
   * @param shape - The CapsuleColliderShape
   */ _proto.addCapsuleColliderShapeWireframe = function addCapsuleColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var maxScale = Math.max(worldScale.x, worldScale.y, worldScale.z);
        var radius = shape.radius, height = shape.height, upAxis = shape.upAxis, position = shape.position, rotation = shape.rotation;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation, tempAxis = WireframeManager._tempAxis, halfSqrt = WireframeManager._halfSqrt;
        var positionsOffset = this._localPositions.length;
        var capsuleIndicesCount = WireframePrimitive.capsuleIndexCount;
        this._growthIndexMemory(capsuleIndicesCount);
        this._growthPosition(WireframePrimitive.capsulePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCapsuleWireframe(maxScale * radius, maxScale * height, localPositions, positionsOffset, indices, this._indicesCount);
        switch(upAxis){
            case miniprogram.ColliderShapeUpAxis.X:
                tempAxis.set(0, 0, halfSqrt, halfSqrt);
                break;
            case miniprogram.ColliderShapeUpAxis.Y:
                tempAxis.set(0, 0, 0, 1);
                break;
            case miniprogram.ColliderShapeUpAxis.Z:
                tempAxis.set(halfSqrt, 0, 0, halfSqrt);
        }
        miniprogram.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        miniprogram.Quaternion.multiply(tempRotation, tempAxis, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        miniprogram.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += capsuleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    _proto.addParticleRendererEmissionShapeWireframe = function addParticleRendererEmissionShapeWireframe(particleRenderer) {
        if (particleRenderer.generator.emission.enabled) {
            var shape = particleRenderer.generator.emission.shape;
            var transform = particleRenderer.entity.transform;
            switch(shape == null ? void 0 : shape.shapeType){
                case 0:
                    this.addBoxParticleShapeWireframe(shape, transform);
                    break;
                case 1:
                    this.addCircleParticleShapeWireframe(shape, transform);
                    break;
                case 2:
                    this.addConeParticleShapeWireframe(shape, transform);
                    break;
                case 3:
                    this.addHemisphereParticleShapeWireframe(shape, transform);
                    break;
                case 4:
                    this.addSphereParticleShapeWireframe(shape, transform);
                    break;
            }
        }
    };
    _proto.addBoxParticleShapeWireframe = function addBoxParticleShapeWireframe(shape, transform) {
        var size = shape.size;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(size.x, size.y, size.z, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addCircleParticleShapeWireframe = function addCircleParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        this._growthIndexMemory(circleIndicesCount);
        this._growthPosition(WireframePrimitive.circlePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCircleWireframe(radius, 0, new miniprogram.Vector3(), localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += circleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addConeParticleShapeWireframe = function addConeParticleShapeWireframe(shape, transform) {
        var radius = shape.radius, length = shape.length, angle = shape.angle;
        var positionsOffset = this._localPositions.length;
        var frustumIndicesCount = WireframePrimitive.frustumIndexCount;
        this._growthIndexMemory(frustumIndicesCount);
        this._growthPosition(WireframePrimitive.frustumPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createFrustumWireframe(radius, length, angle, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += frustumIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addHemisphereParticleShapeWireframe = function addHemisphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var hemisphereIndicesCount = WireframePrimitive.hemisphereIndexCount;
        this._growthIndexMemory(hemisphereIndicesCount);
        this._growthPosition(WireframePrimitive.hemispherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createHemisphereWireframe(radius, 2, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += hemisphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addSphereParticleShapeWireframe = function addSphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(radius, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.onAwake = function onAwake() {
        var engine = this.engine;
        var mesh = new miniprogram.ModelMesh(engine);
        var material = new PlainColorMaterial(engine);
        var renderer = this.entity.getComponent(miniprogram.MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine._hardwareRenderer.canIUse(miniprogram.GLCapabilityType.elementIndexUint);
        mesh.addSubMesh(0, this._indicesCount, miniprogram.MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        this._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        this._supportUint32Array = supportUint32Array;
    };
    _proto.onEnable = function onEnable() {
        this._renderer.enabled = true;
    };
    _proto.onDisable = function onDisable() {
        this._renderer.enabled = false;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh, localPositions = _this._localPositions, globalPositions = _this._globalPositions, wireframeElements = _this._wireframeElements, wireframeRenderers = _this._wireframeRenderers, indices = _this._indices;
        // update local to world geometry
        var localPositionLength = localPositions.length;
        globalPositions.length = localPositionLength;
        var positionIndex = 0;
        var needUpdate = false;
        for(var i = 0, n = wireframeElements.length; i < n; i++){
            var wireframeElement = wireframeElements[i];
            var beginIndex = wireframeElement.transformRanges;
            var endIndex = i < n - 1 ? wireframeElements[i + 1].transformRanges : localPositionLength;
            if (wireframeElement.updateFlag.flag) {
                var transform = wireframeElement.transform;
                var worldMatrix = WireframeManager._tempMatrix;
                if (wireframeElement.isScaleIgnored) {
                    miniprogram.Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, worldMatrix);
                } else {
                    worldMatrix.copyFrom(transform.worldMatrix);
                }
                for(var j = beginIndex; j < endIndex; j++){
                    var localPosition = localPositions[positionIndex];
                    var globalPosition = WireframeManager._getPositionFromPool(positionIndex);
                    miniprogram.Vector3.transformCoordinate(localPosition, worldMatrix, globalPosition);
                    globalPositions[positionIndex] = globalPosition;
                    positionIndex++;
                }
                wireframeElement.updateFlag.flag = false;
                needUpdate = true;
            } else {
                positionIndex += endIndex - beginIndex;
            }
        }
        // update world-space geometry
        this._growthIndexMemory(this._boundsIndicesCount);
        var indicesCount = this._indicesCount;
        for(var i1 = 0; i1 < wireframeRenderers.length; i1++){
            var renderer = wireframeRenderers[i1];
            var bounds = renderer.bounds;
            var tempVector = WireframeManager._tempVector;
            bounds.getExtent(tempVector);
            var positionsOffset = globalPositions.length;
            WireframePrimitive.createCuboidWireframe(tempVector.x * 2, tempVector.y * 2, tempVector.z * 2, globalPositions, positionsOffset, indices, indicesCount);
            bounds.getCenter(tempVector);
            for(var i2 = positionsOffset; i2 < globalPositions.length; i2++){
                var position = globalPositions[i2];
                position.add(tempVector);
            }
            indicesCount += WireframePrimitive.cuboidIndexCount;
        }
        if (wireframeRenderers.length > 0 || needUpdate) {
            mesh.setPositions(globalPositions);
            mesh.setIndices(this._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = indicesCount;
        }
        if (indicesCount === 0) {
            this._renderer.setMaterial(null);
        } else {
            this._renderer.setMaterial(this._material);
        }
    };
    _proto._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = this._indices;
        var neededLength = this._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = this._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = this._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            this._indices = newIndices;
        }
    };
    _proto._growthPosition = function _growthPosition(length) {
        var position = this._localPositions;
        for(var i = 0; i < length; i++){
            position.push(new miniprogram.Vector3());
        }
    };
    _proto._localTranslate = function _localTranslate(positionsOffset, offset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            position.add(offset);
        }
    };
    _proto._localRotation = function _localRotation(positionsOffset, rotation) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            miniprogram.Vector3.transformByQuat(position, rotation, position);
        }
    };
    _proto._rotateAroundX = function _rotateAroundX(positionsOffset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            var py = position.y;
            var pz = position.z;
            position.z = py;
            position.y = -pz;
        }
    };
    WireframeManager._getPositionFromPool = function _getPositionFromPool(positionIndex) {
        var position;
        var positionPool = WireframeManager._positionPool;
        if (positionIndex < positionPool.length) {
            position = positionPool[positionIndex];
        } else {
            position = new miniprogram.Vector3();
            WireframeManager._positionPool.push(position);
        }
        return position;
    };
    _create_class$1(WireframeManager, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this._material.baseColor;
            },
            set: function set(value) {
                this._material.baseColor = value;
            }
        }
    ]);
    return WireframeManager;
}(miniprogram.Script);
exports.WireframeManager._positionPool = [];
exports.WireframeManager._ndcPosition = [
    new miniprogram.Vector3(-1, 1, -1),
    new miniprogram.Vector3(1, 1, -1),
    new miniprogram.Vector3(1, -1, -1),
    new miniprogram.Vector3(-1, -1, -1)
];
exports.WireframeManager._tempMatrix = new miniprogram.Matrix();
exports.WireframeManager._tempVector = new miniprogram.Vector3();
exports.WireframeManager._tempRotation = new miniprogram.Quaternion();
exports.WireframeManager._tempAxis = new miniprogram.Quaternion();
exports.WireframeManager._halfSqrt = 0.70710678118655;
exports.WireframeManager = __decorate([
    miniprogram.dependentComponents(miniprogram.MeshRenderer, miniprogram.DependentMode.CheckOnly)
], exports.WireframeManager);
/**
 * @internal
 * Store Wireframe element info.
 */ var WireframeElement = function WireframeElement(transform, transformRanges, isScaleIgnored) {
    if (isScaleIgnored === void 0) isScaleIgnored = true;
    this.transform = transform;
    this.transformRanges = transformRanges;
    this.isScaleIgnored = isScaleIgnored;
    this.updateFlag = transform.registerWorldChangeFlag();
};

exports.LineDrawer = /*#__PURE__*/ function(Script) {
    _inherits$1(LineDrawer, Script);
    function LineDrawer() {
        return Script.apply(this, arguments);
    }
    var _proto = LineDrawer.prototype;
    _proto.onAwake = function onAwake() {
        var engine = this.engine;
        var mesh = new miniprogram.ModelMesh(engine);
        var material = new PlainColorMaterial(engine);
        var renderer = this.entity.getComponent(miniprogram.MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine._hardwareRenderer.canIUse(miniprogram.GLCapabilityType.elementIndexUint);
        // @ts-ignore
        mesh._enableVAO = false;
        mesh.addSubMesh(0, LineDrawer._indicesCount, miniprogram.MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        LineDrawer._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        LineDrawer._supportUint32Array = supportUint32Array;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh;
        if (LineDrawer._positionCount > 0) {
            mesh.setPositions(LineDrawer._positions);
            mesh.setIndices(LineDrawer._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = LineDrawer._indicesCount;
            this._renderer.setMaterial(this._material);
        } else {
            this._renderer.setMaterial(null);
        }
        LineDrawer.flush();
    };
    /**
   * Draws a line starting at from towards to.
   * @param from - from position
   * @param to - to position
   */ LineDrawer.drawLine = function drawLine(from, to) {
        LineDrawer._growthPosition(2);
        LineDrawer._growthIndexMemory(2);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(from);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(to);
        } else {
            miniprogram.Vector3.transformCoordinate(from, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            miniprogram.Vector3.transformCoordinate(to, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a rectangle at four vertex
   * @param leftTop - left top position
   * @param rightTop - right top position
   * @param rightBottom - right bottom position
   * @param leftBottom - left bottom position
   */ LineDrawer.drawRect = function drawRect(leftTop, rightTop, rightBottom, leftBottom) {
        LineDrawer._growthPosition(4);
        LineDrawer._growthIndexMemory(8);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightBottom);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftBottom);
        } else {
            miniprogram.Vector3.transformCoordinate(leftTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            miniprogram.Vector3.transformCoordinate(rightTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            miniprogram.Vector3.transformCoordinate(rightBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            miniprogram.Vector3.transformCoordinate(leftBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a wireframe sphere with center and radius.
   * @param radius - sphere radius
   * @param center - sphere center
   */ LineDrawer.drawSphere = function drawSphere(radius, center) {
        var positionCount = WireframePrimitive.spherePositionCount;
        var indexCount = WireframePrimitive.sphereIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createSphereWireframe(radius, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                miniprogram.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe box with center and size.
   * @param width - width
   * @param height - height
   * @param depth - depth
   * @param center - center
   */ LineDrawer.drawCuboid = function drawCuboid(width, height, depth, center) {
        var positionCount = WireframePrimitive.cuboidPositionCount;
        var indexCount = WireframePrimitive.cuboidIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCuboidWireframe(width, height, depth, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                miniprogram.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe capsule with radius, height and center.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param center - The center
   */ LineDrawer.drawCapsule = function drawCapsule(radius, height, center) {
        var positionCount = WireframePrimitive.capsulePositionCount;
        var indexCount = WireframePrimitive.capsuleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCapsuleWireframe(radius, height, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                miniprogram.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe circle with radius, axis and center.
   * @param radius - The radius
   * @param axis - The axis
   * @param center - The center
   */ LineDrawer.drawCircle = function drawCircle(radius, axis, center) {
        WireframePrimitive._shift.set(0, 0, 0);
        var positionCount = WireframePrimitive.circlePositionCount;
        var indexCount = WireframePrimitive.circleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                miniprogram.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    LineDrawer.flush = function flush() {
        LineDrawer._positionCount = 0;
        LineDrawer._indicesCount = 0;
    };
    LineDrawer._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = LineDrawer._indices;
        var neededLength = LineDrawer._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = LineDrawer._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = LineDrawer._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            LineDrawer._indices = newIndices;
        }
    };
    LineDrawer._growthPosition = function _growthPosition(length) {
        var position = LineDrawer._positions;
        var neededLength = LineDrawer._positionCount + length;
        if (neededLength > position.length) {
            for(var i = 0, n = neededLength - position.length; i < n; i++){
                position.push(new miniprogram.Vector3());
            }
        }
    };
    _create_class$1(LineDrawer, [
        {
            key: "color",
            set: /**
   * Color of the material.
   * By default, color is (1,1,1,1).
   */ function set(value) {
                this._material.baseColor.copyFrom(value);
            }
        }
    ]);
    return LineDrawer;
}(miniprogram.Script);
exports.LineDrawer._positions = [];
exports.LineDrawer._positionCount = 0;
exports.LineDrawer._indicesCount = 0;
/**
   * The LineDrawer.matrix stores the position, rotation and scale of the LineDrawer.
   * By default, LineDrawer always uses world coordinates.
   * The default LineDrawer.matrix transforms the world coordinates using a default identity matrix.
   */ exports.LineDrawer.matrix = null;
exports.LineDrawer = __decorate([
    miniprogram.dependentComponents(miniprogram.MeshRenderer, miniprogram.DependentMode.CheckOnly)
], exports.LineDrawer);
exports.AxisType = void 0;
(function(AxisType) {
    AxisType[AxisType["X"] = 0] = "X";
    AxisType[AxisType["Y"] = 1] = "Y";
    AxisType[AxisType["Z"] = 2] = "Z";
})(exports.AxisType || (exports.AxisType = {}));

exports.WireframePrimitive = WireframePrimitive;
