import { W as WireframePrimitive, _ as _create_class } from './WireframePrimitive-80c67e9d.js';
import { _ as __decorate, a as _inherits } from './tslib.es6-c8446176.js';
import { dependentComponents, MeshRenderer, DependentMode, ModelMesh, GLCapabilityType, MeshTopology, Vector3, Script } from '@galacean/engine';
import { PlainColorMaterial } from '@galacean/engine-toolkit-custom-material';

var LineDrawer = /*#__PURE__*/ function(Script) {
    _inherits(LineDrawer, Script);
    function LineDrawer() {
        return Script.apply(this, arguments);
    }
    var _proto = LineDrawer.prototype;
    _proto.onAwake = function onAwake() {
        var engine = this.engine;
        var mesh = new ModelMesh(engine);
        var material = new PlainColorMaterial(engine);
        var renderer = this.entity.getComponent(MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint);
        // @ts-ignore
        mesh._enableVAO = false;
        mesh.addSubMesh(0, LineDrawer._indicesCount, MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        LineDrawer._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        LineDrawer._supportUint32Array = supportUint32Array;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh;
        if (LineDrawer._positionCount > 0) {
            mesh.setPositions(LineDrawer._positions);
            mesh.setIndices(LineDrawer._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = LineDrawer._indicesCount;
            this._renderer.setMaterial(this._material);
        } else {
            this._renderer.setMaterial(null);
        }
        LineDrawer.flush();
    };
    /**
   * Draws a line starting at from towards to.
   * @param from - from position
   * @param to - to position
   */ LineDrawer.drawLine = function drawLine(from, to) {
        LineDrawer._growthPosition(2);
        LineDrawer._growthIndexMemory(2);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(from);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(to);
        } else {
            Vector3.transformCoordinate(from, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            Vector3.transformCoordinate(to, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a rectangle at four vertex
   * @param leftTop - left top position
   * @param rightTop - right top position
   * @param rightBottom - right bottom position
   * @param leftBottom - left bottom position
   */ LineDrawer.drawRect = function drawRect(leftTop, rightTop, rightBottom, leftBottom) {
        LineDrawer._growthPosition(4);
        LineDrawer._growthIndexMemory(8);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightBottom);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftBottom);
        } else {
            Vector3.transformCoordinate(leftTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            Vector3.transformCoordinate(rightTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            Vector3.transformCoordinate(rightBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            Vector3.transformCoordinate(leftBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a wireframe sphere with center and radius.
   * @param radius - sphere radius
   * @param center - sphere center
   */ LineDrawer.drawSphere = function drawSphere(radius, center) {
        var positionCount = WireframePrimitive.spherePositionCount;
        var indexCount = WireframePrimitive.sphereIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createSphereWireframe(radius, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe box with center and size.
   * @param width - width
   * @param height - height
   * @param depth - depth
   * @param center - center
   */ LineDrawer.drawCuboid = function drawCuboid(width, height, depth, center) {
        var positionCount = WireframePrimitive.cuboidPositionCount;
        var indexCount = WireframePrimitive.cuboidIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCuboidWireframe(width, height, depth, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe capsule with radius, height and center.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param center - The center
   */ LineDrawer.drawCapsule = function drawCapsule(radius, height, center) {
        var positionCount = WireframePrimitive.capsulePositionCount;
        var indexCount = WireframePrimitive.capsuleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCapsuleWireframe(radius, height, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe circle with radius, axis and center.
   * @param radius - The radius
   * @param axis - The axis
   * @param center - The center
   */ LineDrawer.drawCircle = function drawCircle(radius, axis, center) {
        WireframePrimitive._shift.set(0, 0, 0);
        var positionCount = WireframePrimitive.circlePositionCount;
        var indexCount = WireframePrimitive.circleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    LineDrawer.flush = function flush() {
        LineDrawer._positionCount = 0;
        LineDrawer._indicesCount = 0;
    };
    LineDrawer._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = LineDrawer._indices;
        var neededLength = LineDrawer._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = LineDrawer._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = LineDrawer._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            LineDrawer._indices = newIndices;
        }
    };
    LineDrawer._growthPosition = function _growthPosition(length) {
        var position = LineDrawer._positions;
        var neededLength = LineDrawer._positionCount + length;
        if (neededLength > position.length) {
            for(var i = 0, n = neededLength - position.length; i < n; i++){
                position.push(new Vector3());
            }
        }
    };
    _create_class(LineDrawer, [
        {
            key: "color",
            set: /**
   * Color of the material.
   * By default, color is (1,1,1,1).
   */ function set(value) {
                this._material.baseColor.copyFrom(value);
            }
        }
    ]);
    return LineDrawer;
}(Script);
LineDrawer._positions = [];
LineDrawer._positionCount = 0;
LineDrawer._indicesCount = 0;
/**
   * The LineDrawer.matrix stores the position, rotation and scale of the LineDrawer.
   * By default, LineDrawer always uses world coordinates.
   * The default LineDrawer.matrix transforms the world coordinates using a default identity matrix.
   */ LineDrawer.matrix = null;
LineDrawer = __decorate([
    dependentComponents(MeshRenderer, DependentMode.CheckOnly)
], LineDrawer);
var AxisType;
(function(AxisType) {
    AxisType[AxisType["X"] = 0] = "X";
    AxisType[AxisType["Y"] = 1] = "Y";
    AxisType[AxisType["Z"] = 2] = "Z";
})(AxisType || (AxisType = {}));

export { AxisType, LineDrawer };
//# sourceMappingURL=LineDrawer.js.map
