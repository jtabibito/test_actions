import { Vector3, MathUtil } from '@galacean/engine';

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

/**
 * Wireframe primitive.
 */ var WireframePrimitive = /*#__PURE__*/ function() {
    function WireframePrimitive() {}
    /**
   * Store cuboid wireframe mesh data.
   * The origin located in center of cuboid.
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCuboidWireframe = function createCuboidWireframe(width, height, depth, positions, positionOffset, indices, indicesOffset) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var offset = positionOffset;
        // Up
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        // Down
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Left
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Right
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        // Front
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Back
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Up
        indices[indicesOffset++] = positionOffset;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset;
        // Down
        indices[indicesOffset++] = positionOffset + 4;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 4;
        // Left
        indices[indicesOffset++] = positionOffset + 8;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 8;
        // Right
        indices[indicesOffset++] = positionOffset + 12;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 12;
        // Front
        indices[indicesOffset++] = positionOffset + 16;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 16;
        // Back
        indices[indicesOffset++] = positionOffset + 20;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 20;
    };
    /**
   * Store sphere wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - Sphere radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createSphereWireframe = function createSphereWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // X
        WireframePrimitive.createCircleWireframe(radius, 0, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount * 2, indices, indicesOffset + WireframePrimitive.circleIndexCount * 2);
    };
    /**
   * Store cone wireframe mesh data.
   * The origin located in top of cone.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createConeWireframe = function createConeWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, -height, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(-radius, -height, 0);
        positions[offset++].set(radius, -height, 0);
        positions[offset++].set(0, -height, radius);
        positions[offset++].set(0, -height, -radius);
        indicesOffset += WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 4;
    };
    /**
   * Store unbound cylinder wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - The radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createUnboundCylinderWireframe = function createUnboundCylinderWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        var height = 5;
        WireframePrimitive._shift.set(0, 0, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        indicesOffset += WireframePrimitive.circleIndexCount;
        for(var i = 0; i < 8; i++){
            var radian = MathUtil.degreeToRadian(45 * i);
            positions[offset++].set(radius * Math.cos(radian), 0, radius * Math.sin(radian));
            positions[offset++].set(radius * Math.cos(radian), -height, radius * Math.sin(radian));
            indices[indicesOffset + i * 2] = indexBegin + 2 * i;
            indices[indicesOffset + i * 2 + 1] = indexBegin + 2 * i + 1;
        }
    };
    /**
   * Store capsule wireframe mesh data.
   * The origin located in center of capsule.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCapsuleWireframe = function createCapsuleWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        var vertexCount = WireframePrimitive.circleVertexCount;
        var halfHeight = height / 2;
        // Y-Top
        WireframePrimitive._shift.set(0, halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y-Bottom
        WireframePrimitive._shift.set(0, -halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + vertexCount, indices, indicesOffset + circleIndicesCount);
        // X-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 2, positions, positionOffset + vertexCount * 2, indices, indicesOffset + circleIndicesCount * 2);
        // Z-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 0, positions, positionOffset + vertexCount * 3, indices, indicesOffset + circleIndicesCount * 2 + WireframePrimitive.ellipticIndexCount);
    };
    /**
   * Store circle wireframe mesh data.
   * @param radius - The radius
   * @param axis - The default direction
   * @param shift - The default shift
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCircleWireframe = function createCircleWireframe(radius, axis, shift, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(shift.x, radius * Math.cos(thetaDelta) + shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, radius * Math.sin(thetaDelta) + shift.y, shift.z);
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store elliptic wireframe mesh data.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createEllipticWireframe = function createEllipticWireframe(radius, height, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta) + height, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta), height, radius * Math.sin(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta), radius * Math.sin(thetaDelta) + height, 0);
                    break;
            }
            if (i == vertexCount / 2) {
                height = -height;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store frustum wireframe mesh data.
   * The origin located in the center of cap.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param angle - The angle of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createFrustumWireframe = function createFrustumWireframe(radius, height, angle, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        WireframePrimitive._shift.set(0, 0, -height);
        var radian = MathUtil.degreeToRadian(angle);
        var dirTanA = Math.tan(radian);
        var bottomRadius = radius + dirTanA * height;
        WireframePrimitive.createCircleWireframe(bottomRadius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        var indexBegin = positionOffset + 2 * WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(0, 0, -height);
        positions[offset++].set(radius, 0, 0);
        positions[offset++].set(bottomRadius, 0, -height);
        positions[offset++].set(-radius, 0, 0);
        positions[offset++].set(-bottomRadius, 0, -height);
        positions[offset++].set(0, radius, 0);
        positions[offset++].set(0, bottomRadius, -height);
        positions[offset++].set(0, -radius, 0);
        positions[offset++].set(0, -bottomRadius, -height);
        indicesOffset += 2 * WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin + 4;
        indices[indicesOffset++] = indexBegin + 5;
        indices[indicesOffset++] = indexBegin + 6;
        indices[indicesOffset++] = indexBegin + 7;
        indices[indicesOffset++] = indexBegin + 8;
        indices[indicesOffset++] = indexBegin + 9;
    };
    /**
   * Store hemisphere wireframe mesh data.
   * @param radius - The radius of hemisphere
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createHemisphereWireframe = function createHemisphereWireframe(radius, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount / 2;
        var twoPi = Math.PI;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount + 1; i++){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta), 0, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta), radius * Math.cos(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(-radius * Math.cos(thetaDelta), 0, -radius * Math.sin(thetaDelta));
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            }
        }
        indicesOffset += WireframePrimitive.circleVertexCount;
        for(var i1 = 0; i1 < vertexCount + 1; i1++){
            var v1 = i1 * countReciprocal;
            var thetaDelta1 = v1 * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta1), radius * Math.cos(thetaDelta1), 0);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta1), radius * Math.sin(thetaDelta1), 0);
                    break;
                case 2:
                    positions[offset++].set(0, -radius * Math.cos(thetaDelta1), -radius * Math.sin(thetaDelta1));
                    break;
            }
            var globalIndex1 = i1 + positionOffset + vertexCount + 1;
            if (i1 < vertexCount) {
                indices[indicesOffset + 2 * i1] = globalIndex1;
                indices[indicesOffset + 2 * i1 + 1] = globalIndex1 + 1;
            }
        }
        WireframePrimitive._shift.set(0, 0, 0);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount + 2, indices, indicesOffset + WireframePrimitive.circleVertexCount);
    };
    _create_class(WireframePrimitive, null, [
        {
            key: "cuboidIndexCount",
            get: /**
   * Get cuboid wire frame index count.
   */ function get() {
                return 48;
            }
        },
        {
            key: "cuboidPositionCount",
            get: /**
   * Get cuboid wire frame position count.
   */ function get() {
                return 24;
            }
        },
        {
            key: "sphereIndexCount",
            get: /**
   * Get sphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 3;
            }
        },
        {
            key: "spherePositionCount",
            get: /**
   * Get sphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount * 3;
            }
        },
        {
            key: "coneIndexCount",
            get: /**
   * Get cone wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 8;
            }
        },
        {
            key: "conePositionCount",
            get: /**
   * Get cone wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 5;
            }
        },
        {
            key: "unboundCylinderIndexCount",
            get: /**
   * Get unbound cylinder wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 16;
            }
        },
        {
            key: "unboundCylinderPositionCount",
            get: /**
   * Get unbound cylinder wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 16;
            }
        },
        {
            key: "capsuleIndexCount",
            get: /**
   * Get capsule wire frame index count.
   */ function get() {
                return (WireframePrimitive.circleIndexCount + WireframePrimitive.ellipticIndexCount) * 2;
            }
        },
        {
            key: "capsulePositionCount",
            get: /**
   * Get capsule wire frame position count.
   */ function get() {
                return (WireframePrimitive.circlePositionCount + WireframePrimitive.ellipticPositionCount) * 2;
            }
        },
        {
            key: "circleIndexCount",
            get: /**
   * Get circle wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "circlePositionCount",
            get: /**
   * Get circle wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "ellipticIndexCount",
            get: /**
   * Get elliptic wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "ellipticPositionCount",
            get: /**
   * Get elliptic wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "frustumIndexCount",
            get: /**
   * Get frustum wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 2 + 10;
            }
        },
        {
            key: "frustumPositionCount",
            get: /**
   * Get frustum wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + 10;
            }
        },
        {
            key: "hemisphereIndexCount",
            get: /**
   * Get hemisphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + WireframePrimitive.circleIndexCount;
            }
        },
        {
            key: "hemispherePositionCount",
            get: /**
   * Get hemisphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount + 2 + WireframePrimitive.circlePositionCount;
            }
        }
    ]);
    return WireframePrimitive;
}();
WireframePrimitive._shift = new Vector3();
/** global settings for vertex count */ WireframePrimitive.circleVertexCount = 40;

export { WireframePrimitive as W, _create_class as _ };
//# sourceMappingURL=WireframePrimitive-80c67e9d.js.map
