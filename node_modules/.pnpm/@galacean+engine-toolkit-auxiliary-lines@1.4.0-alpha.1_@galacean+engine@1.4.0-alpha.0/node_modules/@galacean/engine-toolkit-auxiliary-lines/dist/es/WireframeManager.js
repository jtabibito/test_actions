import { W as WireframePrimitive, _ as _create_class } from './WireframePrimitive-80c67e9d.js';
import { _ as __decorate, a as _inherits } from './tslib.es6-c8446176.js';
import { Vector3, Matrix, Quaternion, dependentComponents, MeshRenderer, DependentMode, Camera, SpotLight, DirectLight, PointLight, Collider, ParticleRenderer, ColliderShapeUpAxis, ModelMesh, GLCapabilityType, MeshTopology, BoxColliderShape, SphereColliderShape, CapsuleColliderShape, Script } from '@galacean/engine';
import { PlainColorMaterial } from '@galacean/engine-toolkit-custom-material';

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

var WireframeManager = /*#__PURE__*/ function(Script) {
    _inherits(WireframeManager, Script);
    function WireframeManager() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._cameraPositions = [
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3()
        ];
        _this._localPositions = [];
        _this._globalPositions = [];
        _this._indices = null;
        _this._indicesCount = 0;
        _this._boundsIndicesCount = 0;
        _this._wireframeRenderers = [];
        _this._wireframeElements = [];
        return _this;
    }
    var _proto = WireframeManager.prototype;
    /**
   * Clear all wireframe.
   */ _proto.clear = function clear() {
        this._wireframeRenderers.length = 0;
        this._wireframeElements.length = 0;
        this._localPositions.length = 0;
        this._globalPositions.length = 0;
        this._indicesCount = 0;
        this._mesh.subMesh.count = 0;
    };
    /**
   * Create auxiliary mesh for entity.
   * @param entity - The entity
   * @param includeChildren - whether include child entity(default is true)
   */ _proto.addEntityWireframe = function addEntityWireframe(entity, includeChildren) {
        if (includeChildren === void 0) includeChildren = true;
        if (includeChildren) {
            var components = new Array();
            entity.getComponentsIncludeChildren(Camera, components);
            for(var i = 0, n = components.length; i < n; i++){
                this.addCameraWireframe(components[i]);
            }
            var componentsOffset = components.length;
            entity.getComponentsIncludeChildren(SpotLight, components);
            for(var i1 = componentsOffset, n1 = components.length; i1 < n1; i1++){
                this.addSpotLightWireframe(components[i1]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(DirectLight, components);
            for(var i2 = componentsOffset, n2 = components.length; i2 < n2; i2++){
                this.addDirectLightWireframe(components[i2]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(PointLight, components);
            for(var i3 = componentsOffset, n3 = components.length; i3 < n3; i3++){
                this.addPointLightWireframe(components[i3]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(Collider, components);
            for(var i4 = componentsOffset, n4 = components.length; i4 < n4; i4++){
                this.addCollideWireframe(components[i4]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(ParticleRenderer, components);
            for(var i5 = componentsOffset, n5 = components.length; i5 < n5; i5++){
                this.addParticleRendererEmissionShapeWireframe(components[i5]);
            }
        } else {
            var camera = entity.getComponent(Camera);
            camera && this.addCameraWireframe(camera);
            var spotLight = entity.getComponent(SpotLight);
            spotLight && this.addSpotLightWireframe(spotLight);
            var directLight = entity.getComponent(DirectLight);
            directLight && this.addDirectLightWireframe(directLight);
            var pointLight = entity.getComponent(PointLight);
            pointLight && this.addPointLightWireframe(pointLight);
            var collider = entity.getComponent(Collider);
            collider && this.addCollideWireframe(collider);
            var particle = entity.getComponent(ParticleRenderer);
            particle && this.addParticleRendererEmissionShapeWireframe(particle);
        }
    };
    /**
   * Create auxiliary mesh for camera.
   * @param camera - The Camera
   */ _proto.addCameraWireframe = function addCameraWireframe(camera) {
        var transform = camera.entity.transform;
        var inverseProj = camera.projectionMatrix.clone();
        inverseProj.invert();
        var localPositions = this._localPositions;
        var positionsOffset = localPositions.length;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
        var ndcPosition = WireframeManager._ndcPosition;
        // front
        for(var i = 0; i < 4; i++){
            var newPosition = this._cameraPositions[i];
            newPosition.copyFrom(ndcPosition[i]);
            newPosition.transformCoordinate(inverseProj);
            localPositions.push(newPosition);
        }
        // back
        for(var i1 = 0; i1 < 4; i1++){
            var newPosition1 = this._cameraPositions[i1 + 4];
            newPosition1.copyFrom(ndcPosition[i1]);
            newPosition1.z = 1;
            newPosition1.transformCoordinate(inverseProj);
            localPositions.push(newPosition1);
        }
        this._growthIndexMemory(24);
        var indices = this._indices;
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset; // front
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 7; // link
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 4; // back
    };
    /**
   * Create auxiliary mesh for spot light.
   * @param light - The SpotLight
   */ _proto.addSpotLightWireframe = function addSpotLightWireframe(light) {
        var height = light.distance;
        var radius = Math.tan(light.angle / 2) * height;
        var positionsOffset = this._localPositions.length;
        var coneIndicesCount = WireframePrimitive.coneIndexCount;
        this._growthIndexMemory(coneIndicesCount);
        this._growthPosition(WireframePrimitive.conePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createConeWireframe(radius, height, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += coneIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for point light.
   * @param light - The PointLight
   */ _proto.addPointLightWireframe = function addPointLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(light.distance, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for directional light.
   * @param light - The DirectLight
   */ _proto.addDirectLightWireframe = function addDirectLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var unboundCylinderIndicesCount = WireframePrimitive.unboundCylinderIndexCount;
        this._growthIndexMemory(unboundCylinderIndicesCount);
        this._growthPosition(WireframePrimitive.unboundCylinderPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createUnboundCylinderWireframe(1, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += unboundCylinderIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for renderer axis-aligned boundingbox.
   * @param renderer - The Renderer
   */ _proto.addRendererWireframe = function addRendererWireframe(renderer) {
        this._boundsIndicesCount += WireframePrimitive.cuboidIndexCount;
        this._wireframeRenderers.push(renderer);
    };
    /**
   * Create auxiliary mesh for collider.
   * @param collider - The Collider
   */ _proto.addCollideWireframe = function addCollideWireframe(collider) {
        var shapes = collider.shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            var shape = shapes[i];
            if (_instanceof(shape, BoxColliderShape)) {
                this.addBoxColliderShapeWireframe(shape);
            } else if (_instanceof(shape, SphereColliderShape)) {
                this.addSphereColliderShapeWireframe(shape);
            } else if (_instanceof(shape, CapsuleColliderShape)) {
                this.addCapsuleColliderShapeWireframe(shape);
            }
        }
    };
    /**
   * Create auxiliary mesh for box collider shape.
   * @param shape - The BoxColliderShape
   */ _proto.addBoxColliderShapeWireframe = function addBoxColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, size = shape.size;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(worldScale.x * size.x, worldScale.y * size.y, worldScale.z * size.z, localPositions, positionsOffset, indices, this._indicesCount);
        Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for sphere collider shape.
   * @param shape - The SphereColliderShape
   */ _proto.addSphereColliderShapeWireframe = function addSphereColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, radius = shape.radius;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(Math.max(worldScale.x, worldScale.y, worldScale.z) * radius, localPositions, positionsOffset, indices, this._indicesCount);
        Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for capsule collider shape.
   * @param shape - The CapsuleColliderShape
   */ _proto.addCapsuleColliderShapeWireframe = function addCapsuleColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var maxScale = Math.max(worldScale.x, worldScale.y, worldScale.z);
        var radius = shape.radius, height = shape.height, upAxis = shape.upAxis, position = shape.position, rotation = shape.rotation;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation, tempAxis = WireframeManager._tempAxis, halfSqrt = WireframeManager._halfSqrt;
        var positionsOffset = this._localPositions.length;
        var capsuleIndicesCount = WireframePrimitive.capsuleIndexCount;
        this._growthIndexMemory(capsuleIndicesCount);
        this._growthPosition(WireframePrimitive.capsulePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCapsuleWireframe(maxScale * radius, maxScale * height, localPositions, positionsOffset, indices, this._indicesCount);
        switch(upAxis){
            case ColliderShapeUpAxis.X:
                tempAxis.set(0, 0, halfSqrt, halfSqrt);
                break;
            case ColliderShapeUpAxis.Y:
                tempAxis.set(0, 0, 0, 1);
                break;
            case ColliderShapeUpAxis.Z:
                tempAxis.set(halfSqrt, 0, 0, halfSqrt);
        }
        Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        Quaternion.multiply(tempRotation, tempAxis, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += capsuleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    _proto.addParticleRendererEmissionShapeWireframe = function addParticleRendererEmissionShapeWireframe(particleRenderer) {
        if (particleRenderer.generator.emission.enabled) {
            var shape = particleRenderer.generator.emission.shape;
            var transform = particleRenderer.entity.transform;
            switch(shape == null ? void 0 : shape.shapeType){
                case 0:
                    this.addBoxParticleShapeWireframe(shape, transform);
                    break;
                case 1:
                    this.addCircleParticleShapeWireframe(shape, transform);
                    break;
                case 2:
                    this.addConeParticleShapeWireframe(shape, transform);
                    break;
                case 3:
                    this.addHemisphereParticleShapeWireframe(shape, transform);
                    break;
                case 4:
                    this.addSphereParticleShapeWireframe(shape, transform);
                    break;
            }
        }
    };
    _proto.addBoxParticleShapeWireframe = function addBoxParticleShapeWireframe(shape, transform) {
        var size = shape.size;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(size.x, size.y, size.z, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addCircleParticleShapeWireframe = function addCircleParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        this._growthIndexMemory(circleIndicesCount);
        this._growthPosition(WireframePrimitive.circlePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCircleWireframe(radius, 0, new Vector3(), localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += circleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addConeParticleShapeWireframe = function addConeParticleShapeWireframe(shape, transform) {
        var radius = shape.radius, length = shape.length, angle = shape.angle;
        var positionsOffset = this._localPositions.length;
        var frustumIndicesCount = WireframePrimitive.frustumIndexCount;
        this._growthIndexMemory(frustumIndicesCount);
        this._growthPosition(WireframePrimitive.frustumPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createFrustumWireframe(radius, length, angle, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += frustumIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addHemisphereParticleShapeWireframe = function addHemisphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var hemisphereIndicesCount = WireframePrimitive.hemisphereIndexCount;
        this._growthIndexMemory(hemisphereIndicesCount);
        this._growthPosition(WireframePrimitive.hemispherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createHemisphereWireframe(radius, 2, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += hemisphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addSphereParticleShapeWireframe = function addSphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(radius, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.onAwake = function onAwake() {
        var engine = this.engine;
        var mesh = new ModelMesh(engine);
        var material = new PlainColorMaterial(engine);
        var renderer = this.entity.getComponent(MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint);
        mesh.addSubMesh(0, this._indicesCount, MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        this._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        this._supportUint32Array = supportUint32Array;
    };
    _proto.onEnable = function onEnable() {
        this._renderer.enabled = true;
    };
    _proto.onDisable = function onDisable() {
        this._renderer.enabled = false;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh, localPositions = _this._localPositions, globalPositions = _this._globalPositions, wireframeElements = _this._wireframeElements, wireframeRenderers = _this._wireframeRenderers, indices = _this._indices;
        // update local to world geometry
        var localPositionLength = localPositions.length;
        globalPositions.length = localPositionLength;
        var positionIndex = 0;
        var needUpdate = false;
        for(var i = 0, n = wireframeElements.length; i < n; i++){
            var wireframeElement = wireframeElements[i];
            var beginIndex = wireframeElement.transformRanges;
            var endIndex = i < n - 1 ? wireframeElements[i + 1].transformRanges : localPositionLength;
            if (wireframeElement.updateFlag.flag) {
                var transform = wireframeElement.transform;
                var worldMatrix = WireframeManager._tempMatrix;
                if (wireframeElement.isScaleIgnored) {
                    Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, worldMatrix);
                } else {
                    worldMatrix.copyFrom(transform.worldMatrix);
                }
                for(var j = beginIndex; j < endIndex; j++){
                    var localPosition = localPositions[positionIndex];
                    var globalPosition = WireframeManager._getPositionFromPool(positionIndex);
                    Vector3.transformCoordinate(localPosition, worldMatrix, globalPosition);
                    globalPositions[positionIndex] = globalPosition;
                    positionIndex++;
                }
                wireframeElement.updateFlag.flag = false;
                needUpdate = true;
            } else {
                positionIndex += endIndex - beginIndex;
            }
        }
        // update world-space geometry
        this._growthIndexMemory(this._boundsIndicesCount);
        var indicesCount = this._indicesCount;
        for(var i1 = 0; i1 < wireframeRenderers.length; i1++){
            var renderer = wireframeRenderers[i1];
            var bounds = renderer.bounds;
            var tempVector = WireframeManager._tempVector;
            bounds.getExtent(tempVector);
            var positionsOffset = globalPositions.length;
            WireframePrimitive.createCuboidWireframe(tempVector.x * 2, tempVector.y * 2, tempVector.z * 2, globalPositions, positionsOffset, indices, indicesCount);
            bounds.getCenter(tempVector);
            for(var i2 = positionsOffset; i2 < globalPositions.length; i2++){
                var position = globalPositions[i2];
                position.add(tempVector);
            }
            indicesCount += WireframePrimitive.cuboidIndexCount;
        }
        if (wireframeRenderers.length > 0 || needUpdate) {
            mesh.setPositions(globalPositions);
            mesh.setIndices(this._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = indicesCount;
        }
        if (indicesCount === 0) {
            this._renderer.setMaterial(null);
        } else {
            this._renderer.setMaterial(this._material);
        }
    };
    _proto._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = this._indices;
        var neededLength = this._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = this._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = this._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            this._indices = newIndices;
        }
    };
    _proto._growthPosition = function _growthPosition(length) {
        var position = this._localPositions;
        for(var i = 0; i < length; i++){
            position.push(new Vector3());
        }
    };
    _proto._localTranslate = function _localTranslate(positionsOffset, offset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            position.add(offset);
        }
    };
    _proto._localRotation = function _localRotation(positionsOffset, rotation) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            Vector3.transformByQuat(position, rotation, position);
        }
    };
    _proto._rotateAroundX = function _rotateAroundX(positionsOffset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            var py = position.y;
            var pz = position.z;
            position.z = py;
            position.y = -pz;
        }
    };
    WireframeManager._getPositionFromPool = function _getPositionFromPool(positionIndex) {
        var position;
        var positionPool = WireframeManager._positionPool;
        if (positionIndex < positionPool.length) {
            position = positionPool[positionIndex];
        } else {
            position = new Vector3();
            WireframeManager._positionPool.push(position);
        }
        return position;
    };
    _create_class(WireframeManager, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this._material.baseColor;
            },
            set: function set(value) {
                this._material.baseColor = value;
            }
        }
    ]);
    return WireframeManager;
}(Script);
WireframeManager._positionPool = [];
WireframeManager._ndcPosition = [
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1),
    new Vector3(1, -1, -1),
    new Vector3(-1, -1, -1)
];
WireframeManager._tempMatrix = new Matrix();
WireframeManager._tempVector = new Vector3();
WireframeManager._tempRotation = new Quaternion();
WireframeManager._tempAxis = new Quaternion();
WireframeManager._halfSqrt = 0.70710678118655;
WireframeManager = __decorate([
    dependentComponents(MeshRenderer, DependentMode.CheckOnly)
], WireframeManager);
/**
 * @internal
 * Store Wireframe element info.
 */ var WireframeElement = function WireframeElement(transform, transformRanges, isScaleIgnored) {
    if (isScaleIgnored === void 0) isScaleIgnored = true;
    this.transform = transform;
    this.transformRanges = transformRanges;
    this.isScaleIgnored = isScaleIgnored;
    this.updateFlag = transform.registerWorldChangeFlag();
};

export { WireframeManager };
//# sourceMappingURL=WireframeManager.js.map
