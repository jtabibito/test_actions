'use strict';

var engine = require('@galacean/engine');
var engineToolkitCustomMaterial = require('@galacean/engine-toolkit-custom-material');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Wireframe primitive.
 */ var WireframePrimitive = /*#__PURE__*/ function() {
    function WireframePrimitive() {}
    /**
   * Store cuboid wireframe mesh data.
   * The origin located in center of cuboid.
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCuboidWireframe = function createCuboidWireframe(width, height, depth, positions, positionOffset, indices, indicesOffset) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var offset = positionOffset;
        // Up
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        // Down
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Left
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Right
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        // Front
        positions[offset++].set(-halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, halfHeight, halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, halfDepth);
        // Back
        positions[offset++].set(-halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, halfHeight, -halfDepth);
        positions[offset++].set(halfWidth, -halfHeight, -halfDepth);
        positions[offset++].set(-halfWidth, -halfHeight, -halfDepth);
        // Up
        indices[indicesOffset++] = positionOffset;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 1;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 2;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset + 3;
        indices[indicesOffset++] = positionOffset;
        // Down
        indices[indicesOffset++] = positionOffset + 4;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 5;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 6;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 7;
        indices[indicesOffset++] = positionOffset + 4;
        // Left
        indices[indicesOffset++] = positionOffset + 8;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 9;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 10;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 11;
        indices[indicesOffset++] = positionOffset + 8;
        // Right
        indices[indicesOffset++] = positionOffset + 12;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 13;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 14;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 15;
        indices[indicesOffset++] = positionOffset + 12;
        // Front
        indices[indicesOffset++] = positionOffset + 16;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 17;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 18;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 19;
        indices[indicesOffset++] = positionOffset + 16;
        // Back
        indices[indicesOffset++] = positionOffset + 20;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 21;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 22;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 23;
        indices[indicesOffset++] = positionOffset + 20;
    };
    /**
   * Store sphere wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - Sphere radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createSphereWireframe = function createSphereWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // X
        WireframePrimitive.createCircleWireframe(radius, 0, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount * 2, indices, indicesOffset + WireframePrimitive.circleIndexCount * 2);
    };
    /**
   * Store cone wireframe mesh data.
   * The origin located in top of cone.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createConeWireframe = function createConeWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, -height, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(-radius, -height, 0);
        positions[offset++].set(radius, -height, 0);
        positions[offset++].set(0, -height, radius);
        positions[offset++].set(0, -height, -radius);
        indicesOffset += WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 4;
    };
    /**
   * Store unbound cylinder wireframe mesh data.
   * The origin located in center of sphere.
   * @param radius - The radius
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createUnboundCylinderWireframe = function createUnboundCylinderWireframe(radius, positions, positionOffset, indices, indicesOffset) {
        var height = 5;
        WireframePrimitive._shift.set(0, 0, 0);
        // Y
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        var indexBegin = positionOffset + WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        indicesOffset += WireframePrimitive.circleIndexCount;
        for(var i = 0; i < 8; i++){
            var radian = engine.MathUtil.degreeToRadian(45 * i);
            positions[offset++].set(radius * Math.cos(radian), 0, radius * Math.sin(radian));
            positions[offset++].set(radius * Math.cos(radian), -height, radius * Math.sin(radian));
            indices[indicesOffset + i * 2] = indexBegin + 2 * i;
            indices[indicesOffset + i * 2 + 1] = indexBegin + 2 * i + 1;
        }
    };
    /**
   * Store capsule wireframe mesh data.
   * The origin located in center of capsule.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCapsuleWireframe = function createCapsuleWireframe(radius, height, positions, positionOffset, indices, indicesOffset) {
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        var vertexCount = WireframePrimitive.circleVertexCount;
        var halfHeight = height / 2;
        // Y-Top
        WireframePrimitive._shift.set(0, halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        // Y-Bottom
        WireframePrimitive._shift.set(0, -halfHeight, 0);
        WireframePrimitive.createCircleWireframe(radius, 1, WireframePrimitive._shift, positions, positionOffset + vertexCount, indices, indicesOffset + circleIndicesCount);
        // X-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 2, positions, positionOffset + vertexCount * 2, indices, indicesOffset + circleIndicesCount * 2);
        // Z-Elliptic
        WireframePrimitive.createEllipticWireframe(radius, halfHeight, 0, positions, positionOffset + vertexCount * 3, indices, indicesOffset + circleIndicesCount * 2 + WireframePrimitive.ellipticIndexCount);
    };
    /**
   * Store circle wireframe mesh data.
   * @param radius - The radius
   * @param axis - The default direction
   * @param shift - The default shift
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createCircleWireframe = function createCircleWireframe(radius, axis, shift, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(shift.x, radius * Math.cos(thetaDelta) + shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, shift.y, radius * Math.sin(thetaDelta) + shift.z);
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta) + shift.x, radius * Math.sin(thetaDelta) + shift.y, shift.z);
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store elliptic wireframe mesh data.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createEllipticWireframe = function createEllipticWireframe(radius, height, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount;
        var twoPi = Math.PI * 2;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount; ++i){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta) + height, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta), height, radius * Math.sin(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(radius * Math.cos(thetaDelta), radius * Math.sin(thetaDelta) + height, 0);
                    break;
            }
            if (i == vertexCount / 2) {
                height = -height;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount - 1) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            } else {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = positionOffset;
            }
        }
    };
    /**
   * Store frustum wireframe mesh data.
   * The origin located in the center of cap.
   * @param radius - The radius of cap
   * @param height - The height of cone
   * @param angle - The angle of cone
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createFrustumWireframe = function createFrustumWireframe(radius, height, angle, positions, positionOffset, indices, indicesOffset) {
        WireframePrimitive._shift.set(0, 0, 0);
        // Z
        WireframePrimitive.createCircleWireframe(radius, 2, WireframePrimitive._shift, positions, positionOffset, indices, indicesOffset);
        WireframePrimitive._shift.set(0, 0, -height);
        var radian = engine.MathUtil.degreeToRadian(angle);
        var dirTanA = Math.tan(radian);
        var bottomRadius = radius + dirTanA * height;
        WireframePrimitive.createCircleWireframe(bottomRadius, 2, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount, indices, indicesOffset + WireframePrimitive.circleIndexCount);
        var indexBegin = positionOffset + 2 * WireframePrimitive.circleVertexCount;
        var offset = indexBegin;
        positions[offset++].set(0, 0, 0);
        positions[offset++].set(0, 0, -height);
        positions[offset++].set(radius, 0, 0);
        positions[offset++].set(bottomRadius, 0, -height);
        positions[offset++].set(-radius, 0, 0);
        positions[offset++].set(-bottomRadius, 0, -height);
        positions[offset++].set(0, radius, 0);
        positions[offset++].set(0, bottomRadius, -height);
        positions[offset++].set(0, -radius, 0);
        positions[offset++].set(0, -bottomRadius, -height);
        indicesOffset += 2 * WireframePrimitive.circleIndexCount;
        indices[indicesOffset++] = indexBegin;
        indices[indicesOffset++] = indexBegin + 1;
        indices[indicesOffset++] = indexBegin + 2;
        indices[indicesOffset++] = indexBegin + 3;
        indices[indicesOffset++] = indexBegin + 4;
        indices[indicesOffset++] = indexBegin + 5;
        indices[indicesOffset++] = indexBegin + 6;
        indices[indicesOffset++] = indexBegin + 7;
        indices[indicesOffset++] = indexBegin + 8;
        indices[indicesOffset++] = indexBegin + 9;
    };
    /**
   * Store hemisphere wireframe mesh data.
   * @param radius - The radius of hemisphere
   * @param axis - The default direction
   * @param positions - position array
   * @param positionOffset - The min of index list
   * @param indices - index array
   * @param indicesOffset - index array offset
   */ WireframePrimitive.createHemisphereWireframe = function createHemisphereWireframe(radius, axis, positions, positionOffset, indices, indicesOffset) {
        var vertexCount = WireframePrimitive.circleVertexCount / 2;
        var twoPi = Math.PI;
        var countReciprocal = 1.0 / vertexCount;
        var offset = positionOffset;
        for(var i = 0; i < vertexCount + 1; i++){
            var v = i * countReciprocal;
            var thetaDelta = v * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta), 0, radius * Math.cos(thetaDelta));
                    break;
                case 1:
                    positions[offset++].set(0, radius * Math.sin(thetaDelta), radius * Math.cos(thetaDelta));
                    break;
                case 2:
                    positions[offset++].set(-radius * Math.cos(thetaDelta), 0, -radius * Math.sin(thetaDelta));
                    break;
            }
            var globalIndex = i + positionOffset;
            if (i < vertexCount) {
                indices[indicesOffset + 2 * i] = globalIndex;
                indices[indicesOffset + 2 * i + 1] = globalIndex + 1;
            }
        }
        indicesOffset += WireframePrimitive.circleVertexCount;
        for(var i1 = 0; i1 < vertexCount + 1; i1++){
            var v1 = i1 * countReciprocal;
            var thetaDelta1 = v1 * twoPi;
            switch(axis){
                case 0:
                    positions[offset++].set(radius * Math.sin(thetaDelta1), radius * Math.cos(thetaDelta1), 0);
                    break;
                case 1:
                    positions[offset++].set(radius * Math.cos(thetaDelta1), radius * Math.sin(thetaDelta1), 0);
                    break;
                case 2:
                    positions[offset++].set(0, -radius * Math.cos(thetaDelta1), -radius * Math.sin(thetaDelta1));
                    break;
            }
            var globalIndex1 = i1 + positionOffset + vertexCount + 1;
            if (i1 < vertexCount) {
                indices[indicesOffset + 2 * i1] = globalIndex1;
                indices[indicesOffset + 2 * i1 + 1] = globalIndex1 + 1;
            }
        }
        WireframePrimitive._shift.set(0, 0, 0);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, positions, positionOffset + WireframePrimitive.circleVertexCount + 2, indices, indicesOffset + WireframePrimitive.circleVertexCount);
    };
    _create_class(WireframePrimitive, null, [
        {
            key: "cuboidIndexCount",
            get: /**
   * Get cuboid wire frame index count.
   */ function get() {
                return 48;
            }
        },
        {
            key: "cuboidPositionCount",
            get: /**
   * Get cuboid wire frame position count.
   */ function get() {
                return 24;
            }
        },
        {
            key: "sphereIndexCount",
            get: /**
   * Get sphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 3;
            }
        },
        {
            key: "spherePositionCount",
            get: /**
   * Get sphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount * 3;
            }
        },
        {
            key: "coneIndexCount",
            get: /**
   * Get cone wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 8;
            }
        },
        {
            key: "conePositionCount",
            get: /**
   * Get cone wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 5;
            }
        },
        {
            key: "unboundCylinderIndexCount",
            get: /**
   * Get unbound cylinder wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount + 16;
            }
        },
        {
            key: "unboundCylinderPositionCount",
            get: /**
   * Get unbound cylinder wire frame position count.
   */ function get() {
                return WireframePrimitive.circlePositionCount + 16;
            }
        },
        {
            key: "capsuleIndexCount",
            get: /**
   * Get capsule wire frame index count.
   */ function get() {
                return (WireframePrimitive.circleIndexCount + WireframePrimitive.ellipticIndexCount) * 2;
            }
        },
        {
            key: "capsulePositionCount",
            get: /**
   * Get capsule wire frame position count.
   */ function get() {
                return (WireframePrimitive.circlePositionCount + WireframePrimitive.ellipticPositionCount) * 2;
            }
        },
        {
            key: "circleIndexCount",
            get: /**
   * Get circle wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "circlePositionCount",
            get: /**
   * Get circle wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "ellipticIndexCount",
            get: /**
   * Get elliptic wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2;
            }
        },
        {
            key: "ellipticPositionCount",
            get: /**
   * Get elliptic wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount;
            }
        },
        {
            key: "frustumIndexCount",
            get: /**
   * Get frustum wire frame index count.
   */ function get() {
                return WireframePrimitive.circleIndexCount * 2 + 10;
            }
        },
        {
            key: "frustumPositionCount",
            get: /**
   * Get frustum wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + 10;
            }
        },
        {
            key: "hemisphereIndexCount",
            get: /**
   * Get hemisphere wire frame index count.
   */ function get() {
                return WireframePrimitive.circleVertexCount * 2 + WireframePrimitive.circleIndexCount;
            }
        },
        {
            key: "hemispherePositionCount",
            get: /**
   * Get hemisphere wire frame position count.
   */ function get() {
                return WireframePrimitive.circleVertexCount + 2 + WireframePrimitive.circlePositionCount;
            }
        }
    ]);
    return WireframePrimitive;
}();
WireframePrimitive._shift = new engine.Vector3();
/** global settings for vertex count */ WireframePrimitive.circleVertexCount = 40;

exports.WireframeManager = /*#__PURE__*/ function(Script) {
    _inherits(WireframeManager, Script);
    function WireframeManager() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._cameraPositions = [
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3(),
            new engine.Vector3()
        ];
        _this._localPositions = [];
        _this._globalPositions = [];
        _this._indices = null;
        _this._indicesCount = 0;
        _this._boundsIndicesCount = 0;
        _this._wireframeRenderers = [];
        _this._wireframeElements = [];
        return _this;
    }
    var _proto = WireframeManager.prototype;
    /**
   * Clear all wireframe.
   */ _proto.clear = function clear() {
        this._wireframeRenderers.length = 0;
        this._wireframeElements.length = 0;
        this._localPositions.length = 0;
        this._globalPositions.length = 0;
        this._indicesCount = 0;
        this._mesh.subMesh.count = 0;
    };
    /**
   * Create auxiliary mesh for entity.
   * @param entity - The entity
   * @param includeChildren - whether include child entity(default is true)
   */ _proto.addEntityWireframe = function addEntityWireframe(entity, includeChildren) {
        if (includeChildren === void 0) includeChildren = true;
        if (includeChildren) {
            var components = new Array();
            entity.getComponentsIncludeChildren(engine.Camera, components);
            for(var i = 0, n = components.length; i < n; i++){
                this.addCameraWireframe(components[i]);
            }
            var componentsOffset = components.length;
            entity.getComponentsIncludeChildren(engine.SpotLight, components);
            for(var i1 = componentsOffset, n1 = components.length; i1 < n1; i1++){
                this.addSpotLightWireframe(components[i1]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(engine.DirectLight, components);
            for(var i2 = componentsOffset, n2 = components.length; i2 < n2; i2++){
                this.addDirectLightWireframe(components[i2]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(engine.PointLight, components);
            for(var i3 = componentsOffset, n3 = components.length; i3 < n3; i3++){
                this.addPointLightWireframe(components[i3]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(engine.Collider, components);
            for(var i4 = componentsOffset, n4 = components.length; i4 < n4; i4++){
                this.addCollideWireframe(components[i4]);
            }
            componentsOffset = components.length;
            entity.getComponentsIncludeChildren(engine.ParticleRenderer, components);
            for(var i5 = componentsOffset, n5 = components.length; i5 < n5; i5++){
                this.addParticleRendererEmissionShapeWireframe(components[i5]);
            }
        } else {
            var camera = entity.getComponent(engine.Camera);
            camera && this.addCameraWireframe(camera);
            var spotLight = entity.getComponent(engine.SpotLight);
            spotLight && this.addSpotLightWireframe(spotLight);
            var directLight = entity.getComponent(engine.DirectLight);
            directLight && this.addDirectLightWireframe(directLight);
            var pointLight = entity.getComponent(engine.PointLight);
            pointLight && this.addPointLightWireframe(pointLight);
            var collider = entity.getComponent(engine.Collider);
            collider && this.addCollideWireframe(collider);
            var particle = entity.getComponent(engine.ParticleRenderer);
            particle && this.addParticleRendererEmissionShapeWireframe(particle);
        }
    };
    /**
   * Create auxiliary mesh for camera.
   * @param camera - The Camera
   */ _proto.addCameraWireframe = function addCameraWireframe(camera) {
        var transform = camera.entity.transform;
        var inverseProj = camera.projectionMatrix.clone();
        inverseProj.invert();
        var localPositions = this._localPositions;
        var positionsOffset = localPositions.length;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
        var ndcPosition = WireframeManager._ndcPosition;
        // front
        for(var i = 0; i < 4; i++){
            var newPosition = this._cameraPositions[i];
            newPosition.copyFrom(ndcPosition[i]);
            newPosition.transformCoordinate(inverseProj);
            localPositions.push(newPosition);
        }
        // back
        for(var i1 = 0; i1 < 4; i1++){
            var newPosition1 = this._cameraPositions[i1 + 4];
            newPosition1.copyFrom(ndcPosition[i1]);
            newPosition1.z = 1;
            newPosition1.transformCoordinate(inverseProj);
            localPositions.push(newPosition1);
        }
        this._growthIndexMemory(24);
        var indices = this._indices;
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset; // front
        indices[this._indicesCount++] = positionsOffset;
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 1;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 2;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 3;
        indices[this._indicesCount++] = positionsOffset + 7; // link
        indices[this._indicesCount++] = positionsOffset + 4;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 5;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 6;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 7;
        indices[this._indicesCount++] = positionsOffset + 4; // back
    };
    /**
   * Create auxiliary mesh for spot light.
   * @param light - The SpotLight
   */ _proto.addSpotLightWireframe = function addSpotLightWireframe(light) {
        var height = light.distance;
        var radius = Math.tan(light.angle / 2) * height;
        var positionsOffset = this._localPositions.length;
        var coneIndicesCount = WireframePrimitive.coneIndexCount;
        this._growthIndexMemory(coneIndicesCount);
        this._growthPosition(WireframePrimitive.conePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createConeWireframe(radius, height, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += coneIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for point light.
   * @param light - The PointLight
   */ _proto.addPointLightWireframe = function addPointLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(light.distance, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for directional light.
   * @param light - The DirectLight
   */ _proto.addDirectLightWireframe = function addDirectLightWireframe(light) {
        var positionsOffset = this._localPositions.length;
        var unboundCylinderIndicesCount = WireframePrimitive.unboundCylinderIndexCount;
        this._growthIndexMemory(unboundCylinderIndicesCount);
        this._growthPosition(WireframePrimitive.unboundCylinderPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createUnboundCylinderWireframe(1, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += unboundCylinderIndicesCount;
        // rotation to default transform forward direction(-Z)
        this._rotateAroundX(positionsOffset);
        this._wireframeElements.push(new WireframeElement(light.entity.transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for renderer axis-aligned boundingbox.
   * @param renderer - The Renderer
   */ _proto.addRendererWireframe = function addRendererWireframe(renderer) {
        this._boundsIndicesCount += WireframePrimitive.cuboidIndexCount;
        this._wireframeRenderers.push(renderer);
    };
    /**
   * Create auxiliary mesh for collider.
   * @param collider - The Collider
   */ _proto.addCollideWireframe = function addCollideWireframe(collider) {
        var shapes = collider.shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            var shape = shapes[i];
            if (_instanceof(shape, engine.BoxColliderShape)) {
                this.addBoxColliderShapeWireframe(shape);
            } else if (_instanceof(shape, engine.SphereColliderShape)) {
                this.addSphereColliderShapeWireframe(shape);
            } else if (_instanceof(shape, engine.CapsuleColliderShape)) {
                this.addCapsuleColliderShapeWireframe(shape);
            }
        }
    };
    /**
   * Create auxiliary mesh for box collider shape.
   * @param shape - The BoxColliderShape
   */ _proto.addBoxColliderShapeWireframe = function addBoxColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, size = shape.size;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(worldScale.x * size.x, worldScale.y * size.y, worldScale.z * size.z, localPositions, positionsOffset, indices, this._indicesCount);
        engine.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        engine.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for sphere collider shape.
   * @param shape - The SphereColliderShape
   */ _proto.addSphereColliderShapeWireframe = function addSphereColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var position = shape.position, rotation = shape.rotation, radius = shape.radius;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(Math.max(worldScale.x, worldScale.y, worldScale.z) * radius, localPositions, positionsOffset, indices, this._indicesCount);
        engine.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        engine.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    /**
   * Create auxiliary mesh for capsule collider shape.
   * @param shape - The CapsuleColliderShape
   */ _proto.addCapsuleColliderShapeWireframe = function addCapsuleColliderShapeWireframe(shape) {
        var transform = shape.collider.entity.transform;
        var worldScale = transform.lossyWorldScale;
        var maxScale = Math.max(worldScale.x, worldScale.y, worldScale.z);
        var radius = shape.radius, height = shape.height, upAxis = shape.upAxis, position = shape.position, rotation = shape.rotation;
        var tempVector = WireframeManager._tempVector, tempRotation = WireframeManager._tempRotation, tempAxis = WireframeManager._tempAxis, halfSqrt = WireframeManager._halfSqrt;
        var positionsOffset = this._localPositions.length;
        var capsuleIndicesCount = WireframePrimitive.capsuleIndexCount;
        this._growthIndexMemory(capsuleIndicesCount);
        this._growthPosition(WireframePrimitive.capsulePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCapsuleWireframe(maxScale * radius, maxScale * height, localPositions, positionsOffset, indices, this._indicesCount);
        switch(upAxis){
            case engine.ColliderShapeUpAxis.X:
                tempAxis.set(0, 0, halfSqrt, halfSqrt);
                break;
            case engine.ColliderShapeUpAxis.Y:
                tempAxis.set(0, 0, 0, 1);
                break;
            case engine.ColliderShapeUpAxis.Z:
                tempAxis.set(halfSqrt, 0, 0, halfSqrt);
        }
        engine.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, tempRotation);
        engine.Quaternion.multiply(tempRotation, tempAxis, tempRotation);
        this._localRotation(positionsOffset, tempRotation);
        engine.Vector3.multiply(position, worldScale, tempVector);
        this._localTranslate(positionsOffset, tempVector);
        this._indicesCount += capsuleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset));
    };
    _proto.addParticleRendererEmissionShapeWireframe = function addParticleRendererEmissionShapeWireframe(particleRenderer) {
        if (particleRenderer.generator.emission.enabled) {
            var shape = particleRenderer.generator.emission.shape;
            var transform = particleRenderer.entity.transform;
            switch(shape == null ? void 0 : shape.shapeType){
                case 0:
                    this.addBoxParticleShapeWireframe(shape, transform);
                    break;
                case 1:
                    this.addCircleParticleShapeWireframe(shape, transform);
                    break;
                case 2:
                    this.addConeParticleShapeWireframe(shape, transform);
                    break;
                case 3:
                    this.addHemisphereParticleShapeWireframe(shape, transform);
                    break;
                case 4:
                    this.addSphereParticleShapeWireframe(shape, transform);
                    break;
            }
        }
    };
    _proto.addBoxParticleShapeWireframe = function addBoxParticleShapeWireframe(shape, transform) {
        var size = shape.size;
        var positionsOffset = this._localPositions.length;
        var cuboidIndicesCount = WireframePrimitive.cuboidIndexCount;
        this._growthIndexMemory(cuboidIndicesCount);
        this._growthPosition(WireframePrimitive.cuboidPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCuboidWireframe(size.x, size.y, size.z, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += cuboidIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addCircleParticleShapeWireframe = function addCircleParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var circleIndicesCount = WireframePrimitive.circleIndexCount;
        this._growthIndexMemory(circleIndicesCount);
        this._growthPosition(WireframePrimitive.circlePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createCircleWireframe(radius, 0, new engine.Vector3(), localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += circleIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addConeParticleShapeWireframe = function addConeParticleShapeWireframe(shape, transform) {
        var radius = shape.radius, length = shape.length, angle = shape.angle;
        var positionsOffset = this._localPositions.length;
        var frustumIndicesCount = WireframePrimitive.frustumIndexCount;
        this._growthIndexMemory(frustumIndicesCount);
        this._growthPosition(WireframePrimitive.frustumPositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createFrustumWireframe(radius, length, angle, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += frustumIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addHemisphereParticleShapeWireframe = function addHemisphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var hemisphereIndicesCount = WireframePrimitive.hemisphereIndexCount;
        this._growthIndexMemory(hemisphereIndicesCount);
        this._growthPosition(WireframePrimitive.hemispherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createHemisphereWireframe(radius, 2, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += hemisphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.addSphereParticleShapeWireframe = function addSphereParticleShapeWireframe(shape, transform) {
        var radius = shape.radius;
        var positionsOffset = this._localPositions.length;
        var sphereIndicesCount = WireframePrimitive.sphereIndexCount;
        this._growthIndexMemory(sphereIndicesCount);
        this._growthPosition(WireframePrimitive.spherePositionCount);
        var _this = this, indices = _this._indices, localPositions = _this._localPositions;
        WireframePrimitive.createSphereWireframe(radius, localPositions, positionsOffset, indices, this._indicesCount);
        this._indicesCount += sphereIndicesCount;
        this._wireframeElements.push(new WireframeElement(transform, positionsOffset, false));
    };
    _proto.onAwake = function onAwake() {
        var engine$1 = this.engine;
        var mesh = new engine.ModelMesh(engine$1);
        var material = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
        var renderer = this.entity.getComponent(engine.MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine$1._hardwareRenderer.canIUse(engine.GLCapabilityType.elementIndexUint);
        mesh.addSubMesh(0, this._indicesCount, engine.MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        this._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        this._supportUint32Array = supportUint32Array;
    };
    _proto.onEnable = function onEnable() {
        this._renderer.enabled = true;
    };
    _proto.onDisable = function onDisable() {
        this._renderer.enabled = false;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh, localPositions = _this._localPositions, globalPositions = _this._globalPositions, wireframeElements = _this._wireframeElements, wireframeRenderers = _this._wireframeRenderers, indices = _this._indices;
        // update local to world geometry
        var localPositionLength = localPositions.length;
        globalPositions.length = localPositionLength;
        var positionIndex = 0;
        var needUpdate = false;
        for(var i = 0, n = wireframeElements.length; i < n; i++){
            var wireframeElement = wireframeElements[i];
            var beginIndex = wireframeElement.transformRanges;
            var endIndex = i < n - 1 ? wireframeElements[i + 1].transformRanges : localPositionLength;
            if (wireframeElement.updateFlag.flag) {
                var transform = wireframeElement.transform;
                var worldMatrix = WireframeManager._tempMatrix;
                if (wireframeElement.isScaleIgnored) {
                    engine.Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, worldMatrix);
                } else {
                    worldMatrix.copyFrom(transform.worldMatrix);
                }
                for(var j = beginIndex; j < endIndex; j++){
                    var localPosition = localPositions[positionIndex];
                    var globalPosition = WireframeManager._getPositionFromPool(positionIndex);
                    engine.Vector3.transformCoordinate(localPosition, worldMatrix, globalPosition);
                    globalPositions[positionIndex] = globalPosition;
                    positionIndex++;
                }
                wireframeElement.updateFlag.flag = false;
                needUpdate = true;
            } else {
                positionIndex += endIndex - beginIndex;
            }
        }
        // update world-space geometry
        this._growthIndexMemory(this._boundsIndicesCount);
        var indicesCount = this._indicesCount;
        for(var i1 = 0; i1 < wireframeRenderers.length; i1++){
            var renderer = wireframeRenderers[i1];
            var bounds = renderer.bounds;
            var tempVector = WireframeManager._tempVector;
            bounds.getExtent(tempVector);
            var positionsOffset = globalPositions.length;
            WireframePrimitive.createCuboidWireframe(tempVector.x * 2, tempVector.y * 2, tempVector.z * 2, globalPositions, positionsOffset, indices, indicesCount);
            bounds.getCenter(tempVector);
            for(var i2 = positionsOffset; i2 < globalPositions.length; i2++){
                var position = globalPositions[i2];
                position.add(tempVector);
            }
            indicesCount += WireframePrimitive.cuboidIndexCount;
        }
        if (wireframeRenderers.length > 0 || needUpdate) {
            mesh.setPositions(globalPositions);
            mesh.setIndices(this._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = indicesCount;
        }
        if (indicesCount === 0) {
            this._renderer.setMaterial(null);
        } else {
            this._renderer.setMaterial(this._material);
        }
    };
    _proto._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = this._indices;
        var neededLength = this._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = this._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = this._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            this._indices = newIndices;
        }
    };
    _proto._growthPosition = function _growthPosition(length) {
        var position = this._localPositions;
        for(var i = 0; i < length; i++){
            position.push(new engine.Vector3());
        }
    };
    _proto._localTranslate = function _localTranslate(positionsOffset, offset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            position.add(offset);
        }
    };
    _proto._localRotation = function _localRotation(positionsOffset, rotation) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            engine.Vector3.transformByQuat(position, rotation, position);
        }
    };
    _proto._rotateAroundX = function _rotateAroundX(positionsOffset) {
        var localPositions = this._localPositions;
        for(var i = positionsOffset; i < localPositions.length; i++){
            var position = localPositions[i];
            var py = position.y;
            var pz = position.z;
            position.z = py;
            position.y = -pz;
        }
    };
    WireframeManager._getPositionFromPool = function _getPositionFromPool(positionIndex) {
        var position;
        var positionPool = WireframeManager._positionPool;
        if (positionIndex < positionPool.length) {
            position = positionPool[positionIndex];
        } else {
            position = new engine.Vector3();
            WireframeManager._positionPool.push(position);
        }
        return position;
    };
    _create_class(WireframeManager, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this._material.baseColor;
            },
            set: function set(value) {
                this._material.baseColor = value;
            }
        }
    ]);
    return WireframeManager;
}(engine.Script);
exports.WireframeManager._positionPool = [];
exports.WireframeManager._ndcPosition = [
    new engine.Vector3(-1, 1, -1),
    new engine.Vector3(1, 1, -1),
    new engine.Vector3(1, -1, -1),
    new engine.Vector3(-1, -1, -1)
];
exports.WireframeManager._tempMatrix = new engine.Matrix();
exports.WireframeManager._tempVector = new engine.Vector3();
exports.WireframeManager._tempRotation = new engine.Quaternion();
exports.WireframeManager._tempAxis = new engine.Quaternion();
exports.WireframeManager._halfSqrt = 0.70710678118655;
exports.WireframeManager = __decorate([
    engine.dependentComponents(engine.MeshRenderer, engine.DependentMode.CheckOnly)
], exports.WireframeManager);
/**
 * @internal
 * Store Wireframe element info.
 */ var WireframeElement = function WireframeElement(transform, transformRanges, isScaleIgnored) {
    if (isScaleIgnored === void 0) isScaleIgnored = true;
    this.transform = transform;
    this.transformRanges = transformRanges;
    this.isScaleIgnored = isScaleIgnored;
    this.updateFlag = transform.registerWorldChangeFlag();
};

exports.LineDrawer = /*#__PURE__*/ function(Script) {
    _inherits(LineDrawer, Script);
    function LineDrawer() {
        return Script.apply(this, arguments);
    }
    var _proto = LineDrawer.prototype;
    _proto.onAwake = function onAwake() {
        var engine$1 = this.engine;
        var mesh = new engine.ModelMesh(engine$1);
        var material = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
        var renderer = this.entity.getComponent(engine.MeshRenderer);
        renderer.castShadows = false;
        renderer.receiveShadows = false;
        // @ts-ignore
        var supportUint32Array = engine$1._hardwareRenderer.canIUse(engine.GLCapabilityType.elementIndexUint);
        // @ts-ignore
        mesh._enableVAO = false;
        mesh.addSubMesh(0, LineDrawer._indicesCount, engine.MeshTopology.Lines);
        renderer.mesh = mesh;
        renderer.setMaterial(material);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._mesh = mesh;
        this._material = material;
        this._renderer = renderer;
        LineDrawer._indices = supportUint32Array ? new Uint32Array(128) : new Uint16Array(128);
        LineDrawer._supportUint32Array = supportUint32Array;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        var _this = this, mesh = _this._mesh;
        if (LineDrawer._positionCount > 0) {
            mesh.setPositions(LineDrawer._positions);
            mesh.setIndices(LineDrawer._indices);
            mesh.uploadData(false);
            mesh.subMesh.count = LineDrawer._indicesCount;
            this._renderer.setMaterial(this._material);
        } else {
            this._renderer.setMaterial(null);
        }
        LineDrawer.flush();
    };
    /**
   * Draws a line starting at from towards to.
   * @param from - from position
   * @param to - to position
   */ LineDrawer.drawLine = function drawLine(from, to) {
        LineDrawer._growthPosition(2);
        LineDrawer._growthIndexMemory(2);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(from);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(to);
        } else {
            engine.Vector3.transformCoordinate(from, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            engine.Vector3.transformCoordinate(to, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a rectangle at four vertex
   * @param leftTop - left top position
   * @param rightTop - right top position
   * @param rightBottom - right bottom position
   * @param leftBottom - left bottom position
   */ LineDrawer.drawRect = function drawRect(leftTop, rightTop, rightBottom, leftBottom) {
        LineDrawer._growthPosition(4);
        LineDrawer._growthIndexMemory(8);
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 1;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 2;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount;
        LineDrawer._indices[LineDrawer._indicesCount++] = LineDrawer._positionCount + 3;
        if (LineDrawer.matrix == null) {
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightTop);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(rightBottom);
            LineDrawer._positions[LineDrawer._positionCount++].copyFrom(leftBottom);
        } else {
            engine.Vector3.transformCoordinate(leftTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            engine.Vector3.transformCoordinate(rightTop, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            engine.Vector3.transformCoordinate(rightBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
            engine.Vector3.transformCoordinate(leftBottom, LineDrawer.matrix, LineDrawer._positions[LineDrawer._positionCount++]);
        }
    };
    /**
   * Draws a wireframe sphere with center and radius.
   * @param radius - sphere radius
   * @param center - sphere center
   */ LineDrawer.drawSphere = function drawSphere(radius, center) {
        var positionCount = WireframePrimitive.spherePositionCount;
        var indexCount = WireframePrimitive.sphereIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createSphereWireframe(radius, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                engine.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe box with center and size.
   * @param width - width
   * @param height - height
   * @param depth - depth
   * @param center - center
   */ LineDrawer.drawCuboid = function drawCuboid(width, height, depth, center) {
        var positionCount = WireframePrimitive.cuboidPositionCount;
        var indexCount = WireframePrimitive.cuboidIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCuboidWireframe(width, height, depth, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                engine.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe capsule with radius, height and center.
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param center - The center
   */ LineDrawer.drawCapsule = function drawCapsule(radius, height, center) {
        var positionCount = WireframePrimitive.capsulePositionCount;
        var indexCount = WireframePrimitive.capsuleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCapsuleWireframe(radius, height, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                engine.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    /**
   * Draw a wireframe circle with radius, axis and center.
   * @param radius - The radius
   * @param axis - The axis
   * @param center - The center
   */ LineDrawer.drawCircle = function drawCircle(radius, axis, center) {
        WireframePrimitive._shift.set(0, 0, 0);
        var positionCount = WireframePrimitive.circlePositionCount;
        var indexCount = WireframePrimitive.circleIndexCount;
        var globalPosition = LineDrawer._positions;
        LineDrawer._growthPosition(positionCount);
        LineDrawer._growthIndexMemory(indexCount);
        WireframePrimitive.createCircleWireframe(radius, axis, WireframePrimitive._shift, globalPosition, LineDrawer._positionCount, LineDrawer._indices, LineDrawer._indicesCount);
        for(var i = 0; i < positionCount; i++){
            var pos = globalPosition[LineDrawer._positionCount + i];
            pos.add(center);
            if (LineDrawer.matrix != null) {
                engine.Vector3.transformCoordinate(pos, LineDrawer.matrix, pos);
            }
        }
        LineDrawer._positionCount += positionCount;
        LineDrawer._indicesCount += indexCount;
    };
    LineDrawer.flush = function flush() {
        LineDrawer._positionCount = 0;
        LineDrawer._indicesCount = 0;
    };
    LineDrawer._growthIndexMemory = function _growthIndexMemory(length) {
        var indices = LineDrawer._indices;
        var neededLength = LineDrawer._indicesCount + length;
        if (neededLength > indices.length) {
            var maxLength = LineDrawer._supportUint32Array ? 4294967295 : 65535;
            if (neededLength > maxLength) {
                throw Error("The vertex count is over limit.");
            }
            var newIndices = LineDrawer._supportUint32Array ? new Uint32Array(neededLength) : new Uint16Array(neededLength);
            newIndices.set(indices);
            LineDrawer._indices = newIndices;
        }
    };
    LineDrawer._growthPosition = function _growthPosition(length) {
        var position = LineDrawer._positions;
        var neededLength = LineDrawer._positionCount + length;
        if (neededLength > position.length) {
            for(var i = 0, n = neededLength - position.length; i < n; i++){
                position.push(new engine.Vector3());
            }
        }
    };
    _create_class(LineDrawer, [
        {
            key: "color",
            set: /**
   * Color of the material.
   * By default, color is (1,1,1,1).
   */ function set(value) {
                this._material.baseColor.copyFrom(value);
            }
        }
    ]);
    return LineDrawer;
}(engine.Script);
exports.LineDrawer._positions = [];
exports.LineDrawer._positionCount = 0;
exports.LineDrawer._indicesCount = 0;
/**
   * The LineDrawer.matrix stores the position, rotation and scale of the LineDrawer.
   * By default, LineDrawer always uses world coordinates.
   * The default LineDrawer.matrix transforms the world coordinates using a default identity matrix.
   */ exports.LineDrawer.matrix = null;
exports.LineDrawer = __decorate([
    engine.dependentComponents(engine.MeshRenderer, engine.DependentMode.CheckOnly)
], exports.LineDrawer);
exports.AxisType = void 0;
(function(AxisType) {
    AxisType[AxisType["X"] = 0] = "X";
    AxisType[AxisType["Y"] = 1] = "Y";
    AxisType[AxisType["Z"] = 2] = "Z";
})(exports.AxisType || (exports.AxisType = {}));

exports.WireframePrimitive = WireframePrimitive;
//# sourceMappingURL=browser.js.map
