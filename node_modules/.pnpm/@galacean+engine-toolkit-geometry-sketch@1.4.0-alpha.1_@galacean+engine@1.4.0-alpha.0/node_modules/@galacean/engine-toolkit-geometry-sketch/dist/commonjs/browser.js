'use strict';

var engine = require('@galacean/engine');

exports.SketchMode = void 0;
(function(SketchMode) {
    SketchMode[SketchMode["Wireframe"] = 0] = "Wireframe";
    SketchMode[SketchMode["Normal"] = 1] = "Normal";
    SketchMode[SketchMode["Tangent"] = 2] = "Tangent";
    SketchMode[SketchMode["BiTangent"] = 3] = "BiTangent";
})(exports.SketchMode || (exports.SketchMode = {}));

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

var geometryTextureDefine = "\n   uniform sampler2D u_verticesSampler;\n   uniform float u_verticesTextureWidth;\n   uniform float u_verticesTextureHeight;\n   \n   uniform sampler2D u_indicesSampler;\n   uniform float u_indicesTextureWidth;\n   uniform float u_indicesTextureHeight;\n   \n   vec4 getVertexElement(float row, float col) {\n        return texture2D(u_verticesSampler, vec2((col + 0.5) / u_verticesTextureWidth, (row + 0.5) / u_verticesTextureHeight));\n   }\n   \n   vec3 getIndicesElement(float row, float col) {\n        return texture2D(u_indicesSampler, vec2((col + 0.5) / u_indicesTextureWidth, (row + 0.5) / u_indicesTextureHeight )).xyz;\n   }\n   \n   vec2 getVec2(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        return vec2(x, y);\n   }\n   \n   vec3 getVec3(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float z = rows[row_index][value_index];\n        return vec3(x, y, z);\n   }\n   \n   vec4 getVec4(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float z = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float w = rows[row_index][value_index];\n        return vec4(x, y, z, w);\n   }\n";
var geometryTextureVert = "\n        int row = pointIndex * ELEMENT_COUNT / int(u_verticesTextureWidth);\n        int col = pointIndex * ELEMENT_COUNT % int(u_verticesTextureWidth);\n        \n        vec4 rows[ELEMENT_COUNT];\n        for( int i = 0; i < ELEMENT_COUNT; i++ ) {\n            rows[i] = getVertexElement(float(row), float(col + i));\n        }\n        \n        vec3 POSITION = vec3(rows[0].x, rows[0].y, rows[0].z);        \n        int row_index = 0;\n        int value_index = 2;\n#ifdef RENDERER_HAS_NORMAL \n        vec3 NORMAL = getVec3(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_VERTEXCOLOR\n        vec4 COLOR_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_WEIGHT\n        vec4 WEIGHTS_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_JOINT\n        vec4 JOINTS_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_TANGENT\n        vec4 TANGENT = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_UV\n        vec2 TEXCOORD_0 = getVec2(rows, row_index, value_index);\n#endif\n";

engine.Shader.create("tbnShader", "\n#include <common>\n   uniform float u_lineScale;\n   uniform mat4 camera_VPMat;\n   uniform mat4 u_worldMatrix;\n   uniform mat4 u_worldNormal;\n\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\n    uniform sampler2D renderer_JointSampler;\n    uniform float renderer_JointCount;\n\n    mat4 getJointMatrix(sampler2D smp, float index) {\n        float base = index / renderer_JointCount;\n        float hf = 0.5 / renderer_JointCount;\n        float v = base + hf;\n\n        vec4 m0 = texture2D(smp, vec2(0.125, v ));\n        vec4 m1 = texture2D(smp, vec2(0.375, v ));\n        vec4 m2 = texture2D(smp, vec2(0.625, v ));\n        vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n        return mat4(m0, m1, m2, m3);\n    }\n#else\n    uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n#endif\n#endif\n\n" + geometryTextureDefine + "\n\nvoid main() {\n    int pointIndex = gl_VertexID / 2;\n    " + geometryTextureVert + "\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n\n    gl_Position = u_worldMatrix * position; \n    \n#if defined(SHOW_NORMAL) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        gl_Position.xyz += normalize(normalW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_TANGENT) && defined(RENDERER_HAS_TANGENT)\n    if (gl_VertexID % 2 == 1) {\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        gl_Position.xyz += normalize(tangentW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_BITANGENT) && defined(RENDERER_HAS_TANGENT) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        gl_Position.xyz += normalize(bitangentW) * u_lineScale;\n    }\n#endif\n    \n    gl_Position = camera_VPMat * gl_Position; \n}\n", "\nuniform vec4 material_BaseColor;\nvoid main() {\n    gl_FragColor = material_BaseColor;\n}\n");
/**
 * Material for normal shading
 */ var NormalMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(NormalMaterial, BaseMaterial);
    function NormalMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(NormalMaterial._baseColorProp, new engine.Color(1, 0, 0, 1));
        _this.shaderData.enableMacro("SHOW_NORMAL");
        return _this;
    }
    _create_class(NormalMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(NormalMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(NormalMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return NormalMaterial;
}(engine.BaseMaterial);
/**
 * Material for normal tangent
 */ var TangentMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(TangentMaterial, BaseMaterial);
    function TangentMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(TangentMaterial._baseColorProp, new engine.Color(0, 1, 0, 1));
        _this.shaderData.enableMacro("SHOW_TANGENT");
        return _this;
    }
    _create_class(TangentMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(TangentMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(TangentMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return TangentMaterial;
}(engine.BaseMaterial);
/**
 * Material for normal bi-tangent
 */ var BiTangentMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(BiTangentMaterial, BaseMaterial);
    function BiTangentMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(BiTangentMaterial._baseColorProp, new engine.Color(0, 0, 1, 1));
        _this.shaderData.enableMacro("SHOW_BITANGENT");
        return _this;
    }
    _create_class(BiTangentMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(BiTangentMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(BiTangentMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return BiTangentMaterial;
}(engine.BaseMaterial);

engine.Shader.create("wireframeShader", "\n#include <common>\n   uniform float u_lineScale;\n   uniform mat4 camera_VPMat;\n   uniform mat4 u_worldMatrix;\n   uniform mat4 u_worldNormal;\n\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\n    uniform sampler2D renderer_JointSampler;\n    uniform float renderer_JointCount;\n\n    mat4 getJointMatrix(sampler2D smp, float index) {\n        float base = index / renderer_JointCount;\n        float hf = 0.5 / renderer_JointCount;\n        float v = base + hf;\n\n        vec4 m0 = texture2D(smp, vec2(0.125, v ));\n        vec4 m1 = texture2D(smp, vec2(0.375, v ));\n        vec4 m2 = texture2D(smp, vec2(0.625, v ));\n        vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n        return mat4(m0, m1, m2, m3);\n    }\n#else\n    uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n#endif\n#endif\n\n" + geometryTextureDefine + "\n\nvarying vec3 v_baryCenter;\n\nvoid main() {\n    int indicesIndex = gl_VertexID / 3;\n    int indicesRow = indicesIndex / int(u_indicesTextureWidth);\n    int indicesCol = indicesIndex % int(u_indicesTextureWidth);\n    vec3 triangleIndices = getIndicesElement(float(indicesRow), float(indicesCol));\n    int subIndex = gl_VertexID % 3;\n    v_baryCenter = vec3(0.0);\n    v_baryCenter[subIndex] = 1.0;\n    \n    int pointIndex = int(triangleIndices[subIndex]);\n    " + geometryTextureVert + "\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n    \n    gl_Position = u_worldMatrix * position; \n    gl_Position = camera_VPMat * gl_Position; \n}\n", "\nvarying vec3 v_baryCenter;\n\nfloat edgeFactor(){\n    vec3 d = fwidth(v_baryCenter);\n    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_baryCenter);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\nuniform vec4 material_BaseColor;\nvoid main() {\n    if (gl_FrontFacing) {\n        gl_FragColor = vec4(material_BaseColor.xyz, 1.0 - edgeFactor());\n    } else {\n        // fade back face\n        gl_FragColor = vec4(material_BaseColor.xyz, (1.0 - edgeFactor()) * 0.3);\n    }\n}\n");
var WireframeMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(WireframeMaterial, BaseMaterial);
    function WireframeMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("wireframeShader")) || this;
        _this.shaderData.setColor(WireframeMaterial._baseColorProp, new engine.Color(0, 0, 0, 1));
        _this.isTransparent = true;
        _this.renderFace = engine.RenderFace.Double;
        return _this;
    }
    _create_class(WireframeMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(WireframeMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(WireframeMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return WireframeMaterial;
}(engine.BaseMaterial);

/**
 * Sketch Renderer
 */ var SketchRenderer = /*#__PURE__*/ function(SkinnedMeshRenderer) {
    _inherits(SketchRenderer, SkinnedMeshRenderer);
    function SketchRenderer(entity) {
        var _this;
        _this = SkinnedMeshRenderer.call(this, entity) || this;
        _this._worldNormalMatrix = new engine.Matrix();
        _this._worldMatrix = null;
        _this._targetMesh = null;
        _this._verticesTexture = null;
        _this._indicesTexture = null;
        _this._showState = [
            false,
            false,
            false,
            false
        ];
        _this._triangleSubMesh = new engine.SubMesh();
        _this._lineSubMesh = new engine.SubMesh(0, 0, engine.MeshTopology.Lines);
        var engine$1 = _this.engine;
        _this.mesh = new engine.ModelMesh(engine$1);
        _this._wireframeMaterial = new WireframeMaterial(engine$1);
        _this._normalMaterial = new NormalMaterial(engine$1);
        _this._tangentMaterial = new TangentMaterial(engine$1);
        _this._biTangentMaterial = new BiTangentMaterial(engine$1);
        _this.mesh.addSubMesh(_this._triangleSubMesh); // wireframe
        _this.mesh.addSubMesh(_this._lineSubMesh); // normal
        _this.mesh.addSubMesh(_this._lineSubMesh); // tangent
        _this.mesh.addSubMesh(_this._lineSubMesh); // bi-tangent
        _this.scale = 0.1;
        return _this;
    }
    var _proto = SketchRenderer.prototype;
    /**
   * Set sketch mode
   * @param mode - The sketch mode
   * @param isShow - whether show the sketch
   */ _proto.setSketchMode = function setSketchMode(mode, isShow) {
        switch(mode){
            case exports.SketchMode.Wireframe:
                if (isShow) {
                    this._targetMesh && this.setMaterial(0, this._wireframeMaterial);
                    this._showState[0] = true;
                } else {
                    this.setMaterial(0, null);
                    this._showState[0] = false;
                }
                break;
            case exports.SketchMode.Normal:
                if (isShow) {
                    this._targetMesh && this.setMaterial(1, this._normalMaterial);
                    this._showState[1] = true;
                } else {
                    this.setMaterial(1, null);
                    this._showState[1] = false;
                }
                break;
            case exports.SketchMode.Tangent:
                if (isShow) {
                    this._targetMesh && this.setMaterial(2, this._tangentMaterial);
                    this._showState[2] = true;
                } else {
                    this.setMaterial(2, null);
                    this._showState[2] = false;
                }
                break;
            case exports.SketchMode.BiTangent:
                if (isShow) {
                    this._targetMesh && this.setMaterial(3, this._biTangentMaterial);
                    this._showState[3] = true;
                } else {
                    this.setMaterial(3, null);
                    this._showState[3] = false;
                }
                break;
        }
    };
    _proto.clear = function clear() {
        this.setMaterial(0, null);
        this.setMaterial(1, null);
        this.setMaterial(2, null);
        this.setMaterial(3, null);
    };
    _proto.update = function update(deltaTime) {
        SkinnedMeshRenderer.prototype.update.call(this, deltaTime);
        var worldMatrix = this._worldMatrix;
        if (worldMatrix) {
            var worldNormalMatrix = this._worldNormalMatrix;
            engine.Matrix.invert(worldMatrix, worldNormalMatrix);
            worldNormalMatrix.transpose();
            this.shaderData.setMatrix(SketchRenderer._worldNormalProp, worldNormalMatrix);
        }
    };
    _proto._uploadIndicesBuffer = function _uploadIndicesBuffer(value) {
        //@ts-ignore
        var indexBuffer = value._indexBufferBinding.buffer;
        var byteLength = indexBuffer.byteLength;
        var buffer = new Uint8Array(byteLength);
        indexBuffer.getData(buffer);
        //@ts-ignore
        var indexFormat = value._indicesFormat;
        var triangleCount = 0;
        switch(indexFormat){
            case engine.IndexFormat.UInt8:
                {
                    triangleCount = byteLength / 3;
                    var width = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new engine.Texture2D(this.engine, width, height, engine.TextureFormat.R32G32B32A32, false);
                    var floatBuffer = new Float32Array(width * height * 4);
                    for(var i = 0; i < triangleCount; i++){
                        for(var j = 0; j < 3; j++){
                            floatBuffer[i * 4 + j] = buffer[i * 3 + j];
                        }
                        floatBuffer[i * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height);
                    break;
                }
            case engine.IndexFormat.UInt16:
                {
                    var uint16Buffer = new Uint16Array(buffer.buffer);
                    triangleCount = byteLength / 6;
                    var width1 = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height1 = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new engine.Texture2D(this.engine, width1, height1, engine.TextureFormat.R32G32B32A32, false);
                    var floatBuffer1 = new Float32Array(width1 * height1 * 4);
                    for(var i1 = 0; i1 < triangleCount; i1++){
                        for(var j1 = 0; j1 < 3; j1++){
                            floatBuffer1[i1 * 4 + j1] = uint16Buffer[i1 * 3 + j1];
                        }
                        floatBuffer1[i1 * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer1);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width1);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height1);
                    break;
                }
            case engine.IndexFormat.UInt32:
                {
                    var uint32Buffer = new Uint32Array(buffer.buffer);
                    triangleCount = byteLength / 12;
                    var width2 = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height2 = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new engine.Texture2D(this.engine, width2, height2, engine.TextureFormat.R32G32B32A32, false);
                    var floatBuffer2 = new Float32Array(width2 * height2 * 4);
                    for(var i2 = 0; i2 < triangleCount; i2++){
                        for(var j2 = 0; j2 < 3; j2++){
                            floatBuffer2[i2 * 4 + j2] = uint32Buffer[i2 * 3 + j2];
                        }
                        floatBuffer2[i2 * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer2);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width2);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height2);
                    break;
                }
        }
        this._indicesTexture.filterMode = engine.TextureFilterMode.Point;
    };
    _proto._uploadVerticesBuffer = function _uploadVerticesBuffer(value) {
        //@ts-ignore
        var vertexBufferBinding = value._vertexBufferBindings[0];
        var vertexCount = value.vertexCount;
        var elementCount = this._updateMeshElement(value);
        var jointIndexBegin = SketchRenderer._jointIndexBegin;
        var newElementCount = elementCount;
        if (jointIndexBegin !== -1) {
            newElementCount += 3;
        }
        var buffer = new Float32Array(elementCount * vertexCount);
        vertexBufferBinding.buffer.getData(buffer);
        var uint8Buffer = new Uint8Array(buffer.buffer);
        var alignElementCount = Math.ceil(newElementCount / 4) * 4;
        this.shaderData.enableMacro("ELEMENT_COUNT", (alignElementCount / 4).toString());
        var width = Math.min(vertexCount, SketchRenderer._MAX_TEXTURE_ROWS) * alignElementCount;
        var height = Math.ceil(vertexCount / SketchRenderer._MAX_TEXTURE_ROWS);
        var alignBuffer = new Float32Array(width * height);
        for(var i = 0; i < vertexCount; i++){
            for(var j = 0; j < newElementCount; j++){
                if (jointIndexBegin !== -1 && j === jointIndexBegin) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 1) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 1];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 2) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 2];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 3) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 3];
                } else {
                    if (jointIndexBegin !== -1 && j > jointIndexBegin + 3) {
                        alignBuffer[i * alignElementCount + j] = buffer[i * elementCount + j - 3];
                    } else {
                        alignBuffer[i * alignElementCount + j] = buffer[i * elementCount + j];
                    }
                }
            }
        }
        this._createVerticesTexture(alignBuffer, width / 4, height);
        SketchRenderer._jointIndexBegin = -1;
    };
    _proto._createVerticesTexture = function _createVerticesTexture(vertexBuffer, width, height) {
        this._verticesTexture = new engine.Texture2D(this.engine, width, height, engine.TextureFormat.R32G32B32A32, false);
        this._verticesTexture.filterMode = engine.TextureFilterMode.Point;
        this._verticesTexture.setPixelBuffer(vertexBuffer);
        this.shaderData.setTexture(SketchRenderer._verticesSamplerProp, this._verticesTexture);
        this.shaderData.setFloat(SketchRenderer._verticesTextureWidthProp, width);
        this.shaderData.setFloat(SketchRenderer._verticesTextureHeightProp, height);
    };
    _proto._updateMeshElement = function _updateMeshElement(value) {
        var shaderData = this.shaderData;
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._normalMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._vertexColorMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._tangentMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._uvMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._uv1Macro);
        shaderData.disableMacro(SketchRenderer._weightMacro);
        shaderData.disableMacro(SketchRenderer._jointMacro);
        var elementCount = 0;
        //@ts-ignore
        var vertexElements = value._vertexElements;
        for(var i = 0, n = vertexElements.length; i < n; i++){
            var semantic = vertexElements[i].semantic;
            switch(semantic){
                case "POSITION":
                    elementCount += 3;
                    break;
                case "NORMAL":
                    elementCount += 3;
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._normalMacro);
                    break;
                case "COLOR_0":
                    elementCount += 4;
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._vertexColorMacro);
                    break;
                case "WEIGHTS_0":
                    elementCount += 4;
                    shaderData.enableMacro(SketchRenderer._weightMacro);
                    break;
                case "JOINTS_0":
                    SketchRenderer._jointIndexBegin = elementCount;
                    elementCount += 1;
                    shaderData.enableMacro(SketchRenderer._jointMacro);
                    break;
                case "TANGENT":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._tangentMacro);
                    elementCount += 4;
                    break;
                case "TEXCOORD_0":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._uvMacro);
                    elementCount += 2;
                    break;
                case "TEXCOORD_1":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._uv1Macro);
                    elementCount += 2;
                    break;
                case "TEXCOORD_2":
                    elementCount += 2;
                    break;
                case "TEXCOORD_3":
                    elementCount += 2;
                    break;
                case "TEXCOORD_4":
                    elementCount += 2;
                    break;
                case "TEXCOORD_5":
                    elementCount += 2;
                    break;
                case "TEXCOORD_6":
                    elementCount += 2;
                    break;
                case "TEXCOORD_7":
                    elementCount += 2;
                    break;
            }
        }
        return elementCount;
    };
    _proto._updateLineSubMesh = function _updateLineSubMesh(mesh) {
        this._lineSubMesh.count = mesh.vertexCount * 2;
    };
    _proto._updateTriangleSubMesh = function _updateTriangleSubMesh(mesh) {
        var triangleCount = 0;
        var subMeshes = mesh.subMeshes;
        for(var i = 0; i < subMeshes.length; i++){
            var subMesh = subMeshes[i];
            triangleCount += subMesh.count;
        }
        this._triangleSubMesh.count = triangleCount;
    };
    _proto._destroy = function _destroy() {
        this._indicesTexture && this._indicesTexture.destroy();
        this._verticesTexture && this._verticesTexture.destroy();
    };
    _create_class(SketchRenderer, [
        {
            key: "scale",
            get: /**
   * Line scale
   */ function get() {
                return this.shaderData.getFloat(SketchRenderer._lineScaleProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SketchRenderer._lineScaleProp, value);
            }
        },
        {
            key: "worldMatrix",
            set: /**
   * World matrix
   */ function set(value) {
                if (value !== this._worldMatrix) {
                    this._worldMatrix = value;
                    this.shaderData.setMatrix(SketchRenderer._worldMatrixProp, value);
                }
            }
        },
        {
            key: "targetMesh",
            set: /**
   * Target mesh
   */ function set(value) {
                if (value !== this._targetMesh) {
                    this._destroy();
                    this._targetMesh = value;
                    this._uploadVerticesBuffer(value);
                    this._uploadIndicesBuffer(value);
                    this._updateTriangleSubMesh(value);
                    this._updateLineSubMesh(value);
                    for(var i = 0; i < 4; i++){
                        this.setSketchMode(i, this._showState[i]);
                    }
                }
            }
        },
        {
            key: "wireframeMaterial",
            get: /**
   * Material for wireframe shading
   */ function get() {
                return this._wireframeMaterial;
            }
        },
        {
            key: "normalMaterial",
            get: /**
   * Material for normal shading
   */ function get() {
                return this._normalMaterial;
            }
        },
        {
            key: "tangentMaterial",
            get: /**
   * Material for tangent shading
   */ function get() {
                return this._normalMaterial;
            }
        },
        {
            key: "biTangentMaterial",
            get: /**
   * Material for biTangent shading
   */ function get() {
                return this._normalMaterial;
            }
        }
    ]);
    return SketchRenderer;
}(engine.SkinnedMeshRenderer);
SketchRenderer._weightMacro = engine.ShaderMacro.getByName("RENDERER_HAS_WEIGHT");
SketchRenderer._jointMacro = engine.ShaderMacro.getByName("RENDERER_HAS_JOINT");
SketchRenderer._MAX_TEXTURE_ROWS = 512;
SketchRenderer._jointIndexBegin = -1;
SketchRenderer._verticesSamplerProp = engine.ShaderProperty.getByName("u_verticesSampler");
SketchRenderer._verticesTextureHeightProp = engine.ShaderProperty.getByName("u_verticesTextureHeight");
SketchRenderer._verticesTextureWidthProp = engine.ShaderProperty.getByName("u_verticesTextureWidth");
SketchRenderer._indicesSamplerProp = engine.ShaderProperty.getByName("u_indicesSampler");
SketchRenderer._indicesTextureHeightProp = engine.ShaderProperty.getByName("u_indicesTextureHeight");
SketchRenderer._indicesTextureWidthProp = engine.ShaderProperty.getByName("u_indicesTextureWidth");
SketchRenderer._lineScaleProp = engine.ShaderProperty.getByName("u_lineScale");
SketchRenderer._worldMatrixProp = engine.ShaderProperty.getByName("u_worldMatrix");
SketchRenderer._worldNormalProp = engine.ShaderProperty.getByName("u_worldNormal");

exports.BiTangentMaterial = BiTangentMaterial;
exports.NormalMaterial = NormalMaterial;
exports.SketchRenderer = SketchRenderer;
exports.TangentMaterial = TangentMaterial;
exports.WireframeMaterial = WireframeMaterial;
//# sourceMappingURL=browser.js.map
