import { _ as _inherits, a as _create_class } from '../_inherits-ae42bcd9.js';
import { Shader, Color, BaseMaterial } from '@galacean/engine';
import { geometryTextureDefine, geometryTextureVert } from './GeometryShader.js';

Shader.create("tbnShader", "\n#include <common>\n   uniform float u_lineScale;\n   uniform mat4 camera_VPMat;\n   uniform mat4 u_worldMatrix;\n   uniform mat4 u_worldNormal;\n\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\n    uniform sampler2D renderer_JointSampler;\n    uniform float renderer_JointCount;\n\n    mat4 getJointMatrix(sampler2D smp, float index) {\n        float base = index / renderer_JointCount;\n        float hf = 0.5 / renderer_JointCount;\n        float v = base + hf;\n\n        vec4 m0 = texture2D(smp, vec2(0.125, v ));\n        vec4 m1 = texture2D(smp, vec2(0.375, v ));\n        vec4 m2 = texture2D(smp, vec2(0.625, v ));\n        vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n        return mat4(m0, m1, m2, m3);\n    }\n#else\n    uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n#endif\n#endif\n\n" + geometryTextureDefine + "\n\nvoid main() {\n    int pointIndex = gl_VertexID / 2;\n    " + geometryTextureVert + "\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n\n    gl_Position = u_worldMatrix * position; \n    \n#if defined(SHOW_NORMAL) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        gl_Position.xyz += normalize(normalW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_TANGENT) && defined(RENDERER_HAS_TANGENT)\n    if (gl_VertexID % 2 == 1) {\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        gl_Position.xyz += normalize(tangentW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_BITANGENT) && defined(RENDERER_HAS_TANGENT) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        gl_Position.xyz += normalize(bitangentW) * u_lineScale;\n    }\n#endif\n    \n    gl_Position = camera_VPMat * gl_Position; \n}\n", "\nuniform vec4 material_BaseColor;\nvoid main() {\n    gl_FragColor = material_BaseColor;\n}\n");
/**
 * Material for normal shading
 */ var NormalMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(NormalMaterial, BaseMaterial);
    function NormalMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(NormalMaterial._baseColorProp, new Color(1, 0, 0, 1));
        _this.shaderData.enableMacro("SHOW_NORMAL");
        return _this;
    }
    _create_class(NormalMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(NormalMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(NormalMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return NormalMaterial;
}(BaseMaterial);
/**
 * Material for normal tangent
 */ var TangentMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(TangentMaterial, BaseMaterial);
    function TangentMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(TangentMaterial._baseColorProp, new Color(0, 1, 0, 1));
        _this.shaderData.enableMacro("SHOW_TANGENT");
        return _this;
    }
    _create_class(TangentMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(TangentMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(TangentMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return TangentMaterial;
}(BaseMaterial);
/**
 * Material for normal bi-tangent
 */ var BiTangentMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(BiTangentMaterial, BaseMaterial);
    function BiTangentMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("tbnShader")) || this;
        _this.shaderData.setColor(BiTangentMaterial._baseColorProp, new Color(0, 0, 1, 1));
        _this.shaderData.enableMacro("SHOW_BITANGENT");
        return _this;
    }
    _create_class(BiTangentMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(BiTangentMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(BiTangentMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return BiTangentMaterial;
}(BaseMaterial);

export { BiTangentMaterial, NormalMaterial, TangentMaterial };
//# sourceMappingURL=TBNMaterial.js.map
