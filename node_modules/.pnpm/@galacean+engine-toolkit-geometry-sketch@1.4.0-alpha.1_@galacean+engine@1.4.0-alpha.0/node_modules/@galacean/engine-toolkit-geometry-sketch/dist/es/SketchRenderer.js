import { SketchMode } from './SketchMode.js';
import { _ as _inherits, a as _create_class } from './_inherits-ae42bcd9.js';
import { ShaderMacro, ShaderProperty, Matrix, IndexFormat, Texture2D, TextureFormat, TextureFilterMode, SkinnedMeshRenderer, SubMesh, MeshTopology, ModelMesh } from '@galacean/engine';
import { NormalMaterial, TangentMaterial, BiTangentMaterial } from './material/TBNMaterial.js';
import { WireframeMaterial } from './material/WireframeMaterial.js';
import './material/GeometryShader.js';

/**
 * Sketch Renderer
 */ var SketchRenderer = /*#__PURE__*/ function(SkinnedMeshRenderer) {
    _inherits(SketchRenderer, SkinnedMeshRenderer);
    function SketchRenderer(entity) {
        var _this;
        _this = SkinnedMeshRenderer.call(this, entity) || this;
        _this._worldNormalMatrix = new Matrix();
        _this._worldMatrix = null;
        _this._targetMesh = null;
        _this._verticesTexture = null;
        _this._indicesTexture = null;
        _this._showState = [
            false,
            false,
            false,
            false
        ];
        _this._triangleSubMesh = new SubMesh();
        _this._lineSubMesh = new SubMesh(0, 0, MeshTopology.Lines);
        var engine = _this.engine;
        _this.mesh = new ModelMesh(engine);
        _this._wireframeMaterial = new WireframeMaterial(engine);
        _this._normalMaterial = new NormalMaterial(engine);
        _this._tangentMaterial = new TangentMaterial(engine);
        _this._biTangentMaterial = new BiTangentMaterial(engine);
        _this.mesh.addSubMesh(_this._triangleSubMesh); // wireframe
        _this.mesh.addSubMesh(_this._lineSubMesh); // normal
        _this.mesh.addSubMesh(_this._lineSubMesh); // tangent
        _this.mesh.addSubMesh(_this._lineSubMesh); // bi-tangent
        _this.scale = 0.1;
        return _this;
    }
    var _proto = SketchRenderer.prototype;
    /**
   * Set sketch mode
   * @param mode - The sketch mode
   * @param isShow - whether show the sketch
   */ _proto.setSketchMode = function setSketchMode(mode, isShow) {
        switch(mode){
            case SketchMode.Wireframe:
                if (isShow) {
                    this._targetMesh && this.setMaterial(0, this._wireframeMaterial);
                    this._showState[0] = true;
                } else {
                    this.setMaterial(0, null);
                    this._showState[0] = false;
                }
                break;
            case SketchMode.Normal:
                if (isShow) {
                    this._targetMesh && this.setMaterial(1, this._normalMaterial);
                    this._showState[1] = true;
                } else {
                    this.setMaterial(1, null);
                    this._showState[1] = false;
                }
                break;
            case SketchMode.Tangent:
                if (isShow) {
                    this._targetMesh && this.setMaterial(2, this._tangentMaterial);
                    this._showState[2] = true;
                } else {
                    this.setMaterial(2, null);
                    this._showState[2] = false;
                }
                break;
            case SketchMode.BiTangent:
                if (isShow) {
                    this._targetMesh && this.setMaterial(3, this._biTangentMaterial);
                    this._showState[3] = true;
                } else {
                    this.setMaterial(3, null);
                    this._showState[3] = false;
                }
                break;
        }
    };
    _proto.clear = function clear() {
        this.setMaterial(0, null);
        this.setMaterial(1, null);
        this.setMaterial(2, null);
        this.setMaterial(3, null);
    };
    _proto.update = function update(deltaTime) {
        SkinnedMeshRenderer.prototype.update.call(this, deltaTime);
        var worldMatrix = this._worldMatrix;
        if (worldMatrix) {
            var worldNormalMatrix = this._worldNormalMatrix;
            Matrix.invert(worldMatrix, worldNormalMatrix);
            worldNormalMatrix.transpose();
            this.shaderData.setMatrix(SketchRenderer._worldNormalProp, worldNormalMatrix);
        }
    };
    _proto._uploadIndicesBuffer = function _uploadIndicesBuffer(value) {
        //@ts-ignore
        var indexBuffer = value._indexBufferBinding.buffer;
        var byteLength = indexBuffer.byteLength;
        var buffer = new Uint8Array(byteLength);
        indexBuffer.getData(buffer);
        //@ts-ignore
        var indexFormat = value._indicesFormat;
        var triangleCount = 0;
        switch(indexFormat){
            case IndexFormat.UInt8:
                {
                    triangleCount = byteLength / 3;
                    var width = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new Texture2D(this.engine, width, height, TextureFormat.R32G32B32A32, false);
                    var floatBuffer = new Float32Array(width * height * 4);
                    for(var i = 0; i < triangleCount; i++){
                        for(var j = 0; j < 3; j++){
                            floatBuffer[i * 4 + j] = buffer[i * 3 + j];
                        }
                        floatBuffer[i * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height);
                    break;
                }
            case IndexFormat.UInt16:
                {
                    var uint16Buffer = new Uint16Array(buffer.buffer);
                    triangleCount = byteLength / 6;
                    var width1 = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height1 = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new Texture2D(this.engine, width1, height1, TextureFormat.R32G32B32A32, false);
                    var floatBuffer1 = new Float32Array(width1 * height1 * 4);
                    for(var i1 = 0; i1 < triangleCount; i1++){
                        for(var j1 = 0; j1 < 3; j1++){
                            floatBuffer1[i1 * 4 + j1] = uint16Buffer[i1 * 3 + j1];
                        }
                        floatBuffer1[i1 * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer1);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width1);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height1);
                    break;
                }
            case IndexFormat.UInt32:
                {
                    var uint32Buffer = new Uint32Array(buffer.buffer);
                    triangleCount = byteLength / 12;
                    var width2 = Math.min(triangleCount, SketchRenderer._MAX_TEXTURE_ROWS);
                    var height2 = Math.ceil(triangleCount / SketchRenderer._MAX_TEXTURE_ROWS);
                    this._indicesTexture = new Texture2D(this.engine, width2, height2, TextureFormat.R32G32B32A32, false);
                    var floatBuffer2 = new Float32Array(width2 * height2 * 4);
                    for(var i2 = 0; i2 < triangleCount; i2++){
                        for(var j2 = 0; j2 < 3; j2++){
                            floatBuffer2[i2 * 4 + j2] = uint32Buffer[i2 * 3 + j2];
                        }
                        floatBuffer2[i2 * 4 + 3] = 0;
                    }
                    this._indicesTexture.setPixelBuffer(floatBuffer2);
                    this.shaderData.setTexture(SketchRenderer._indicesSamplerProp, this._indicesTexture);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureWidthProp, width2);
                    this.shaderData.setFloat(SketchRenderer._indicesTextureHeightProp, height2);
                    break;
                }
        }
        this._indicesTexture.filterMode = TextureFilterMode.Point;
    };
    _proto._uploadVerticesBuffer = function _uploadVerticesBuffer(value) {
        //@ts-ignore
        var vertexBufferBinding = value._vertexBufferBindings[0];
        var vertexCount = value.vertexCount;
        var elementCount = this._updateMeshElement(value);
        var jointIndexBegin = SketchRenderer._jointIndexBegin;
        var newElementCount = elementCount;
        if (jointIndexBegin !== -1) {
            newElementCount += 3;
        }
        var buffer = new Float32Array(elementCount * vertexCount);
        vertexBufferBinding.buffer.getData(buffer);
        var uint8Buffer = new Uint8Array(buffer.buffer);
        var alignElementCount = Math.ceil(newElementCount / 4) * 4;
        this.shaderData.enableMacro("ELEMENT_COUNT", (alignElementCount / 4).toString());
        var width = Math.min(vertexCount, SketchRenderer._MAX_TEXTURE_ROWS) * alignElementCount;
        var height = Math.ceil(vertexCount / SketchRenderer._MAX_TEXTURE_ROWS);
        var alignBuffer = new Float32Array(width * height);
        for(var i = 0; i < vertexCount; i++){
            for(var j = 0; j < newElementCount; j++){
                if (jointIndexBegin !== -1 && j === jointIndexBegin) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 1) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 1];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 2) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 2];
                } else if (jointIndexBegin !== -1 && j === jointIndexBegin + 3) {
                    alignBuffer[i * alignElementCount + j] = uint8Buffer[i * elementCount * 4 + jointIndexBegin * 4 + 3];
                } else {
                    if (jointIndexBegin !== -1 && j > jointIndexBegin + 3) {
                        alignBuffer[i * alignElementCount + j] = buffer[i * elementCount + j - 3];
                    } else {
                        alignBuffer[i * alignElementCount + j] = buffer[i * elementCount + j];
                    }
                }
            }
        }
        this._createVerticesTexture(alignBuffer, width / 4, height);
        SketchRenderer._jointIndexBegin = -1;
    };
    _proto._createVerticesTexture = function _createVerticesTexture(vertexBuffer, width, height) {
        this._verticesTexture = new Texture2D(this.engine, width, height, TextureFormat.R32G32B32A32, false);
        this._verticesTexture.filterMode = TextureFilterMode.Point;
        this._verticesTexture.setPixelBuffer(vertexBuffer);
        this.shaderData.setTexture(SketchRenderer._verticesSamplerProp, this._verticesTexture);
        this.shaderData.setFloat(SketchRenderer._verticesTextureWidthProp, width);
        this.shaderData.setFloat(SketchRenderer._verticesTextureHeightProp, height);
    };
    _proto._updateMeshElement = function _updateMeshElement(value) {
        var shaderData = this.shaderData;
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._normalMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._vertexColorMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._tangentMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._uvMacro);
        //@ts-ignore
        shaderData.disableMacro(SketchRenderer._uv1Macro);
        shaderData.disableMacro(SketchRenderer._weightMacro);
        shaderData.disableMacro(SketchRenderer._jointMacro);
        var elementCount = 0;
        //@ts-ignore
        var vertexElements = value._vertexElements;
        for(var i = 0, n = vertexElements.length; i < n; i++){
            var semantic = vertexElements[i].semantic;
            switch(semantic){
                case "POSITION":
                    elementCount += 3;
                    break;
                case "NORMAL":
                    elementCount += 3;
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._normalMacro);
                    break;
                case "COLOR_0":
                    elementCount += 4;
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._vertexColorMacro);
                    break;
                case "WEIGHTS_0":
                    elementCount += 4;
                    shaderData.enableMacro(SketchRenderer._weightMacro);
                    break;
                case "JOINTS_0":
                    SketchRenderer._jointIndexBegin = elementCount;
                    elementCount += 1;
                    shaderData.enableMacro(SketchRenderer._jointMacro);
                    break;
                case "TANGENT":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._tangentMacro);
                    elementCount += 4;
                    break;
                case "TEXCOORD_0":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._uvMacro);
                    elementCount += 2;
                    break;
                case "TEXCOORD_1":
                    //@ts-ignore
                    shaderData.enableMacro(SketchRenderer._uv1Macro);
                    elementCount += 2;
                    break;
                case "TEXCOORD_2":
                    elementCount += 2;
                    break;
                case "TEXCOORD_3":
                    elementCount += 2;
                    break;
                case "TEXCOORD_4":
                    elementCount += 2;
                    break;
                case "TEXCOORD_5":
                    elementCount += 2;
                    break;
                case "TEXCOORD_6":
                    elementCount += 2;
                    break;
                case "TEXCOORD_7":
                    elementCount += 2;
                    break;
            }
        }
        return elementCount;
    };
    _proto._updateLineSubMesh = function _updateLineSubMesh(mesh) {
        this._lineSubMesh.count = mesh.vertexCount * 2;
    };
    _proto._updateTriangleSubMesh = function _updateTriangleSubMesh(mesh) {
        var triangleCount = 0;
        var subMeshes = mesh.subMeshes;
        for(var i = 0; i < subMeshes.length; i++){
            var subMesh = subMeshes[i];
            triangleCount += subMesh.count;
        }
        this._triangleSubMesh.count = triangleCount;
    };
    _proto._destroy = function _destroy() {
        this._indicesTexture && this._indicesTexture.destroy();
        this._verticesTexture && this._verticesTexture.destroy();
    };
    _create_class(SketchRenderer, [
        {
            key: "scale",
            get: /**
   * Line scale
   */ function get() {
                return this.shaderData.getFloat(SketchRenderer._lineScaleProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SketchRenderer._lineScaleProp, value);
            }
        },
        {
            key: "worldMatrix",
            set: /**
   * World matrix
   */ function set(value) {
                if (value !== this._worldMatrix) {
                    this._worldMatrix = value;
                    this.shaderData.setMatrix(SketchRenderer._worldMatrixProp, value);
                }
            }
        },
        {
            key: "targetMesh",
            set: /**
   * Target mesh
   */ function set(value) {
                if (value !== this._targetMesh) {
                    this._destroy();
                    this._targetMesh = value;
                    this._uploadVerticesBuffer(value);
                    this._uploadIndicesBuffer(value);
                    this._updateTriangleSubMesh(value);
                    this._updateLineSubMesh(value);
                    for(var i = 0; i < 4; i++){
                        this.setSketchMode(i, this._showState[i]);
                    }
                }
            }
        },
        {
            key: "wireframeMaterial",
            get: /**
   * Material for wireframe shading
   */ function get() {
                return this._wireframeMaterial;
            }
        },
        {
            key: "normalMaterial",
            get: /**
   * Material for normal shading
   */ function get() {
                return this._normalMaterial;
            }
        },
        {
            key: "tangentMaterial",
            get: /**
   * Material for tangent shading
   */ function get() {
                return this._normalMaterial;
            }
        },
        {
            key: "biTangentMaterial",
            get: /**
   * Material for biTangent shading
   */ function get() {
                return this._normalMaterial;
            }
        }
    ]);
    return SketchRenderer;
}(SkinnedMeshRenderer);
SketchRenderer._weightMacro = ShaderMacro.getByName("RENDERER_HAS_WEIGHT");
SketchRenderer._jointMacro = ShaderMacro.getByName("RENDERER_HAS_JOINT");
SketchRenderer._MAX_TEXTURE_ROWS = 512;
SketchRenderer._jointIndexBegin = -1;
SketchRenderer._verticesSamplerProp = ShaderProperty.getByName("u_verticesSampler");
SketchRenderer._verticesTextureHeightProp = ShaderProperty.getByName("u_verticesTextureHeight");
SketchRenderer._verticesTextureWidthProp = ShaderProperty.getByName("u_verticesTextureWidth");
SketchRenderer._indicesSamplerProp = ShaderProperty.getByName("u_indicesSampler");
SketchRenderer._indicesTextureHeightProp = ShaderProperty.getByName("u_indicesTextureHeight");
SketchRenderer._indicesTextureWidthProp = ShaderProperty.getByName("u_indicesTextureWidth");
SketchRenderer._lineScaleProp = ShaderProperty.getByName("u_lineScale");
SketchRenderer._worldMatrixProp = ShaderProperty.getByName("u_worldMatrix");
SketchRenderer._worldNormalProp = ShaderProperty.getByName("u_worldNormal");

export { SketchRenderer };
//# sourceMappingURL=SketchRenderer.js.map
