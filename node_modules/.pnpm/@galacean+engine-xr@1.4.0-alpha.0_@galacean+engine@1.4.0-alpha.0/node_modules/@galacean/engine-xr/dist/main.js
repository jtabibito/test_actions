'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var engine = require('@galacean/engine');

function _is_native_reflect_construct() {
    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of(instance, Class.prototype);

            return instance;
        };
    }

    return _construct.apply(null, arguments);
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * Enumerates some input devices that can be tracked.(including status, posture and other information)
 */ var XRTrackedInputDevice = /*#__PURE__*/ function(XRTrackedInputDevice) {
    /** Controller */ XRTrackedInputDevice[XRTrackedInputDevice["Controller"] = 0] = "Controller";
    /** Left controller */ XRTrackedInputDevice[XRTrackedInputDevice["LeftController"] = 1] = "LeftController";
    /** Right controller */ XRTrackedInputDevice[XRTrackedInputDevice["RightController"] = 2] = "RightController";
    /** Camera */ XRTrackedInputDevice[XRTrackedInputDevice["Camera"] = 3] = "Camera";
    /** Left camera */ XRTrackedInputDevice[XRTrackedInputDevice["LeftCamera"] = 4] = "LeftCamera";
    /** Right camera */ XRTrackedInputDevice[XRTrackedInputDevice["RightCamera"] = 5] = "RightCamera";
    /** Head */ XRTrackedInputDevice[XRTrackedInputDevice["LeftHand"] = 6] = "LeftHand";
    /** Right hand */ XRTrackedInputDevice[XRTrackedInputDevice["RightHand"] = 7] = "RightHand";
    return XRTrackedInputDevice;
}({});

/**
 * The state of an XRSession.
 */ var XRSessionState = /*#__PURE__*/ function(XRSessionState) {
    /** Not initialized. */ XRSessionState[XRSessionState["None"] = 0] = "None";
    /** Initializing session. */ XRSessionState[XRSessionState["Initializing"] = 1] = "Initializing";
    /** Initialized but not started. */ XRSessionState[XRSessionState["Initialized"] = 2] = "Initialized";
    /** Running. */ XRSessionState[XRSessionState["Running"] = 3] = "Running";
    /** Paused. */ XRSessionState[XRSessionState["Paused"] = 4] = "Paused";
    return XRSessionState;
}({});

/**
 * The manager of XR camera.
 */ var XRCameraManager = /*#__PURE__*/ function() {
    function XRCameraManager(_xrManager) {
        this._xrManager = _xrManager;
    }
    var _proto = XRCameraManager.prototype;
    /**
   * Attach the camera to the specified input type(Camera, LeftCamera or RightCamera).
   * The camera entity need to be moved to the XROrigin entity.
   * @param type - The input type
   * @param camera - The camera to be attached
   */ _proto.attachCamera = function attachCamera(type, camera) {
        var xrCamera = this._xrManager.inputManager.getTrackedDevice(type);
        var preCamera = xrCamera._camera;
        if (preCamera !== camera) {
            // @ts-ignore
            preCamera && (preCamera._cameraType = engine.CameraType.Normal);
            switch(type){
                case XRTrackedInputDevice.Camera:
                    // @ts-ignore
                    camera._cameraType = engine.CameraType.XRCenterCamera;
                    break;
                case XRTrackedInputDevice.LeftCamera:
                    // @ts-ignore
                    camera._cameraType = engine.CameraType.XRLeftCamera;
                    break;
                case XRTrackedInputDevice.RightCamera:
                    // @ts-ignore
                    camera._cameraType = engine.CameraType.XRRightCamera;
                    break;
            }
            xrCamera._camera = camera;
        }
    };
    /**
   * Detach the camera from the specified input type.
   * @param type - The input type
   * @returns The camera that was detached
   */ _proto.detachCamera = function detachCamera(type) {
        var xrCamera = this._xrManager.inputManager.getTrackedDevice(type);
        var preCamera = xrCamera._camera;
        // @ts-ignore
        preCamera && (preCamera._cameraType = engine.CameraType.Normal);
        xrCamera._camera = null;
        return preCamera;
    };
    /**
   * @internal
   */ _proto._onSessionStart = function _onSessionStart() {};
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        var _this__xrManager_inputManager = this._xrManager.inputManager, cameras = _this__xrManager_inputManager._cameras;
        for(var i = 0, n = cameras.length; i < n; i++){
            var cameraDevice = cameras[i];
            var camera = cameraDevice._camera;
            if (!camera) continue;
            // sync position and rotation
            var transform = camera.entity.transform;
            var pose = cameraDevice.pose;
            transform.position = pose.position;
            transform.rotationQuaternion = pose.rotation;
            // sync viewport
            var viewport = camera.viewport;
            var _cameraDevice_viewport = cameraDevice.viewport, x = _cameraDevice_viewport.x, y = _cameraDevice_viewport.y, width = _cameraDevice_viewport.width, height = _cameraDevice_viewport.height;
            if (!(x === viewport.x && y === viewport.y && width === viewport.z && height === viewport.w)) {
                camera.viewport = viewport.set(x, y, width, height);
            }
            // sync project matrix
            if (!engine.Matrix.equals(camera.projectionMatrix, cameraDevice.projectionMatrix)) {
                camera.projectionMatrix = cameraDevice.projectionMatrix;
            }
        }
    };
    /**
   * @internal
   */ _proto._onSessionExit = function _onSessionExit() {};
    /**
   * @internal
   */ _proto._getIgnoreClearFlags = function _getIgnoreClearFlags(cameraType) {
        if (cameraType === engine.CameraType.XRCenterCamera) {
            if (this._xrManager.sessionManager.state === XRSessionState.Running) {
                return engine.CameraClearFlags.Color;
            } else {
                return engine.CameraClearFlags.None;
            }
        } else {
            return engine.CameraClearFlags.None;
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {};
    _create_class(XRCameraManager, [
        {
            key: "fixedFoveation",
            get: /**
   * The fixed foveation of the camera.
   */ function get() {
                var _this__xrManager_sessionManager = this._xrManager.sessionManager, platformSession = _this__xrManager_sessionManager._platformSession;
                if (platformSession) {
                    return platformSession.getFixedFoveation();
                } else {
                    throw new Error("XR session is not available.");
                }
            },
            set: function set(value) {
                var _this__xrManager_sessionManager = this._xrManager.sessionManager, platformSession = _this__xrManager_sessionManager._platformSession;
                if (platformSession) {
                    platformSession.setFixedFoveation(value);
                } else {
                    throw new Error("XR session is not available.");
                }
            }
        }
    ]);
    return XRCameraManager;
}();

/**
 * Data for describing pose in the XR space.
 */ var XRPose = function XRPose() {
    /** The position of the pose in XR space. */ this.position = new engine.Vector3();
    /** The rotation of the pose in XR space. */ this.rotation = new engine.Quaternion();
    /** The matrix of the pose in XR space. */ this.matrix = new engine.Matrix();
    /** The inverse matrix of the pose in XR space. */ this.inverseMatrix = new engine.Matrix();
};

/**
 * Enum for XR tracking state.
 */ var XRTrackingState = /*#__PURE__*/ function(XRTrackingState) {
    /** Not tracking */ XRTrackingState[XRTrackingState["NotTracking"] = 0] = "NotTracking";
    /** Tracking */ XRTrackingState[XRTrackingState["Tracking"] = 1] = "Tracking";
    /** Lost track */ XRTrackingState[XRTrackingState["TrackingLost"] = 2] = "TrackingLost";
    return XRTrackingState;
}({});

var XRInput = function XRInput(type) {
    this.type = type;
    this./** The tracking state of xr input. */ trackingState = XRTrackingState.NotTracking;
};

/**
 * The XR camera.
 */ var XRCamera = /*#__PURE__*/ function(XRInput) {
    _inherits(XRCamera, XRInput);
    function XRCamera() {
        var _this;
        _this = XRInput.apply(this, arguments) || this, /** The pose of the camera in XR space. */ _this.pose = new XRPose(), /** The viewport of the camera. */ _this.viewport = new engine.Rect(), /** The projection matrix of the camera. */ _this.projectionMatrix = new engine.Matrix();
        return _this;
    }
    return XRCamera;
}(XRInput);

/**
 * Enum for XR input button.
 */ var XRInputButton = /*#__PURE__*/ function(XRInputButton) {
    /** None */ XRInputButton[XRInputButton["None"] = 0] = "None";
    /** Select */ XRInputButton[XRInputButton["Select"] = 1] = "Select";
    /** Select */ XRInputButton[XRInputButton["Trigger"] = 1] = "Trigger";
    /** Squeeze */ XRInputButton[XRInputButton["Squeeze"] = 2] = "Squeeze";
    /** TouchPad */ XRInputButton[XRInputButton["TouchPad"] = 4] = "TouchPad";
    /** A */ XRInputButton[XRInputButton["AButton"] = 8] = "AButton";
    /** B */ XRInputButton[XRInputButton["BButton"] = 16] = "BButton";
    return XRInputButton;
}({});

/**
 * The XR controller.
 */ var XRController = /*#__PURE__*/ function(XRInput) {
    _inherits(XRController, XRInput);
    function XRController() {
        var _this;
        _this = XRInput.apply(this, arguments) || this, /** The grip space pose of the controller in XR space. */ _this.gripPose = new XRPose(), /** The target ray space pose of the controller in XR space. */ _this.targetRayPose = new XRPose(), /** The currently pressed buttons of this controller. */ _this.pressedButtons = XRInputButton.None, /** Record button lifted. */ _this.down = XRInputButton.None, /** Record button pressed. */ _this.up = XRInputButton.None;
        return _this;
    }
    var _proto = XRController.prototype;
    /**
   *
   * Returns whether the button is pressed.
   * @param button - The button to check
   * @returns Whether the button is pressed
   */ _proto.isButtonDown = function isButtonDown(button) {
        return (this.down & button) !== 0;
    };
    /**
   * Returns whether the button is lifted.
   * @param button - The button to check
   * @returns Whether the button is lifted
   */ _proto.isButtonUp = function isButtonUp(button) {
        return (this.up & button) !== 0;
    };
    /**
   * Returns whether the button is held down.
   * @param button - The button to check
   * @returns Whether the button is held down
   */ _proto.isButtonHeldDown = function isButtonHeldDown(button) {
        return (this.pressedButtons & button) !== 0;
    };
    return XRController;
}(XRInput);

var XRInputEventType = /*#__PURE__*/ function(XRInputEventType) {
    XRInputEventType[XRInputEventType["SelectStart"] = 0] = "SelectStart";
    XRInputEventType[XRInputEventType["Select"] = 1] = "Select";
    XRInputEventType[XRInputEventType["SelectEnd"] = 2] = "SelectEnd";
    XRInputEventType[XRInputEventType["SqueezeStart"] = 3] = "SqueezeStart";
    XRInputEventType[XRInputEventType["Squeeze"] = 4] = "Squeeze";
    XRInputEventType[XRInputEventType["SqueezeEnd"] = 5] = "SqueezeEnd";
    return XRInputEventType;
}({});

var XRTargetRayMode = /*#__PURE__*/ function(XRTargetRayMode) {
    XRTargetRayMode[XRTargetRayMode["Gaze"] = 0] = "Gaze";
    XRTargetRayMode[XRTargetRayMode["TrackedPointer"] = 1] = "TrackedPointer";
    XRTargetRayMode[XRTargetRayMode["Screen"] = 2] = "Screen";
    return XRTargetRayMode;
}({});

/**
 * The manager of XR input.
 */ var XRInputManager = /*#__PURE__*/ function() {
    function XRInputManager(_xrManager, _engine) {
        this._xrManager = _xrManager;
        this._engine = _engine;
        this./** @internal */ _cameras = [];
        this./** @internal */ _controllers = [];
        this._added = [];
        this._removed = [];
        this._trackedDevices = [];
        this._statusSnapshot = [];
        this._listeners = new engine.SafeLoopArray();
        var _this = this, trackedDevices = _this._trackedDevices, controllers = _this._controllers, cameras = _this._cameras;
        for(var i = 0; i < 6; i++){
            switch(i){
                case XRTrackedInputDevice.Camera:
                case XRTrackedInputDevice.LeftCamera:
                case XRTrackedInputDevice.RightCamera:
                    cameras.push(trackedDevices[i] = new XRCamera(i));
                    break;
                case XRTrackedInputDevice.Controller:
                case XRTrackedInputDevice.LeftController:
                case XRTrackedInputDevice.RightController:
                    controllers.push(trackedDevices[i] = new XRController(i));
                    break;
            }
        }
        this._statusSnapshot.fill(XRTrackingState.NotTracking, 0, trackedDevices.length);
    }
    var _proto = XRInputManager.prototype;
    /**
   * Returns the tracked device instance.
   * @param type - The tracked input device type
   * @returns The input instance
   */ _proto.getTrackedDevice = function getTrackedDevice(type) {
        return this._trackedDevices[type];
    };
    /**
   * Add a listener for tracked device changes.
   * @param listener - The listener to add
   */ _proto.addTrackedDeviceChangedListener = function addTrackedDeviceChangedListener(listener) {
        this._listeners.push({
            fn: listener
        });
    };
    /**
   * Remove a listener of tracked device changes.
   * @param listener - The listener to remove
   */ _proto.removeTrackedDeviceChangedListener = function removeTrackedDeviceChangedListener(listener) {
        this._listeners.findAndRemove(function(value) {
            return value.fn === listener ? value.destroyed = true : false;
        });
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        var _this = this, added = _this._added, removed = _this._removed, statusSnapshot = _this._statusSnapshot;
        var _this1 = this, trackedDevices = _this1._trackedDevices, controllers = _this1._controllers;
        // Reset data
        added.length = removed.length = 0;
        for(var i = 0, n = controllers.length; i < n; i++){
            var controller = controllers[i];
            controller.down = controller.up = 0;
        }
        // Handle events and update tracked devices
        var _this__xrManager_sessionManager = this._xrManager.sessionManager, platformSession = _this__xrManager_sessionManager._platformSession;
        var platformEvents = platformSession.events;
        for(var i1 = 0, n1 = platformEvents.length; i1 < n1; i1++){
            this._handleEvent(platformEvents[i1]);
        }
        platformSession.resetEvents();
        platformSession.frame.updateInputs(trackedDevices);
        for(var i2 = 0, n2 = trackedDevices.length; i2 < n2; i2++){
            var input = trackedDevices[i2];
            if (!input) continue;
            var nowState = input.trackingState;
            if (statusSnapshot[i2] === XRTrackingState.Tracking) {
                if (nowState !== XRTrackingState.Tracking) {
                    removed.push(input);
                }
            } else {
                if (nowState === XRTrackingState.Tracking) {
                    added.push(input);
                }
            }
            statusSnapshot[i2] = nowState;
        }
        // Dispatch change event
        if (added.length > 0 || removed.length > 0) {
            var listeners = this._listeners.getLoopArray();
            for(var i3 = 0, n3 = listeners.length; i3 < n3; i3++){
                var listener = listeners[i3];
                !listener.destroyed && listener.fn(added, removed);
            }
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        this._listeners.findAndRemove(function(value) {
            return value.destroyed = true;
        });
    };
    _proto._handleEvent = function _handleEvent(event) {
        var input = this._trackedDevices[event.input];
        switch(event.targetRayMode){
            case XRTargetRayMode.TrackedPointer:
                switch(event.type){
                    case XRInputEventType.SelectStart:
                        input.down |= XRInputButton.Select;
                        input.pressedButtons |= XRInputButton.Select;
                        break;
                    case XRInputEventType.SelectEnd:
                        input.up |= XRInputButton.Select;
                        input.pressedButtons &= ~XRInputButton.Select;
                        break;
                    case XRInputEventType.SqueezeStart:
                        input.down |= XRInputButton.Squeeze;
                        input.pressedButtons |= XRInputButton.Squeeze;
                        break;
                    case XRInputEventType.SqueezeEnd:
                        input.up |= XRInputButton.Squeeze;
                        input.pressedButtons &= ~XRInputButton.Squeeze;
                        break;
                }
                break;
            case XRTargetRayMode.Screen:
                var _this = this, engine = _this._engine;
                // @ts-ignore
                var target = engine.inputManager._pointerManager._target;
                // @ts-ignore
                var canvas = engine.canvas._webCanvas;
                var clientWidth = canvas.clientWidth, clientHeight = canvas.clientHeight;
                var clientX = clientWidth * (event.x + 1) * 0.5;
                var clientY = clientHeight * (event.y + 1) * 0.5;
                // @ts-ignore
                switch(event.type){
                    case XRInputEventType.SelectStart:
                        target.dispatchEvent(this._makeUpPointerEvent("pointerdown", event.id, clientX, clientY));
                        break;
                    case XRInputEventType.Select:
                        target.dispatchEvent(this._makeUpPointerEvent("pointermove", event.id, clientX, clientY));
                        break;
                    case XRInputEventType.SelectEnd:
                        target.dispatchEvent(this._makeUpPointerEvent("pointerup", event.id, clientX, clientY));
                        target.dispatchEvent(this._makeUpPointerEvent("pointerleave", event.id, clientX, clientY));
                        break;
                }
                break;
        }
    };
    _proto._makeUpPointerEvent = function _makeUpPointerEvent(type, pointerId, clientX, clientY) {
        var eventInitDict = {
            pointerId: pointerId,
            clientX: clientX,
            clientY: clientY
        };
        switch(type){
            case "pointerdown":
                eventInitDict.button = 0;
                eventInitDict.buttons = 1;
                break;
            case "pointermove":
                eventInitDict.button = -1;
                eventInitDict.buttons = 1;
                break;
            case "pointerup":
                eventInitDict.button = 0;
                eventInitDict.buttons = 0;
                break;
            case "pointerleave":
                eventInitDict.button = 0;
                eventInitDict.buttons = 0;
                break;
        }
        return new PointerEvent(type, eventInitDict);
    };
    return XRInputManager;
}();

/**
 * The type of XR session.
 */ var XRSessionMode = /*#__PURE__*/ function(XRSessionMode) {
    XRSessionMode[XRSessionMode["None"] = 0] = "None";
    XRSessionMode[XRSessionMode["AR"] = 1] = "AR";
    XRSessionMode[XRSessionMode["VR"] = 2] = "VR";
    return XRSessionMode;
}({});

/**
 * XRSessionManager manages the life cycle of XR sessions.
 */ var XRSessionManager = /*#__PURE__*/ function() {
    function XRSessionManager(_xrManager, _engine) {
        this._xrManager = _xrManager;
        this._engine = _engine;
        this._mode = XRSessionMode.None;
        this._state = XRSessionState.None;
        this._listeners = new engine.SafeLoopArray();
        // @ts-ignore
        this._rhi = _engine._hardwareRenderer;
        this._raf = requestAnimationFrame.bind(window);
        this._caf = cancelAnimationFrame.bind(window);
        this._onSessionExit = this._onSessionExit.bind(this);
    }
    var _proto = XRSessionManager.prototype;
    /**
   * Check if the specified mode is supported.
   * @param mode - The mode to check
   * @returns A promise that resolves if the mode is supported, otherwise rejects
   */ _proto.isSupportedMode = function isSupportedMode(mode) {
        return this._xrManager._platformDevice.isSupportedSessionMode(mode);
    };
    /**
   * Run the session.
   */ _proto.run = function run() {
        var _this = this, platformSession = _this._platformSession, engine = _this._engine;
        if (!platformSession) {
            throw new Error("Without session to run.");
        }
        platformSession.start();
        this._setState(XRSessionState.Running);
        this._xrManager._onSessionStart();
        if (!engine.isPaused) {
            engine.pause();
            engine.resume();
        }
    };
    /**
   * Stop the session.
   */ _proto.stop = function stop() {
        var _this = this, platformSession = _this._platformSession, engine = _this._engine, rhi = _this._rhi;
        if (!platformSession) {
            throw new Error("Without session to stop.");
        }
        if (this._state !== XRSessionState.Running) {
            throw new Error("Session is not running.");
        }
        rhi._mainFrameBuffer = null;
        rhi._mainFrameWidth = rhi._mainFrameHeight = 0;
        platformSession.stop();
        this._setState(XRSessionState.Paused);
        this._xrManager._onSessionStop();
        if (!engine.isPaused) {
            engine.pause();
            engine.resume();
        }
    };
    /**
   * Add a listening function for session state changes.
   * @param listener - The listening function
   */ _proto.addStateChangedListener = function addStateChangedListener(listener) {
        this._listeners.push({
            fn: listener
        });
    };
    /**
   * Remove a listening function of session state changes.
   * @param listener - The listening function
   */ _proto.removeStateChangedListener = function removeStateChangedListener(listener) {
        this._listeners.findAndRemove(function(value) {
            return value.fn === listener ? value.destroyed = true : false;
        });
    };
    /**
   * @internal
   */ _proto._setState = function _setState(value) {
        this._state = value;
        var listeners = this._listeners.getLoopArray();
        for(var i = 0, n = listeners.length; i < n; i++){
            var listener = listeners[i];
            !listener.destroyed && listener.fn(value);
        }
    };
    /**
   * @internal
   */ _proto._initialize = function _initialize(mode, features) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var xrManager = _this._xrManager;
            // Initialize all features
            var platformFeatures = [];
            for(var i = 0, n = features.length; i < n; i++){
                var _features_i = features[i], platformFeature = _features_i._platformFeature;
                platformFeature && platformFeatures.push(platformFeature);
            }
            xrManager._platformDevice.requestSession(_this._rhi, mode, platformFeatures).then(function(platformSession) {
                _this._mode = mode;
                _this._platformSession = platformSession;
                _this._setState(XRSessionState.Initialized);
                platformSession.setSessionExitCallBack(_this._onSessionExit);
                platformSession.addEventListener();
                xrManager._onSessionInit();
                resolve();
            }, reject);
        });
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        var _this = this, rhi = _this._rhi, platformSession = _this._platformSession;
        rhi._mainFrameBuffer = platformSession.framebuffer;
        rhi._mainFrameWidth = platformSession.framebufferWidth;
        rhi._mainFrameHeight = platformSession.framebufferHeight;
    };
    /**
   * @internal
   */ _proto._getRequestAnimationFrame = function _getRequestAnimationFrame() {
        if (this._state === XRSessionState.Running) {
            return this._platformSession.requestAnimationFrame;
        } else {
            return this._raf;
        }
    };
    /**
   * @internal
   */ _proto._getCancelAnimationFrame = function _getCancelAnimationFrame() {
        if (this._state === XRSessionState.Running) {
            return this._platformSession.cancelAnimationFrame;
        } else {
            return this._caf;
        }
    };
    /**
   * @internal
   */ _proto._exit = function _exit() {
        var _this = this, platformSession = _this._platformSession;
        if (!platformSession) {
            return Promise.reject("Without session to stop.");
        }
        return platformSession.end();
    };
    _proto._onSessionExit = function _onSessionExit() {
        var _this = this, rhi = _this._rhi, platformSession = _this._platformSession, engine = _this._engine;
        rhi._mainFrameBuffer = null;
        rhi._mainFrameWidth = rhi._mainFrameHeight = 0;
        platformSession.removeEventListener();
        this._platformSession = null;
        this._setState(XRSessionState.None);
        this._xrManager._onSessionExit();
        if (!engine.isPaused) {
            engine.pause();
            engine.resume();
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        this._listeners.findAndRemove(function(value) {
            return value.destroyed = true;
        });
        this._raf = this._caf = null;
    };
    _create_class(XRSessionManager, [
        {
            key: "mode",
            get: /**
   * The current session mode( AR or VR ).
   */ function get() {
                return this._mode;
            }
        },
        {
            key: "state",
            get: /**
   * Return the current session state.
   */ function get() {
                return this._state;
            }
        },
        {
            key: "supportedFrameRate",
            get: /**
   * Return a list of supported frame rates.(only available in-session)
   */ function get() {
                return this._platformSession.supportedFrameRates;
            }
        },
        {
            key: "frameRate",
            get: /**
   * Return the current frame rate as reported by the device.
   */ function get() {
                return this._platformSession.frameRate;
            }
        }
    ]);
    return XRSessionManager;
}();

/**
 * @internal
 */ var XRManagerExtended = /*#__PURE__*/ function(XRManager) {
    _inherits(XRManagerExtended, XRManager);
    function XRManagerExtended() {
        return XRManager.apply(this, arguments) || this;
    }
    var _proto = XRManagerExtended.prototype;
    _proto.isSupportedFeature = function isSupportedFeature(feature) {
        return this._platformDevice.isSupportedFeature(XRManagerExtended._featureMap.get(feature));
    };
    _proto.addFeature = function addFeature(type) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            args[_key - 1] = arguments[_key];
        }
        if (this.sessionManager._platformSession) {
            throw new Error("Cannot add feature when the session is initialized.");
        }
        if (!this._platformDevice.isSupportedFeature(XRManagerExtended._featureMap.get(type))) {
            throw new Error("The feature is not supported");
        }
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            if (_instanceof(features[i], type)) throw new Error("The feature has been added");
        }
        var feature = _construct(type, [].concat([
            this
        ], args));
        features.push(feature);
        return feature;
    };
    _proto.getFeature = function getFeature(type) {
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            if (_instanceof(feature, type)) {
                return feature;
            }
        }
    };
    _proto.enterXR = function enterXR(sessionMode, autoRun) {
        var _this = this;
        if (autoRun === void 0) autoRun = true;
        var sessionManager = this.sessionManager;
        if (sessionManager._platformSession) {
            throw new Error("Please exit XR immersive mode first.");
        }
        if (!this._origin) {
            throw new Error("Please set origin before enter XR.");
        }
        return new Promise(function(resolve, reject) {
            // 1. Check if this xr mode is supported
            sessionManager.isSupportedMode(sessionMode).then(function() {
                sessionManager._setState(XRSessionState.Initializing);
                // 2. Initialize session
                sessionManager._initialize(sessionMode, _this.features).then(function() {
                    autoRun && sessionManager.run();
                    resolve();
                }, reject);
            }, reject);
        });
    };
    _proto.exitXR = function exitXR() {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this.sessionManager._exit().then(function() {
                resolve();
            }, reject);
        });
    };
    _proto._initialize = function _initialize(engine, xrDevice) {
        this._features = [];
        this._platformDevice = xrDevice;
        this.sessionManager = new XRSessionManager(this, engine);
        this.inputManager = new XRInputManager(this, engine);
        this.cameraManager = new XRCameraManager(this);
    };
    _proto._update = function _update() {
        var sessionManager = this.sessionManager;
        if (sessionManager.state !== XRSessionState.Running) return;
        sessionManager._onUpdate();
        this.inputManager._onUpdate();
        this.cameraManager._onUpdate();
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            feature.enabled && feature._onUpdate();
        }
    };
    _proto._destroy = function _destroy() {
        var _this = this;
        if (this.sessionManager._platformSession) {
            this.exitXR().then(function() {
                _this.sessionManager._onDestroy();
                _this.inputManager._onDestroy();
                _this.cameraManager._onDestroy();
            });
        } else {
            this.sessionManager._onDestroy();
            this.inputManager._onDestroy();
            this.cameraManager._onDestroy();
        }
    };
    _proto._getRequestAnimationFrame = function _getRequestAnimationFrame() {
        return this.sessionManager._getRequestAnimationFrame();
    };
    _proto._getCancelAnimationFrame = function _getCancelAnimationFrame() {
        return this.sessionManager._getCancelAnimationFrame();
    };
    _proto._getCameraIgnoreClearFlags = function _getCameraIgnoreClearFlags(type) {
        return this.cameraManager._getIgnoreClearFlags(type);
    };
    /**
   * @internal
   */ _proto._onSessionStop = function _onSessionStop() {
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            feature.enabled && feature._onSessionStop();
        }
    };
    /**
   * @internal
   */ _proto._onSessionInit = function _onSessionInit() {
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            feature.enabled && feature._onSessionInit();
        }
    };
    /**
   * @internal
   */ _proto._onSessionStart = function _onSessionStart() {
        this.cameraManager._onSessionStart();
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            feature.enabled && feature._onSessionStart();
        }
    };
    /**
   * @internal
   */ _proto._onSessionExit = function _onSessionExit() {
        this.cameraManager._onSessionExit();
        var features = this.features;
        for(var i = 0, n = features.length; i < n; i++){
            var feature = features[i];
            feature.enabled && feature._onSessionExit();
            feature._onDestroy();
        }
        features.length = 0;
    };
    _create_class(XRManagerExtended, [
        {
            key: "features",
            get: function get() {
                return this._features;
            }
        },
        {
            key: "origin",
            get: function get() {
                return this._origin;
            },
            set: function set(value) {
                if (this.sessionManager._platformSession) {
                    throw new Error("Cannot set origin when the session is initialized.");
                }
                this._origin = value;
            }
        }
    ]);
    return XRManagerExtended;
}(engine.XRManager);
/** @internal */ XRManagerExtended._featureMap = new Map();
/**
 * @internal
 */ function registerXRFeature(type) {
    return function(feature) {
        XRManagerExtended._featureMap.set(feature, type);
    };
}
// 实现混入的函数
function ApplyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function(baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));
        });
    });
}
ApplyMixins(engine.XRManager, [
    XRManagerExtended
]);

/**
 * The base class of XR feature manager.
 */ var XRFeature = /*#__PURE__*/ function() {
    function XRFeature(_xrManager, _type) {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            args[_key - 2] = arguments[_key];
        }
        var _xrManager__platformDevice;
        this._xrManager = _xrManager;
        this._type = _type;
        this._enabled = true;
        this._platformFeature = (_xrManager__platformDevice = _xrManager._platformDevice).createPlatformFeature.apply(_xrManager__platformDevice, [].concat([
            _type
        ], args));
        this._onEnable();
    }
    var _proto = XRFeature.prototype;
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {};
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {};
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {};
    /**
   * @internal
   */ _proto._onSessionInit = function _onSessionInit() {};
    /**
   * @internal
   */ _proto._onSessionStart = function _onSessionStart() {};
    /**
   * @internal
   */ _proto._onSessionStop = function _onSessionStop() {};
    /**
   * @internal
   */ _proto._onSessionExit = function _onSessionExit() {};
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {};
    _create_class(XRFeature, [
        {
            key: "enabled",
            get: /**
   * Returns whether the feature is enabled.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (this.enabled !== value) {
                    this._enabled = value;
                    value ? this._onEnable() : this._onDisable();
                }
            }
        }
    ]);
    return XRFeature;
}();

var XRFeatureType = /*#__PURE__*/ function(XRFeatureType) {
    XRFeatureType[XRFeatureType["AnchorTracking"] = 0] = "AnchorTracking";
    XRFeatureType[XRFeatureType["ImageTracking"] = 1] = "ImageTracking";
    XRFeatureType[XRFeatureType["PlaneTracking"] = 2] = "PlaneTracking";
    XRFeatureType[XRFeatureType["HitTest"] = 3] = "HitTest";
    return XRFeatureType;
}({});

var XRRequestTrackingState = /*#__PURE__*/ function(XRRequestTrackingState) {
    XRRequestTrackingState[XRRequestTrackingState["None"] = 0] = "None";
    XRRequestTrackingState[XRRequestTrackingState["Submitted"] = 1] = "Submitted";
    XRRequestTrackingState[XRRequestTrackingState["Resolved"] = 2] = "Resolved";
    XRRequestTrackingState[XRRequestTrackingState["Rejected"] = 3] = "Rejected";
    XRRequestTrackingState[XRRequestTrackingState["Destroyed"] = 4] = "Destroyed";
    XRRequestTrackingState[XRRequestTrackingState["WaitingDestroy"] = 5] = "WaitingDestroy";
    return XRRequestTrackingState;
}({});

/**
 * The base class of XR trackable manager.
 */ var XRTrackableFeature = /*#__PURE__*/ function(XRFeature) {
    _inherits(XRTrackableFeature, XRFeature);
    function XRTrackableFeature() {
        var _this;
        _this = XRFeature.apply(this, arguments) || this, _this._requestTrackings = [], _this._tracked = [], _this._added = [], _this._updated = [], _this._removed = [], _this._statusSnapshot = {}, _this._listeners = new engine.SafeLoopArray();
        return _this;
    }
    var _proto = XRTrackableFeature.prototype;
    /**
   * Add a listening function for tracked object changes.
   * @param listener - The listening function
   */ _proto.addChangedListener = function addChangedListener(listener) {
        this._listeners.push({
            fn: listener
        });
    };
    /**
   * Remove a listening function of tracked object changes.
   * @param listener - The listening function
   */ _proto.removeChangedListener = function removeChangedListener(listener) {
        this._listeners.findAndRemove(function(value) {
            return value.fn === listener ? value.destroyed = true : false;
        });
    };
    _proto._onUpdate = function _onUpdate() {
        var _this__xrManager_sessionManager = this._xrManager.sessionManager, platformSession = _this__xrManager_sessionManager._platformSession;
        var platformFrame = platformSession.frame;
        var _this = this, platformFeature = _this._platformFeature, requestTrackings = _this._requestTrackings, statusSnapshot = _this._statusSnapshot, allTracked = _this._tracked, added = _this._added, updated = _this._updated, removed = _this._removed;
        if (!platformFrame || !requestTrackings.length) {
            return;
        }
        if (!platformFeature.checkAvailable(platformSession, platformFrame, requestTrackings)) {
            return;
        }
        added.length = updated.length = removed.length = 0;
        platformFeature.getTrackedResult(platformSession, platformFrame, requestTrackings, this._generateTracked);
        for(var i = 0, n = requestTrackings.length; i < n; i++){
            var requestTracking = requestTrackings[i];
            switch(requestTracking.state){
                case XRRequestTrackingState.Destroyed:
                    var destroyedTracked = requestTracking.tracked;
                    for(var j = 0, n1 = destroyedTracked.length; j < n1; j++){
                        var tracked = destroyedTracked[j];
                        var trackId = tracked.id;
                        if (statusSnapshot[trackId] === XRTrackingState.Tracking) {
                            removed.push(tracked);
                            allTracked.splice(allTracked.indexOf(tracked), 1);
                        }
                        statusSnapshot[trackId] = XRTrackingState.NotTracking;
                    }
                    break;
                case XRRequestTrackingState.Resolved:
                    var tracked1 = requestTracking.tracked;
                    for(var j1 = 0, n2 = tracked1.length; j1 < n2; j1++){
                        var trackedObject = tracked1[j1];
                        var trackId1 = trackedObject.id;
                        if (trackedObject.state === XRTrackingState.Tracking) {
                            if (statusSnapshot[trackId1] === XRTrackingState.Tracking) {
                                updated.push(trackedObject);
                            } else {
                                added.push(trackedObject);
                                statusSnapshot[trackId1] = XRTrackingState.Tracking;
                                allTracked.push(trackedObject);
                            }
                        } else {
                            if (statusSnapshot[trackId1] === XRTrackingState.Tracking) {
                                removed.push(trackedObject);
                                allTracked.splice(allTracked.indexOf(trackedObject), 1);
                            }
                            statusSnapshot[trackId1] = trackedObject.state;
                        }
                    }
                    break;
            }
        }
        for(var i1 = requestTrackings.length - 1; i1 >= 0; i1--){
            requestTrackings[i1].state === XRRequestTrackingState.Destroyed && requestTrackings.splice(i1, 1);
        }
        if (added.length > 0 || updated.length > 0 || removed.length > 0) {
            var listeners = this._listeners.getLoopArray();
            for(var i2 = 0, n3 = listeners.length; i2 < n3; i2++){
                var listener = listeners[i2];
                !listener.destroyed && listener.fn(added, updated, removed);
            }
        }
    };
    _proto._onSessionStop = function _onSessionStop() {
        this._added.length = this._updated.length = this._removed.length = 0;
    };
    _proto._onSessionExit = function _onSessionExit() {
        // prettier-ignore
        this._requestTrackings.length = this._tracked.length = this._added.length = this._updated.length = this._removed.length = 0;
        this._listeners.findAndRemove(function(value) {
            return value.destroyed = true;
        });
    };
    _proto._addRequestTracking = function _addRequestTracking(requestTracking) {
        var _this = this, platformFeature = _this._platformFeature;
        if (this._xrManager.sessionManager._platformSession && !platformFeature.canModifyRequestTrackingAfterInit) {
            throw new Error(XRFeatureType[this._type] + " request tracking cannot be modified after initialization.");
        }
        this._requestTrackings.push(requestTracking);
        platformFeature.onAddRequestTracking(requestTracking);
    };
    _proto._removeRequestTracking = function _removeRequestTracking(requestTracking) {
        var _this = this, platformFeature = _this._platformFeature;
        if (this._xrManager.sessionManager._platformSession && !platformFeature.canModifyRequestTrackingAfterInit) {
            throw new Error(XRFeatureType[this._type] + " request tracking cannot be modified after initialization.");
        }
        platformFeature.onDelRequestTracking(requestTracking);
    };
    _proto._removeAllRequestTrackings = function _removeAllRequestTrackings() {
        var _this = this, platformFeature = _this._platformFeature;
        if (this._xrManager.sessionManager._platformSession && !platformFeature.canModifyRequestTrackingAfterInit) {
            throw new Error(XRFeatureType[this._type] + " request tracking cannot be modified after initialization.");
        }
        var _this1 = this, requestTrackings = _this1._requestTrackings;
        for(var i = 0, n = requestTrackings.length; i < n; i++){
            platformFeature.onDelRequestTracking(requestTrackings[i]);
        }
    };
    return XRTrackableFeature;
}(XRFeature);
XRTrackableFeature._uuid = 0;

/**
 * The base class of XR tracked object.
 */ var XRTracked = function XRTracked() {
    /** The pose of the trackable in XR space. */ this.pose = new XRPose();
    /** The tracking state of the trackable. */ this.state = XRTrackingState.NotTracking;
};

/**
 * Enum for the types of hit test that can be performed.
 * Note: currently only supports plane.
 */ var TrackableType = /*#__PURE__*/ function(TrackableType) {
    /** Tracked plane. */ TrackableType[TrackableType["Plane"] = 1] = "Plane";
    /** All tracked objects. */ TrackableType[TrackableType["All"] = 1] = "All";
    return TrackableType;
}({});

/**
 * XR hit result.
 * It is the detection result returned by using XR HitTest feature.
 */ var XRHitResult = function XRHitResult() {
    /** The position of the hit point. */ this.point = new engine.Vector3();
    /** The normal of the hit point. */ this.normal = new engine.Vector3();
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * Enumerates modes of plane in XR.
 */ var XRPlaneMode = /*#__PURE__*/ function(XRPlaneMode) {
    /** None. */ XRPlaneMode[XRPlaneMode["None"] = 0] = "None";
    /** Horizontal */ XRPlaneMode[XRPlaneMode["Horizontal"] = 1] = "Horizontal";
    /** Vertical */ XRPlaneMode[XRPlaneMode["Vertical"] = 2] = "Vertical";
    /** Includes horizontal and vertical. */ XRPlaneMode[XRPlaneMode["EveryThing"] = 3] = "EveryThing";
    return XRPlaneMode;
}({});

/**
 * @internal
 */ var XRRequestTracking = function XRRequestTracking() {
    /** The status of the current request tracking. */ this.state = XRRequestTrackingState.None;
    /** Tracked instances, make up from the tracking data returned by Session. */ this.tracked = [];
};

/**
 * The request plane in XR space.
 */ var XRRequestPlane = /*#__PURE__*/ function(XRRequestTracking) {
    _inherits(XRRequestPlane, XRRequestTracking);
    function XRRequestPlane(detectionMode) {
        var _this;
        _this = XRRequestTracking.call(this) || this, _this.detectionMode = detectionMode;
        return _this;
    }
    return XRRequestPlane;
}(XRRequestTracking);

/**
 * The tracked plane in XR space.
 */ var XRTrackedPlane = /*#__PURE__*/ function(XRTracked) {
    _inherits(XRTrackedPlane, XRTracked);
    function XRTrackedPlane() {
        var _this;
        _this = XRTracked.apply(this, arguments) || this, /** The points that make up this plane.
   *  Note: These points are in the plane coordinate system,
   *  and their Y coordinates are all zero.
   */ _this.polygon = [], /**
   * Whether this frame changes the attributes of the plane.
   * Note: Includes `polygon` but no `pose`.
   */ _this.attributesDirty = false;
        return _this;
    }
    return XRTrackedPlane;
}(XRTracked);

exports.XRPlaneTracking = /*#__PURE__*/ function(XRTrackableFeature1) {
    _inherits(XRPlaneTracking, XRTrackableFeature1);
    function XRPlaneTracking(xrManager, detectionMode) {
        if (detectionMode === void 0) detectionMode = XRPlaneMode.EveryThing;
        var _this;
        _this = XRTrackableFeature1.call(this, xrManager, XRFeatureType.PlaneTracking, detectionMode) || this;
        _this._addRequestTracking(new XRRequestPlane(detectionMode));
        return _this;
    }
    var _proto = XRPlaneTracking.prototype;
    _proto._generateTracked = function _generateTracked() {
        var plane = new XRTrackedPlane();
        plane.id = XRTrackableFeature._uuid++;
        return plane;
    };
    _create_class(XRPlaneTracking, [
        {
            key: "detectionMode",
            get: /**
   * The plane detection mode.
   */ function get() {
                return this._requestTrackings[0].detectionMode;
            }
        },
        {
            key: "trackedPlanes",
            get: /**
   * The tracked planes.
   */ function get() {
                return this._tracked;
            }
        }
    ]);
    return XRPlaneTracking;
}(XRTrackableFeature);
exports.XRPlaneTracking = __decorate([
    registerXRFeature(XRFeatureType.PlaneTracking)
], exports.XRPlaneTracking);

exports.XRHitTest = /*#__PURE__*/ function(XRFeature) {
    _inherits(XRHitTest, XRFeature);
    function XRHitTest(xrManager) {
        var _this;
        _this = XRFeature.call(this, xrManager, XRFeatureType.HitTest) || this, _this._tempRay = new engine.Ray(), _this._tempPlane = new engine.Plane(), _this._tempVec2 = new engine.Vector2(), _this._tempVec30 = new engine.Vector3(), _this._tempVec31 = new engine.Vector3(), _this._tempVec32 = new engine.Vector3(), _this._tempVec33 = new engine.Vector3(), _this._tempVec34 = new engine.Vector3(), _this._tempVec35 = new engine.Vector3();
        return _this;
    }
    var _proto = XRHitTest.prototype;
    /**
   * Hit test.
   * @param ray - The ray to test
   * @param type - The type of hit test
   * @returns The hit result
   */ _proto.hitTest = function hitTest(ray, type) {
        var result = [];
        if (type & TrackableType.Plane) {
            this._hitTestPlane(ray, result);
        }
        return result;
    };
    /**
   * Screen hit test.
   * @param x - The x coordinate of the screen point
   * @param y - The y coordinate of the screen point
   * @param type - The type of hit test
   * @returns The hit result
   */ _proto.screenHitTest = function screenHitTest(x, y, type) {
        var _this = this, xrManager = _this._xrManager;
        if (xrManager.sessionManager.mode !== XRSessionMode.AR) {
            throw new Error("Only AR mode supports using screen ray hit test.");
        }
        var _xrManager_inputManager_getTrackedDevice = xrManager.inputManager.getTrackedDevice(XRTrackedInputDevice.Camera), camera = _xrManager_inputManager_getTrackedDevice._camera;
        if (!camera) {
            throw new Error("No camera available.");
        }
        var ray = camera.screenPointToRay(this._tempVec2.set(x, y), this._tempRay);
        return this.hitTest(ray, type);
    };
    _proto._hitTestPlane = function _hitTestPlane(ray, result) {
        var planeManager = this._xrManager.getFeature(exports.XRPlaneTracking);
        if (!planeManager || !planeManager.enabled) {
            throw new Error("The plane estimation function needs to be turned on for plane hit test.");
        }
        var _this = this, plane = _this._tempPlane, normal = _this._tempVec30, hitPoint = _this._tempVec31, hitPointInPlane = _this._tempVec32;
        var trackedPlanes = planeManager.trackedPlanes;
        for(var i = 0, n = trackedPlanes.length; i < n; i++){
            var trackedPlane = trackedPlanes[i];
            normal.set(0, 1, 0).transformNormal(trackedPlane.pose.matrix);
            plane.normal.copyFrom(normal);
            plane.distance = -engine.Vector3.dot(normal, trackedPlane.pose.position);
            var distance = ray.intersectPlane(plane);
            if (distance >= 0) {
                ray.getPoint(distance, hitPoint);
                engine.Vector3.transformToVec3(hitPoint, trackedPlane.pose.inverseMatrix, hitPointInPlane);
                // Check if the hit position is within the plane boundary.
                if (this._checkPointerWithinPlane(hitPointInPlane, trackedPlane)) {
                    var hitResult = new XRHitResult();
                    hitResult.point.copyFrom(hitPoint);
                    hitResult.normal.copyFrom(normal);
                    hitResult.distance = distance;
                    hitResult.trackedObject = trackedPlane;
                    hitResult.trackableType = TrackableType.Plane;
                    result.push(hitResult);
                }
            }
        }
    };
    _proto._checkPointerWithinPlane = function _checkPointerWithinPlane(pointer, plane) {
        var _this = this, preToCur = _this._tempVec33, preToPointer = _this._tempVec34, cross = _this._tempVec35;
        var polygon = plane.polygon;
        var length = polygon.length;
        var prePoint = polygon[length - 1];
        var side = 0;
        for(var i = 0; i < length; i++){
            var curPoint = polygon[i];
            engine.Vector3.subtract(curPoint, prePoint, preToCur);
            engine.Vector3.subtract(pointer, prePoint, preToPointer);
            engine.Vector3.cross(preToCur, preToPointer, cross);
            var y = cross.y;
            if (side === 0) {
                if (y > 0) {
                    side = 1;
                } else if (y < 0) {
                    side = -1;
                }
            } else {
                if (y > 0 && side < 0 || y < 0 && side > 0) {
                    return false;
                }
            }
            prePoint = curPoint;
        }
        return true;
    };
    return XRHitTest;
}(XRFeature);
exports.XRHitTest = __decorate([
    registerXRFeature(XRFeatureType.HitTest)
], exports.XRHitTest);

/**
 * The anchor in XR space.
 */ var XRAnchor = /*#__PURE__*/ function(XRTracked) {
    _inherits(XRAnchor, XRTracked);
    function XRAnchor() {
        return XRTracked.apply(this, arguments) || this;
    }
    return XRAnchor;
}(XRTracked);

/**
 * The request anchor in XR space.
 */ var XRRequestAnchor = /*#__PURE__*/ function(XRRequestTracking) {
    _inherits(XRRequestAnchor, XRRequestTracking);
    function XRRequestAnchor(position, rotation) {
        var _this;
        _this = XRRequestTracking.call(this) || this, _this.position = position, _this.rotation = rotation;
        return _this;
    }
    return XRRequestAnchor;
}(XRRequestTracking);

exports.XRAnchorTracking = /*#__PURE__*/ function(XRTrackableFeature1) {
    _inherits(XRAnchorTracking, XRTrackableFeature1);
    function XRAnchorTracking(xrManager) {
        var _this;
        _this = XRTrackableFeature1.call(this, xrManager, XRFeatureType.AnchorTracking) || this, _this._anchors = [];
        return _this;
    }
    var _proto = XRAnchorTracking.prototype;
    /**
   * Add a anchor in XR space.
   * @param anchor - The anchor to be added
   */ _proto.addAnchor = function addAnchor(position, rotation) {
        if (!this._enabled) {
            throw new Error("Cannot add an anchor from a disabled anchor manager.");
        }
        var _this = this, anchors = _this._anchors;
        var requestAnchor = new XRRequestAnchor(position, rotation);
        var xrAnchor = this._generateTracked();
        requestAnchor.tracked[0] = xrAnchor;
        this._addRequestTracking(requestAnchor);
        anchors.push(xrAnchor);
        return xrAnchor;
    };
    /**
   * Remove a anchor in XR space.
   * @param anchor - The anchor to be removed
   */ _proto.removeAnchor = function removeAnchor(anchor) {
        if (!this._enabled) {
            throw new Error("Cannot remove an anchor from a disabled anchor manager.");
        }
        var _this = this, requestTrackings = _this._requestTrackings, anchors = _this._anchors;
        for(var i = 0, n = requestTrackings.length; i < n; i++){
            var requestAnchor = requestTrackings[i];
            if (requestAnchor.tracked[0] === anchor) {
                this._removeRequestTracking(requestAnchor);
                break;
            }
        }
        anchors.splice(anchors.indexOf(anchor), 1);
    };
    /**
   * Remove all tracking anchors.
   */ _proto.clearAnchors = function clearAnchors() {
        if (!this._enabled) {
            throw new Error("Cannot remove anchors from a disabled anchor manager.");
        }
        this._removeAllRequestTrackings();
    };
    _proto._generateTracked = function _generateTracked() {
        var anchor = new XRAnchor();
        anchor.id = XRTrackableFeature._uuid++;
        return anchor;
    };
    _create_class(XRAnchorTracking, [
        {
            key: "trackingAnchors",
            get: /**
   * The anchors to tracking.
   */ function get() {
                return this._anchors;
            }
        },
        {
            key: "trackedAnchors",
            get: /**
   * The tracked anchors.
   */ function get() {
                return this._tracked;
            }
        }
    ]);
    return XRAnchorTracking;
}(XRTrackableFeature);
exports.XRAnchorTracking = __decorate([
    registerXRFeature(XRFeatureType.AnchorTracking)
], exports.XRAnchorTracking);

/**
 * The request image in XR space.
 */ var XRRequestImage = /*#__PURE__*/ function(XRRequestTracking) {
    _inherits(XRRequestImage, XRRequestTracking);
    function XRRequestImage(image) {
        var _this;
        _this = XRRequestTracking.call(this) || this, _this.image = image;
        return _this;
    }
    return XRRequestImage;
}(XRRequestTracking);

/**
 * A tracked image in XR space.
 */ var XRTrackedImage = /*#__PURE__*/ function(XRTracked) {
    _inherits(XRTrackedImage, XRTracked);
    function XRTrackedImage() {
        return XRTracked.apply(this, arguments) || this;
    }
    return XRTrackedImage;
}(XRTracked);

exports.XRImageTracking = /*#__PURE__*/ function(XRTrackableFeature1) {
    _inherits(XRImageTracking, XRTrackableFeature1);
    function XRImageTracking(xrManager, trackingImages) {
        var _this;
        _this = XRTrackableFeature1.call(this, xrManager, XRFeatureType.ImageTracking, trackingImages) || this;
        _this._trackingImages = trackingImages;
        var imageLength = trackingImages ? trackingImages.length : 0;
        if (imageLength > 0) {
            for(var i = 0, n = trackingImages.length; i < n; i++){
                _this._addRequestTracking(new XRRequestImage(trackingImages[i]));
            }
        } else {
            console.warn("No image to be tracked.");
        }
        return _this;
    }
    var _proto = XRImageTracking.prototype;
    _proto._generateTracked = function _generateTracked() {
        var image = new XRTrackedImage();
        image.id = XRTrackableFeature._uuid++;
        return image;
    };
    _create_class(XRImageTracking, [
        {
            key: "trackingImages",
            get: /**
   * The image to tracking.
   */ function get() {
                return this._trackingImages;
            }
        },
        {
            key: "trackedImages",
            get: /**
   * The tracked images.
   */ function get() {
                return this._tracked;
            }
        }
    ]);
    return XRImageTracking;
}(XRTrackableFeature);
exports.XRImageTracking = __decorate([
    registerXRFeature(XRFeatureType.ImageTracking)
], exports.XRImageTracking);

/**
 *  A reference image is an image to look for in the physical environment.
 */ var XRReferenceImage = function XRReferenceImage(name, imageSource, physicalWidth) {
    this.name = name;
    this.imageSource = imageSource;
    this.physicalWidth = physicalWidth;
};

exports.XRReferenceImageDecoder = /*#__PURE__*/ function() {
    function XRReferenceImageDecoder() {}
    XRReferenceImageDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve, reject) {
            var physicalWidth = bufferReader.nextFloat32();
            bufferReader.nextUint8();
            var img = new Image();
            img.onload = function() {
                resolve(new XRReferenceImage("", img, physicalWidth));
            };
            img.src = URL.createObjectURL(new window.Blob([
                bufferReader.nextImagesData(1)[0]
            ]));
        });
    };
    return XRReferenceImageDecoder;
}();
exports.XRReferenceImageDecoder = __decorate([
    engine.decoder("XRReferenceImage")
], exports.XRReferenceImageDecoder);

function _extends() {
    _extends = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

exports.XRReferenceImageLoader = /*#__PURE__*/ function(Loader) {
    _inherits(XRReferenceImageLoader, Loader);
    function XRReferenceImageLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = XRReferenceImageLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new engine.AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                engine.decode(data, resourceManager.engine).then(function(referenceImage) {
                    resolve(referenceImage);
                });
            }).catch(reject);
        });
    };
    return XRReferenceImageLoader;
}(engine.Loader);
exports.XRReferenceImageLoader = __decorate([
    engine.resourceLoader("XRReferenceImage", [])
], exports.XRReferenceImageLoader);

exports.TrackableType = TrackableType;
exports.XRAnchor = XRAnchor;
exports.XRCamera = XRCamera;
exports.XRCameraManager = XRCameraManager;
exports.XRController = XRController;
exports.XRFeature = XRFeature;
exports.XRFeatureType = XRFeatureType;
exports.XRHitResult = XRHitResult;
exports.XRInputButton = XRInputButton;
exports.XRInputEventType = XRInputEventType;
exports.XRInputManager = XRInputManager;
exports.XRPlaneMode = XRPlaneMode;
exports.XRPose = XRPose;
exports.XRReferenceImage = XRReferenceImage;
exports.XRRequestTrackingState = XRRequestTrackingState;
exports.XRSessionManager = XRSessionManager;
exports.XRSessionMode = XRSessionMode;
exports.XRSessionState = XRSessionState;
exports.XRTargetRayMode = XRTargetRayMode;
exports.XRTrackableFeature = XRTrackableFeature;
exports.XRTracked = XRTracked;
exports.XRTrackedImage = XRTrackedImage;
exports.XRTrackedInputDevice = XRTrackedInputDevice;
exports.XRTrackedPlane = XRTrackedPlane;
exports.XRTrackingState = XRTrackingState;
//# sourceMappingURL=main.js.map
