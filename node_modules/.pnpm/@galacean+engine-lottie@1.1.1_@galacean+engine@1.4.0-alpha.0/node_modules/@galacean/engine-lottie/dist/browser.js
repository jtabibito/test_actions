(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@galacean/engine')) :
    typeof define === 'function' && define.amd ? define(['exports', '@galacean/engine'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Galacean = global.Galacean || {}, global.Galacean.Lottie = {}), global.Galacean));
})(this, (function (exports, engine) { 'use strict';

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;

            if ("value" in descriptor) descriptor.writable = true;

            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _create_class(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);

        return Constructor;
    }

    function _set_prototype_of(o, p) {
        _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
            o.__proto__ = p;

            return o;
        };

        return _set_prototype_of(o, p);
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

        if (superClass) _set_prototype_of(subClass, superClass);
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gaëtan Renaudeau 2014 - 2015 – MIT License
     */

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = typeof Float32Array === 'function';

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }

    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
     for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
       var currentSlope = getSlope(aGuessT, mX1, mX2);
       if (currentSlope === 0.0) {
         return aGuessT;
       }
       var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
       aGuessT -= currentX / currentSlope;
     }
     return aGuessT;
    }

    function LinearEasing (x) {
      return x;
    }

    var src = function bezier (mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }

      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }

      // Precompute samples table
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }

      function getTForX (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;

        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;

        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }

      return function BezierEasing (x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };

    var defaultCurveSegments = 200;
    var beziers = {};
    /**
     * get a bezierEasing from real time or cache
     */ function getBezierEasing(a, b, c, d, nm) {
        var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
        var bezier = beziers[str];
        if (bezier) {
            return bezier;
        }
        bezier = src(a, b, c, d);
        beziers[str] = bezier;
        return bezier;
    }
    var storedData = {};
    function buildBezierData(s, e, to, ti, segments) {
        var curveSegments = segments ? Math.min(segments, defaultCurveSegments) : defaultCurveSegments;
        var bezierName = (s[0] + "_" + s[1] + "_" + e[0] + "_" + e[1] + "_" + to[0] + "_" + to[1] + "_" + ti[0] + "_" + ti[1] + "_" + curveSegments).replace(/\./g, "p");
        if (!storedData[bezierName]) {
            var segmentLength = 0;
            var lastPoint;
            var points = [];
            for(var k = 0; k < curveSegments; k++){
                var len = to.length;
                var point = new Array(len);
                var perc = k / (curveSegments - 1);
                var ptDistance = 0;
                for(var i = 0; i < len; i += 1){
                    var ptCoord = Math.pow(1 - perc, 3) * s[i] + 3 * Math.pow(1 - perc, 2) * perc * (s[i] + to[i]) + 3 * (1 - perc) * Math.pow(perc, 2) * (e[i] + ti[i]) + Math.pow(perc, 3) * e[i];
                    point[i] = ptCoord;
                    if (lastPoint) {
                        ptDistance += Math.pow(point[i] - lastPoint[i], 2);
                    }
                }
                ptDistance = Math.sqrt(ptDistance);
                segmentLength += ptDistance;
                points.push({
                    partialLength: ptDistance,
                    point: point
                });
                lastPoint = point;
            }
            storedData[bezierName] = {
                segmentLength: segmentLength,
                points: points
            };
        }
        return storedData[bezierName];
    }
    var bez = {
        buildBezierData: buildBezierData,
        getBezierEasing: getBezierEasing
    };

    /**
     * some useful toolkit
     * @namespace
     */ var Tools = {
        /**
       * euclidean modulo
       * @method
       * @param {Number} n input value
       * @param {Number} m modulo
       * @return {Number} re-map to modulo area
       */ euclideanModulo: function euclideanModulo(n, m) {
            return (n % m + m) % m;
        },
        /**
       * bounce value when value spill codomain
       * @method
       * @param {Number} n input value
       * @param {Number} min lower boundary
       * @param {Number} max upper boundary
       * @return {Number} bounce back to boundary area
       */ codomainBounce: function codomainBounce(n, min, max) {
            if (n < min) return 2 * min - n;
            if (n > max) return 2 * max - n;
            return n;
        },
        /**
       * clamp a value in range
       * @method
       * @param {Number} x input value
       * @param {Number} a lower boundary
       * @param {Number} b upper boundary
       * @return {Number} clamp in range
       */ clamp: function clamp(x, a, b) {
            return x < a ? a : x > b ? b : x;
        }
    };

    // @ts-nocheck
    var EX_REG = /(loopIn|loopOut)\(([^)]+)/;
    var STR_REG = /["']\w+["']/;
    /**
     * Cycle
     * @class
     * @private
     */ var Cycle = /*#__PURE__*/ function() {
        function Cycle(type, begin, end) {
            this.begin = begin;
            this.end = end;
            this.total = this.end - this.begin;
            this.type = type;
        }
        var _proto = Cycle.prototype;
        /**
       * progress
       * @param {number} progress progress
       * @return {number} progress
       */ _proto.update = function update(progress) {
            if (this.type === "in") {
                if (progress >= this.begin) return progress;
                return this.end - Tools.euclideanModulo(this.begin - progress, this.total);
            } else if (this.type === "out") {
                if (progress <= this.end) return progress;
                return this.begin + Tools.euclideanModulo(progress - this.end, this.total);
            }
        };
        return Cycle;
    }();
    /**
     * Pingpong
     * @class
     * @private
     */ var Pingpong = /*#__PURE__*/ function() {
        function Pingpong(type, begin, end) {
            this.begin = begin;
            this.end = end;
            this.total = this.end - this.begin;
            this.type = type;
        }
        var _proto = Pingpong.prototype;
        /**
       * progress
       * @param {number} progress progress
       * @return {number} progress
       */ _proto.update = function update(progress) {
            if (this.type === "in" && progress < this.begin || this.type === "out" && progress > this.end) {
                var space = progress - this.end;
                return this.pingpong(space);
            }
            return progress;
        };
        /**
       * pingpong
       * @param {number} space
       * @return {number}
       */ _proto.pingpong = function pingpong(space) {
            var dir = Math.floor(space / this.total) % 2;
            if (dir) {
                return this.begin + Tools.euclideanModulo(space, this.total);
            } else {
                return this.end - Tools.euclideanModulo(space, this.total);
            }
        };
        return Pingpong;
    }();
    var FN_MAPS = {
        loopIn: function loopIn(datak, mode, offset) {
            var begin = datak[0].t;
            var last = datak.length - 1;
            var endIdx = Math.min(last, offset);
            var end = datak[endIdx].t;
            switch(mode){
                case "cycle":
                    return new Cycle("in", begin, end);
                case "pingpong":
                    return new Pingpong("in", begin, end);
            }
            return null;
        },
        loopOut: function loopOut(datak, mode, offset) {
            var last = datak.length - 1;
            var beginIdx = Math.max(0, last - offset);
            var begin = datak[beginIdx].t;
            var end = datak[last].t;
            switch(mode){
                case "cycle":
                    return new Cycle("out", begin, end);
                case "pingpong":
                    return new Pingpong("out", begin, end);
            }
            return null;
        }
    };
    /**
     * parseParams
     * @ignore
     * @param {string} pStr string
     * @return {array}
     */ function parseParams(pStr) {
        var params = pStr.split(/\s*,\s*/);
        return params.map(function(it) {
            if (STR_REG.test(it)) return it.replace(/"|'/g, "");
            return parseInt(it);
        });
    }
    /**
     * parseEx
     * @ignore
     * @param {string} ex string
     * @return {object}
     */ function parseEx(ex) {
        var rs = ex.match(EX_REG);
        var ps = parseParams(rs[2]);
        return {
            name: rs[1],
            mode: ps[0],
            offset: ps[1]
        };
    }
    /**
     * hasSupportExpression
     * @ignore
     * @param {string} ksp string
     * @return {boolean}
     */ function hasSupportExpression(ksp) {
        return ksp.x && EX_REG.test(ksp.x);
    }
    /**
     * getExpression
     * @ignore
     * @param {object} ksp ksp
     * @return {object}
     */ function getExpression(ksp) {
        var _parseEx = parseEx(ksp.x), name = _parseEx.name, mode = _parseEx.mode, _parseEx_offset = _parseEx.offset, offset = _parseEx_offset === void 0 ? 0 : _parseEx_offset;
        var _offset = offset === 0 ? ksp.k.length - 1 : offset;
        return FN_MAPS[name] && FN_MAPS[name](ksp.k, mode, _offset);
    }
    var Expression = {
        hasSupportExpression: hasSupportExpression,
        getExpression: getExpression
    };

    var BaseProperty = /*#__PURE__*/ function() {
        function BaseProperty(data, mult) {
            this.mult = mult || 1;
            this.value = data.k;
            this.animated = data.a;
            if (Expression.hasSupportExpression(data)) {
                this.expression = Expression.getExpression(data);
            }
        }
        var _proto = BaseProperty.prototype;
        _proto.getValue = function getValue(frameNum, i, keyData, nextKeyData) {
            var perc;
            var keyTime = keyData.t;
            var nextKeyTime = nextKeyData.t;
            var startValue = keyData.s[i];
            var endValue = (nextKeyData.s || keyData.e)[i];
            if (keyData.h === 1) {
                return startValue;
            }
            if (frameNum >= nextKeyTime) {
                perc = 1;
            } else if (frameNum < keyTime) {
                perc = 0;
            } else {
                var bezier = keyData.beziers[i];
                if (!bezier) {
                    if (typeof keyData.o.x === "number") {
                        bezier = bez.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y);
                    } else {
                        bezier = bez.getBezierEasing(keyData.o.x[i], keyData.o.y[i], keyData.i.x[i], keyData.i.y[i]);
                    }
                    keyData.beziers[i] = bezier;
                }
                perc = bezier((frameNum - keyTime) / (nextKeyTime - keyTime));
            }
            return startValue + (endValue - startValue) * perc;
        };
        _proto.reset = function reset() {};
        return BaseProperty;
    }();

    var ValueProperty = /*#__PURE__*/ function(BaseProperty) {
        _inherits(ValueProperty, BaseProperty);
        function ValueProperty(data, mult) {
            if (mult === void 0) mult = 1;
            var _this;
            _this = BaseProperty.call(this, data, mult) || this;
            _this.v = mult ? _this.value * mult : _this.value;
            return _this;
        }
        var _proto = ValueProperty.prototype;
        _proto.update = function update() {
            this.v = this.value * this.mult;
        };
        return ValueProperty;
    }(BaseProperty);

    var MultiDimensionalProperty = /*#__PURE__*/ function(BaseProperty) {
        _inherits(MultiDimensionalProperty, BaseProperty);
        function MultiDimensionalProperty(data, mult) {
            if (mult === void 0) mult = 1;
            var _this;
            _this = BaseProperty.call(this, data, mult) || this;
            var len = _this.value.length;
            _this.v = new Float32Array(len);
            _this.newValue = new Float32Array(len);
            for(var i = 0; i < len; i += 1){
                _this.v[i] = _this.value[i] * _this.mult;
            }
            return _this;
        }
        var _proto = MultiDimensionalProperty.prototype;
        _proto.update = function update() {
            var finalValue;
            finalValue = this.value;
            for(var i = 0, len = this.v.length; i < len; i++){
                this.v[i] = finalValue[i] * this.mult;
            }
        };
        return MultiDimensionalProperty;
    }(BaseProperty);

    var KeyframedValueProperty = /*#__PURE__*/ function(BaseProperty) {
        _inherits(KeyframedValueProperty, BaseProperty);
        function KeyframedValueProperty(data, mult) {
            if (mult === void 0) mult = 1;
            var _this;
            _this = BaseProperty.call(this, data, mult) || this, _this._value = 0;
            _this.v = 0;
            if (Expression.hasSupportExpression(data)) {
                _this.expression = Expression.getExpression(data);
            }
            return _this;
        }
        var _proto = KeyframedValueProperty.prototype;
        _proto.reset = function reset() {
            this._value = 0;
        };
        _proto.update = function update(frameNum) {
            if (this.expression) {
                frameNum = this.expression.update(frameNum);
            }
            var value = this.value;
            var keyData;
            var nextKeyData;
            // Find current frame
            for(var i = 0, l = value.length - 1; i < l; i++){
                keyData = value[i];
                nextKeyData = value[i + 1];
                if (nextKeyData.t > frameNum) {
                    break;
                }
            }
            if (!keyData.beziers) {
                keyData.beziers = [];
            }
            this.v = this.getValue(frameNum, 0, keyData, nextKeyData) * this.mult;
        };
        return KeyframedValueProperty;
    }(BaseProperty);

    var KeyframedMultidimensionalProperty = /*#__PURE__*/ function(BaseProperty) {
        _inherits(KeyframedMultidimensionalProperty, BaseProperty);
        function KeyframedMultidimensionalProperty(data, mult, frames) {
            if (mult === void 0) mult = 1;
            var _this;
            _this = BaseProperty.call(this, data, mult) || this, _this._lastPoint = 0, _this._addedLength = 0;
            var arrLen = _this.value[0].s.length;
            // Set bezier segments according to frames, which is better for performance.
            if (frames) {
                _this._frames = frames >> 0;
            }
            _this.newValue = new Float32Array(arrLen);
            _this.v = new Float32Array(arrLen);
            return _this;
        }
        var _proto = KeyframedMultidimensionalProperty.prototype;
        _proto.update = function update(frameNum) {
            if (this.expression) {
                frameNum = this.expression.update(frameNum);
            }
            var value = this.value;
            var newValue = this.newValue;
            var keyData;
            var nextKeyData;
            // Find current frame
            for(var i = 0, l = value.length - 1; i < l; i++){
                keyData = value[i];
                nextKeyData = value[i + 1];
                if (nextKeyData.t > frameNum) {
                    this._lastPoint = 0;
                    this._addedLength = 0;
                    break;
                }
            }
            if (frameNum > nextKeyData.t) {
                for(var i1 = 0, len = this.v.length; i1 < len; i1++){
                    this.v[i1] = this.getValue(frameNum, i1, keyData, nextKeyData) * this.mult;
                }
                return;
            }
            if (keyData.to) {
                var nextKeyTime = nextKeyData.t;
                var keyTime = keyData.t;
                if (!keyData.bezierData) {
                    keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti, this._frames);
                }
                var _keyData_bezierData = keyData.bezierData, points = _keyData_bezierData.points, segmentLength = _keyData_bezierData.segmentLength;
                var bezier = keyData.timeBezier;
                // Cache time bezier easing
                if (!bezier) {
                    bezier = bez.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n);
                    keyData.timeBezier = bezier;
                }
                var t = 0;
                if (nextKeyTime >= 0) {
                    t = (frameNum - keyTime) / (nextKeyTime - keyTime);
                    t = Math.min(Math.max(0, t), 1);
                }
                var percent = bezier(t);
                var distanceInLine = segmentLength * percent;
                var addedLength = this._addedLength;
                var lastPoint = this._lastPoint;
                for(var i2 = lastPoint, l1 = points.length; i2 < l1; i2++){
                    if (i2 === l1 - 1) {
                        lastPoint = 0;
                        addedLength = 0;
                        break;
                    }
                    lastPoint = i2;
                    var point = points[i2];
                    var nextPoint = points[i2 + 1];
                    var partialLength = nextPoint.partialLength;
                    if (distanceInLine >= addedLength && distanceInLine < addedLength + partialLength) {
                        var segmentPercent = (distanceInLine - addedLength) / partialLength;
                        for(var k = 0, l2 = point.point.length; k < l2; k += 1){
                            newValue[k] = point.point[k] + (nextPoint.point[k] - point.point[k]) * segmentPercent;
                        }
                        break;
                    }
                    // Add partial length util the distanceInLine is between two points.
                    addedLength += partialLength;
                }
                this._lastPoint = lastPoint;
                this._addedLength = addedLength;
            } else {
                if (!keyData.beziers) {
                    keyData.beziers = [];
                }
                for(var i3 = 0, len1 = keyData.s.length; i3 < len1; i3++){
                    newValue[i3] = this.getValue(frameNum, i3, keyData, nextKeyData);
                }
            }
            for(var i4 = 0, len2 = this.v.length; i4 < len2; i4++){
                this.v[i4] = newValue[i4] * this.mult;
            }
        };
        return KeyframedMultidimensionalProperty;
    }(BaseProperty);

    var TransformFrames = /*#__PURE__*/ function() {
        function TransformFrames(data) {
            this.properties = [];
            this.autoOrient = false;
            var create = TransformFrames.create;
            if (data.p.k) {
                this.p = create(data.p, 1);
                this.properties.push(this.p);
            } else {
                if (data.p.x) {
                    this.x = create(data.p.x, 1);
                    this.properties.push(this.x);
                }
                // @ts-ignore
                if (data.p.y) {
                    // @ts-ignore
                    this.y = create(data.p.y, 1);
                    this.properties.push(this.y);
                }
                // @ts-ignore
                if (data.p.z) {
                    // @ts-ignore
                    this.z = create(data.p.z, 1);
                    this.properties.push(this.z);
                }
            }
            this.a = create(data.a, 1);
            this.properties.push(this.a);
            this.s = create(data.s, 1, 0.01);
            this.properties.push(this.s);
            this.o = create(data.o, 0, 0.01);
            this.properties.push(this.o);
            // 2d rotation
            if (data.r) {
                this.r = create(data.r, 0);
                this.properties.push(this.r);
            } else if (data.rx || data.ry || data.rz) {
                if (data.rx) {
                    this.rx = create(data.rx, 0);
                    this.properties.push(this.rx);
                }
                if (data.ry) {
                    this.ry = create(data.ry, 0);
                    this.properties.push(this.ry);
                }
                if (data.rz) {
                    this.rz = create(data.rz, 0);
                    this.properties.push(this.rz);
                }
            } else if (data.or) {
                this.or = create(data.or, 1);
                this.properties.push(this.or);
            }
            if (!this.properties.length) {
                this.update();
            }
        }
        var _proto = TransformFrames.prototype;
        _proto.reset = function reset() {
            for(var i = 0, len = this.properties.length; i < len; i++){
                this.properties[i].reset();
            }
        };
        _proto.update = function update(frameNum) {
            if (frameNum === void 0) frameNum = 0;
            var len = this.properties.length;
            for(var i = 0; i < len; i++){
                this.properties[i].update(frameNum);
            }
            if (this.autoOrient) ;
        };
        TransformFrames.create = function create(data, type, mult) {
            if (type === void 0) type = 0;
            if (mult === void 0) mult = 1;
            if (!data.k.length) {
                return new ValueProperty(data, mult);
            } else if (typeof data.k[0] === "number") {
                return new MultiDimensionalProperty(data, mult);
            } else {
                if (type) {
                    return new KeyframedMultidimensionalProperty(data, mult, data.k[data.k.length - 1].t - data.k[0].t);
                } else {
                    return new KeyframedValueProperty(data, mult);
                }
            }
        };
        return TransformFrames;
    }();

    var BaseLottieElement = /*#__PURE__*/ function() {
        function BaseLottieElement(layer) {
            this.stretch = 1;
            this.parent = null;
            this.visible = true;
            this.startTime = 0;
            this.treeIndex = [];
            this.childLayers = [];
            this.is3D = !!layer.ddd;
            this.name = layer.nm || "";
            this.index = layer.index;
            this.timeRemapping = layer.tm;
            this.width = layer.w;
            this.height = layer.h;
            this.inPoint = layer.ip;
            this.outPoint = layer.op;
            if (layer.st) {
                this.startTime = layer.st;
            }
            this.stretch = layer.stretch || 1;
            this.offsetTime = layer.offsetTime || 0;
            if (layer.ks) {
                this.transform = new TransformFrames(layer.ks);
            }
        }
        var _proto = BaseLottieElement.prototype;
        _proto.reset = function reset() {
            if (this.transform) {
                this.transform.reset();
            }
            for(var i = 0; i < this.childLayers.length; i++){
                this.childLayers[i].reset();
            }
        };
        _proto.update = function update(frameNum, isParentVisible) {
            if (frameNum === void 0) frameNum = 0;
            var frame = (frameNum - this.offsetTime) / this.stretch;
            if (isParentVisible === true) {
                this.visible = this.inPoint <= frame && this.outPoint >= frame;
            } else if (isParentVisible === false) {
                this.visible = false;
            }
            if (this.transform && this.visible) {
                this.transform.update(frame);
            }
            for(var i = 0; i < this.childLayers.length; i++){
                this.childLayers[i].update(frameNum, this.visible);
            }
        };
        /**
       * add child layer
       */ _proto.addChild = function addChild(node) {
            node.parent = this;
            node.entity.parent = this.entity;
            this.childLayers.push(node);
        };
        _proto.destroy = function destroy() {
            this.entity.parent = null;
            this.entity.destroy();
            this.entity = null;
            this.transform = null;
            this.parent = null;
        };
        return BaseLottieElement;
    }();

    var CompLottieElement = /*#__PURE__*/ function(BaseLottieElement) {
        _inherits(CompLottieElement, BaseLottieElement);
        function CompLottieElement(layer, engine$1, entity, name) {
            var _this;
            _this = BaseLottieElement.call(this, layer) || this;
            _this.layers = layer.layers;
            _this.comps = layer.comps;
            if (entity) {
                _this.entity = entity;
                if (name) {
                    _this.entity.name = name;
                }
            } else {
                var compEntity = new engine.Entity(engine$1, name);
                _this.entity = compEntity;
            }
            return _this;
        }
        var _proto = CompLottieElement.prototype;
        _proto.destroy = function destroy() {
            BaseLottieElement.prototype.destroy.call(this);
            this.layers = null;
            this.comps = null;
        };
        return CompLottieElement;
    }(BaseLottieElement);

    var SpriteLottieElement = /*#__PURE__*/ function(BaseLottieElement) {
        _inherits(SpriteLottieElement, BaseLottieElement);
        function SpriteLottieElement(layer, atlas, entity, childEntity) {
            var _this;
            _this = BaseLottieElement.call(this, layer) || this;
            var spriteRenderer;
            if (layer.refId) {
                if (childEntity) {
                    _this.entity = childEntity;
                    spriteRenderer = childEntity.getComponent(engine.SpriteRenderer);
                    _this.sprite = spriteRenderer.sprite;
                } else {
                    _this.sprite = atlas.getSprite(layer.refId);
                    var spriteEntity = new engine.Entity(entity.engine, layer.nm);
                    spriteRenderer = spriteEntity.addComponent(engine.SpriteRenderer);
                    spriteRenderer.sprite = _this.sprite;
                    _this.entity = spriteEntity;
                }
                var _this_sprite = _this.sprite, atlasRegion = _this_sprite.atlasRegion, texture = _this_sprite.texture;
                texture.wrapModeU = texture.wrapModeV = engine.TextureWrapMode.Clamp;
                _this.spriteRenderer = spriteRenderer;
                // local priority 范围控制在 （0, 1），同时为了尽可能避免精度问题，this.index * 1000000
                spriteRenderer.priority = (Number.MAX_SAFE_INTEGER - _this.index * 1000000) / Number.MAX_SAFE_INTEGER;
                _this.width = atlasRegion.width * texture.width;
                _this.height = atlasRegion.height * texture.height;
            }
            return _this;
        }
        var _proto = SpriteLottieElement.prototype;
        _proto.destroy = function destroy() {
            var _this_sprite_texture, _this_sprite;
            BaseLottieElement.prototype.destroy.call(this);
            (_this_sprite = this.sprite) == null ? void 0 : (_this_sprite_texture = _this_sprite.texture) == null ? void 0 : _this_sprite_texture.destroy();
            this.sprite = null;
            this.spriteRenderer = null;
        };
        return SpriteLottieElement;
    }(BaseLottieElement);

    var TextLottieElement = /*#__PURE__*/ function(BaseLottieElement) {
        _inherits(TextLottieElement, BaseLottieElement);
        function TextLottieElement(layer, engine$1, entity, name) {
            var _this;
            var _layer_t_d, _layer_t;
            _this = BaseLottieElement.call(this, layer) || this;
            if (entity) {
                _this.entity = entity;
                if (name) {
                    _this.entity.name = name;
                }
            } else {
                _this.entity = new engine.Entity(engine$1, layer.nm);
            }
            var textRenderer = _this.entity.addComponent(engine.TextRenderer);
            var keyframes = layer == null ? void 0 : (_layer_t = layer.t) == null ? void 0 : (_layer_t_d = _layer_t.d) == null ? void 0 : _layer_t_d.k;
            if (keyframes.length === 1) {
                var _keyframes_;
                // only one frame
                var firstKeyframeStart = keyframes == null ? void 0 : (_keyframes_ = keyframes[0]) == null ? void 0 : _keyframes_.s;
                if (firstKeyframeStart) {
                    var text = firstKeyframeStart.t, font = firstKeyframeStart.f, fontSize = firstKeyframeStart.s, fontColor = firstKeyframeStart.fc, lineHeight = firstKeyframeStart.lh;
                    // set the Font object by font
                    textRenderer.font = engine.Font.createFromOS(engine$1, font);
                    // set the text to be displayed by text
                    textRenderer.text = text;
                    // set the font size by fontSize
                    textRenderer.fontSize = fontSize;
                    // set the text color by color
                    textRenderer.color.set(fontColor[0], fontColor[1], fontColor[2], 1);
                    // set line spacing via lineSpacing
                    textRenderer.lineSpacing = lineHeight;
                } else {
                    engine.Logger.warn("TextLottieElement: " + name + ", No corresponding text data found.");
                }
            } else {
                // TODO: multi keyframes
                engine.Logger.warn("TextLottieElement: multi keyframes feature is not supported in this version.");
            }
            textRenderer.priority = (Number.MAX_SAFE_INTEGER - _this.index * 1000000) / Number.MAX_SAFE_INTEGER;
            return _this;
        }
        return TextLottieElement;
    }(BaseLottieElement);

    var LottieAnimation = /*#__PURE__*/ function(Script) {
        _inherits(LottieAnimation, Script);
        function LottieAnimation() {
            var _this;
            _this = Script.apply(this, arguments) || this, /** The number of units in world space that correspond to one pixel in the sprite. */ /** Repeat times of the animation. */ _this.repeats = 0, /** whether the animation loop or not. */ _this.isLooping = false, /** whether the animation play back and forth */ _this.isAlternate = false, /** The direction of animation, 1 means play for */ _this.direction = 1, _this.speed = 1, // @ts-ignore
            _this.pixelsPerUnit = engine.Engine._pixelsPerUnit, _this._alpha = 1, _this._priority = 0, _this._priorityDirty = true, _this._layer = engine.Layer.Layer0, _this._layerDirty = true, _this._autoPlay = false, _this._clipEndCallbacks = {}, _this._isPlaying = false, _this._curFrame = 0, _this._frame = 0, _this._root = null;
            return _this;
        }
        var _proto = LottieAnimation.prototype;
        /**
       * Play the lottie animation
       */ _proto.play = function play(name) {
            var _this = this;
            if (name) {
                var clip = this.resource.clips[name];
                this._clip = clip;
            } else {
                this._clip = null;
            }
            this._isPlaying = true;
            this._frame = this._curFrame;
            return new Promise(function(resolve) {
                if (name) {
                    _this._clipEndCallbacks[name] = resolve;
                } else {
                    _this._clipEndCallbacks["ALL"] = resolve;
                }
            });
        };
        /**
       * Pause the lottie animation
       */ _proto.pause = function pause() {
            this._isPlaying = false;
            this._curFrame = this._frame;
        };
        _proto.stop = function stop() {
            this._isPlaying = false;
            this._curFrame = 0;
            this._frame = 0;
        };
        _proto._setLayer = function _setLayer(layer, entity) {
            if (!entity) {
                entity = this.entity;
            }
            entity.layer = layer;
            var children = entity.children;
            for(var i = children.length - 1; i >= 0; i--){
                var child = children[i];
                child.layer = layer;
                this._setLayer(layer, child);
            }
        };
        _proto._createLayerElements = function _createLayerElements(layers, elements, parent, isCloned) {
            if (!layers) return;
            for(var i = 0, l = layers.length; i < l; i++){
                var layer = layers[i];
                var element = null;
                if (layer.td !== undefined) continue;
                var treeIndex = parent.treeIndex.concat(i);
                var childEntity = isCloned && this._findEntityInTree(treeIndex);
                switch(layer.ty){
                    case 0:
                        element = new CompLottieElement(layer, this.engine, childEntity, layer.id);
                        break;
                    case 2:
                        element = new SpriteLottieElement(layer, this._resource.atlas, this.entity, childEntity);
                        break;
                    case 3:
                        var _layer_ks_o, _layer_ks;
                        if ((layer == null ? void 0 : (_layer_ks = layer.ks) == null ? void 0 : (_layer_ks_o = _layer_ks.o) == null ? void 0 : _layer_ks_o.k) === 0) {
                            layer.ks.o.k = 100;
                        }
                        element = new CompLottieElement(layer, this.engine, childEntity, layer.id);
                        break;
                    case 5:
                        element = new TextLottieElement(layer, this.engine, childEntity, layer.id);
                        break;
                }
                if (element) {
                    element.treeIndex = treeIndex;
                    elements.push(element);
                    parent.addChild(element);
                    if (layer.layers) {
                        this._createLayerElements(layer.layers, elements, element, isCloned);
                    }
                }
            }
        };
        _proto._findEntityInTree = function _findEntityInTree(treeIndex) {
            var childEntity;
            for(var i = 0, l = treeIndex.length; i < l; i++){
                var index = treeIndex[i];
                if (childEntity) {
                    childEntity = childEntity.children[index];
                } else {
                    childEntity = this.entity.children[index];
                }
            }
            return childEntity;
        };
        _proto._createElements = function _createElements(value, isCloned) {
            var root = new CompLottieElement(value, this.engine, this.entity);
            this._root = root;
            var layers = root.layers;
            var elements = [];
            this._createLayerElements(layers, elements, root, isCloned);
            this._elements = elements;
        };
        _proto._updateElements = function _updateElements(correctedFrame) {
            this._root.update(correctedFrame);
            var elements = this._elements;
            for(var i = 0, l = elements.length; i < l; i++){
                var layer = elements[i];
                this._updateElement(layer);
            }
        };
        _proto._updateElement = function _updateElement(layer) {
            var _parent_transform, _parent_transform1;
            // @ts-ignore
            var transform = layer.transform, entity = layer.entity, sprite = layer.sprite, spriteRenderer = layer.spriteRenderer, parent = layer.parent, width = layer.width, height = layer.height;
            var entityTransform = entity.transform;
            var a = transform.a.v;
            var s = transform.s.v;
            var o = transform.o.v;
            var pixelsPerUnit = this.pixelsPerUnit;
            var x = 0, y = 0, z = 0;
            if (transform.p) {
                var p = transform.p.v;
                var _p_;
                x = (_p_ = p[0]) != null ? _p_ : 0;
                var _p_1;
                y = (_p_1 = p[1]) != null ? _p_1 : 0;
                var _p_2;
                z = (_p_2 = p[2]) != null ? _p_2 : 0;
            } else {
                if (transform.x) {
                    x = transform.x.v;
                }
                if (transform.y) {
                    y = transform.y.v;
                }
                if (transform.z) {
                    z = transform.z.v;
                }
            }
            var rx = 0;
            var ry = 0;
            var rz = 0;
            if (!layer.visible) {
                entity.isActive = layer.visible;
                return;
            }
            // 2d rotation
            if (transform.r) {
                rz = transform.r.v;
            } else if (transform.rx || transform.ry || transform.rz) {
                rx = transform.rx ? transform.rx.v : 0;
                ry = transform.ry ? transform.ry.v : 0;
                rz = transform.rz ? transform.rz.v : 0;
            } else if (transform.or) {
                var v = transform.or.v;
                rx = v[0];
                ry = v[1];
                rz = v[2];
            }
            // parent opacity
            if (parent == null ? void 0 : (_parent_transform = parent.transform) == null ? void 0 : _parent_transform.o) {
                o *= parent == null ? void 0 : parent.transform.o.v;
            }
            if (sprite) {
                // update color of sprite
                var _spriteRenderer_color = spriteRenderer.color, r = _spriteRenderer_color.r, g = _spriteRenderer_color.g, b = _spriteRenderer_color.b;
                spriteRenderer.color.set(r, g, b, o * this._alpha);
                // update pixels per unit of sprite
                sprite.pixelsPerUnit = pixelsPerUnit;
                // update pivot of sprite
                sprite.pivot = LottieAnimation._pivotVector.set(a[0] / width, (height - a[1]) / height);
            }
            entity.isActive = layer.visible;
            // scale
            entityTransform.setScale(s[0], s[1], s[2]);
            entityTransform.setRotation(rx, ry, -rz);
            // anchor
            if (parent == null ? void 0 : (_parent_transform1 = parent.transform) == null ? void 0 : _parent_transform1.a) {
                entityTransform.setPosition((x - parent.transform.a.v[0]) / pixelsPerUnit, (-y + parent.transform.a.v[1]) / pixelsPerUnit, z / pixelsPerUnit);
            } else {
                entityTransform.setPosition((x - this._width / 2) / pixelsPerUnit, (-y + this._height / 2) / pixelsPerUnit, z / pixelsPerUnit);
            }
        };
        _proto._resetElements = function _resetElements() {
            var elements = this._elements;
            for(var i = 0, l = elements.length; i < l; i++){
                elements[i].reset();
            }
        };
        /**
       * @override
       */ _proto.onUpdate = function onUpdate(deltaTime) {
            if (!this._isPlaying || !this._resource) {
                return null;
            }
            if (this._priorityDirty) {
                this._priorityDirty = false;
                var renderers = LottieAnimation._tempRenderers;
                renderers.length = 0;
                this.entity.getComponentsIncludeChildren(engine.Renderer, renderers);
                // the diff of global priority
                var priorityDiff = 0;
                for(var i = 0, l = renderers.length; i < l; ++i){
                    var renderer = renderers[i];
                    if (i === 0) {
                        // this._priority represent global priority，Math.floor(renderer.priority) get current global priority
                        priorityDiff = this._priority - Math.floor(renderer.priority);
                    }
                    renderer.priority = renderer.priority + priorityDiff;
                }
            }
            if (this._layerDirty) {
                this._layerDirty = false;
                this._setLayer(this.layer, this.entity);
            }
            var time = this.direction * this.speed * deltaTime * 1000;
            this._frame += time / this._resource.timePerFrame;
            var clip = this._clip;
            if (this._spill()) {
                var duration = this._resource.duration;
                this._resetElements();
                if (this.repeats > 0 || this.isLooping) {
                    if (this.repeats > 0) {
                        --this.repeats;
                    }
                    if (this.isAlternate) {
                        this.direction *= -1;
                        if (clip) {
                            this._frame = Tools.codomainBounce(this._frame, 0, clip.end - clip.start);
                        } else {
                            this._frame = Tools.codomainBounce(this._frame, 0, duration);
                        }
                    } else {
                        this.direction = 1;
                        if (clip) {
                            this._frame = Tools.euclideanModulo(this._frame, clip.end - clip.start);
                        } else {
                            this._frame = Tools.euclideanModulo(this._frame, duration);
                        }
                    }
                } else {
                    if (clip) {
                        if (this._frame >= clip.end - clip.start) {
                            var endCallback = this._clipEndCallbacks[clip.name];
                            if (endCallback) {
                                endCallback(clip);
                            }
                        }
                        this._frame = Tools.clamp(this._frame, 0, clip.end - clip.start);
                    } else {
                        if (this._frame >= duration) {
                            var endCallback1 = this._clipEndCallbacks["ALL"];
                            if (endCallback1) {
                                endCallback1();
                            }
                        }
                        this._frame = Tools.clamp(this._frame, 0, duration);
                    }
                }
            }
            if (clip) {
                this._updateElements(this._resource.inPoint + this._frame + clip.start);
            } else {
                this._updateElements(this._resource.inPoint + this._frame);
            }
        };
        /**
       * is this time frame spill the range
       */ _proto._spill = function _spill() {
            var duration;
            if (this._clip) {
                var clip = this._clip;
                duration = clip.end - clip.start;
            } else {
                duration = this._resource.duration;
            }
            var bottomSpill = this._frame <= 0 && this.direction === -1;
            var topSpill = this._frame >= duration && this.direction === 1;
            return bottomSpill || topSpill;
        };
        /**
       * @override
       * @param target
       */ _proto._cloneTo = function _cloneTo(target) {
            target._createElements(this._resource, true);
        };
        _proto._destroy = function _destroy() {
            var elements = this._elements;
            if (elements) {
                for(var i = 0, l = elements.length; i < l; i++){
                    elements[i].destroy();
                }
            }
        };
        _proto.onDestroy = function onDestroy() {
            this._destroy();
        };
        _create_class(LottieAnimation, [
            {
                key: "resource",
                get: function get() {
                    return this._resource;
                },
                set: function set(value) {
                    if (this._resource === value) {
                        return;
                    }
                    if (this._resource) {
                        this.pause();
                        this._destroy();
                        this._resource.refCount--;
                        if (this._resource.refCount <= 0) {
                            this._resource.destroy();
                        }
                    }
                    this._resource = value;
                    if (value) {
                        value.refCount++;
                        this._width = value.width;
                        this._height = value.height;
                        this._createElements(value);
                        this._priorityDirty = true;
                        this._layerDirty = true;
                    }
                    // update the first frame
                    this._curFrame = 0;
                    this.play();
                    this.onUpdate(0);
                    if (!this.autoPlay) {
                        this.pause();
                    }
                }
            },
            {
                key: "priority",
                get: function get() {
                    return this._priority;
                },
                set: function set(value) {
                    if (this._priority !== value) {
                        this._priority = value;
                        this._priorityDirty = true;
                    }
                }
            },
            {
                key: "layer",
                get: function get() {
                    return this._layer;
                },
                set: function set(value) {
                    if (this._layer !== value) {
                        this._layer = value;
                        this._layerDirty = true;
                    }
                }
            },
            {
                key: "alpha",
                get: function get() {
                    return this._alpha;
                },
                set: /**
       * global alpha
       */ function set(value) {
                    // update in updateElement
                    if (this._alpha !== value) {
                        this._alpha = value;
                        if (!this.isPlaying) {
                            this.play();
                            this.onUpdate(0);
                            this.pause();
                        }
                    }
                }
            },
            {
                key: "autoPlay",
                get: function get() {
                    return this._autoPlay;
                },
                set: function set(value) {
                    this._autoPlay = value;
                    if (value) {
                        this.play();
                    }
                }
            },
            {
                key: "frame",
                get: function get() {
                    return this._frame;
                }
            },
            {
                key: "isPlaying",
                get: function get() {
                    return this._isPlaying;
                }
            }
        ]);
        return LottieAnimation;
    }(engine.Script);
    LottieAnimation._pivotVector = new engine.Vector2();
    LottieAnimation._tempRenderers = [];
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_clipEndCallbacks", void 0);
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_isPlaying", void 0);
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_curFrame", void 0);
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_frame", void 0);
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_root", void 0);
    __decorate([
        engine.ignoreClone
    ], LottieAnimation.prototype, "_elements", void 0);

    function _extends() {
        _extends = Object.assign || function assign(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
            }

            return target;
        };

        return _extends.apply(this, arguments);
    }

    function _type_of(obj) {
        "@swc/helpers - typeof";

        return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }

    /**
     * @internal
     */ var LottieResource = /*#__PURE__*/ function(EngineObject) {
        _inherits(LottieResource, EngineObject);
        function LottieResource(engine, res, atlas) {
            var _this;
            _this = EngineObject.call(this, engine) || this, _this.refCount = 0;
            _this.timePerFrame = 1000 / res.fr;
            _this.duration = Math.floor(res.op - res.ip);
            _this.width = res.w;
            _this.height = res.h;
            _this.inPoint = res.ip;
            _this.outPoint = res.op;
            _this.atlas = atlas;
            _this.layers = res.layers;
            _this.comps = res.assets;
            _this.name = res.nm;
            _this.clips = {};
            var compsMap = {};
            var comps = _this.comps;
            if (comps) {
                for(var i = 0, l = comps.length; i < l; i++){
                    var comp = comps[i];
                    if (comp.id) {
                        compsMap[comp.id] = comp;
                    }
                }
            }
            _this._buildTree(_this.layers, compsMap);
            if (res.lolitaAnimations) {
                _this._parseAnimations(res.lolitaAnimations);
            }
            return _this;
        }
        var _proto = LottieResource.prototype;
        _proto.setClips = function setClips(v) {
            this.clips = {};
            this._parseAnimations(v);
        };
        _proto._parseAnimations = function _parseAnimations(clips) {
            var _this = this;
            clips.forEach(function(clip) {
                _this.clips[clip.name] = _extends({}, clip);
            });
        };
        /**
       * 在构建树结构的同时，继承合成的时间条关系
       * @param layers
       * @param compsMap
       * @param startTime - 这条合成的 offsetTime
       * @param stretch - 这条合成的 stretch
       * @param indStart - 这条合成的基础 ind
       * @param indFactor - 这条合成的 ind 缩放因子
       */ _proto._buildTree = function _buildTree(layers, compsMap, startTime, stretch, indStart, indFactor) {
            if (startTime === void 0) startTime = 0;
            if (stretch === void 0) stretch = 1;
            if (indStart === void 0) indStart = 0;
            if (indFactor === void 0) indFactor = 1;
            var layersMap = {};
            for(var i = 0, l = layers.length; i < l; i++){
                var layer = layers[i];
                layersMap[layer.ind] = layer;
            }
            for(var i1 = layers.length - 1; i1 >= 0; i1--){
                var layer1 = layers[i1];
                var refId = layer1.refId, parent = layer1.parent;
                layer1.offsetTime = startTime;
                layer1.stretch = stretch;
                layer1.index = layer1.ind * indFactor + indStart;
                if (parent) {
                    if (!layersMap[parent].layers) {
                        layersMap[parent].layers = [];
                    }
                    layersMap[parent].layers.push(layer1);
                    layers.splice(i1, 1);
                }
                if (refId && compsMap[refId]) {
                    var refLayers = [];
                    // deep clone the layers in comp asset
                    for(var j = 0; j < compsMap[refId].layers.length; j++){
                        refLayers.push(this._deepClone(compsMap[refId].layers[j]));
                    }
                    var offsetTime = (layer1.offsetTime || 0) + (layer1.st || 0);
                    var _$stretch = (layer1.stretch || 1) * (layer1.sr || 1);
                    var compIndFactor = indFactor / (refLayers[refLayers.length - 1].ind + 1) * indFactor;
                    this._buildTree(refLayers, compsMap, offsetTime, _$stretch, layer1.index, compIndFactor);
                    if (layer1.layers) {
                        var _layer_layers;
                        (_layer_layers = layer1.layers).push.apply(_layer_layers, [].concat(refLayers));
                    } else {
                        layer1.layers = [].concat(refLayers);
                    }
                }
            }
        };
        _proto._deepClone = function _deepClone(from) {
            var _this = this;
            var out = Array.isArray(from) ? [].concat(from) : _extends({}, from);
            Reflect.ownKeys(out).map(function(key) {
                out[key] = _this._isObject(from[key]) ? _this._deepClone(from[key]) : from[key];
            });
            return out;
        };
        _proto._isObject = function _isObject(obj) {
            return ((typeof obj === "undefined" ? "undefined" : _type_of(obj)) === "object" || typeof obj === "function") && (typeof obj === "undefined" ? "undefined" : _type_of(obj)) !== null;
        };
        _proto.destroy = function destroy() {
            this.layers = null;
            this.clips = null;
            this.comps = null;
            this.atlas.destroy(true);
            this.atlas = null;
            EngineObject.prototype.destroy.call(this);
        };
        return LottieResource;
    }(engine.EngineObject);

    exports.EditorLottieLoader = /*#__PURE__*/ function(Loader) {
        _inherits(EditorLottieLoader, Loader);
        function EditorLottieLoader() {
            return Loader.apply(this, arguments) || this;
        }
        var _proto = EditorLottieLoader.prototype;
        // @ts-ignore
        _proto.load = function load(item, resourceManager) {
            return new engine.AssetPromise(function(resolve) {
                engine.request(item.url, {
                    type: "json"
                }).then(function(data) {
                    var jsonUrl = data.jsonUrl, atlasUrl = data.atlasUrl;
                    var jsonPromise = engine.request(jsonUrl, resourceManager);
                    var atlasPromise = resourceManager.load({
                        url: atlasUrl,
                        type: engine.AssetType.SpriteAtlas
                    });
                    engine.AssetPromise.all([
                        jsonPromise,
                        atlasPromise
                    ]).then(function(param) {
                        var res = param[0], atlas = param[1];
                        var engine = resourceManager.engine;
                        var resource = new LottieResource(engine, res, atlas);
                        resolve(resource);
                    });
                });
            });
        };
        return EditorLottieLoader;
    }(engine.Loader);
    exports.EditorLottieLoader = __decorate([
        engine.resourceLoader("EditorLottie", [
            "json"
        ])
    ], exports.EditorLottieLoader);

    var Base64Atlas = /*#__PURE__*/ function() {
        function Base64Atlas(assets, engine$1) {
            var _this = this;
            this.sprites = {};
            this.assetsPromises = [];
            this.assetsPromises = assets.map(function(asset) {
                return engine$1.resourceManager.load({
                    url: asset.p,
                    type: engine.AssetType.Texture2D
                }).then(function(texture) {
                    var sprite = new engine.Sprite(engine$1);
                    sprite.texture = texture;
                    _this.sprites[asset.id] = sprite;
                });
            });
        }
        var _proto = Base64Atlas.prototype;
        _proto.request = function request() {
            return Promise.all(this.assetsPromises);
        };
        _proto.getSprite = function getSprite(id) {
            return this.sprites[id];
        };
        return Base64Atlas;
    }();
    exports.LottieLoader = /*#__PURE__*/ function(Loader) {
        _inherits(LottieLoader, Loader);
        function LottieLoader() {
            return Loader.apply(this, arguments) || this;
        }
        var _proto = LottieLoader.prototype;
        // @ts-ignore
        _proto.load = function load(item, resourceManager) {
            var urls = item.urls;
            var jsonPromise = engine.request(urls[0], {
                type: "json"
            });
            // atlas
            if (urls[1]) {
                var atlasPromise = resourceManager.load({
                    url: urls[1],
                    type: engine.AssetType.SpriteAtlas
                });
                return engine.AssetPromise.all([
                    jsonPromise,
                    atlasPromise
                ]).then(function(param) {
                    var res = param[0], atlas = param[1];
                    var engine$1 = resourceManager.engine;
                    var resource = new LottieResource(engine$1, res, atlas);
                    var lottieEntity = new engine.Entity(engine$1);
                    var lottie = lottieEntity.addComponent(LottieAnimation);
                    lottie.resource = resource;
                    return lottieEntity;
                });
            } else {
                return engine.AssetPromise.all([
                    jsonPromise
                ]).then(function(param) {
                    var res = param[0];
                    var engine$1 = resourceManager.engine;
                    var spriteAssets = res.assets.filter(function(asset) {
                        return asset.p;
                    });
                    res.assets = res.assets.filter(function(asset) {
                        return !asset.p;
                    });
                    var atlas = new Base64Atlas(spriteAssets, engine$1);
                    return atlas.request().then(function() {
                        var resource = new LottieResource(engine$1, res, atlas);
                        var lottieEntity = new engine.Entity(engine$1);
                        var lottie = lottieEntity.addComponent(LottieAnimation);
                        lottie.resource = resource;
                        return lottieEntity;
                    });
                });
            }
        };
        return LottieLoader;
    }(engine.Loader);
    exports.LottieLoader = __decorate([
        engine.resourceLoader("lottie", [
            "json"
        ])
    ], exports.LottieLoader);

    engine.Loader.registerClass("LottieAnimation", LottieAnimation);

    exports.LottieAnimation = LottieAnimation;
    exports.LottieResource = LottieResource;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
