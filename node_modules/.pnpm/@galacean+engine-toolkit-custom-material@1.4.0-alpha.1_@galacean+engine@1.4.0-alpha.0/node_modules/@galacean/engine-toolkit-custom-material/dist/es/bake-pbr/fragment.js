var fragment = "\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n";

export { fragment as default };
//# sourceMappingURL=fragment.js.map
