import { ShaderProperty, ShaderPass, Shader, RenderQueueType, BlendFactor, CompareFunction, StencilOperation, Color, Vector3 } from '@galacean/engine';

var PlanarShadowShaderFactory = /*#__PURE__*/ function() {
    function PlanarShadowShaderFactory() {}
    /**
   * Replace material Shader and initialization。
   * @param material - Material to replace and initialization。
   */ PlanarShadowShaderFactory.replaceShader = function replaceShader(material) {
        material.shader = Shader.find("planarShadowShader");
        var shadowRenderState = material.renderStates[1];
        shadowRenderState.renderQueueType = RenderQueueType.Transparent;
        shadowRenderState.depthState.writeEnabled = false;
        var targetBlendState = shadowRenderState.blendState.targetBlendState;
        targetBlendState.enabled = true;
        targetBlendState.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        targetBlendState.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        targetBlendState.sourceAlphaBlendFactor = BlendFactor.One;
        targetBlendState.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        // set shadow pass stencilState
        var stencilState = shadowRenderState.stencilState;
        stencilState.enabled = true;
        stencilState.referenceValue = 0;
        stencilState.compareFunctionFront = CompareFunction.Equal;
        stencilState.compareFunctionBack = CompareFunction.Equal;
        stencilState.failOperationFront = StencilOperation.Keep;
        stencilState.failOperationBack = StencilOperation.Keep;
        stencilState.zFailOperationFront = StencilOperation.Keep;
        stencilState.zFailOperationBack = StencilOperation.Keep;
        stencilState.passOperationFront = StencilOperation.IncrementWrap;
        stencilState.passOperationBack = StencilOperation.IncrementWrap;
        var shaderData = material.shaderData;
        shaderData.setFloat(PlanarShadowShaderFactory._shadowFalloffProp, 0);
        shaderData.setColor(PlanarShadowShaderFactory._shadowColorProp, new Color(1.0, 1.0, 1.0, 1.0));
        shaderData.setVector3(PlanarShadowShaderFactory._lightDirProp, new Vector3(0, 0, 0));
        shaderData.setFloat(PlanarShadowShaderFactory._planarHeightProp, 0);
    };
    /**
   * Set planar height.
   */ PlanarShadowShaderFactory.setPlanarHeight = function setPlanarHeight(material, value) {
        material.shaderData.setFloat(PlanarShadowShaderFactory._planarHeightProp, value);
    };
    /**
   * Set light direction.
   */ PlanarShadowShaderFactory.setLightDirection = function setLightDirection(material, value) {
        var lightDir = material.shaderData.getVector3(PlanarShadowShaderFactory._lightDirProp);
        if (value !== lightDir) {
            lightDir.copyFrom(value.normalize());
        } else {
            value.normalize();
        }
    };
    /**
   * Set shadow color
   */ PlanarShadowShaderFactory.setShadowColor = function setShadowColor(material, value) {
        var shadowColor = material.shaderData.getColor(PlanarShadowShaderFactory._shadowColorProp);
        if (value !== shadowColor) {
            shadowColor.copyFrom(value);
        }
    };
    /**
   * Set Shadow falloff coefficient
   */ PlanarShadowShaderFactory.setShadowFalloff = function setShadowFalloff(material, value) {
        material.shaderData.setFloat(PlanarShadowShaderFactory._shadowFalloffProp, value);
    };
    return PlanarShadowShaderFactory;
}();
PlanarShadowShaderFactory._lightDirProp = ShaderProperty.getByName("u_lightDir");
PlanarShadowShaderFactory._planarHeightProp = ShaderProperty.getByName("u_planarHeight");
PlanarShadowShaderFactory._shadowColorProp = ShaderProperty.getByName("u_planarShadowColor");
PlanarShadowShaderFactory._shadowFalloffProp = ShaderProperty.getByName("u_planarShadowFalloff");
var planarShadow = new ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ", "\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");
Shader.create("planarShadowShader", [
    Shader.find("pbr").subShaders[0].passes[0],
    planarShadow
]);

export { PlanarShadowShaderFactory };
//# sourceMappingURL=PlanarShadowShaderFactory.js.map
