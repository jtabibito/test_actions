import { _ as _create_class } from '../_create_class-8d4b456b.js';
import { _ as _inherits } from '../_inherits-5a51c3d0.js';
import { Shader, ShaderProperty, Vector2, Vector4, BaseMaterial } from '@galacean/engine';

var vertexSource = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ";
var fragmentSource = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
Shader.create("water-fall", vertexSource, fragmentSource);
var WaterFallMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(WaterFallMaterial, BaseMaterial);
    function WaterFallMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("water-fall")) || this;
        _this.shaderData.setVector2(WaterFallMaterial._waterSpeed, new Vector2(0.2, 0.0));
        _this.shaderData.setVector2(WaterFallMaterial._waterfallSpeed, new Vector2(0.9, 0));
        _this.shaderData.setVector4(WaterFallMaterial._edgeColor, new Vector4(160 / 255, 250 / 255, 250 / 255, 1.0));
        _this.shaderData.setVector2(WaterFallMaterial._edgeParam, new Vector2(0.7, 0.05));
        _this.shaderData.setFloat(WaterFallMaterial._distorsionAmount, 0.03);
        _this.shaderData.setVector2(WaterFallMaterial._distorsionSpeed, new Vector2(1.0, 1.0));
        return _this;
    }
    _create_class(WaterFallMaterial, [
        {
            key: "normalTexture",
            get: /**
   *  Normal Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._normalTextureProp, value);
            }
        },
        {
            key: "waterTexture",
            get: /**
   *  Water Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._waterTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._waterTextureProp, value);
            }
        },
        {
            key: "waterfallTexture",
            get: /**
   *  Water Fall Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._waterfallTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._waterfallTextureProp, value);
            }
        },
        {
            key: "edgeNoiseTexture",
            get: /**
   *  Edge Noise Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._edgeTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._edgeTextureProp, value);
            }
        },
        {
            key: "waterSpeed",
            get: /**
   *  Water Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._waterSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._waterSpeed, val);
            }
        },
        {
            key: "waterfallSpeed",
            get: /**
   *  Water Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._waterfallSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._waterfallSpeed, val);
            }
        },
        {
            key: "edgeColor",
            get: /**
   * Water Edge Color
   */ function get() {
                return this.shaderData.getVector4(WaterFallMaterial._edgeColor);
            },
            set: function set(val) {
                this.shaderData.setVector4(WaterFallMaterial._edgeColor, val);
            }
        },
        {
            key: "edgeParam",
            get: /**
   * Edge Param;
   * x for edge thickness, must between 0 ~ 1;
   * y for edge smoothness, must between 0 ~ 0.5;
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._edgeParam);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._edgeParam, val);
            }
        },
        {
            key: "distorsionAmount",
            get: /**
   * Distorsion Amount, must between -1 ~ 1
   */ function get() {
                return this.shaderData.getFloat(WaterFallMaterial._distorsionAmount);
            },
            set: function set(val) {
                this.shaderData.setFloat(WaterFallMaterial._distorsionAmount, val);
            }
        },
        {
            key: "distorsionSpeed",
            get: /**
   * Distorsion Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._distorsionSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._distorsionSpeed, val);
            }
        }
    ]);
    return WaterFallMaterial;
}(BaseMaterial);
WaterFallMaterial._waterSpeed = ShaderProperty.getByName("u_water_speed");
WaterFallMaterial._waterfallSpeed = ShaderProperty.getByName("u_waterfall_speed");
WaterFallMaterial._distorsionSpeed = ShaderProperty.getByName("u_distorsion_speed");
WaterFallMaterial._edgeColor = ShaderProperty.getByName("u_edgeColor");
WaterFallMaterial._edgeParam = ShaderProperty.getByName("u_edgeParam");
WaterFallMaterial._distorsionAmount = ShaderProperty.getByName("u_distorsion_amount");
WaterFallMaterial._waterTextureProp = ShaderProperty.getByName("u_waterTex");
WaterFallMaterial._waterfallTextureProp = ShaderProperty.getByName("u_waterfallTex");
WaterFallMaterial._edgeTextureProp = ShaderProperty.getByName("u_edgeNoiseTex");

export { WaterFallMaterial };
//# sourceMappingURL=WaterfallMaterial.js.map
