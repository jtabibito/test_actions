export { PlanarShadowShaderFactory } from './PlanarShadowShaderFactory.js';
import '@galacean/engine';

var PlanarShadow = "Shader \"PlanarShadow\" {\n\n  SubShader \"Default\" {\n\n    UsePass \"pbr/Default/Forward\"\n\n    Pass \"planarShadow\" {\n      // render states\n      DepthState {\n        WriteEnabled = true;\n      }\n\n      BlendState blendState {\n        Enabled = true;\n        SourceColorBlendFactor = BlendFactor.SourceAlpha;\n        DestinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        SourceAlphaBlendFactor = BlendFactor.One;\n        DestinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n      }\n\n      StencilState {\n        Enabled = true;\n        ReferenceValue = 0;\n        CompareFunctionFront = CompareFunction.Equal;\n        CompareFunctionBack = CompareFunction.Equal;\n        FailOperationFront = StencilOperation.Keep;\n        FailOperationBack = StencilOperation.Keep;\n        ZFailOperationFront = StencilOperation.Keep;\n        ZFailOperationBack = StencilOperation.Keep;\n        PassOperationFront = StencilOperation.IncrementWrap;\n        PassOperationBack = StencilOperation.IncrementWrap;\n      }\n\n      BlendState = blendState;\n\n      RenderQueueType = RenderQueueType.Transparent;\n\n      vec3 u_lightDir;\n      float u_planarHeight;\n      vec4 u_planarShadowColor;\n      float u_planarShadowFalloff;\n\n      sampler2D renderer_JointSampler;\n      float renderer_JointCount;\n\n      mat4 renderer_ModelMat;\n      mat4 camera_VPMat;\n\n      #ifdef RENDERER_HAS_SKIN\n\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n          mat4 getJointMatrix(sampler2D smp, float index) {\n              float base = index / renderer_JointCount;\n              float hf = 0.5 / renderer_JointCount;\n              float v = base + hf;\n\n              vec4 m0 = texture2D(smp, vec2(0.125, v ));\n              vec4 m1 = texture2D(smp, vec2(0.375, v ));\n              vec4 m2 = texture2D(smp, vec2(0.625, v ));\n              vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n              return mat4(m0, m1, m2, m3);\n          }\n        #elif defined(RENDERER_BLENDSHAPE_COUNT)\n            mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n        #endif\n      #endif\n\n      vec3 ShadowProjectPos(vec4 vertPos) {\n        vec3 shadowPos;\n\n        // get the world space coordinates of the vertex\n\n        vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n        \n        // world space coordinates of the shadow (the part below the ground is unchanged)\n        shadowPos.y = min(worldPos.y , u_planarHeight);\n        shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n        return shadowPos;\n      }\n\n      struct a2v {\n        vec4 POSITION;\n        vec4 JOINTS_0; \n        vec4 WEIGHTS_0;\n      }\n\n      struct v2f {\n        vec4 color;\n      }\n\n      v2f vert(a2v v) {\n        v2f o;\n\n        vec4 position = vec4(v.POSITION.xyz, 1.0 );\n        #ifdef RENDERER_HAS_SKIN\n            #ifdef RENDERER_USE_JOINT_TEXTURE\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, v.JOINTS_0.x ) +\n                    v.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, v.JOINTS_0.y ) +\n                    v.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, v.JOINTS_0.z ) +\n                    v.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, v.JOINTS_0.w );\n            #else\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * renderer_JointMatrix[ int( v.JOINTS_0.x ) ] +\n                    v.WEIGHTS_0.y * renderer_JointMatrix[ int( v.JOINTS_0.y ) ] +\n                    v.WEIGHTS_0.z * renderer_JointMatrix[ int( v.JOINTS_0.z ) ] +\n                    v.WEIGHTS_0.w * renderer_JointMatrix[ int( v.JOINTS_0.w ) ];\n            #endif\n            position = skinMatrix * position;\n        #endif\n\n        // get the shadow's world space coordinates\n        vec3 shadowPos = ShadowProjectPos(position);\n\n        // convert to clip space\n        gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n        // get the world coordinates of the center point\n        vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n        // calculate shadow falloff\n        float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n        // shadow color\n        o.color = u_planarShadowColor;\n        o.color.a *= falloff;\n      }\n      \n      VertexShader = vert;\n      FragmentShader = frag;\n\n      void frag(v2f i) {\n        gl_FragColor = i.color;\n      }\n    }\n  }\n}";

export { PlanarShadow as PlanarShadowShaderSource };
//# sourceMappingURL=index.js.map
