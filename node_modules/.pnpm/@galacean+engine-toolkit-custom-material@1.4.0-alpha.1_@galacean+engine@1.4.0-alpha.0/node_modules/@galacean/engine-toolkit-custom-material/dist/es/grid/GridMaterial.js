import { _ as _create_class } from '../_create_class-8d4b456b.js';
import { _ as _inherits } from '../_inherits-5a51c3d0.js';
import { ShaderProperty, Shader, MathUtil, BaseMaterial } from '@galacean/engine';

/**
 * Grid Material.
 */ var GridMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(GridMaterial, BaseMaterial);
    function GridMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("grid")) || this;
        _this.isTransparent = true;
        var shaderData = _this.shaderData;
        shaderData.setFloat(GridMaterial._nearClipProperty, 0.1);
        shaderData.setFloat(GridMaterial._farClipProperty, 100);
        shaderData.setFloat(GridMaterial._primaryScaleProperty, 10);
        shaderData.setFloat(GridMaterial._secondaryScaleProperty, 1);
        shaderData.setFloat(GridMaterial._gridIntensityProperty, 0.2);
        shaderData.setFloat(GridMaterial._axisIntensityProperty, 0.1);
        shaderData.setFloat(GridMaterial._flipProgressProperty, 0.0);
        shaderData.setFloat(GridMaterial._fadeProperty, 0.0);
        return _this;
    }
    _create_class(GridMaterial, [
        {
            key: "nearClipPlane",
            get: /**
   * Near clip plane - the closest point to the camera when rendering occurs.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._nearClipProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._nearClipProperty, value);
            }
        },
        {
            key: "farClipPlane",
            get: /**
   * Far clip plane - the furthest point to the camera when rendering occurs.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._farClipProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._farClipProperty, value);
            }
        },
        {
            key: "primaryScale",
            get: /**
   * Primary scale of grid size.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._primaryScaleProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._primaryScaleProperty, value);
            }
        },
        {
            key: "secondaryScale",
            get: /**
   * Secondary scale of grid size.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._secondaryScaleProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._secondaryScaleProperty, value);
            }
        },
        {
            key: "gridIntensity",
            get: /**
   * Grid color intensity.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._gridIntensityProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._gridIntensityProperty, value);
            }
        },
        {
            key: "axisIntensity",
            get: /**
   * Axis color intensity.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._axisIntensityProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._axisIntensityProperty, value);
            }
        },
        {
            key: "flipProgress",
            get: /**
   * 2D-3D flip progress.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._flipProgressProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._flipProgressProperty, MathUtil.clamp(value, 0, 1));
            }
        },
        {
            key: "fade",
            get: /**
   * fade parameter.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._fadeProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._fadeProperty, MathUtil.clamp(value, 0, 1));
            }
        }
    ]);
    return GridMaterial;
}(BaseMaterial);
GridMaterial._farClipProperty = ShaderProperty.getByName("u_far");
GridMaterial._nearClipProperty = ShaderProperty.getByName("u_near");
GridMaterial._primaryScaleProperty = ShaderProperty.getByName("u_primaryScale");
GridMaterial._secondaryScaleProperty = ShaderProperty.getByName("u_secondaryScale");
GridMaterial._gridIntensityProperty = ShaderProperty.getByName("u_gridIntensity");
GridMaterial._axisIntensityProperty = ShaderProperty.getByName("u_axisIntensity");
GridMaterial._flipProgressProperty = ShaderProperty.getByName("u_flipProgress");
GridMaterial._fadeProperty = ShaderProperty.getByName("u_fade");
Shader.create("grid", "\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}", "\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");

export { GridMaterial };
//# sourceMappingURL=GridMaterial.js.map
