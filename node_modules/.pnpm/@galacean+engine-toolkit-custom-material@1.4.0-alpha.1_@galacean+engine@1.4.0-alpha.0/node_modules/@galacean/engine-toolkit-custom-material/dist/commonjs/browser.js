'use strict';

var engine = require('@galacean/engine');

var PlanarShadow = "Shader \"PlanarShadow\" {\n\n  SubShader \"Default\" {\n\n    UsePass \"pbr/Default/Forward\"\n\n    Pass \"planarShadow\" {\n      // render states\n      DepthState {\n        WriteEnabled = true;\n      }\n\n      BlendState blendState {\n        Enabled = true;\n        SourceColorBlendFactor = BlendFactor.SourceAlpha;\n        DestinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        SourceAlphaBlendFactor = BlendFactor.One;\n        DestinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n      }\n\n      StencilState {\n        Enabled = true;\n        ReferenceValue = 0;\n        CompareFunctionFront = CompareFunction.Equal;\n        CompareFunctionBack = CompareFunction.Equal;\n        FailOperationFront = StencilOperation.Keep;\n        FailOperationBack = StencilOperation.Keep;\n        ZFailOperationFront = StencilOperation.Keep;\n        ZFailOperationBack = StencilOperation.Keep;\n        PassOperationFront = StencilOperation.IncrementWrap;\n        PassOperationBack = StencilOperation.IncrementWrap;\n      }\n\n      BlendState = blendState;\n\n      RenderQueueType = RenderQueueType.Transparent;\n\n      vec3 u_lightDir;\n      float u_planarHeight;\n      vec4 u_planarShadowColor;\n      float u_planarShadowFalloff;\n\n      sampler2D renderer_JointSampler;\n      float renderer_JointCount;\n\n      mat4 renderer_ModelMat;\n      mat4 camera_VPMat;\n\n      #ifdef RENDERER_HAS_SKIN\n\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n          mat4 getJointMatrix(sampler2D smp, float index) {\n              float base = index / renderer_JointCount;\n              float hf = 0.5 / renderer_JointCount;\n              float v = base + hf;\n\n              vec4 m0 = texture2D(smp, vec2(0.125, v ));\n              vec4 m1 = texture2D(smp, vec2(0.375, v ));\n              vec4 m2 = texture2D(smp, vec2(0.625, v ));\n              vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n              return mat4(m0, m1, m2, m3);\n          }\n        #elif defined(RENDERER_BLENDSHAPE_COUNT)\n            mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n        #endif\n      #endif\n\n      vec3 ShadowProjectPos(vec4 vertPos) {\n        vec3 shadowPos;\n\n        // get the world space coordinates of the vertex\n\n        vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n        \n        // world space coordinates of the shadow (the part below the ground is unchanged)\n        shadowPos.y = min(worldPos.y , u_planarHeight);\n        shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n        return shadowPos;\n      }\n\n      struct a2v {\n        vec4 POSITION;\n        vec4 JOINTS_0; \n        vec4 WEIGHTS_0;\n      }\n\n      struct v2f {\n        vec4 color;\n      }\n\n      v2f vert(a2v v) {\n        v2f o;\n\n        vec4 position = vec4(v.POSITION.xyz, 1.0 );\n        #ifdef RENDERER_HAS_SKIN\n            #ifdef RENDERER_USE_JOINT_TEXTURE\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, v.JOINTS_0.x ) +\n                    v.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, v.JOINTS_0.y ) +\n                    v.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, v.JOINTS_0.z ) +\n                    v.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, v.JOINTS_0.w );\n            #else\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * renderer_JointMatrix[ int( v.JOINTS_0.x ) ] +\n                    v.WEIGHTS_0.y * renderer_JointMatrix[ int( v.JOINTS_0.y ) ] +\n                    v.WEIGHTS_0.z * renderer_JointMatrix[ int( v.JOINTS_0.z ) ] +\n                    v.WEIGHTS_0.w * renderer_JointMatrix[ int( v.JOINTS_0.w ) ];\n            #endif\n            position = skinMatrix * position;\n        #endif\n\n        // get the shadow's world space coordinates\n        vec3 shadowPos = ShadowProjectPos(position);\n\n        // convert to clip space\n        gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n        // get the world coordinates of the center point\n        vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n        // calculate shadow falloff\n        float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n        // shadow color\n        o.color = u_planarShadowColor;\n        o.color.a *= falloff;\n      }\n      \n      VertexShader = vert;\n      FragmentShader = frag;\n\n      void frag(v2f i) {\n        gl_FragColor = i.color;\n      }\n    }\n  }\n}";

var PlanarShadowShaderFactory = /*#__PURE__*/ function() {
    function PlanarShadowShaderFactory() {}
    /**
   * Replace material Shader and initialization。
   * @param material - Material to replace and initialization。
   */ PlanarShadowShaderFactory.replaceShader = function replaceShader(material) {
        material.shader = engine.Shader.find("planarShadowShader");
        var shadowRenderState = material.renderStates[1];
        shadowRenderState.renderQueueType = engine.RenderQueueType.Transparent;
        shadowRenderState.depthState.writeEnabled = false;
        var targetBlendState = shadowRenderState.blendState.targetBlendState;
        targetBlendState.enabled = true;
        targetBlendState.sourceColorBlendFactor = engine.BlendFactor.SourceAlpha;
        targetBlendState.destinationColorBlendFactor = engine.BlendFactor.OneMinusSourceAlpha;
        targetBlendState.sourceAlphaBlendFactor = engine.BlendFactor.One;
        targetBlendState.destinationAlphaBlendFactor = engine.BlendFactor.OneMinusSourceAlpha;
        // set shadow pass stencilState
        var stencilState = shadowRenderState.stencilState;
        stencilState.enabled = true;
        stencilState.referenceValue = 0;
        stencilState.compareFunctionFront = engine.CompareFunction.Equal;
        stencilState.compareFunctionBack = engine.CompareFunction.Equal;
        stencilState.failOperationFront = engine.StencilOperation.Keep;
        stencilState.failOperationBack = engine.StencilOperation.Keep;
        stencilState.zFailOperationFront = engine.StencilOperation.Keep;
        stencilState.zFailOperationBack = engine.StencilOperation.Keep;
        stencilState.passOperationFront = engine.StencilOperation.IncrementWrap;
        stencilState.passOperationBack = engine.StencilOperation.IncrementWrap;
        var shaderData = material.shaderData;
        shaderData.setFloat(PlanarShadowShaderFactory._shadowFalloffProp, 0);
        shaderData.setColor(PlanarShadowShaderFactory._shadowColorProp, new engine.Color(1.0, 1.0, 1.0, 1.0));
        shaderData.setVector3(PlanarShadowShaderFactory._lightDirProp, new engine.Vector3(0, 0, 0));
        shaderData.setFloat(PlanarShadowShaderFactory._planarHeightProp, 0);
    };
    /**
   * Set planar height.
   */ PlanarShadowShaderFactory.setPlanarHeight = function setPlanarHeight(material, value) {
        material.shaderData.setFloat(PlanarShadowShaderFactory._planarHeightProp, value);
    };
    /**
   * Set light direction.
   */ PlanarShadowShaderFactory.setLightDirection = function setLightDirection(material, value) {
        var lightDir = material.shaderData.getVector3(PlanarShadowShaderFactory._lightDirProp);
        if (value !== lightDir) {
            lightDir.copyFrom(value.normalize());
        } else {
            value.normalize();
        }
    };
    /**
   * Set shadow color
   */ PlanarShadowShaderFactory.setShadowColor = function setShadowColor(material, value) {
        var shadowColor = material.shaderData.getColor(PlanarShadowShaderFactory._shadowColorProp);
        if (value !== shadowColor) {
            shadowColor.copyFrom(value);
        }
    };
    /**
   * Set Shadow falloff coefficient
   */ PlanarShadowShaderFactory.setShadowFalloff = function setShadowFalloff(material, value) {
        material.shaderData.setFloat(PlanarShadowShaderFactory._shadowFalloffProp, value);
    };
    return PlanarShadowShaderFactory;
}();
PlanarShadowShaderFactory._lightDirProp = engine.ShaderProperty.getByName("u_lightDir");
PlanarShadowShaderFactory._planarHeightProp = engine.ShaderProperty.getByName("u_planarHeight");
PlanarShadowShaderFactory._shadowColorProp = engine.ShaderProperty.getByName("u_planarShadowColor");
PlanarShadowShaderFactory._shadowFalloffProp = engine.ShaderProperty.getByName("u_planarShadowFalloff");
var planarShadow = new engine.ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ", "\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");
engine.Shader.create("planarShadowShader", [
    engine.Shader.find("pbr").subShaders[0].passes[0],
    planarShadow
]);

var Grid = "Shader \"Grid\" {\n\n  SubShader \"Default\" {\n\n    Pass \"Forward\" {\n      \n      mat4 camera_ViewInvMat;\n\n      VertexShader = vert;\n      FragmentShader = frag;\n\n      struct a2v {\n        vec3 POSITION;\n      }\n\n      struct v2f {\n        vec3 nearPoint;\n        vec3 farPoint;\n      }\n\n      vec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n        vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n        return unprojectedPoint.xyz / unprojectedPoint.w;\n      }\n\n      #ifdef GRAPHICS_API_WEBGL2\n        #define INVERSE_MAT(mat) inverse(mat)\n      #else\n        mat2 inverseMat(mat2 m) {\n          return mat2(m[1][1],-m[0][1],\n              -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n        }\n        mat3 inverseMat(mat3 m) {\n          float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n          float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n          float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n          float b01 = a22 * a11 - a12 * a21;\n          float b11 = -a22 * a10 + a12 * a20;\n          float b21 = a21 * a10 - a11 * a20;\n\n          float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n          return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n                b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n                b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n        }\n        mat4 inverseMat(mat4 m) {\n          float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n            a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n            a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n            a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n            b00 = a00 * a11 - a01 * a10,\n            b01 = a00 * a12 - a02 * a10,\n            b02 = a00 * a13 - a03 * a10,\n            b03 = a01 * a12 - a02 * a11,\n            b04 = a01 * a13 - a03 * a11,\n            b05 = a02 * a13 - a03 * a12,\n            b06 = a20 * a31 - a21 * a30,\n            b07 = a20 * a32 - a22 * a30,\n            b08 = a20 * a33 - a23 * a30,\n            b09 = a21 * a32 - a22 * a31,\n            b10 = a21 * a33 - a23 * a31,\n            b11 = a22 * a33 - a23 * a32,\n\n            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n          return mat4(\n            a11 * b11 - a12 * b10 + a13 * b09,\n            a02 * b10 - a01 * b11 - a03 * b09,\n            a31 * b05 - a32 * b04 + a33 * b03,\n            a22 * b04 - a21 * b05 - a23 * b03,\n            a12 * b08 - a10 * b11 - a13 * b07,\n            a00 * b11 - a02 * b08 + a03 * b07,\n            a32 * b02 - a30 * b05 - a33 * b01,\n            a20 * b05 - a22 * b02 + a23 * b01,\n            a10 * b10 - a11 * b08 + a13 * b06,\n            a01 * b08 - a00 * b10 - a03 * b06,\n            a30 * b04 - a31 * b02 + a33 * b00,\n            a21 * b02 - a20 * b04 - a23 * b00,\n            a11 * b07 - a10 * b09 - a12 * b06,\n            a00 * b09 - a01 * b07 + a02 * b06,\n            a31 * b01 - a30 * b03 - a32 * b00,\n            a20 * b03 - a21 * b01 + a22 * b00) / det;\n        }\n\n        #define INVERSE_MAT(mat) inverseMat(mat)\n      #endif\n\n\n      v2f vert(a2v v) {\n        v2f o;\n\n        float tol = 0.0001;\n        mat4 viewInvMat = camera_ViewInvMat;\n        if (abs(viewInvMat[3][1]) < tol) {\n            viewInvMat[3][1] = tol;\n        }\n        mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n        o.nearPoint = UnprojectPoint(v.POSITION.x, v.POSITION.y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n        o.farPoint = UnprojectPoint(v.POSITION.x, v.POSITION.y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n        gl_Position = vec4(v.POSITION, 1.0);// using directly the clipped coordinates\n      }\n\n      mat4 renderer_LocalMat;\n      mat4 renderer_ModelMat;\n      mat4 camera_ViewMat;\n      mat4 camera_ProjMat;\n      mat4 renderer_MVMat;\n      mat4 renderer_MVPMat;\n      mat4 renderer_NormalMat;\n\n      float u_far;\n      float u_near;\n      float u_primaryScale;\n      float u_secondaryScale;\n      float u_gridIntensity;\n      float u_axisIntensity;\n      float u_flipProgress;\n      float u_fade;\n\n      vec4 grid(vec3 fragPos3D, float scale, float fade) {\n        vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n        vec2 derivative = fwidth(coord);\n        vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n        float line = min(grid.x, grid.y);\n        float minimumz = min(derivative.y, 1.0);\n        float minimumx = min(derivative.x, 1.0);\n        vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n        // z-axis\n        if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx) {\n          color.z = 1.0;\n        }\n        // x-axis or y-axis\n        float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n        if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz) {\n          color.x = 1.0;\n        }\n        return color;\n      }\n\n      float computeDepth(vec3 pos) {\n        vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n        // map to 0-1\n        return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n      }\n\n      float computeLinearDepth(vec3 pos) {\n        vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n        float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n        float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n        return linearDepth / u_far;// normalize\n      }\n\n      void frag(v2f i) {\n        float ty = -i.nearPoint.y / (i.farPoint.y - i.nearPoint.y);\n        float tz = -i.nearPoint.z / (i.farPoint.z - i.nearPoint.z);\n        float t = mix(ty, tz, u_flipProgress);\n        vec3 fragPos3D = i.nearPoint + t * (i.farPoint - i.nearPoint);\n\n        gl_FragDepth = computeDepth(fragPos3D);\n\n        float linearDepth = computeLinearDepth(fragPos3D);\n        float fading = max(0.0, (0.5 - linearDepth));\n\n        // adding multiple resolution for the grid\n        gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n        gl_FragColor.a *= fading;\n      }\n    }\n  }\n}";

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/**
 * Grid Material.
 */ var GridMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(GridMaterial, BaseMaterial);
    function GridMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("grid")) || this;
        _this.isTransparent = true;
        var shaderData = _this.shaderData;
        shaderData.setFloat(GridMaterial._nearClipProperty, 0.1);
        shaderData.setFloat(GridMaterial._farClipProperty, 100);
        shaderData.setFloat(GridMaterial._primaryScaleProperty, 10);
        shaderData.setFloat(GridMaterial._secondaryScaleProperty, 1);
        shaderData.setFloat(GridMaterial._gridIntensityProperty, 0.2);
        shaderData.setFloat(GridMaterial._axisIntensityProperty, 0.1);
        shaderData.setFloat(GridMaterial._flipProgressProperty, 0.0);
        shaderData.setFloat(GridMaterial._fadeProperty, 0.0);
        return _this;
    }
    _create_class(GridMaterial, [
        {
            key: "nearClipPlane",
            get: /**
   * Near clip plane - the closest point to the camera when rendering occurs.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._nearClipProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._nearClipProperty, value);
            }
        },
        {
            key: "farClipPlane",
            get: /**
   * Far clip plane - the furthest point to the camera when rendering occurs.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._farClipProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._farClipProperty, value);
            }
        },
        {
            key: "primaryScale",
            get: /**
   * Primary scale of grid size.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._primaryScaleProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._primaryScaleProperty, value);
            }
        },
        {
            key: "secondaryScale",
            get: /**
   * Secondary scale of grid size.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._secondaryScaleProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._secondaryScaleProperty, value);
            }
        },
        {
            key: "gridIntensity",
            get: /**
   * Grid color intensity.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._gridIntensityProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._gridIntensityProperty, value);
            }
        },
        {
            key: "axisIntensity",
            get: /**
   * Axis color intensity.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._axisIntensityProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._axisIntensityProperty, value);
            }
        },
        {
            key: "flipProgress",
            get: /**
   * 2D-3D flip progress.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._flipProgressProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._flipProgressProperty, engine.MathUtil.clamp(value, 0, 1));
            }
        },
        {
            key: "fade",
            get: /**
   * fade parameter.
   */ function get() {
                return this.shaderData.getFloat(GridMaterial._fadeProperty);
            },
            set: function set(value) {
                this.shaderData.setFloat(GridMaterial._fadeProperty, engine.MathUtil.clamp(value, 0, 1));
            }
        }
    ]);
    return GridMaterial;
}(engine.BaseMaterial);
GridMaterial._farClipProperty = engine.ShaderProperty.getByName("u_far");
GridMaterial._nearClipProperty = engine.ShaderProperty.getByName("u_near");
GridMaterial._primaryScaleProperty = engine.ShaderProperty.getByName("u_primaryScale");
GridMaterial._secondaryScaleProperty = engine.ShaderProperty.getByName("u_secondaryScale");
GridMaterial._gridIntensityProperty = engine.ShaderProperty.getByName("u_gridIntensity");
GridMaterial._axisIntensityProperty = engine.ShaderProperty.getByName("u_axisIntensity");
GridMaterial._flipProgressProperty = engine.ShaderProperty.getByName("u_flipProgress");
GridMaterial._fadeProperty = engine.ShaderProperty.getByName("u_fade");
engine.Shader.create("grid", "\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}", "\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");

var GridMesh = /*#__PURE__*/ function() {
    function GridMesh() {}
    GridMesh.createGridPlane = function createGridPlane(engine$1) {
        var mesh = new engine.ModelMesh(engine$1);
        GridMesh._updateGridData(mesh);
        engine$1.resourceManager.addContentRestorer(new GridMeshRestorer(mesh));
        return mesh;
    };
    GridMesh._updateGridData = function _updateGridData(mesh) {
        // No-FlipY: POSITION_FLIP.xy, FlipY: POSITION_FLIP.zw
        // prettier-ignore
        var vertices = new Float32Array([
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            1,
            -1,
            1
        ]); // right-top
        mesh.setVertexElements([
            new engine.VertexElement("POSITION_FLIP", 0, engine.VertexElementFormat.Vector4, 0)
        ]);
        mesh.setVertexBufferBinding(new engine.Buffer(mesh.engine, engine.BufferBindFlag.VertexBuffer, vertices, engine.BufferUsage.Static), 16);
        mesh.addSubMesh(0, 4, engine.MeshTopology.TriangleStrip);
        var bounds = mesh.bounds;
        bounds.min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        bounds.max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        return mesh;
    };
    return GridMesh;
}();
/**
 * @internal
 */ var GridMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GridMeshRestorer, ContentRestorer);
    function GridMeshRestorer(resource) {
        return ContentRestorer.call(this, resource);
    }
    var _proto = GridMeshRestorer.prototype;
    /**
   * @override
   */ _proto.restoreContent = function restoreContent() {
        GridMesh._updateGridData(this.resource);
    };
    return GridMeshRestorer;
}(engine.ContentRestorer);

/**
 * Grid Control
 */ var GridControl = /*#__PURE__*/ function(Script) {
    _inherits(GridControl, Script);
    function GridControl() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._progress = 0;
        _this._is2DGrid = false;
        _this._flipGrid = false;
        /**
   * Flip speed
   */ _this.speed = 10.0;
        /**
   * Camera
   */ _this.camera = null;
        /**
   * target distance
   */ _this.distance = 8;
        return _this;
    }
    var _proto = GridControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine$1 = _this.engine, entity = _this.entity;
        var gridRenderer = entity.addComponent(engine.MeshRenderer);
        gridRenderer.receiveShadows = false;
        gridRenderer.castShadows = false;
        gridRenderer.mesh = GridMesh.createGridPlane(engine$1);
        this._material = new GridMaterial(engine$1);
        gridRenderer.setMaterial(this._material);
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        var _this = this, material = _this._material, camera = _this.camera;
        if (camera === null) return;
        material.nearClipPlane = camera.nearClipPlane;
        material.farClipPlane = camera.farClipPlane;
        var logDistance = Math.log2(this.distance);
        var upperDistance = Math.pow(2, Math.floor(logDistance) + 1);
        var lowerDistance = Math.pow(2, Math.floor(logDistance));
        material.fade = (this.distance - lowerDistance) / (upperDistance - lowerDistance);
        var level = -Math.floor(logDistance);
        material.primaryScale = Math.pow(2, level);
        material.secondaryScale = Math.pow(2, level + 1);
        material.axisIntensity = 0.3 / material.primaryScale;
        if (this._flipGrid) {
            this._progress += deltaTime;
            var percent = engine.MathUtil.clamp(this._progress * this.speed, 0, 1);
            if (percent >= 1) {
                this._flipGrid = false;
            }
            if (!this._is2DGrid) {
                percent = 1 - percent;
            }
            material.flipProgress = percent;
        }
    };
    _create_class(GridControl, [
        {
            key: "material",
            get: /**
   * Grid Material.
   */ function get() {
                return this._material;
            }
        },
        {
            key: "is2DGrid",
            get: /**
   * Is 2D Grid.
   */ function get() {
                return this._is2DGrid;
            },
            set: function set(value) {
                this._is2DGrid = value;
                this._progress = 0;
                this._flipGrid = true;
            }
        }
    ]);
    return GridControl;
}(engine.Script);

var vertexSource$2 = "\n  attribute vec3 POSITION;\n  attribute vec2 TEXCOORD_0;\n  attribute vec4 COLOR_0;\n  uniform mat4 renderer_MVPMat;\n  \n  uniform float u_time;\n  uniform vec2 u_foam_speed; \n  uniform vec2 u_distorsion_speed; \n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  varying vec4 v_color;\n      \n  void main() {\n    gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    waterTexCoords = TEXCOORD_0 + vec2(u_foam_speed.x * u_time, u_foam_speed.y * u_time);\n    normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));\n    v_color = COLOR_0; \n  }\n  ";
var fragmentSource$2 = "\n  #include <common>\n  varying vec4 v_color;\n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  uniform sampler2D material_NormalTexture;\n  uniform sampler2D u_foamTex;\n  uniform vec3 u_foamColor;\n  uniform vec2 u_foam_param;\n  uniform float u_distorsion_amount;\n  void main() {  \n    vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n    vec4 waterTex = texture2D(u_foamTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n    float alphaComp = v_color.r * waterTex.r * u_foam_param.x;\n    float alpha = pow(alphaComp,2.0);\n    alpha = smoothstep(0.5 - u_foam_param.y, 0.5+ u_foam_param.y, alpha);\n    alpha = saturate(alpha);\n    \n    gl_FragColor = vec4(u_foamColor.rgb, alpha);\n  }\n  ";
engine.Shader.create("water-ripple", vertexSource$2, fragmentSource$2);
var WaterRippleMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(WaterRippleMaterial, BaseMaterial);
    function WaterRippleMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("water-ripple")) || this;
        _this.isTransparent = true;
        var shaderData = _this.shaderData;
        shaderData.setVector3(WaterRippleMaterial._foamColor, new engine.Vector3((69 + 255) / 400, (156 + 255) / 400, (247 + 255) / 400));
        shaderData.setVector2(WaterRippleMaterial._foamSpeed, new engine.Vector2(-1, 0.3));
        shaderData.setVector2(WaterRippleMaterial._foamParam, new engine.Vector2(2.0, 0.05));
        shaderData.setVector2(WaterRippleMaterial._distorsionSpeed, new engine.Vector2(1.0, 0));
        shaderData.setFloat(WaterRippleMaterial._distorsionAmount, 0.03);
        return _this;
    }
    _create_class(WaterRippleMaterial, [
        {
            key: "foamTexture",
            get: /**
   * Foam Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterRippleMaterial._foamTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterRippleMaterial._foamTextureProp, value);
            }
        },
        {
            key: "normalTexture",
            get: /**
   * Normal Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterRippleMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterRippleMaterial._normalTextureProp, value);
            }
        },
        {
            key: "foamColor",
            get: /**
   * Foam Color
   */ function get() {
                return this.shaderData.getVector3(WaterRippleMaterial._foamColor);
            },
            set: function set(val) {
                this.shaderData.setVector3(WaterRippleMaterial._foamColor, val);
            }
        },
        {
            key: "foamSpeed",
            get: /**
   * Foam speed on x direction and y direction
   * foam speed y, foam amount, foam smoothness
   */ function get() {
                return this.shaderData.getVector2(WaterRippleMaterial._foamSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterRippleMaterial._foamSpeed, val);
            }
        },
        {
            key: "foamParam",
            get: /**
   * Foam Param;
   * x for foam amount
   * y for foam smoothness, must between 0 ~ 0.5;
   */ function get() {
                return this.shaderData.getVector2(WaterRippleMaterial._foamParam);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterRippleMaterial._foamParam, val);
            }
        },
        {
            key: "distorsionSpeed",
            get: /**
   * Distorsion Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterRippleMaterial._distorsionSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterRippleMaterial._distorsionSpeed, val);
            }
        },
        {
            key: "distorsionAmount",
            get: /**
   * Distorsion Amount, must between -1 ~ 1
   */ function get() {
                return this.shaderData.getFloat(WaterRippleMaterial._distorsionAmount);
            },
            set: function set(val) {
                this.shaderData.setFloat(WaterRippleMaterial._distorsionAmount, val);
            }
        }
    ]);
    return WaterRippleMaterial;
}(engine.BaseMaterial);
WaterRippleMaterial._foamColor = engine.ShaderProperty.getByName("u_foamColor");
WaterRippleMaterial._foamSpeed = engine.ShaderProperty.getByName("u_foam_speed");
WaterRippleMaterial._foamParam = engine.ShaderProperty.getByName("u_foam_param");
WaterRippleMaterial._distorsionSpeed = engine.ShaderProperty.getByName("u_distorsion_speed");
WaterRippleMaterial._distorsionAmount = engine.ShaderProperty.getByName("u_distorsion_amount");
WaterRippleMaterial._foamTextureProp = engine.ShaderProperty.getByName("u_foamTex");

var vertexSource$1 = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n\n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_distorsion_speed; \n    \n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * sin(u_time), u_water_speed.y * cos(u_time));\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));     \n      \n      v_color = COLOR_0;\n    }\n    ";
var fragmentSource$1 = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_edgeTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {\n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 edgeTex = texture2D(u_edgeTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      float edge = pow((v_color.r + edgeTex.r) * v_color.r, 2.0);\n      edge = saturate(1.0 - smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edge));\n      vec4 finalCol = mix(waterTex, u_edgeColor, edge);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
engine.Shader.create("water", vertexSource$1, fragmentSource$1);
var WaterMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(WaterMaterial, BaseMaterial);
    function WaterMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("water")) || this;
        _this.shaderData.setVector2(WaterMaterial._waterSpeed, new engine.Vector2(-0.02, 0.02));
        _this.shaderData.setVector4(WaterMaterial._edgeColor, new engine.Vector4((69 + 255) / 510, (156 + 255) / 510, (247 + 255) / 510, 1));
        _this.shaderData.setVector2(WaterMaterial._edgeParam, new engine.Vector2(0.008, 0.002));
        _this.shaderData.setFloat(WaterMaterial._distorsionAmount, 0.02);
        _this.shaderData.setVector2(WaterMaterial._distorsionSpeed, new engine.Vector2(0.2, 0.2));
        return _this;
    }
    _create_class(WaterMaterial, [
        {
            key: "normalTexture",
            get: /**
   *  Normal Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterMaterial._normalTextureProp, value);
            }
        },
        {
            key: "waterTexture",
            get: /**
   *  Water Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterMaterial._waterTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterMaterial._waterTextureProp, value);
            }
        },
        {
            key: "edgeTexture",
            get: /**
   *  Edge Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterMaterial._edgeTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterMaterial._edgeTextureProp, value);
            }
        },
        {
            key: "waterSpeed",
            get: /**
   *  Water Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterMaterial._waterSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterMaterial._waterSpeed, val);
            }
        },
        {
            key: "edgeColor",
            get: /**
   * Water Edge Color
   */ function get() {
                return this.shaderData.getVector4(WaterMaterial._edgeColor);
            },
            set: function set(val) {
                this.shaderData.setVector4(WaterMaterial._edgeColor, val);
            }
        },
        {
            key: "edgeParam",
            get: /**
   * Edge Param;
   * x for edge thickness, must between 0 ~ 1;
   * y for edge smoothness, must between 0 ~ 0.5;
   */ function get() {
                return this.shaderData.getVector2(WaterMaterial._edgeParam);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterMaterial._edgeParam, val);
            }
        },
        {
            key: "distorsionAmount",
            get: /**
   * Distorsion Amount, must between -1 ~ 1
   */ function get() {
                return this.shaderData.getFloat(WaterMaterial._distorsionAmount);
            },
            set: function set(val) {
                this.shaderData.setFloat(WaterMaterial._distorsionAmount, val);
            }
        },
        {
            key: "distorsionSpeed",
            get: /**
   * Distorsion Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterMaterial._distorsionSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterMaterial._distorsionSpeed, val);
            }
        }
    ]);
    return WaterMaterial;
}(engine.BaseMaterial);
WaterMaterial._waterSpeed = engine.ShaderProperty.getByName("u_water_speed");
WaterMaterial._edgeColor = engine.ShaderProperty.getByName("u_edgeColor");
WaterMaterial._edgeParam = engine.ShaderProperty.getByName("u_edgeParam");
WaterMaterial._distorsionAmount = engine.ShaderProperty.getByName("u_distorsion_amount");
WaterMaterial._distorsionSpeed = engine.ShaderProperty.getByName("u_distorsion_speed");
WaterMaterial._waterTextureProp = engine.ShaderProperty.getByName("u_waterTex");
WaterMaterial._edgeTextureProp = engine.ShaderProperty.getByName("u_edgeTex");

var vertexSource = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ";
var fragmentSource = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
engine.Shader.create("water-fall", vertexSource, fragmentSource);
var WaterFallMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(WaterFallMaterial, BaseMaterial);
    function WaterFallMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("water-fall")) || this;
        _this.shaderData.setVector2(WaterFallMaterial._waterSpeed, new engine.Vector2(0.2, 0.0));
        _this.shaderData.setVector2(WaterFallMaterial._waterfallSpeed, new engine.Vector2(0.9, 0));
        _this.shaderData.setVector4(WaterFallMaterial._edgeColor, new engine.Vector4(160 / 255, 250 / 255, 250 / 255, 1.0));
        _this.shaderData.setVector2(WaterFallMaterial._edgeParam, new engine.Vector2(0.7, 0.05));
        _this.shaderData.setFloat(WaterFallMaterial._distorsionAmount, 0.03);
        _this.shaderData.setVector2(WaterFallMaterial._distorsionSpeed, new engine.Vector2(1.0, 1.0));
        return _this;
    }
    _create_class(WaterFallMaterial, [
        {
            key: "normalTexture",
            get: /**
   *  Normal Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._normalTextureProp, value);
            }
        },
        {
            key: "waterTexture",
            get: /**
   *  Water Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._waterTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._waterTextureProp, value);
            }
        },
        {
            key: "waterfallTexture",
            get: /**
   *  Water Fall Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._waterfallTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._waterfallTextureProp, value);
            }
        },
        {
            key: "edgeNoiseTexture",
            get: /**
   *  Edge Noise Texture Map
   */ function get() {
                return this.shaderData.getTexture(WaterFallMaterial._edgeTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(WaterFallMaterial._edgeTextureProp, value);
            }
        },
        {
            key: "waterSpeed",
            get: /**
   *  Water Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._waterSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._waterSpeed, val);
            }
        },
        {
            key: "waterfallSpeed",
            get: /**
   *  Water Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._waterfallSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._waterfallSpeed, val);
            }
        },
        {
            key: "edgeColor",
            get: /**
   * Water Edge Color
   */ function get() {
                return this.shaderData.getVector4(WaterFallMaterial._edgeColor);
            },
            set: function set(val) {
                this.shaderData.setVector4(WaterFallMaterial._edgeColor, val);
            }
        },
        {
            key: "edgeParam",
            get: /**
   * Edge Param;
   * x for edge thickness, must between 0 ~ 1;
   * y for edge smoothness, must between 0 ~ 0.5;
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._edgeParam);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._edgeParam, val);
            }
        },
        {
            key: "distorsionAmount",
            get: /**
   * Distorsion Amount, must between -1 ~ 1
   */ function get() {
                return this.shaderData.getFloat(WaterFallMaterial._distorsionAmount);
            },
            set: function set(val) {
                this.shaderData.setFloat(WaterFallMaterial._distorsionAmount, val);
            }
        },
        {
            key: "distorsionSpeed",
            get: /**
   * Distorsion Speed on x direction and y direction
   */ function get() {
                return this.shaderData.getVector2(WaterFallMaterial._distorsionSpeed);
            },
            set: function set(val) {
                this.shaderData.setVector2(WaterFallMaterial._distorsionSpeed, val);
            }
        }
    ]);
    return WaterFallMaterial;
}(engine.BaseMaterial);
WaterFallMaterial._waterSpeed = engine.ShaderProperty.getByName("u_water_speed");
WaterFallMaterial._waterfallSpeed = engine.ShaderProperty.getByName("u_waterfall_speed");
WaterFallMaterial._distorsionSpeed = engine.ShaderProperty.getByName("u_distorsion_speed");
WaterFallMaterial._edgeColor = engine.ShaderProperty.getByName("u_edgeColor");
WaterFallMaterial._edgeParam = engine.ShaderProperty.getByName("u_edgeParam");
WaterFallMaterial._distorsionAmount = engine.ShaderProperty.getByName("u_distorsion_amount");
WaterFallMaterial._waterTextureProp = engine.ShaderProperty.getByName("u_waterTex");
WaterFallMaterial._waterfallTextureProp = engine.ShaderProperty.getByName("u_waterfallTex");
WaterFallMaterial._edgeTextureProp = engine.ShaderProperty.getByName("u_edgeNoiseTex");

var fragment = "\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n";

var vertex = "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n";

engine.Shader.create("bake-pbr", vertex, fragment);
/**
 * Bake PBR Material.
 */ var BakePBRMaterial = /*#__PURE__*/ function(PBRMaterial) {
    _inherits(BakePBRMaterial, PBRMaterial);
    function BakePBRMaterial(engine$1) {
        var _this;
        _this = PBRMaterial.call(this, engine$1) || this;
        _this.shader = engine.Shader.find("bake-pbr");
        _this.shaderData.setFloat(BakePBRMaterial._lightMapIntensityProp, 1);
        return _this;
    }
    var _proto = BakePBRMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new BakePBRMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class(BakePBRMaterial, [
        {
            key: "lightmapTexture",
            get: /**
   * Light map texture.
   */ function get() {
                return this.shaderData.getTexture(BakePBRMaterial._lightMapTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BakePBRMaterial._lightMapTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("LIGHTMAP_TEXTURE");
                } else {
                    this.shaderData.disableMacro("LIGHTMAP_TEXTURE");
                }
            }
        },
        {
            key: "lightmapIntensity",
            get: /**
   * Light map intensity, default 1.0.
   */ function get() {
                return this.shaderData.getFloat(BakePBRMaterial._lightMapIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(BakePBRMaterial._lightMapIntensityProp, value);
            }
        }
    ]);
    return BakePBRMaterial;
}(engine.PBRMaterial);
BakePBRMaterial._lightMapTextureProp = engine.ShaderProperty.getByName("u_lightMapTexture");
BakePBRMaterial._lightMapIntensityProp = engine.ShaderProperty.getByName("u_lightMapIntensity");

/**
 * plain color Material. don't effected by light and fog.
 */ var PlainColorMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(PlainColorMaterial, BaseMaterial);
    function PlainColorMaterial(engine$1) {
        var _this;
        _this = BaseMaterial.call(this, engine$1, engine.Shader.find("plain-color")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.setColor(PlainColorMaterial._baseColorProp, new engine.Color(1, 1, 1, 1));
        _this.renderState.rasterState.cullMode = engine.CullMode.Off;
        return _this;
    }
    var _proto = PlainColorMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new PlainColorMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class(PlainColorMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PlainColorMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PlainColorMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return PlainColorMaterial;
}(engine.BaseMaterial);
engine.Shader.create("plain-color", "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n\nvoid main() {\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n}\n", "\n#include <common>\n\nuniform vec4 material_BaseColor;\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n     #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n}\n");

exports.BakePBRMaterial = BakePBRMaterial;
exports.GridControl = GridControl;
exports.GridMaterial = GridMaterial;
exports.GridShaderSource = Grid;
exports.PlainColorMaterial = PlainColorMaterial;
exports.PlanarShadowShaderFactory = PlanarShadowShaderFactory;
exports.PlanarShadowShaderSource = PlanarShadow;
exports.WaterFallMaterial = WaterFallMaterial;
exports.WaterMaterial = WaterMaterial;
exports.WaterRippleMaterial = WaterRippleMaterial;
//# sourceMappingURL=browser.js.map
