'use strict';

var engine = require('@galacean/engine');

exports.LineCap = void 0;
(function(LineCap) {
    LineCap[LineCap["Round"] = 0] = "Round";
    LineCap[LineCap["Butt"] = 1] = "Butt";
    LineCap[LineCap["Square"] = 2] = "Square";
})(exports.LineCap || (exports.LineCap = {}));
exports.LineJoin = void 0;
(function(LineJoin) {
    LineJoin[LineJoin["Miter"] = 0] = "Miter";
    LineJoin[LineJoin["Round"] = 1] = "Round";
    LineJoin[LineJoin["Bevel"] = 2] = "Bevel";
})(exports.LineJoin || (exports.LineJoin = {}));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;

        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
        });
    };
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

//-- Shader 代码
var vertexSource$1 = "\nattribute vec2 a_pos;\nattribute vec2 a_normal;\nattribute vec2 a_data;\n\nuniform mat4 renderer_MVPMat;\nuniform float u_width;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\n\nvoid main() {\n    v_direction = a_data.x;\n    v_part = a_data.y;\n    float layer_index = 1.0;\n\n    v_origin = a_pos;\n    vec2 position = a_pos + a_normal * u_width;\n    v_position = position;\n    gl_Position = renderer_MVPMat * vec4(position, 0.0, 1);\n}\n  ";
var fragmentSource$1 = "\nprecision highp float;\n\nuniform vec4 u_color;\nuniform int u_join;\nuniform int u_cap;\nuniform float u_width;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\n\nfloat IS_CAP = 0.0;\n\nvoid main() {\n    vec4 finalColor;\n    if (u_cap == 0 && v_part == IS_CAP) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    if (u_join == 1 && v_part > 1.0) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n\n    gl_FragColor = u_color;\n}\n\n  ";
engine.Shader.create("line", vertexSource$1, fragmentSource$1);

var LineMaterial = /*#__PURE__*/ function(Material) {
    _inherits(LineMaterial, Material);
    function LineMaterial(engine$1) {
        var _this;
        _this = Material.call(this, engine$1, engine.Shader.find("line")) || this;
        var _this_renderState = _this.renderState, depthState = _this_renderState.depthState, targetBlendState = _this_renderState.blendState.targetBlendState, rasterState = _this_renderState.rasterState;
        rasterState.cullMode = engine.CullMode.Off;
        depthState.writeEnabled = false;
        _this.renderState.renderQueueType = engine.RenderQueueType.Transparent;
        targetBlendState.enabled = true;
        targetBlendState.sourceColorBlendFactor = engine.BlendFactor.SourceAlpha;
        targetBlendState.destinationColorBlendFactor = engine.BlendFactor.OneMinusSourceAlpha;
        targetBlendState.sourceAlphaBlendFactor = engine.BlendFactor.SourceAlpha;
        targetBlendState.destinationAlphaBlendFactor = engine.BlendFactor.OneMinusSourceAlpha;
        targetBlendState.colorBlendOperation = engine.BlendOperation.Add;
        targetBlendState.alphaBlendOperation = engine.BlendOperation.Add;
        return _this;
    }
    return LineMaterial;
}(engine.Material);

//-- Shader 代码
var vertexSource = "\nattribute vec2 a_pos;\nattribute vec2 a_normal;\nattribute vec2 a_data;\nattribute float a_lengthsofar;\n\nuniform mat4 renderer_MVPMat;\nuniform float u_width;\nuniform vec2 u_dash;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\nvarying vec2 v_tex;\n\nvoid main() {\n    v_direction = a_data.x;\n    v_part = a_data.y;\n    float layer_index = 1.0;\n\n\n    v_origin = a_pos;\n\n    float texcoord_y = 0.0;\n\n    texcoord_y = a_lengthsofar / (u_dash.x + u_dash.y);\n    if (v_direction == 1.0) {\n        v_tex = vec2(1.0, texcoord_y);\n    } else {\n        v_tex = vec2(0.0, texcoord_y);\n    }\n    vec2 position = a_pos + a_normal * u_width;\n    v_position = position;\n    gl_Position = renderer_MVPMat * vec4(position, 0.0, 1);\n}\n  ";
var fragmentSource = "\nprecision highp float;\n\nuniform vec4 u_color;\nuniform int u_join;\nuniform int u_cap;\nuniform float u_width;\nuniform sampler2D u_texture;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\nvarying vec2 v_tex;\n\nfloat IS_CAP = 0.0;\n\nvoid main() {\n    vec4 finalColor;\n    if (u_cap == 0 && v_part == IS_CAP) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    if (u_join == 1 && v_part > 1.5) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    vec4 textureColor = texture2D(u_texture, v_tex);\n    if (textureColor.a <= 0.5) {\n      gl_FragColor = vec4(u_color.rgb, 0.0);\n    } else {\n      gl_FragColor = u_color;\n    }\n}\n";
engine.Shader.create("dash", vertexSource, fragmentSource);

var DashMaterial = /*#__PURE__*/ function(LineMaterial) {
    _inherits(DashMaterial, LineMaterial);
    function DashMaterial(engine$1) {
        var _this;
        _this = LineMaterial.call(this, engine$1) || this;
        _this.shader = engine.Shader.find("dash");
        return _this;
    }
    return DashMaterial;
}(LineMaterial);

var wasmString = "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";

var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function InvalidCharacterError(message) {
    this.message = message;
}
InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = "InvalidCharacterError";
function atob$1(input) {
    var str = String(input).replace(/=+$/, "");
    if (str.length % 4 === 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    var output = "";
    for(// initialize result and counters
    var bc = 0, bs, buffer, idx = 0; // get next character
    buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
    // convert the first 8 bits to one ascii character
    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0){
        // try to find character in table (0-63, not found => -1)
        buffer = chars.indexOf(buffer);
    }
    return output;
}

var LineVertexBuilder = /*#__PURE__*/ function() {
    function LineVertexBuilder() {
        var _this = this;
        var wasmBuffer = Uint8Array.from(typeof atob === "undefined" ? atob$1(wasmString) : atob(wasmString), function(c) {
            return c.charCodeAt(0);
        });
        this._wasmInitPromise = new Promise(function(resolve) {
            WebAssembly.instantiate(wasmBuffer, {
                env: {
                    consoleLog: function consoleLog(arg) {
                    // console.log('from wasm', arg);
                    },
                    segfault: function(a, b, c) {
                        console.log(a, b, c);
                    },
                    alignfault: function(a, b, c) {
                        console.log(a, b, c);
                    }
                }
            }).then(function(result) {
                _this._memory = result.instance.exports.memory.buffer;
                _this._heap32 = new Float32Array(_this._memory);
                _this._heap16 = new Int16Array(_this._memory);
                _this._wasmModule = result.instance.exports;
                resolve();
            });
        });
    }
    var _proto = LineVertexBuilder.prototype;
    /**
   * Parse the solid line
   * @param points The points array
   * @param join Line's join property
   * @param cap Line's cap property
   * @param start The start index of the output vertex.
   * @returns The vertex buffer and index buffer.
   */ _proto.solidLine = function solidLine(points, join, cap, start) {
        var _this = this;
        return _async_to_generator(function() {
            var vertexCount, indexCount, verticesStart, indicesStart, indicesEnd;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            _this._wasmInitPromise
                        ];
                    case 1:
                        _state.sent();
                        _this._heap32.set(points, 0);
                        vertexCount = _this._getSolidVertexCount(points.length / 2, join);
                        indexCount = vertexCount * 3 - 6;
                        verticesStart = points.length * Float32Array.BYTES_PER_ELEMENT;
                        indicesStart = verticesStart + vertexCount * 24;
                        indicesEnd = indicesStart + indexCount * Uint16Array.BYTES_PER_ELEMENT;
                        _this._wasmModule.build_solid_line(0, points.length / 2, join, cap, start, verticesStart, indicesStart);
                        return [
                            2,
                            {
                                vertices: new Float32Array(_this._memory.slice(verticesStart, indicesStart)),
                                indices: new Uint16Array(_this._memory.slice(indicesStart, indicesEnd))
                            }
                        ];
                }
            });
        })();
    };
    /**
   * Parse the dash line
   * @param points The points array
   * @param join Line's join property
   * @param cap Line's cap property
   * @param lengthsofar Length of all previous lines.
   * @param start The start index of the output vertex.
   * @returns The vertex buffer and index buffer.
   */ _proto.dashLine = function dashLine(points, join, cap, lengthsofar, start) {
        var _this = this;
        return _async_to_generator(function() {
            var vertexCount, indexCount, verticesStart, indicesStart, indicesEnd;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            _this._wasmInitPromise
                        ];
                    case 1:
                        _state.sent();
                        _this._heap32.set(points, 0);
                        vertexCount = _this._getDashVertexCount(points.length / 2, join);
                        indexCount = vertexCount * 3 - 6;
                        verticesStart = points.length * Float32Array.BYTES_PER_ELEMENT;
                        indicesStart = verticesStart + vertexCount * 24;
                        indicesEnd = indicesStart + indexCount * Uint16Array.BYTES_PER_ELEMENT;
                        _this._wasmModule.build_dash_line(0, points.length / 2, join, cap, lengthsofar, start, verticesStart, indicesStart);
                        return [
                            2,
                            {
                                vertices: new Float32Array(_this._memory.slice(verticesStart, indicesStart)),
                                indices: new Uint16Array(_this._memory.slice(indicesStart, indicesEnd))
                            }
                        ];
                }
            });
        })();
    };
    _proto._getSolidVertexCount = function _getSolidVertexCount(pointCount, join) {
        if (join === exports.LineJoin.Round) {
            return pointCount * 5 - 2;
        } else {
            return pointCount * 4;
        }
    };
    _proto._getDashVertexCount = function _getDashVertexCount(pointCount, join) {
        if (join === exports.LineJoin.Bevel) {
            return pointCount * 7 - 6;
        } else {
            return pointCount * 5 - 2;
        }
    };
    _create_class(LineVertexBuilder, null, [
        {
            key: "instance",
            get: function get() {
                if (!this._instance) {
                    this._instance = new LineVertexBuilder();
                }
                return this._instance;
            }
        }
    ]);
    return LineVertexBuilder;
}();

/**
 * Solid Line.
 */ var Line = /*#__PURE__*/ function(Script) {
    _inherits(Line, Script);
    function Line(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this._points = [];
        _this._cap = exports.LineCap.Butt;
        _this._join = exports.LineJoin.Miter;
        _this._flattenPoints = [];
        _this._width = 0.1;
        _this._color = new engine.Color(0, 0, 0, 1);
        _this._needUpdate = false;
        return _this;
    }
    var _proto = Line.prototype;
    /**
   * @internal
   */ _proto.onAwake = function onAwake() {
        this._renderer = this.entity.addComponent(engine.MeshRenderer);
        this.color = this._color;
        this.join = this._join;
        this.cap = this._cap;
        this.width = this._width;
        this._initMaterial();
        this._mesh = new engine.BufferMesh(this.engine, "LineGeometry");
        // Add vertexElement
        this._mesh.setVertexElements([
            new engine.VertexElement("a_pos", 0, engine.VertexElementFormat.Vector2, 0),
            new engine.VertexElement("a_normal", 8, engine.VertexElementFormat.Vector2, 0),
            new engine.VertexElement("a_data", 16, engine.VertexElementFormat.Short2, 0),
            new engine.VertexElement("a_lengthsofar", 20, engine.VertexElementFormat.Float, 0)
        ]);
        this._renderer.mesh = this._mesh;
    };
    /**
   * @internal
   */ _proto.onUpdate = function onUpdate() {
        if (this._needUpdate) {
            this._render();
            this._needUpdate = false;
        }
    };
    /**
   * @internal
   */ _proto.onEnable = function onEnable() {
        this._renderer.enabled = true;
    };
    /**
   * @internal
   */ _proto.onDisable = function onDisable() {
        this._renderer.enabled = false;
    };
    /**
   * @internal
   */ _proto.onDestroy = function onDestroy() {
        this._renderer.destroy();
    };
    _proto._generateData = function _generateData() {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            LineVertexBuilder.instance.solidLine(_this._flattenPoints, _this._join, _this._cap, -1)
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        })();
    };
    _proto._render = function _render() {
        var _this = this;
        return _async_to_generator(function() {
            var _ref, vertices, indices, vertexBuffer, indexBuffer, _this__mesh_indexBufferBinding_buffer, _this__mesh_indexBufferBinding;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            _this._generateData()
                        ];
                    case 1:
                        _ref = _state.sent(), vertices = _ref.vertices, indices = _ref.indices;
                        vertexBuffer = new engine.Buffer(_this.engine, engine.BufferBindFlag.VertexBuffer, vertices, engine.BufferUsage.Static);
                        indexBuffer = new engine.Buffer(_this.engine, engine.BufferBindFlag.IndexBuffer, indices, engine.BufferUsage.Static);
                        vertexBuffer.setData(vertices);
                        indexBuffer.setData(indices);
                        // destroy old buffer
                        if (_this._mesh) {
                            _this._mesh.vertexBufferBindings.forEach(function(binding) {
                                var _binding_buffer;
                                binding == null ? void 0 : (_binding_buffer = binding.buffer) == null ? void 0 : _binding_buffer.destroy();
                            });
                            (_this__mesh_indexBufferBinding = _this._mesh.indexBufferBinding) == null ? void 0 : (_this__mesh_indexBufferBinding_buffer = _this__mesh_indexBufferBinding.buffer) == null ? void 0 : _this__mesh_indexBufferBinding_buffer.destroy();
                        }
                        _this._mesh.setVertexBufferBinding(vertexBuffer, 24, 0);
                        _this._mesh.setIndexBufferBinding(indexBuffer, engine.IndexFormat.UInt16);
                        _this._mesh.clearSubMesh();
                        _this._mesh.addSubMesh(0, indices.length);
                        // @ts-ignore
                        _this._mesh._enableVAO = false;
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto._initMaterial = function _initMaterial() {
        this._material = new LineMaterial(this.engine);
        this._renderer.setMaterial(this._material);
    };
    _create_class(Line, [
        {
            key: "points",
            get: /**
   * The points that make up the line.
   */ function get() {
                return this._points;
            },
            set: function set(value) {
                this._points = value;
                this._flattenPoints = this._points.map(function(point) {
                    return [
                        point.x,
                        point.y
                    ];
                }).flat();
                this._needUpdate = true;
            }
        },
        {
            key: "cap",
            get: /**
   * Determines the shape used to draw the end points of line.
   */ function get() {
                return this._cap;
            },
            set: function set(value) {
                if (value !== this._cap) {
                    var _this__renderer;
                    this._cap = value;
                    (_this__renderer = this._renderer) == null ? void 0 : _this__renderer.shaderData.setInt("u_cap", value);
                    this._needUpdate = true;
                }
            }
        },
        {
            key: "join",
            get: /**
   * Determines the shape used to join two line segments where they meet.
   */ function get() {
                return this._join;
            },
            set: function set(value) {
                if (value !== this._join) {
                    var _this__renderer;
                    this._join = value;
                    (_this__renderer = this._renderer) == null ? void 0 : _this__renderer.shaderData.setInt("u_join", value);
                    this._needUpdate = true;
                }
            }
        },
        {
            key: "width",
            get: /**
   * The thickness of line.
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                this._width = value;
                this._renderer.shaderData.setFloat("u_width", value);
            }
        },
        {
            key: "color",
            get: /**
   * The color of line.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                this._color = value;
                this._renderer.shaderData.setColor("u_color", value);
            }
        }
    ]);
    return Line;
}(engine.Script);

/**
 * Dash Line.
 */ var DashLine = /*#__PURE__*/ function(Line) {
    _inherits(DashLine, Line);
    function DashLine(entity) {
        var _this;
        _this = Line.call(this, entity) || this;
        _this._material = null;
        return _this;
    }
    var _proto = DashLine.prototype;
    _proto._generateData = function _generateData() {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            LineVertexBuilder.instance.dashLine(_this._flattenPoints, _this._join, _this._cap, 0, -1)
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        })();
    };
    _proto._initMaterial = function _initMaterial() {
        var material = new DashMaterial(this.engine);
        this._renderer.setMaterial(material);
        this._material = material;
    };
    _proto._generateDashTexture = function _generateDashTexture(dash) {
        var pixels = [];
        var length = Math.ceil((dash.x + dash.y) * 10);
        for(var index = 0; index < length; index++){
            if (index < dash.x * 10) {
                pixels.push(255, 255, 255, 255);
            } else {
                pixels.push(255, 255, 255, 0);
            }
        }
        return new Uint8Array(pixels);
    };
    _create_class(DashLine, [
        {
            key: "dash",
            get: /**
   * The dash sequence is a series of on/off lengths in points. e.g. [3, 1] would be 3pt long lines separated by 1pt spaces.
   */ function get() {
                return this._dash;
            },
            set: function set(val) {
                var _this__renderer, _this__renderer1;
                this._dash = val;
                (_this__renderer = this._renderer) == null ? void 0 : _this__renderer.shaderData.setVector2("u_dash", val);
                var texture = new engine.Texture2D(this.engine, 1, Math.ceil((val.x + val.y) * 10));
                texture.setPixelBuffer(this._generateDashTexture(val));
                (_this__renderer1 = this._renderer) == null ? void 0 : _this__renderer1.shaderData.setTexture("u_texture", texture);
            }
        }
    ]);
    return DashLine;
}(Line);

exports.DashLine = DashLine;
exports.Line = Line;
//# sourceMappingURL=browser.js.map
