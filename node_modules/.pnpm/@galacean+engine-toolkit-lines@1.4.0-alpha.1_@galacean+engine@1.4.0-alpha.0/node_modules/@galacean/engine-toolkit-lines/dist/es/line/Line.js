import { _ as _async_to_generator, a as _create_class, b as __generator, L as LineVertexBuilder } from '../index-ac53e8dd.js';
import { _ as _inherits, L as LineMaterial } from '../LineMaterial-1723f22c.js';
import { MeshRenderer, BufferMesh, VertexElement, VertexElementFormat, Color, Script, Buffer, BufferBindFlag, BufferUsage, IndexFormat } from '@galacean/engine';
import { LineCap, LineJoin } from './constants.js';
import './vertexBuilder/atob.js';
import './material/lineShader.js';

/**
 * Solid Line.
 */ var Line = /*#__PURE__*/ function(Script) {
    _inherits(Line, Script);
    function Line(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this._points = [];
        _this._cap = LineCap.Butt;
        _this._join = LineJoin.Miter;
        _this._flattenPoints = [];
        _this._width = 0.1;
        _this._color = new Color(0, 0, 0, 1);
        _this._needUpdate = false;
        return _this;
    }
    var _proto = Line.prototype;
    /**
   * @internal
   */ _proto.onAwake = function onAwake() {
        this._renderer = this.entity.addComponent(MeshRenderer);
        this.color = this._color;
        this.join = this._join;
        this.cap = this._cap;
        this.width = this._width;
        this._initMaterial();
        this._mesh = new BufferMesh(this.engine, "LineGeometry");
        // Add vertexElement
        this._mesh.setVertexElements([
            new VertexElement("a_pos", 0, VertexElementFormat.Vector2, 0),
            new VertexElement("a_normal", 8, VertexElementFormat.Vector2, 0),
            new VertexElement("a_data", 16, VertexElementFormat.Short2, 0),
            new VertexElement("a_lengthsofar", 20, VertexElementFormat.Float, 0)
        ]);
        this._renderer.mesh = this._mesh;
    };
    /**
   * @internal
   */ _proto.onUpdate = function onUpdate() {
        if (this._needUpdate) {
            this._render();
            this._needUpdate = false;
        }
    };
    /**
   * @internal
   */ _proto.onEnable = function onEnable() {
        this._renderer.enabled = true;
    };
    /**
   * @internal
   */ _proto.onDisable = function onDisable() {
        this._renderer.enabled = false;
    };
    /**
   * @internal
   */ _proto.onDestroy = function onDestroy() {
        this._renderer.destroy();
    };
    _proto._generateData = function _generateData() {
        var _this = this;
        return _async_to_generator(function() {
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            LineVertexBuilder.instance.solidLine(_this._flattenPoints, _this._join, _this._cap, -1)
                        ];
                    case 1:
                        return [
                            2,
                            _state.sent()
                        ];
                }
            });
        })();
    };
    _proto._render = function _render() {
        var _this = this;
        return _async_to_generator(function() {
            var _ref, vertices, indices, vertexBuffer, indexBuffer, _this__mesh_indexBufferBinding_buffer, _this__mesh_indexBufferBinding;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        return [
                            4,
                            _this._generateData()
                        ];
                    case 1:
                        _ref = _state.sent(), vertices = _ref.vertices, indices = _ref.indices;
                        vertexBuffer = new Buffer(_this.engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static);
                        indexBuffer = new Buffer(_this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Static);
                        vertexBuffer.setData(vertices);
                        indexBuffer.setData(indices);
                        // destroy old buffer
                        if (_this._mesh) {
                            _this._mesh.vertexBufferBindings.forEach(function(binding) {
                                var _binding_buffer;
                                binding == null ? void 0 : (_binding_buffer = binding.buffer) == null ? void 0 : _binding_buffer.destroy();
                            });
                            (_this__mesh_indexBufferBinding = _this._mesh.indexBufferBinding) == null ? void 0 : (_this__mesh_indexBufferBinding_buffer = _this__mesh_indexBufferBinding.buffer) == null ? void 0 : _this__mesh_indexBufferBinding_buffer.destroy();
                        }
                        _this._mesh.setVertexBufferBinding(vertexBuffer, 24, 0);
                        _this._mesh.setIndexBufferBinding(indexBuffer, IndexFormat.UInt16);
                        _this._mesh.clearSubMesh();
                        _this._mesh.addSubMesh(0, indices.length);
                        // @ts-ignore
                        _this._mesh._enableVAO = false;
                        return [
                            2
                        ];
                }
            });
        })();
    };
    _proto._initMaterial = function _initMaterial() {
        this._material = new LineMaterial(this.engine);
        this._renderer.setMaterial(this._material);
    };
    _create_class(Line, [
        {
            key: "points",
            get: /**
   * The points that make up the line.
   */ function get() {
                return this._points;
            },
            set: function set(value) {
                this._points = value;
                this._flattenPoints = this._points.map(function(point) {
                    return [
                        point.x,
                        point.y
                    ];
                }).flat();
                this._needUpdate = true;
            }
        },
        {
            key: "cap",
            get: /**
   * Determines the shape used to draw the end points of line.
   */ function get() {
                return this._cap;
            },
            set: function set(value) {
                if (value !== this._cap) {
                    var _this__renderer;
                    this._cap = value;
                    (_this__renderer = this._renderer) == null ? void 0 : _this__renderer.shaderData.setInt("u_cap", value);
                    this._needUpdate = true;
                }
            }
        },
        {
            key: "join",
            get: /**
   * Determines the shape used to join two line segments where they meet.
   */ function get() {
                return this._join;
            },
            set: function set(value) {
                if (value !== this._join) {
                    var _this__renderer;
                    this._join = value;
                    (_this__renderer = this._renderer) == null ? void 0 : _this__renderer.shaderData.setInt("u_join", value);
                    this._needUpdate = true;
                }
            }
        },
        {
            key: "width",
            get: /**
   * The thickness of line.
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                this._width = value;
                this._renderer.shaderData.setFloat("u_width", value);
            }
        },
        {
            key: "color",
            get: /**
   * The color of line.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                this._color = value;
                this._renderer.shaderData.setColor("u_color", value);
            }
        }
    ]);
    return Line;
}(Script);

export { Line };
//# sourceMappingURL=Line.js.map
