(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@galacean/engine')) :
    typeof define === 'function' && define.amd ? define(['exports', '@galacean/engine'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Galacean = global.Galacean || {}, global.Galacean.PhysicsPhysX = {}), global.Galacean));
})(this, (function (exports, engine) { 'use strict';

    function _instanceof(left, right) {
        if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
            return !!right[Symbol.hasInstance](left);
        } else return left instanceof right;
    }

    function _type_of(obj) {
        "@swc/helpers - typeof";

        return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
    }

    function _set_prototype_of(o, p) {
        _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
            o.__proto__ = p;

            return o;
        };

        return _set_prototype_of(o, p);
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

        if (superClass) _set_prototype_of(subClass, superClass);
    }

    /**
     * Abstract class for collider shapes.
     */ var PhysXColliderShape = /*#__PURE__*/ function() {
        function PhysXColliderShape(physXPhysics) {
            /** @internal */ this._controllers = new engine.DisorderedArray();
            this._worldScale = new engine.Vector3(1, 1, 1);
            this._position = new engine.Vector3();
            this._rotation = null;
            this._axis = null;
            this._physXRotation = new engine.Quaternion();
            this._shapeFlags = 2 | 1;
            this._physXPhysics = physXPhysics;
        }
        var _proto = PhysXColliderShape.prototype;
        /**
       * {@inheritDoc IColliderShape.setRotation }
       */ _proto.setRotation = function setRotation(value) {
            this._rotation = value;
            engine.Quaternion.rotationYawPitchRoll(value.x, value.y, value.z, this._physXRotation);
            this._axis && engine.Quaternion.multiply(this._physXRotation, this._axis, this._physXRotation);
            this._physXRotation.normalize();
            this._setLocalPose();
        };
        /**
       * {@inheritDoc IColliderShape.setPosition }
       */ _proto.setPosition = function setPosition(value) {
            if (value !== this._position) {
                this._position.copyFrom(value);
            }
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                controllers.get(i)._updateShapePosition(this._position, this._worldScale);
            }
            this._setLocalPose();
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            this._worldScale.copyFrom(scale);
            this._setLocalPose();
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                controllers.get(i)._updateShapePosition(this._position, this._worldScale);
            }
        };
        /**
       * {@inheritDoc IColliderShape.setContactOffset }
       * @default 0.02f * PxTolerancesScale::length
       */ _proto.setContactOffset = function setContactOffset(offset) {
            this._pxShape.setContactOffset(offset);
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                var _controllers_get__pxController;
                (_controllers_get__pxController = controllers.get(i)._pxController) == null ? void 0 : _controllers_get__pxController.setContactOffset(offset);
            }
        };
        /**
       * {@inheritDoc IColliderShape.setMaterial }
       */ _proto.setMaterial = function setMaterial(value) {
            this._pxMaterial = value._pxMaterial;
            this._pxShape.setMaterial(this._pxMaterial);
        };
        /**
       * {@inheritDoc IColliderShape.setIsTrigger }
       */ _proto.setIsTrigger = function setIsTrigger(value) {
            this._modifyFlag(1, !value);
            this._modifyFlag(4, value);
            this._setShapeFlags(this._shapeFlags);
        };
        /**
       * {@inheritDoc IColliderShape.destroy }
       */ _proto.destroy = function destroy() {
            this._pxShape.release();
        };
        /**
       *  @internal
       */ _proto._setShapeFlags = function _setShapeFlags(flags) {
            this._shapeFlags = flags;
            this._pxShape.setFlags(new this._physXPhysics._physX.PxShapeFlags(this._shapeFlags));
        };
        _proto._setLocalPose = function _setLocalPose() {
            var transform = PhysXColliderShape.transform;
            engine.Vector3.multiply(this._position, this._worldScale, transform.translation);
            transform.rotation = this._physXRotation;
            this._pxShape.setLocalPose(transform);
        };
        _proto._initialize = function _initialize(material, id) {
            this._id = id;
            this._pxMaterial = material._pxMaterial;
            this._pxShape = this._physXPhysics._pxPhysics.createShape(this._pxGeometry, material._pxMaterial, true, new this._physXPhysics._physX.PxShapeFlags(this._shapeFlags));
            this._pxShape.setUUID(id);
        };
        _proto._modifyFlag = function _modifyFlag(flag, value) {
            this._shapeFlags = value ? this._shapeFlags | flag : this._shapeFlags & ~flag;
        };
        return PhysXColliderShape;
    }();
    PhysXColliderShape.halfSqrt = 0.70710678118655;
    PhysXColliderShape.transform = {
        translation: new engine.Vector3(),
        rotation: null
    };

    /**
     * Box collider shape in PhysX.
     */ var PhysXBoxColliderShape = /*#__PURE__*/ function(PhysXColliderShape) {
        _inherits(PhysXBoxColliderShape, PhysXColliderShape);
        function PhysXBoxColliderShape(physXPhysics, uniqueID, size, material) {
            var _this;
            _this = PhysXColliderShape.call(this, physXPhysics) || this, /** @internal */ _this._halfSize = new engine.Vector3(), _this._sizeScale = new engine.Vector3(1, 1, 1);
            var halfSize = _this._halfSize;
            halfSize.set(size.x * 0.5, size.y * 0.5, size.z * 0.5);
            _this._pxGeometry = new physXPhysics._physX.PxBoxGeometry(halfSize.x, halfSize.y, halfSize.z);
            _this._initialize(material, uniqueID);
            _this._setLocalPose();
            return _this;
        }
        var _proto = PhysXBoxColliderShape.prototype;
        /**
       * {@inheritDoc IBoxColliderShape.setSize }
       */ _proto.setSize = function setSize(value) {
            var halfSize = this._halfSize;
            var tempExtents = PhysXBoxColliderShape._tempHalfExtents;
            halfSize.set(value.x * 0.5, value.y * 0.5, value.z * 0.5);
            engine.Vector3.multiply(halfSize, this._sizeScale, tempExtents);
            this._pxGeometry.halfExtents = tempExtents;
            this._pxShape.setGeometry(this._pxGeometry);
            this._updateController(tempExtents);
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            PhysXColliderShape.prototype.setWorldScale.call(this, scale);
            this._sizeScale.set(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
            var tempExtents = PhysXBoxColliderShape._tempHalfExtents;
            engine.Vector3.multiply(this._halfSize, this._sizeScale, tempExtents);
            this._pxGeometry.halfExtents = tempExtents;
            this._pxShape.setGeometry(this._pxGeometry);
            this._updateController(tempExtents);
        };
        _proto._updateController = function _updateController(extents) {
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                var pxController = controllers.get(i)._pxController;
                if (pxController) {
                    pxController.setHalfHeight(extents.x);
                    pxController.setHalfSideExtent(extents.y);
                    pxController.setHalfForwardExtent(extents.z);
                }
            }
        };
        return PhysXBoxColliderShape;
    }(PhysXColliderShape);
    PhysXBoxColliderShape._tempHalfExtents = new engine.Vector3();

    /**
     * Capsule collider shape in PhysX.
     */ var PhysXCapsuleColliderShape = /*#__PURE__*/ function(PhysXColliderShape1) {
        _inherits(PhysXCapsuleColliderShape, PhysXColliderShape1);
        function PhysXCapsuleColliderShape(physXPhysics, uniqueID, radius, height, material) {
            var _this;
            _this = PhysXColliderShape1.call(this, physXPhysics) || this, _this._upAxis = 1, _this._sizeScale = new engine.Vector3(1, 1, 1);
            _this._radius = radius;
            _this._halfHeight = height * 0.5;
            _this._axis = new engine.Quaternion(0, 0, PhysXColliderShape.halfSqrt, PhysXColliderShape.halfSqrt);
            _this._physXRotation.copyFrom(_this._axis);
            _this._pxGeometry = new physXPhysics._physX.PxCapsuleGeometry(_this._radius, _this._halfHeight);
            _this._initialize(material, uniqueID);
            _this._setLocalPose();
            return _this;
        }
        var _proto = PhysXCapsuleColliderShape.prototype;
        /**
       * {@inheritDoc ICapsuleColliderShape.setRadius }
       */ _proto.setRadius = function setRadius(value) {
            this._radius = value;
            var sizeScale = this._sizeScale;
            switch(this._upAxis){
                case 0:
                    this._pxGeometry.radius = this._radius * Math.max(sizeScale.y, sizeScale.z);
                    break;
                case 1:
                    this._pxGeometry.radius = this._radius * Math.max(sizeScale.x, sizeScale.z);
                    break;
                case 2:
                    this._pxGeometry.radius = this._radius * Math.max(sizeScale.x, sizeScale.y);
                    break;
            }
            this._pxShape.setGeometry(this._pxGeometry);
            var radius = this._pxGeometry.radius;
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                var _controllers_get__pxController;
                (_controllers_get__pxController = controllers.get(i)._pxController) == null ? void 0 : _controllers_get__pxController.setRadius(radius);
            }
        };
        /**
       * {@inheritDoc ICapsuleColliderShape.setHeight }
       */ _proto.setHeight = function setHeight(value) {
            this._halfHeight = value * 0.5;
            var sizeScale = this._sizeScale;
            switch(this._upAxis){
                case 0:
                    this._pxGeometry.halfHeight = this._halfHeight * sizeScale.x;
                    break;
                case 1:
                    this._pxGeometry.halfHeight = this._halfHeight * sizeScale.y;
                    break;
                case 2:
                    this._pxGeometry.halfHeight = this._halfHeight * sizeScale.z;
                    break;
            }
            this._pxShape.setGeometry(this._pxGeometry);
            var height = this._pxGeometry.halfHeight * 2;
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                var _controllers_get__pxController;
                (_controllers_get__pxController = controllers.get(i)._pxController) == null ? void 0 : _controllers_get__pxController.setHeight(height);
            }
        };
        /**
       * {@inheritDoc ICapsuleColliderShape.setUpAxis }
       */ _proto.setUpAxis = function setUpAxis(upAxis) {
            var _this = this, rotation = _this._rotation, axis = _this._axis, physXRotation = _this._physXRotation;
            this._upAxis = upAxis;
            switch(this._upAxis){
                case 0:
                    axis.set(0, 0, 0, 1);
                    break;
                case 1:
                    axis.set(0, 0, PhysXColliderShape.halfSqrt, PhysXColliderShape.halfSqrt);
                    break;
                case 2:
                    axis.set(0, PhysXColliderShape.halfSqrt, 0, PhysXColliderShape.halfSqrt);
                    break;
            }
            if (rotation) {
                engine.Quaternion.rotationYawPitchRoll(rotation.x, rotation.y, rotation.z, physXRotation);
                engine.Quaternion.multiply(physXRotation, axis, physXRotation);
            } else {
                physXRotation.copyFrom(axis);
            }
            this._setLocalPose();
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            PhysXColliderShape1.prototype.setWorldScale.call(this, scale);
            var sizeScale = this._sizeScale.set(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
            var geometry = this._pxGeometry;
            switch(this._upAxis){
                case 0:
                    geometry.radius = this._radius * Math.max(sizeScale.y, sizeScale.z);
                    geometry.halfHeight = this._halfHeight * sizeScale.x;
                    break;
                case 1:
                    geometry.radius = this._radius * Math.max(sizeScale.x, sizeScale.z);
                    geometry.halfHeight = this._halfHeight * sizeScale.y;
                    break;
                case 2:
                    geometry.radius = this._radius * Math.max(sizeScale.x, sizeScale.y);
                    geometry.halfHeight = this._halfHeight * sizeScale.z;
                    break;
            }
            this._pxShape.setGeometry(geometry);
            var radius = geometry.radius;
            var height = geometry.halfHeight * 2;
            var controllers = this._controllers;
            for(var i = 0, n = controllers.length; i < n; i++){
                var pxController = controllers.get(i)._pxController;
                if (pxController) {
                    pxController.setRadius(radius);
                    pxController.setHeight(height);
                }
            }
        };
        return PhysXCapsuleColliderShape;
    }(PhysXColliderShape);

    /**
     * Base class for character controllers.
     */ var PhysXCharacterController = /*#__PURE__*/ function() {
        function PhysXCharacterController(physXPhysics) {
            this._shapeScaledPosition = new engine.Vector3();
            this._worldPosition = null;
            this._physXPhysics = physXPhysics;
        }
        var _proto = PhysXCharacterController.prototype;
        /**
       * {@inheritDoc ICharacterController.move }
       */ _proto.move = function move(disp, minDist, elapsedTime) {
            var _this__pxController;
            var _this__pxController_move;
            return (_this__pxController_move = (_this__pxController = this._pxController) == null ? void 0 : _this__pxController.move(disp, minDist, elapsedTime)) != null ? _this__pxController_move : 0;
        };
        /**
       * {@inheritDoc ICharacterController.setWorldPosition }
       */ _proto.setWorldPosition = function setWorldPosition(position) {
            this._worldPosition = position;
            this._updateNativePosition();
        };
        /**
       * {@inheritDoc ICharacterController.getWorldPosition }
       */ _proto.getWorldPosition = function getWorldPosition(position) {
            if (this._pxController) {
                position.copyFrom(this._pxController.getPosition());
                position.subtract(this._shapeScaledPosition);
            }
        };
        /**
       * {@inheritDoc ICharacterController.setStepOffset }
       */ _proto.setStepOffset = function setStepOffset(offset) {
            var _this__pxController;
            (_this__pxController = this._pxController) == null ? void 0 : _this__pxController.setStepOffset(offset);
        };
        /**
       * {@inheritDoc ICharacterController.setNonWalkableMode }
       */ _proto.setNonWalkableMode = function setNonWalkableMode(flag) {
            var _this__pxController;
            (_this__pxController = this._pxController) == null ? void 0 : _this__pxController.setNonWalkableMode(flag);
        };
        /**
       * {@inheritDoc ICharacterController.setUpDirection }
       */ _proto.setUpDirection = function setUpDirection(up) {
            var _this__pxController;
            (_this__pxController = this._pxController) == null ? void 0 : _this__pxController.setUpDirection(up);
        };
        /**
       * {@inheritDoc ICharacterController.setSlopeLimit }
       */ _proto.setSlopeLimit = function setSlopeLimit(slopeLimit) {
            var _this__pxController;
            (_this__pxController = this._pxController) == null ? void 0 : _this__pxController.setSlopeLimit(slopeLimit);
        };
        /**
       * {@inheritDoc ICharacterController.addShape }
       */ _proto.addShape = function addShape(shape) {
            // When CharacterController is disabled, set shape property need check pxController whether exist because of this._pxManager is null and won't create pxController
            this._pxManager && this._createPXController(this._pxManager, shape);
            this._shape = shape;
            shape._controllers.add(this);
        };
        /**
       * {@inheritDoc ICharacterController.removeShape }
       */ _proto.removeShape = function removeShape(shape) {
            this._destroyPXController();
            this._shape = null;
            shape._controllers.delete(this);
        };
        /**
       * {@inheritDoc ICharacterController.destroy }
       */ _proto.destroy = function destroy() {
            this._destroyPXController();
        };
        /**
       * @internal
       */ _proto._createPXController = function _createPXController(pxManager, shape) {
            var desc;
            if (_instanceof(shape, PhysXBoxColliderShape)) {
                desc = new this._physXPhysics._physX.PxBoxControllerDesc();
                desc.halfHeight = shape._halfSize.x;
                desc.halfSideExtent = shape._halfSize.y;
                desc.halfForwardExtent = shape._halfSize.z;
            } else if (_instanceof(shape, PhysXCapsuleColliderShape)) {
                desc = new this._physXPhysics._physX.PxCapsuleControllerDesc();
                desc.radius = shape._radius;
                desc.height = shape._halfHeight * 2;
                desc.climbingMode = 1; // constraint mode
            } else {
                throw "unsupported shape type";
            }
            desc.setMaterial(shape._pxMaterial);
            this._pxController = pxManager._getControllerManager().createController(desc);
            this._pxController.setUUID(shape._id);
        };
        /**
       * @internal
       */ _proto._destroyPXController = function _destroyPXController() {
            if (this._pxController) {
                this._pxController.release();
                this._pxController = null;
            }
        };
        /**
       * @internal
       */ _proto._updateShapePosition = function _updateShapePosition(shapePosition, worldScale) {
            engine.Vector3.multiply(shapePosition, worldScale, this._shapeScaledPosition);
            this._updateNativePosition();
        };
        _proto._updateNativePosition = function _updateNativePosition() {
            var worldPosition = this._worldPosition;
            if (this._pxController && worldPosition) {
                engine.Vector3.add(worldPosition, this._shapeScaledPosition, PhysXCharacterController._tempVec);
                this._pxController.setPosition(PhysXCharacterController._tempVec);
            }
        };
        return PhysXCharacterController;
    }();
    PhysXCharacterController._tempVec = new engine.Vector3();

    /**
     * Abstract class of physical collider.
     */ var PhysXCollider = /*#__PURE__*/ function() {
        function PhysXCollider(physXPhysics) {
            this._physXPhysics = physXPhysics;
        }
        var _proto = PhysXCollider.prototype;
        /**
       * {@inheritDoc ICollider.addShape }
       */ _proto.addShape = function addShape(shape) {
            this._pxActor.attachShape(shape._pxShape);
        };
        /**
       * {@inheritDoc ICollider.removeShape }
       */ _proto.removeShape = function removeShape(shape) {
            this._pxActor.detachShape(shape._pxShape, true);
        };
        /**
       * {@inheritDoc ICollider.setWorldTransform }
       */ _proto.setWorldTransform = function setWorldTransform(position, rotation) {
            this._pxActor.setGlobalPose(this._transform(position, rotation), true);
        };
        /**
       * {@inheritDoc ICollider.getWorldTransform }
       */ _proto.getWorldTransform = function getWorldTransform(outPosition, outRotation) {
            var transform = this._pxActor.getGlobalPose();
            outPosition.set(transform.translation.x, transform.translation.y, transform.translation.z);
            outRotation.set(transform.rotation.x, transform.rotation.y, transform.rotation.z, transform.rotation.w);
        };
        /**
       * {@inheritDoc ICollider.destroy }
       */ _proto.destroy = function destroy() {
            this._pxActor.release();
        };
        /**
       * @internal
       */ _proto._transform = function _transform(pos, rot) {
            var transform = PhysXCollider._tempTransform;
            transform.translation = pos;
            transform.rotation = rot.normalize();
            return transform;
        };
        return PhysXCollider;
    }();
    PhysXCollider._tempTransform = {
        translation: null,
        rotation: null
    };

    /**
     * A dynamic collider can act with self-defined movement or physical force
     */ var PhysXDynamicCollider = /*#__PURE__*/ function(PhysXCollider) {
        _inherits(PhysXDynamicCollider, PhysXCollider);
        function PhysXDynamicCollider(physXPhysics, position, rotation) {
            var _this;
            _this = PhysXCollider.call(this, physXPhysics) || this;
            var transform = _this._transform(position, rotation);
            _this._pxActor = physXPhysics._pxPhysics.createRigidDynamic(transform);
            return _this;
        }
        var _proto = PhysXDynamicCollider.prototype;
        /**
       * {@inheritDoc IDynamicCollider.setLinearDamping }
       */ _proto.setLinearDamping = function setLinearDamping(value) {
            this._pxActor.setLinearDamping(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setAngularDamping }
       */ _proto.setAngularDamping = function setAngularDamping(value) {
            this._pxActor.setAngularDamping(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setLinearVelocity }
       */ _proto.setLinearVelocity = function setLinearVelocity(value) {
            this._pxActor.setLinearVelocity(value, true);
        };
        /**
       * {@inheritDoc IDynamicCollider.setAngularVelocity }
       */ _proto.setAngularVelocity = function setAngularVelocity(value) {
            this._pxActor.setAngularVelocity(value, true);
        };
        /**
       * {@inheritDoc IDynamicCollider.setMass }
       */ _proto.setMass = function setMass(value) {
            this._pxActor.setMass(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setCenterOfMass }
       */ _proto.setCenterOfMass = function setCenterOfMass(position) {
            this._pxActor.setCMassLocalPose(position);
        };
        /**
       * {@inheritDoc IDynamicCollider.setInertiaTensor }
       */ _proto.setInertiaTensor = function setInertiaTensor(value) {
            this._pxActor.setMassSpaceInertiaTensor(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setMaxAngularVelocity }
       */ _proto.setMaxAngularVelocity = function setMaxAngularVelocity(value) {
            this._pxActor.setMaxAngularVelocity(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setMaxDepenetrationVelocity }
       */ _proto.setMaxDepenetrationVelocity = function setMaxDepenetrationVelocity(value) {
            this._pxActor.setMaxDepenetrationVelocity(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setSleepThreshold }
       * @default 1e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed
       */ _proto.setSleepThreshold = function setSleepThreshold(value) {
            this._pxActor.setSleepThreshold(value);
        };
        /**
       * {@inheritDoc IDynamicCollider.setSolverIterations }
       */ _proto.setSolverIterations = function setSolverIterations(value) {
            this._pxActor.setSolverIterationCounts(value, 1);
        };
        /**
       * {@inheritDoc IDynamicCollider.setCollisionDetectionMode }
       */ _proto.setCollisionDetectionMode = function setCollisionDetectionMode(value) {
            switch(value){
                case 1:
                    this._pxActor.setRigidBodyFlag(this._physXPhysics._physX.PxRigidBodyFlag.eENABLE_CCD, true);
                    break;
                case 2:
                    this._pxActor.setRigidBodyFlag(this._physXPhysics._physX.PxRigidBodyFlag.eENABLE_CCD_FRICTION, true);
                    break;
                case 3:
                    this._pxActor.setRigidBodyFlag(this._physXPhysics._physX.PxRigidBodyFlag.eENABLE_SPECULATIVE_CCD, true);
                    break;
                case 0:
                    var physX = this._physXPhysics._physX;
                    this._pxActor.setRigidBodyFlag(physX.PxRigidBodyFlag.eENABLE_CCD, false);
                    this._pxActor.setRigidBodyFlag(physX.PxRigidBodyFlag.eENABLE_CCD_FRICTION, false);
                    this._pxActor.setRigidBodyFlag(physX.PxRigidBodyFlag.eENABLE_SPECULATIVE_CCD, false);
                    break;
            }
        };
        /**
       * {@inheritDoc IDynamicCollider.setIsKinematic }
       */ _proto.setIsKinematic = function setIsKinematic(value) {
            if (value) {
                this._pxActor.setRigidBodyFlag(this._physXPhysics._physX.PxRigidBodyFlag.eKINEMATIC, true);
            } else {
                this._pxActor.setRigidBodyFlag(this._physXPhysics._physX.PxRigidBodyFlag.eKINEMATIC, false);
            }
        };
        /**
       * {@inheritDoc IDynamicCollider.setConstraints }
       */ _proto.setConstraints = function setConstraints(flags) {
            this._pxActor.setRigidDynamicLockFlags(flags);
        };
        /**
       * {@inheritDoc IDynamicCollider.addForce }
       */ _proto.addForce = function addForce(force) {
            this._pxActor.addForce({
                x: force.x,
                y: force.y,
                z: force.z
            });
        };
        /**
       * {@inheritDoc IDynamicCollider.addTorque }
       */ _proto.addTorque = function addTorque(torque) {
            this._pxActor.addTorque({
                x: torque.x,
                y: torque.y,
                z: torque.z
            });
        };
        /**
       * {@inheritDoc IDynamicCollider.move }
       */ _proto.move = function move(positionOrRotation, rotation) {
            if (rotation) {
                this._pxActor.setKinematicTarget(positionOrRotation, rotation);
                return;
            }
            var tempTranslation = PhysXDynamicCollider._tempTranslation;
            var tempRotation = PhysXDynamicCollider._tempRotation;
            this.getWorldTransform(tempTranslation, tempRotation);
            if (_instanceof(positionOrRotation, engine.Vector3)) {
                this._pxActor.setKinematicTarget(positionOrRotation, tempRotation);
            } else {
                this._pxActor.setKinematicTarget(tempTranslation, positionOrRotation);
            }
        };
        /**
       * {@inheritDoc IDynamicCollider.sleep }
       */ _proto.sleep = function sleep() {
            return this._pxActor.putToSleep();
        };
        /**
       * {@inheritDoc IDynamicCollider.wakeUp }
       */ _proto.wakeUp = function wakeUp() {
            return this._pxActor.wakeUp();
        };
        return PhysXDynamicCollider;
    }(PhysXCollider);
    PhysXDynamicCollider._tempTranslation = new engine.Vector3();
    PhysXDynamicCollider._tempRotation = new engine.Quaternion();

    var PhysXPhysicsManager = function PhysXPhysicsManager() {
        /** @internal */ this._eventMap = {};
    };

    /**
     * Physics material describes how to handle colliding objects (friction, bounciness).
     */ var PhysXPhysicsMaterial = /*#__PURE__*/ function() {
        function PhysXPhysicsMaterial(physXPhysics, staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {
            this._physXPhysics = physXPhysics;
            var pxMaterial = physXPhysics._pxPhysics.createMaterial(staticFriction, dynamicFriction, bounciness);
            pxMaterial.setFrictionCombineMode(frictionCombine);
            pxMaterial.setRestitutionCombineMode(bounceCombine);
            this._pxMaterial = pxMaterial;
        }
        var _proto = PhysXPhysicsMaterial.prototype;
        /**
       * {@inheritDoc IPhysicsMaterial.setBounciness }
       */ _proto.setBounciness = function setBounciness(value) {
            this._pxMaterial.setRestitution(value);
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setDynamicFriction }
       */ _proto.setDynamicFriction = function setDynamicFriction(value) {
            this._pxMaterial.setDynamicFriction(value);
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setStaticFriction }
       */ _proto.setStaticFriction = function setStaticFriction(value) {
            this._pxMaterial.setStaticFriction(value);
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setBounceCombine }
       */ _proto.setBounceCombine = function setBounceCombine(value) {
            this._pxMaterial.setRestitutionCombineMode(value);
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setFrictionCombine }
       */ _proto.setFrictionCombine = function setFrictionCombine(value) {
            this._pxMaterial.setFrictionCombineMode(value);
        };
        /**
       * {@inheritDoc IPhysicsMaterial.destroy }
       */ _proto.destroy = function destroy() {
            this._pxMaterial.release();
        };
        return PhysXPhysicsMaterial;
    }();

    /**
     * A manager is a collection of colliders and constraints which can interact.
     */ var PhysXPhysicsScene = /*#__PURE__*/ function() {
        function PhysXPhysicsScene(physXPhysics, physicsManager, onContactEnter, onContactExit, onContactStay, onTriggerEnter, onTriggerExit, onTriggerStay) {
            var _this = this;
            /** @internal */ this._pxControllerManager = null;
            this._currentEvents = new engine.DisorderedArray();
            this._eventPool = [];
            this._physXPhysics = physXPhysics;
            this._physXManager = physicsManager;
            var physX = physXPhysics._physX;
            this._pxRaycastHit = new physX.PxRaycastHit();
            this._pxFilterData = new physX.PxQueryFilterData();
            this._pxFilterData.flags = new physX.PxQueryFlags(1 | 2 | 4);
            this._onContactEnter = onContactEnter;
            this._onContactExit = onContactExit;
            this._onContactStay = onContactStay;
            this._onTriggerEnter = onTriggerEnter;
            this._onTriggerExit = onTriggerExit;
            this._onTriggerStay = onTriggerStay;
            var triggerCallback = {
                onContactBegin: function(index1, index2) {
                    _this._onContactEnter(index1, index2);
                },
                onContactEnd: function(index1, index2) {
                    _this._onContactExit(index1, index2);
                },
                onContactPersist: function(index1, index2) {
                    _this._onContactStay(index1, index2);
                },
                onTriggerBegin: function(index1, index2) {
                    var event = index1 < index2 ? _this._getTrigger(index1, index2) : _this._getTrigger(index2, index1);
                    event.state = 0;
                    _this._currentEvents.add(event);
                },
                onTriggerEnd: function(index1, index2) {
                    var event;
                    if (index1 < index2) {
                        var subMap = _this._physXManager._eventMap[index1];
                        event = subMap[index2];
                        subMap[index2] = undefined;
                    } else {
                        var subMap1 = _this._physXManager._eventMap[index2];
                        event = subMap1[index1];
                        subMap1[index1] = undefined;
                    }
                    event.state = 2;
                }
            };
            var pxPhysics = physXPhysics._pxPhysics;
            var physXSimulationCallbackInstance = physX.PxSimulationEventCallback.implement(triggerCallback);
            var sceneDesc = physX.getDefaultSceneDesc(pxPhysics.getTolerancesScale(), 0, physXSimulationCallbackInstance);
            this._pxScene = pxPhysics.createScene(sceneDesc);
        }
        var _proto = PhysXPhysicsScene.prototype;
        /**
       * {@inheritDoc IPhysicsManager.setGravity }
       */ _proto.setGravity = function setGravity(value) {
            this._pxScene.setGravity(value);
        };
        /**
       * {@inheritDoc IPhysicsManager.addColliderShape }
       */ _proto.addColliderShape = function addColliderShape(colliderShape) {
            this._physXManager._eventMap[colliderShape._id] = {};
        };
        /**
       * {@inheritDoc IPhysicsManager.removeColliderShape }
       */ _proto.removeColliderShape = function removeColliderShape(colliderShape) {
            var _this = this, eventPool = _this._eventPool, currentEvents = _this._currentEvents;
            var id = colliderShape._id;
            var _this__physXManager = this._physXManager, eventMap = _this__physXManager._eventMap;
            currentEvents.forEach(function(event, i) {
                if (event.index1 == id) {
                    currentEvents.deleteByIndex(i);
                    eventPool.push(event);
                } else if (event.index2 == id) {
                    currentEvents.deleteByIndex(i);
                    eventPool.push(event);
                    // If the shape is big index, should clear from the small index shape subMap
                    eventMap[event.index1][id] = undefined;
                }
            });
            delete eventMap[id];
        };
        /**
       * {@inheritDoc IPhysicsManager.addCollider }
       */ _proto.addCollider = function addCollider(collider) {
            this._pxScene.addActor(collider._pxActor, null);
        };
        /**
       * {@inheritDoc IPhysicsManager.removeCollider }
       */ _proto.removeCollider = function removeCollider(collider) {
            this._pxScene.removeActor(collider._pxActor, true);
        };
        /**
       * {@inheritDoc IPhysicsManager.addCharacterController }
       */ _proto.addCharacterController = function addCharacterController(characterController) {
            // Physx have no API to remove/readd cct into scene.
            if (!characterController._pxController) {
                var shape = characterController._shape;
                if (shape) {
                    var lastPXManager = characterController._pxManager;
                    if (lastPXManager !== this) {
                        lastPXManager && characterController._destroyPXController();
                        characterController._createPXController(this, shape);
                    }
                }
            }
            characterController._pxManager = this;
        };
        /**
       * {@inheritDoc IPhysicsManager.removeCharacterController }
       */ _proto.removeCharacterController = function removeCharacterController(characterController) {
            characterController._pxManager = null;
        };
        /**
       * {@inheritDoc IPhysicsManager.update }
       */ _proto.update = function update(elapsedTime) {
            this._simulate(elapsedTime);
            this._fetchResults();
            this._fireEvent();
        };
        /**
       * {@inheritDoc IPhysicsManager.raycast }
       */ _proto.raycast = function raycast(ray, distance, onRaycast, hit) {
            var _this = this, pxHitResult = _this._pxRaycastHit;
            distance = Math.min(distance, 3.4e38); // float32 max value limit in physx raycast.
            var raycastCallback = {
                preFilter: function(filterData, index, actor) {
                    if (onRaycast(index)) {
                        return 2; // eBLOCK
                    } else {
                        return 0; // eNONE
                    }
                },
                postFilter: function(filterData, hit) {}
            };
            var result = this._pxScene.raycastSingle(ray.origin, ray.direction, distance, pxHitResult, this._pxFilterData, this._physXPhysics._physX.PxQueryFilterCallback.implement(raycastCallback));
            if (result && hit != undefined) {
                var position = PhysXPhysicsScene._tempPosition, normal = PhysXPhysicsScene._tempNormal;
                var pxPosition = pxHitResult.position, pxNormal = pxHitResult.normal;
                position.set(pxPosition.x, pxPosition.y, pxPosition.z);
                normal.set(pxNormal.x, pxNormal.y, pxNormal.z);
                hit(pxHitResult.getShape().getUUID(), pxHitResult.distance, position, normal);
            }
            return result;
        };
        /**
       * @internal
       */ _proto._getControllerManager = function _getControllerManager() {
            var pxControllerManager = this._pxControllerManager;
            if (pxControllerManager === null) {
                this._pxControllerManager = pxControllerManager = this._pxScene.createControllerManager();
            }
            return pxControllerManager;
        };
        _proto._simulate = function _simulate(elapsedTime) {
            this._pxScene.simulate(elapsedTime, true);
        };
        _proto._fetchResults = function _fetchResults(block) {
            if (block === void 0) block = true;
            this._pxScene.fetchResults(block);
        };
        _proto._getTrigger = function _getTrigger(index1, index2) {
            var event;
            if (this._eventPool.length) {
                event = this._eventPool.pop();
                event.index1 = index1;
                event.index2 = index2;
            } else {
                event = new TriggerEvent(index1, index2);
            }
            this._physXManager._eventMap[index1][index2] = event;
            return event;
        };
        _proto._fireEvent = function _fireEvent() {
            var _this = this;
            var _this1 = this, eventPool = _this1._eventPool, currentEvents = _this1._currentEvents;
            currentEvents.forEach(function(event, i) {
                if (event.state == 0) {
                    _this._onTriggerEnter(event.index1, event.index2);
                    event.state = 1;
                } else if (event.state == 1) {
                    _this._onTriggerStay(event.index1, event.index2);
                } else if (event.state == 2) {
                    currentEvents.deleteByIndex(i);
                    _this._onTriggerExit(event.index1, event.index2);
                    eventPool.push(event);
                }
            });
        };
        return PhysXPhysicsScene;
    }();
    PhysXPhysicsScene._tempPosition = new engine.Vector3();
    PhysXPhysicsScene._tempNormal = new engine.Vector3();
    /**
     * Trigger event to store interactive object ids and state.
     */ var TriggerEvent = function TriggerEvent(index1, index2) {
        this.index1 = index1;
        this.index2 = index2;
    };

    /**
     * A static collider component that will not move.
     * @remarks Mostly used for object which always stays at the same place and never moves around.
     */ var PhysXStaticCollider = /*#__PURE__*/ function(PhysXCollider) {
        _inherits(PhysXStaticCollider, PhysXCollider);
        function PhysXStaticCollider(physXPhysics, position, rotation) {
            var _this;
            _this = PhysXCollider.call(this, physXPhysics) || this;
            _this._pxActor = physXPhysics._pxPhysics.createRigidStatic(_this._transform(position, rotation));
            return _this;
        }
        return PhysXStaticCollider;
    }(PhysXCollider);

    /**
     * PhysX runtime mode.
     */ var PhysXRuntimeMode = /*#__PURE__*/ function(PhysXRuntimeMode) {
        /** Use webAssembly mode first, if WebAssembly mode is not supported, roll back to JavaScript mode.  */ PhysXRuntimeMode[PhysXRuntimeMode["Auto"] = 0] = "Auto";
        /** WebAssembly mode. */ PhysXRuntimeMode[PhysXRuntimeMode["WebAssembly"] = 1] = "WebAssembly";
        /** JavaScript mode. */ PhysXRuntimeMode[PhysXRuntimeMode["JavaScript"] = 2] = "JavaScript";
        return PhysXRuntimeMode;
    }({});

    /**
     * a base interface providing common functionality for PhysX joints
     */ var PhysXJoint = /*#__PURE__*/ function() {
        function PhysXJoint(physXPhysics) {
            this._connectedAnchor = new engine.Vector3();
            this._breakForce = Number.MAX_VALUE;
            this._breakTorque = Number.MAX_VALUE;
            this._physXPhysics = physXPhysics;
        }
        var _proto = PhysXJoint.prototype;
        /**
       * {@inheritDoc IJoint.setConnectedCollider }
       */ _proto.setConnectedCollider = function setConnectedCollider(value) {
            var _this__collider;
            this._pxJoint.setActors((value == null ? void 0 : value._pxActor) || null, ((_this__collider = this._collider) == null ? void 0 : _this__collider._pxActor) || null);
        };
        /**
       * {@inheritDoc IJoint.setConnectedAnchor }
       */ _proto.setConnectedAnchor = function setConnectedAnchor(value) {
            this._connectedAnchor.copyFrom(value);
            this._setLocalPose(0, value, PhysXJoint._defaultQuat);
        };
        /**
       * {@inheritDoc IJoint.setConnectedMassScale }
       */ _proto.setConnectedMassScale = function setConnectedMassScale(value) {
            this._pxJoint.setInvMassScale0(1 / value);
        };
        /**
       * {@inheritDoc IJoint.setConnectedInertiaScale }
       */ _proto.setConnectedInertiaScale = function setConnectedInertiaScale(value) {
            this._pxJoint.setInvInertiaScale0(1 / value);
        };
        /**
       * {@inheritDoc IJoint.setMassScale }
       */ _proto.setMassScale = function setMassScale(value) {
            this._pxJoint.setInvMassScale1(1 / value);
        };
        /**
       * {@inheritDoc IJoint.setInertiaScale }
       */ _proto.setInertiaScale = function setInertiaScale(value) {
            this._pxJoint.setInvInertiaScale1(1 / value);
        };
        /**
       * {@inheritDoc IJoint.setBreakForce }
       */ _proto.setBreakForce = function setBreakForce(value) {
            this._breakForce = value;
            this._pxJoint.setBreakForce(this._breakForce, this._breakTorque);
        };
        /**
       * {@inheritDoc IJoint.setBreakTorque }
       */ _proto.setBreakTorque = function setBreakTorque(value) {
            this._breakTorque = value;
            this._pxJoint.setBreakForce(this._breakForce, this._breakTorque);
        };
        /**
       * Set the joint local pose for an actor.
       * @param actor 0 for the first actor, 1 for the second actor.
       * @param position the local position for the actor this joint
       * @param rotation the local rotation for the actor this joint
       */ _proto._setLocalPose = function _setLocalPose(actor, position, rotation) {
            this._pxJoint.setLocalPose(actor, position, rotation);
        };
        return PhysXJoint;
    }();
    PhysXJoint._xAxis = new engine.Vector3(1, 0, 0);
    PhysXJoint._defaultVec = new engine.Vector3();
    PhysXJoint._defaultQuat = new engine.Quaternion();

    /**
     * A fixed joint permits no relative movement between two colliders. ie the bodies are glued together.
     */ var PhysXFixedJoint = /*#__PURE__*/ function(PhysXJoint1) {
        _inherits(PhysXFixedJoint, PhysXJoint1);
        function PhysXFixedJoint(physXPhysics, collider) {
            var _this;
            _this = PhysXJoint1.call(this, physXPhysics) || this;
            _this._collider = collider;
            _this._pxJoint = physXPhysics._pxPhysics.createFixedJoint(null, PhysXJoint._defaultVec, PhysXJoint._defaultQuat, collider._pxActor, PhysXJoint._defaultVec, PhysXJoint._defaultQuat);
            return _this;
        }
        return PhysXFixedJoint;
    }(PhysXJoint);

    /**
     * A joint which behaves in a similar way to a hinge or axle.
     */ var PhysXHingeJoint = /*#__PURE__*/ function(PhysXJoint1) {
        _inherits(PhysXHingeJoint, PhysXJoint1);
        function PhysXHingeJoint(physXPhysics, collider) {
            var _this;
            _this = PhysXJoint1.call(this, physXPhysics) || this, _this._axisRotationQuaternion = new engine.Quaternion(), _this._swingOffset = new engine.Vector3();
            _this._collider = collider;
            _this._pxJoint = physXPhysics._pxPhysics.createRevoluteJoint(null, PhysXJoint._defaultVec, PhysXJoint._defaultQuat, collider._pxActor, PhysXJoint._defaultVec, PhysXJoint._defaultQuat);
            return _this;
        }
        var _proto = PhysXHingeJoint.prototype;
        /**
       * {@inheritDoc IHingeJoint.setAxis }
       */ _proto.setAxis = function setAxis(value) {
            var xAxis = PhysXJoint._xAxis;
            var axisRotationQuaternion = this._axisRotationQuaternion;
            xAxis.set(1, 0, 0);
            value.normalize();
            var angle = Math.acos(engine.Vector3.dot(xAxis, value));
            engine.Vector3.cross(xAxis, value, xAxis);
            engine.Quaternion.rotationAxisAngle(xAxis, angle, axisRotationQuaternion);
            this._setLocalPose(0, this._swingOffset, axisRotationQuaternion);
        };
        /**
       * {@inheritDoc IHingeJoint.setSwingOffset }
       */ _proto.setSwingOffset = function setSwingOffset(value) {
            this._swingOffset.copyFrom(value);
            this._setLocalPose(1, this._swingOffset, this._axisRotationQuaternion);
        };
        /**
       * {@inheritDoc IHingeJoint.getAngle }
       */ _proto.getAngle = function getAngle() {
            return this._pxJoint.getAngle();
        };
        /**
       * {@inheritDoc IHingeJoint.getVelocity }
       */ _proto.getVelocity = function getVelocity() {
            return this._pxJoint.getVelocity();
        };
        /**
       * {@inheritDoc IHingeJoint.setHardLimitCone }
       */ _proto.setHardLimit = function setHardLimit(lowerLimit, upperLimit, contactDist) {
            this._pxJoint.setHardLimit(lowerLimit, upperLimit, contactDist);
        };
        /**
       * {@inheritDoc IHingeJoint.setHardLimitCone }
       */ _proto.setSoftLimit = function setSoftLimit(lowerLimit, upperLimit, stiffness, damping) {
            this._pxJoint.setSoftLimit(lowerLimit, upperLimit, stiffness, damping);
        };
        /**
       * {@inheritDoc IHingeJoint.setDriveVelocity }
       */ _proto.setDriveVelocity = function setDriveVelocity(velocity, autowake) {
            if (autowake === void 0) autowake = true;
            this._pxJoint.setDriveVelocity(velocity, autowake);
        };
        /**
       * {@inheritDoc IHingeJoint.setDriveForceLimit }
       */ _proto.setDriveForceLimit = function setDriveForceLimit(limit) {
            this._pxJoint.setDriveForceLimit(limit);
        };
        /**
       * {@inheritDoc IHingeJoint.setDriveGearRatio }
       */ _proto.setDriveGearRatio = function setDriveGearRatio(ratio) {
            this._pxJoint.setDriveGearRatio(ratio);
        };
        /**
       * {@inheritDoc IHingeJoint.setHingeJointFlag }
       */ _proto.setHingeJointFlag = function setHingeJointFlag(flag, value) {
            this._pxJoint.setRevoluteJointFlag(flag, value);
        };
        return PhysXHingeJoint;
    }(PhysXJoint);

    /**
     * a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects
     */ var PhysXSpringJoint = /*#__PURE__*/ function(PhysXJoint1) {
        _inherits(PhysXSpringJoint, PhysXJoint1);
        function PhysXSpringJoint(physXPhysics, collider) {
            var _this;
            _this = PhysXJoint1.call(this, physXPhysics) || this, _this._swingOffset = new engine.Vector3();
            _this._collider = collider;
            _this._pxJoint = physXPhysics._pxPhysics.createDistanceJoint(null, PhysXJoint._defaultVec, PhysXJoint._defaultQuat, collider._pxActor, PhysXJoint._defaultVec, PhysXJoint._defaultQuat);
            _this._pxJoint.setDistanceJointFlag(2, true); // enable max distance;
            _this._pxJoint.setDistanceJointFlag(4, true); // enable min distance;
            _this._pxJoint.setDistanceJointFlag(8, true); // enable spring;
            return _this;
        }
        var _proto = PhysXSpringJoint.prototype;
        /**
       * {@inheritDoc ISpringJoint.setSwingOffset }
       */ _proto.setSwingOffset = function setSwingOffset(value) {
            this._swingOffset.copyFrom(value);
            this._setLocalPose(1, value, PhysXJoint._defaultQuat);
        };
        /**
       * {@inheritDoc ISpringJoint.setMinDistance }
       */ _proto.setMinDistance = function setMinDistance(distance) {
            this._pxJoint.setMinDistance(distance);
        };
        /**
       * {@inheritDoc ISpringJoint.setMaxDistance }
       */ _proto.setMaxDistance = function setMaxDistance(distance) {
            this._pxJoint.setMaxDistance(distance);
        };
        /**
       * {@inheritDoc ISpringJoint.setTolerance }
       */ _proto.setTolerance = function setTolerance(tolerance) {
            this._pxJoint.setTolerance(tolerance);
        };
        /**
       * {@inheritDoc ISpringJoint.setStiffness }
       */ _proto.setStiffness = function setStiffness(stiffness) {
            this._pxJoint.setStiffness(stiffness);
        };
        /**
       * {@inheritDoc ISpringJoint.setDamping }
       */ _proto.setDamping = function setDamping(damping) {
            this._pxJoint.setDamping(damping);
        };
        return PhysXSpringJoint;
    }(PhysXJoint);

    /**
     * Plane collider shape in PhysX.
     */ var PhysXPlaneColliderShape = /*#__PURE__*/ function(PhysXColliderShape1) {
        _inherits(PhysXPlaneColliderShape, PhysXColliderShape1);
        function PhysXPlaneColliderShape(physXPhysics, uniqueID, material) {
            var _this;
            _this = PhysXColliderShape1.call(this, physXPhysics) || this;
            _this._axis = new engine.Quaternion(0, 0, PhysXColliderShape.halfSqrt, PhysXColliderShape.halfSqrt);
            _this._physXRotation.copyFrom(_this._axis);
            _this._pxGeometry = new physXPhysics._physX.PxPlaneGeometry();
            _this._initialize(material, uniqueID);
            _this._setLocalPose();
            return _this;
        }
        return PhysXPlaneColliderShape;
    }(PhysXColliderShape);

    /**
     * Sphere collider shape in PhysX.
     */ var PhysXSphereColliderShape = /*#__PURE__*/ function(PhysXColliderShape) {
        _inherits(PhysXSphereColliderShape, PhysXColliderShape);
        function PhysXSphereColliderShape(physXPhysics, uniqueID, radius, material) {
            var _this;
            _this = PhysXColliderShape.call(this, physXPhysics) || this, _this._maxScale = 1;
            _this._radius = radius;
            _this._pxGeometry = new physXPhysics._physX.PxSphereGeometry(_this._radius * _this._maxScale);
            _this._initialize(material, uniqueID);
            _this._setLocalPose();
            return _this;
        }
        var _proto = PhysXSphereColliderShape.prototype;
        /**
       * {@inheritDoc ISphereColliderShape.setRadius }
       */ _proto.setRadius = function setRadius(value) {
            this._radius = value;
            this._pxGeometry.radius = value * this._maxScale;
            this._pxShape.setGeometry(this._pxGeometry);
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            PhysXColliderShape.prototype.setWorldScale.call(this, scale);
            this._maxScale = Math.max(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
            this._pxGeometry.radius = this._radius * this._maxScale;
            this._pxShape.setGeometry(this._pxGeometry);
        };
        return PhysXSphereColliderShape;
    }(PhysXColliderShape);

    /**
     * PhysX object creation.
     */ var PhysXPhysics = /*#__PURE__*/ function() {
        function PhysXPhysics(runtimeMode) {
            if (runtimeMode === void 0) runtimeMode = PhysXRuntimeMode.Auto;
            this._initializeState = 0;
            this._runTimeMode = runtimeMode;
        }
        var _proto = PhysXPhysics.prototype;
        /**
       * Initialize PhysXPhysics.
       * @param runtimeMode - Runtime mode
       * @returns Promise object
       */ _proto.initialize = function initialize() {
            var _this = this;
            if (this._initializeState === 2) {
                return Promise.resolve();
            } else if (this._initializeState === 1) {
                return this._initializePromise;
            }
            var runtimeMode = this._runTimeMode;
            var scriptPromise = new Promise(function(resolve, reject) {
                var script = document.createElement("script");
                document.body.appendChild(script);
                script.async = true;
                script.onload = resolve;
                script.onerror = reject;
                if (runtimeMode == PhysXRuntimeMode.Auto) {
                    var supported = function() {
                        try {
                            if ((typeof WebAssembly === "undefined" ? "undefined" : _type_of(WebAssembly)) === "object" && typeof WebAssembly.instantiate === "function") {
                                var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
                                if (_instanceof(module, WebAssembly.Module)) return _instanceof(new WebAssembly.Instance(module), WebAssembly.Instance);
                            }
                        } catch (e) {}
                        return false;
                    }();
                    if (supported) {
                        runtimeMode = PhysXRuntimeMode.WebAssembly;
                    } else {
                        runtimeMode = PhysXRuntimeMode.JavaScript;
                    }
                }
                if (runtimeMode == PhysXRuntimeMode.JavaScript) {
                    script.src = "https://mdn.alipayobjects.com/rms/afts/file/A*rnDeR58NNGoAAAAAAAAAAAAAARQnAQ/physx.release.js.js";
                } else if (runtimeMode == PhysXRuntimeMode.WebAssembly) {
                    script.src = "https://mdn.alipayobjects.com/rms/afts/file/A*nA97QLQehRMAAAAAAAAAAAAAARQnAQ/physx.release.js";
                }
            });
            var initializePromise = new Promise(function(resolve, reject) {
                scriptPromise.then(function() {
                    return window.PHYSX().then(function(PHYSX) {
                        _this._init(PHYSX);
                        _this._initializeState = 2;
                        _this._initializePromise = null;
                        console.log("PhysX loaded.");
                        resolve();
                    }, reject);
                }, reject).catch(reject);
            });
            this._initializePromise = initializePromise;
            return initializePromise;
        };
        /**
       * Destroy PhysXPhysics.
       */ _proto.destroy = function destroy() {
            this._physX.PxCloseExtensions();
            this._pxPhysics.release();
            this._pxFoundation.release();
            this._physX = null;
            this._pxFoundation = null;
            this._pxPhysics = null;
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsManager }
       */ _proto.createPhysicsManager = function createPhysicsManager() {
            return new PhysXPhysicsManager();
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsScene }
       */ _proto.createPhysicsScene = function createPhysicsScene(physicsManager, onContactBegin, onContactEnd, onContactStay, onTriggerBegin, onTriggerEnd, onTriggerStay) {
            var manager = new PhysXPhysicsScene(this, physicsManager, onContactBegin, onContactEnd, onContactStay, onTriggerBegin, onTriggerEnd, onTriggerStay);
            return manager;
        };
        /**
       * {@inheritDoc IPhysics.createStaticCollider }
       */ _proto.createStaticCollider = function createStaticCollider(position, rotation) {
            return new PhysXStaticCollider(this, position, rotation);
        };
        /**
       * {@inheritDoc IPhysics.createDynamicCollider }
       */ _proto.createDynamicCollider = function createDynamicCollider(position, rotation) {
            return new PhysXDynamicCollider(this, position, rotation);
        };
        /**
       * {@inheritDoc IPhysics.createCharacterController }
       */ _proto.createCharacterController = function createCharacterController() {
            return new PhysXCharacterController(this);
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsMaterial }
       */ _proto.createPhysicsMaterial = function createPhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {
            return new PhysXPhysicsMaterial(this, staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine);
        };
        /**
       * {@inheritDoc IPhysics.createBoxColliderShape }
       */ _proto.createBoxColliderShape = function createBoxColliderShape(uniqueID, size, material) {
            return new PhysXBoxColliderShape(this, uniqueID, size, material);
        };
        /**
       * {@inheritDoc IPhysics.createSphereColliderShape }
       */ _proto.createSphereColliderShape = function createSphereColliderShape(uniqueID, radius, material) {
            return new PhysXSphereColliderShape(this, uniqueID, radius, material);
        };
        /**
       * {@inheritDoc IPhysics.createPlaneColliderShape }
       */ _proto.createPlaneColliderShape = function createPlaneColliderShape(uniqueID, material) {
            return new PhysXPlaneColliderShape(this, uniqueID, material);
        };
        /**
       * {@inheritDoc IPhysics.createCapsuleColliderShape }
       */ _proto.createCapsuleColliderShape = function createCapsuleColliderShape(uniqueID, radius, height, material) {
            return new PhysXCapsuleColliderShape(this, uniqueID, radius, height, material);
        };
        /**
       * {@inheritDoc IPhysics.createFixedJoint }
       */ _proto.createFixedJoint = function createFixedJoint(collider) {
            return new PhysXFixedJoint(this, collider);
        };
        /**
       * {@inheritDoc IPhysics.createHingeJoint }
       */ _proto.createHingeJoint = function createHingeJoint(collider) {
            return new PhysXHingeJoint(this, collider);
        };
        /**
       * {@inheritDoc IPhysics.createSpringJoint }
       */ _proto.createSpringJoint = function createSpringJoint(collider) {
            return new PhysXSpringJoint(this, collider);
        };
        _proto._init = function _init(physX) {
            var version = physX.PX_PHYSICS_VERSION;
            var defaultErrorCallback = new physX.PxDefaultErrorCallback();
            var allocator = new physX.PxDefaultAllocator();
            var pxFoundation = physX.PxCreateFoundation(version, allocator, defaultErrorCallback);
            var pxPhysics = physX.PxCreatePhysics(version, pxFoundation, new physX.PxTolerancesScale(), false, null);
            physX.PxInitExtensions(pxPhysics, null);
            this._physX = physX;
            this._pxFoundation = pxFoundation;
            this._pxPhysics = pxPhysics;
        };
        return PhysXPhysics;
    }();

    //@ts-ignore
    var version = "1.4.0-alpha.0";
    console.log("Galacean PhysX version: " + version);

    exports.PhysXPhysics = PhysXPhysics;
    exports.PhysXRuntimeMode = PhysXRuntimeMode;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=browser.js.map
