import { IDynamicCollider } from "@galacean/engine-design";
import { Quaternion, Vector3 } from "@galacean/engine";
import { PhysXCollider } from "./PhysXCollider";
import { PhysXPhysics } from "./PhysXPhysics";
/**
 * The collision detection mode constants used for PhysXDynamicCollider.collisionDetectionMode.
 * */
export declare enum CollisionDetectionMode {
    /** Continuous collision detection is off for this dynamic collider. */
    Discrete = 0,
    /** Continuous collision detection is on for colliding with static mesh geometry. */
    Continuous = 1,
    /** Continuous collision detection is on for colliding with static and dynamic geometry. */
    ContinuousDynamic = 2,
    /** Speculative continuous collision detection is on for static and dynamic geometries */
    ContinuousSpeculative = 3
}
/**
 * A dynamic collider can act with self-defined movement or physical force
 */
export declare class PhysXDynamicCollider extends PhysXCollider implements IDynamicCollider {
    private static _tempTranslation;
    private static _tempRotation;
    constructor(physXPhysics: PhysXPhysics, position: Vector3, rotation: Quaternion);
    /**
     * {@inheritDoc IDynamicCollider.setLinearDamping }
     */
    setLinearDamping(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setAngularDamping }
     */
    setAngularDamping(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setLinearVelocity }
     */
    setLinearVelocity(value: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.setAngularVelocity }
     */
    setAngularVelocity(value: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.setMass }
     */
    setMass(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setCenterOfMass }
     */
    setCenterOfMass(position: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.setInertiaTensor }
     */
    setInertiaTensor(value: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.setMaxAngularVelocity }
     */
    setMaxAngularVelocity(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setMaxDepenetrationVelocity }
     */
    setMaxDepenetrationVelocity(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setSleepThreshold }
     * @default 1e-5f * PxTolerancesScale::speed * PxTolerancesScale::speed
     */
    setSleepThreshold(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setSolverIterations }
     */
    setSolverIterations(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setCollisionDetectionMode }
     */
    setCollisionDetectionMode(value: number): void;
    /**
     * {@inheritDoc IDynamicCollider.setIsKinematic }
     */
    setIsKinematic(value: boolean): void;
    /**
     * {@inheritDoc IDynamicCollider.setConstraints }
     */
    setConstraints(flags: number): void;
    /**
     * {@inheritDoc IDynamicCollider.addForce }
     */
    addForce(force: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.addTorque }
     */
    addTorque(torque: Vector3): void;
    /**
     * {@inheritDoc IDynamicCollider.move }
     */
    move(positionOrRotation: Vector3 | Quaternion, rotation?: Quaternion): void;
    /**
     * {@inheritDoc IDynamicCollider.sleep }
     */
    sleep(): void;
    /**
     * {@inheritDoc IDynamicCollider.wakeUp }
     */
    wakeUp(): void;
}
