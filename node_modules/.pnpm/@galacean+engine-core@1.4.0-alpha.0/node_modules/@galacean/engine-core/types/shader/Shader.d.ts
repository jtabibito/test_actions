import { Engine } from "../Engine";
import { IReferable } from "../asset/IReferable";
import { ShaderMacro } from "./ShaderMacro";
import { ShaderPass } from "./ShaderPass";
import { ShaderProperty } from "./ShaderProperty";
import { SubShader } from "./SubShader";
/**
 * Shader for rendering.
 */
export declare class Shader implements IReferable {
    readonly name: string;
    private static _shaderMap;
    /**
     * Create a shader by source code.
     *
     * @remarks
     *
     * ShaderLab must be enabled first as follows:
     * ```ts
     * // Import shaderLab
     * import { ShaderLab } from "@galacean/engine-shader-lab";
     * // Create engine with shaderLab
     * const engine = await WebGLEngine.create({ canvas: "canvas", shader: new ShaderLab() });
     * ...
     * ```
     *
     * @param shaderSource - shader code
     * @returns Shader
     *
     * @throws
     * Throw string exception if shaderLab has not been enabled properly.
     */
    static create(shaderSource: string): Shader;
    /**
     * Create a shader.
     * @param name - Name of the shader
     * @param vertexSource - Vertex source code
     * @param fragmentSource - Fragment source code
     * @returns Shader
     */
    static create(name: string, vertexSource: string, fragmentSource: string): Shader;
    /**
     * Create a shader.
     * @param name - Name of the shader
     * @param shaderPasses - Shader passes
     * @returns Shader
     */
    static create(name: string, shaderPasses: ShaderPass[]): Shader;
    /**
     * Create a shader.
     * @param name - Name of the shader
     * @param subShaders - Sub shaders
     * @returns Shader
     */
    static create(name: string, subShaders: SubShader[]): Shader;
    /**
     * Find a shader by name.
     * @param name - Name of the shader
     */
    static find(name: string): Shader;
    private static _applyConstRenderStates;
    private _refCount;
    private _destroyed;
    private _subShaders;
    /**
     * Sub shaders of the shader.
     */
    get subShaders(): ReadonlyArray<SubShader>;
    /**
     * Whether it has been destroyed.
     */
    get destroyed(): boolean;
    private constructor();
    /**
     * Compile shader variant by macro name list.
     *
     * @remarks
     * Usually a shader contains some macros,any combination of macros is called shader variant.
     *
     * @param engine - Engine to which the shader variant belongs
     * @param macros - Macro name list
     * @returns Is the compiled shader variant valid
     */
    compileVariant(engine: Engine, macros: string[]): boolean;
    /**
     * Destroy the shader.
     * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
     * @returns Whether the release was successful.
     */
    destroy(force?: boolean): boolean;
    /**
     * @deprecated Please use `ShaderMacro.getByName` instead
     *
     * Get shader macro by name.
     * @param name - Name of the shader macro
     * @returns Shader macro
     */
    static getMacroByName(name: string): ShaderMacro;
    /**
     * @deprecated Please use `ShaderMacro.getByName` instead
     *
     * Get shader macro by name.
     * @param name - Name of the shader macro
     * @param value - Value of the shader macro
     * @returns Shader macro
     */
    static getMacroByName(name: string, value: string): ShaderMacro;
    /**
     * @deprecated Please use `ShaderProperty.getByName` instead
     *
     * Get shader property by name.
     * @param name - Name of the shader property
     * @returns Shader property
     */
    static getPropertyByName(name: string): ShaderProperty;
}
