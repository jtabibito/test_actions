import { ContentRestorer, Engine, EngineObject } from "..";
import { AssetPromise } from "./AssetPromise";
import { Loader } from "./Loader";
import { LoadItem } from "./LoadItem";
/**
 * ResourceManager
 */
export declare class ResourceManager {
    readonly engine: Engine;
    private static _extTypeMapping;
    private static _getTypeByUrl;
    /** The number of retries after failing to load assets. */
    retryCount: number;
    /** Retry delay time after failed to load assets, in milliseconds. */
    retryInterval: number;
    /** The default timeout period for loading assets, in milliseconds. */
    timeout: number;
    /** Base url for loading assets. */
    baseUrl: string | null;
    private _loadingPromises;
    /** Asset path pool, key is the `instanceID` of resource, value is asset path. */
    private _assetPool;
    /** Asset url pool, key is the asset path and the value is the asset. */
    private _assetUrlPool;
    /** Referable resource pool, key is the `instanceID` of resource. */
    private _referResourcePool;
    /** Graphic resource pool, key is the `instanceID` of resource. */
    private _graphicResourcePool;
    /** Restorable resource information pool, key is the `instanceID` of resource. */
    private _contentRestorerPool;
    private _subAssetPromiseCallbacks;
    /**
     * Create a ResourceManager.
     * @param engine - Engine to which the current ResourceManager belongs
     */
    constructor(engine: Engine);
    /**
     * Load asset asynchronously through the path.
     * @param path - Path
     * @returns Asset promise
     */
    load<T>(path: string): AssetPromise<T>;
    /**
     * Load asset collection asynchronously through urls.
     * @param paths - Path collections
     * @returns Asset Promise
     */
    load(paths: string[]): AssetPromise<Object[]>;
    /**
     * Load the asset asynchronously by asset item information.
     * @param assetItem - AssetItem
     * @returns AssetPromise
     */
    load<T>(assetItem: LoadItem): AssetPromise<T>;
    /**
     * Load the asset collection asynchronously by loading the information collection.
     * @param assetItems - Asset collection
     * @returns AssetPromise
     */
    load(assetItems: LoadItem[]): AssetPromise<Object[]>;
    /**
     * Get the resource from cache by asset url, return the resource object if it loaded, otherwise return null.
     * @param url - Resource url
     * @returns Resource object
     */
    getFromCache<T>(url: string): T;
    /**
     * Find the resource by type.
     * @param type - Resource type
     * @returns - Resource collection
     */
    findResourcesByType<T extends EngineObject>(type: new (...args: any[]) => T): T[];
    /**
     * Get asset url from instanceId.
     * @param instanceId - Engine instance id
     * @returns Asset url
     */
    getAssetPath(instanceId: number): string;
    /**
     * Cancel all assets that have not finished loading.
     */
    cancelNotLoaded(): void;
    /**
     * Cancel assets whose url has not finished loading.
     * @param url - Resource url
     */
    cancelNotLoaded(url: string): void;
    /**
     * Cancel the incompletely loaded assets in urls.
     * @param urls - Resource urls
     */
    cancelNotLoaded(urls: string[]): void;
    /**
     * Garbage collection will release resource objects managed by reference counting.
     * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
     */
    gc(): void;
    /**
     * Add content restorer.
     * @param restorer - The restorer
     */
    addContentRestorer<T extends EngineObject>(restorer: ContentRestorer<T>): void;
    private _assignDefaultOptions;
    private _loadSingleItem;
    private _loadMainAsset;
    private _createSubAssetPromiseCallback;
    private _gc;
    private _getResolveResource;
    private _parseURL;
    private _parseQueryPath;
    private _releaseSubAssetPromiseCallback;
}
/**
 * Declare ResourceLoader's decorator.
 * @param assetType - Type of asset
 * @param extNames - Name of file extension
 */
export declare function resourceLoader(assetType: string, extNames: string[], useCache?: boolean): <T extends Loader<any>>(Target: {
    new (useCache: boolean): T;
}) => void;
