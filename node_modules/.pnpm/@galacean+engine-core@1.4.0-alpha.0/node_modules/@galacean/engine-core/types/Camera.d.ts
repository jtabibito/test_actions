import { Matrix, Ray, Rect, Vector2, Vector3, Vector4 } from "@galacean/engine-math";
import { Component } from "./Component";
import { Layer } from "./Layer";
import { CameraClearFlags } from "./enums/CameraClearFlags";
import { DepthTextureMode } from "./enums/DepthTextureMode";
import { Downsampling } from "./enums/Downsampling";
import { MSAASamples } from "./enums/MSAASamples";
import { ReplacementFailureStrategy } from "./enums/ReplacementFailureStrategy";
import { Shader } from "./shader/Shader";
import { ShaderData } from "./shader/ShaderData";
import { ShaderTagKey } from "./shader/ShaderTagKey";
import { RenderTarget } from "./texture/RenderTarget";
import { TextureCubeFace } from "./texture/enums/TextureCubeFace";
/**
 * Camera component, as the entrance to the three-dimensional world.
 * @decorator `@dependentComponents(Transform, DependentMode.CheckOnly)`
 */
export declare class Camera extends Component {
    private static _inverseViewMatrixProperty;
    private static _cameraPositionProperty;
    private static _cameraForwardProperty;
    private static _cameraUpProperty;
    private static _cameraDepthBufferParamsProperty;
    /** Whether to enable frustum culling, it is enabled by default. */
    enableFrustumCulling: boolean;
    /**
     * Determining what to clear when rendering by a Camera.
     *
     * @defaultValue `CameraClearFlags.All`
     */
    clearFlags: CameraClearFlags;
    /**
     * Culling mask - which layers the camera renders.
     * @remarks Support bit manipulation, corresponding to `Layer`.
     */
    cullingMask: Layer;
    /**
     * Depth texture mode.
     * If `DepthTextureMode.PrePass` is used, the depth texture can be accessed in the shader using `camera_DepthTexture`.
     *
     * @defaultValue `DepthTextureMode.None`
     */
    depthTextureMode: DepthTextureMode;
    /**
     * Opacity texture down sampling.
     *
     * @defaultValue `Downsampling.TwoX`
     */
    opaqueTextureDownsampling: Downsampling;
    /**
     * Multi-sample anti-aliasing samples when use independent canvas mode.
     *
     * @remarks The `independentCanvasEnabled` property should be `true` to take effect, otherwise it will be invalid.
     */
    msaaSamples: MSAASamples;
    private _priority;
    private _shaderData;
    private _isCustomViewMatrix;
    private _isCustomProjectionMatrix;
    private _fieldOfView;
    private _orthographicSize;
    private _isProjectionDirty;
    private _isInvProjMatDirty;
    private _customAspectRatio;
    private _renderTarget;
    private _depthBufferParams;
    private _opaqueTextureEnabled;
    private _enableHDR;
    private _enablePostProcess;
    private _frustumChangeFlag;
    private _transform;
    private _isViewMatrixDirty;
    private _isInvViewProjDirty;
    private _viewport;
    private _pixelViewport;
    private _inverseProjectionMatrix;
    private _invViewProjMat;
    /**
     * Whether to enable opaque texture.
     * If enabled, the opaque texture can be accessed in the shader using `camera_OpaqueTexture`.
     *
     * @defaultValue `false`
     * @remarks If enabled, the `independentCanvasEnabled` property will be forced to be true.
     */
    get opaqueTextureEnabled(): boolean;
    set opaqueTextureEnabled(value: boolean);
    /**
     * Whether independent canvas is enabled.
     *
     * @remarks If true, the msaa in viewport can turn or off independently by `msaaSamples` property.
     */
    get independentCanvasEnabled(): boolean;
    /**
     * Shader data.
     */
    get shaderData(): ShaderData;
    /**
     * Near clip plane - the closest point to the camera when rendering occurs.
     */
    get nearClipPlane(): number;
    set nearClipPlane(value: number);
    /**
     * Far clip plane - the furthest point to the camera when rendering occurs.
     */
    get farClipPlane(): number;
    set farClipPlane(value: number);
    /**
     * The camera's view angle. activating when camera use perspective projection.
     */
    get fieldOfView(): number;
    set fieldOfView(value: number);
    /**
     * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
     * the manual value will be kept. Call resetAspectRatio() to restore it.
     */
    get aspectRatio(): number;
    set aspectRatio(value: number);
    /**
     * The viewport of the camera in normalized coordinates on the screen.
     * In normalized screen coordinates, the upper-left corner is (0, 0), and the lower-right corner is (1.0, 1.0).
     * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
     */
    get viewport(): Vector4;
    set viewport(value: Vector4);
    /**
     * The viewport of the camera in pixel coordinates on the screen.
     * In pixel screen coordinates, the upper-left corner is (0, 0), and the lower-right corner is (1.0, 1.0).
     */
    get pixelViewport(): Rect;
    /**
     * Rendering priority, higher priority will be rendered on top of a camera with lower priority.
     */
    get priority(): number;
    set priority(value: number);
    /**
     * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
     */
    get isOrthographic(): boolean;
    set isOrthographic(value: boolean);
    /**
     * Half the size of the camera in orthographic mode.
     */
    get orthographicSize(): number;
    set orthographicSize(value: number);
    /**
     * View matrix.
     */
    get viewMatrix(): Readonly<Matrix>;
    set viewMatrix(value: Matrix);
    /**
     * The projection matrix is ​​calculated by the relevant parameters of the camera by default.
     * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
     */
    get projectionMatrix(): Readonly<Matrix>;
    set projectionMatrix(value: Matrix);
    /**
     * Whether to enable HDR.
     * @defaultValue `false`
     * @remarks If enabled, the `independentCanvasEnabled` property will be forced to be true.
     */
    get enableHDR(): boolean;
    set enableHDR(value: boolean);
    /**
     * Whether to enable post process.
     * @defaultValue `false`
     * @remarks If enabled, the `independentCanvasEnabled` property will be forced to be true.
     */
    get enablePostProcess(): boolean;
    set enablePostProcess(value: boolean);
    /**
     * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
     */
    get renderTarget(): RenderTarget | null;
    set renderTarget(value: RenderTarget | null);
    /**
     * Restore the view matrix to the world matrix of the entity.
     */
    resetViewMatrix(): void;
    /**
     * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
     */
    resetProjectionMatrix(): void;
    /**
     * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
     */
    resetAspectRatio(): void;
    /**
     * Transform a point from world space to viewport space.
     * @param point - Point in world space
     * @param out - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
     * @returns Point in viewport space
     */
    worldToViewportPoint(point: Vector3, out: Vector3): Vector3;
    /**
     * Transform a point from viewport space to world space.
     * @param point - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
     * @param out - Point in world space
     * @returns Point in world space
     */
    viewportToWorldPoint(point: Vector3, out: Vector3): Vector3;
    /**
     * Generate a ray by a point in viewport.
     * @param point - Point in viewport space, X and Y are the camera viewport space coordinates
     * @param out - Ray
     * @returns Ray
     */
    viewportPointToRay(point: Vector2, out: Ray): Ray;
    /**
     * Transform the X and Y coordinates of a point from screen space to viewport space
     * @param point - Point in screen space
     * @param out - Point in viewport space
     * @returns Point in viewport space
     */
    screenToViewportPoint<T extends Vector2 | Vector3>(point: Vector3 | Vector2, out: T): T;
    /**
     * Transform the X and Y coordinates of a point from viewport space to screen space.
     * @param point - Point in viewport space
     * @param out - Point in screen space
     * @returns Point in screen space
     */
    viewportToScreenPoint<T extends Vector2 | Vector3 | Vector4>(point: T, out: T): T;
    /**
     * Transform a point from world space to screen space.
     *
     * @remarks
     * Screen space is defined in pixels, the left-top of the screen is (0,0), the right-top is (canvasPixelWidth,canvasPixelHeight).
     *
     * @param point - Point in world space
     * @param out - The result will be stored
     * @returns X and Y are the coordinates of the point in screen space, Z is the distance from the camera in world space
     */
    worldToScreenPoint(point: Vector3, out: Vector3): Vector3;
    /**
     * Transform a point from screen space to world space.
     *
     * @param point - Screen space point, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight), The z position is in world units from the camera
     * @param out - Point in world space
     * @returns Point in world space
     */
    screenToWorldPoint(point: Vector3, out: Vector3): Vector3;
    /**
     * Generate a ray by a point in screen.
     * @param point - Point in screen space, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight)
     * @param out - Ray
     * @returns Ray
     */
    screenPointToRay(point: Vector2, out: Ray): Ray;
    /**
     * Manually call the rendering of the camera.
     * @param cubeFace - Cube rendering surface collection
     * @param mipLevel - Set mip level the data want to write, only take effect in webgl2.0
     */
    render(cubeFace?: TextureCubeFace, mipLevel?: number): void;
    /**
     * Set the replacement shader.
     * @param shader - Replacement shader
     * @param replacementTagName - Sub shader tag name
     * @param failureStrategy - Replacement failure strategy, @defaultValue `ReplacementFailureStrategy.KeepOriginalShader`
     *
     * @remarks
     * If replacementTagName is not specified, the first sub shader will be replaced.
     * If replacementTagName is specified, the replacement shader will find the first sub shader which has the same tag value get by replacementTagKey. If failed to find the sub shader, the strategy will be determined by failureStrategy.
     */
    setReplacementShader(shader: Shader, replacementTagName?: string, failureStrategy?: ReplacementFailureStrategy): any;
    /**
     * Set the replacement shader.
     * @param shader - Replacement shader
     * @param replacementTag - Sub shader tag
     * @param failureStrategy - Replacement failure strategy, @defaultValue `ReplacementFailureStrategy.KeepOriginalShader`
     *
     * @remarks
     * If replacementTag is not specified, the first sub shader will be replaced.
     * If replacementTag is specified, the replacement shader will find the first sub shader which has the same tag value get by replacementTagKey. If failed to find the sub shader, the strategy will be determined by failureStrategy.
     */
    setReplacementShader(shader: Shader, replacementTag?: ShaderTagKey, failureStrategy?: ReplacementFailureStrategy): any;
    /**
     * Reset and clear the replacement shader.
     */
    resetReplacementShader(): void;
    /**
     * @inheritdoc
     */
    _onEnableInScene(): void;
    /**
     * @inheritdoc
     */
    _onDisableInScene(): void;
    private _updatePixelViewport;
    private _viewMatrixChange;
    private _projectionMatrixChange;
    private _innerViewportToWorldPoint;
    private _updateShaderData;
    /**
     * The inverse matrix of view projection matrix.
     */
    private _getInvViewProjMat;
    /**
     * The inverse of the projection matrix.
     */
    private _getInverseProjectionMatrix;
    private _onPixelViewportChanged;
    private _checkMainCanvasAntialiasWaste;
}
