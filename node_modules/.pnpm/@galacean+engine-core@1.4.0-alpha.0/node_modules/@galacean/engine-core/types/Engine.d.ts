import { IHardwareRenderer, IInputOptions, IPhysics, IShaderLab, IXRDevice } from "@galacean/engine-design";
import { Canvas } from "./Canvas";
import { EngineSettings } from "./EngineSettings";
import { Entity } from "./Entity";
import { SceneManager } from "./SceneManager";
import { ResourceManager } from "./asset/ResourceManager";
import { EventDispatcher, Time } from "./base";
import { ColorSpace } from "./enums/ColorSpace";
import { InputManager } from "./input";
import { ParticleBufferUtils } from "./particle/ParticleBufferUtils";
import { PhysicsScene } from "./physics/PhysicsScene";
import { XRManager } from "./xr/XRManager";
/**
 * Engine.
 */
export declare class Engine extends EventDispatcher {
    /** Input manager of Engine. */
    readonly inputManager: InputManager;
    /** XR manager of Engine. */
    readonly xrManager: XRManager;
    _particleBufferUtils: ParticleBufferUtils;
    private _settings;
    private _resourceManager;
    private _sceneManager;
    private _vSyncCount;
    private _targetFrameRate;
    private _time;
    private _isPaused;
    private _requestId;
    private _timeoutId;
    private _vSyncCounter;
    private _targetFrameInterval;
    private _destroyed;
    private _frameInProcess;
    private _waitingDestroy;
    private _isDeviceLost;
    private _waitingGC;
    private _animate;
    /**
     * Settings of Engine.
     */
    get settings(): EngineSettings;
    /**
     * The canvas to use for rendering.
     */
    get canvas(): Canvas;
    /**
     * The resource manager.
     */
    get resourceManager(): ResourceManager;
    /**
     * The scene manager.
     */
    get sceneManager(): SceneManager;
    /**
     * The time information of the engine.
     */
    get time(): Time;
    /**
     * Whether the engine is paused.
     */
    get isPaused(): boolean;
    /**
     * The number of vertical synchronization means the number of vertical blanking for one frame.
     * @remarks 0 means that the vertical synchronization is turned off.
     */
    get vSyncCount(): number;
    set vSyncCount(value: number);
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
    get targetFrameRate(): number;
    set targetFrameRate(value: number);
    /**
     * Indicates whether the engine is destroyed.
     */
    get destroyed(): boolean;
    protected constructor(canvas: Canvas, hardwareRenderer: IHardwareRenderer, configuration: EngineConfiguration);
    /**
     * Create an entity.
     * @param name - The name of the entity
     * @returns Entity
     */
    createEntity(name?: string): Entity;
    /**
     * Pause the engine.
     */
    pause(): void;
    /**
     * Resume the engine.
     */
    resume(): void;
    /**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */
    update(): void;
    /**
     * Execution engine loop.
     */
    run(): void;
    /**
     * Force lose graphic device.
     * @remarks Used to simulate the phenomenon after the real loss of device.
     */
    forceLoseDevice(): void;
    /**
     * Force restore graphic device.
     * @remarks Used to simulate the phenomenon after the real restore of device.
     */
    forceRestoreDevice(): void;
    private _destroy;
    /**
     * Destroy engine.
     * @remarks If call during frame execution will delay until the end of the frame
     */
    destroy(): void;
    private _onDeviceLost;
    private _onDeviceRestored;
    private _gc;
    /**
     * @deprecated
     * The first scene physics manager.
     */
    get physicsManager(): PhysicsScene;
}
/**
 * Engine configuration.
 */
export interface EngineConfiguration {
    /** Physics. */
    physics?: IPhysics;
    /** XR Device. */
    xrDevice?: IXRDevice;
    /** Color space. */
    colorSpace?: ColorSpace;
    /** Shader lab. */
    shaderLab?: IShaderLab;
    /** Input options. */
    input?: IInputOptions;
}
