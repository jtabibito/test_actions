import { Utils, ModelMesh, BlendShape, Texture2D, Loader, Entity, AnimationClip, AnimationEvent, AnimationStringCurve, Keyframe, AnimationBoolCurve, AnimationRefCurve, AnimationQuaternionCurve, AnimationColorCurve, AnimationVector4Curve, AnimationVector3Curve, AnimationVector2Curve, AnimationFloatArrayCurve, AnimationArrayCurve, AnimationFloatCurve, ReferResource, Scene, resourceLoader, AssetPromise, AssetType, AnimatorController, AnimatorControllerLayer, AnimatorStateTransition, TextureCube, TextureFilterMode, TextureCubeFace, AmbientLight, DiffuseMode, Font, Animator, IndexFormat, VertexElementFormat, GLCapabilityType, Logger, TextureFormat, request, ContentRestorer, InterpolationType, SkinnedMeshRenderer, Transform, PBRMaterial, BlinnPhongMaterial, PBRSpecularMaterial, TextureCoordinate, RenderFace, VertexElement, Buffer, BufferBindFlag, BufferUsage, Camera, MeshRenderer, Skin, TextureWrapMode as TextureWrapMode$1, AnimatorStateMachine, SystemInfo, Shader, Material, PrimitiveMesh, SpriteAtlas, Sprite, ShaderFactory, ShaderLib, BackgroundMode, DirectLight, PointLight, SpotLight, UnlitMaterial } from '@galacean/engine-core';
import { Color, Vector4, Vector3, Vector2, Quaternion, SphericalHarmonics3, MathUtil, BoundingBox, Matrix, Rect } from '@galacean/engine-math';
import { GLCompressedTextureInternalFormat } from '@galacean/engine-rhi-webgl';

function _extends() {
    _extends = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _type_of(obj) {
    "@swc/helpers - typeof";

    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

var BufferReader = /*#__PURE__*/ function() {
    function BufferReader(data, byteOffset, byteLength, littleEndian) {
        if (byteOffset === void 0) byteOffset = 0;
        if (littleEndian === void 0) littleEndian = true;
        this.data = data;
        this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength != null ? byteLength : data.byteLength - byteOffset);
        this._littleEndian = littleEndian;
        this._position = 0;
        this._baseOffset = byteOffset;
    }
    var _proto = BufferReader.prototype;
    _proto.nextUint8 = function nextUint8() {
        var value = this._dataView.getUint8(this._position);
        this._position += 1;
        return value;
    };
    _proto.nextUint16 = function nextUint16() {
        var value = this._dataView.getUint16(this._position, this._littleEndian);
        this._position += 2;
        return value;
    };
    _proto.nextUint32 = function nextUint32() {
        var value = this._dataView.getUint32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextInt32 = function nextInt32() {
        var value = this._dataView.getInt32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
        var value = new Int32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
        var value = this._dataView.getFloat32(this._position, this._littleEndian);
        this._position += 4;
        return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
        var value = new Float32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
        var value = new Uint32Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += 4 * len;
        return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
        var value = new Uint8Array(this.data.buffer, this._position + this._dataView.byteOffset, len);
        this._position += len;
        return value;
    };
    _proto.nextUint64 = function nextUint64() {
        var left = this._dataView.getUint32(this._position, this._littleEndian);
        var right = this._dataView.getUint32(this._position + 4, this._littleEndian);
        var value = left + Math.pow(2, 32) * right;
        this._position += 8;
        return value;
    };
    _proto.nextStr = function nextStr() {
        var strByteLength = this.nextUint16();
        var uint8Array = new Uint8Array(this.data.buffer, this._position + this._dataView.byteOffset, strByteLength);
        this._position += strByteLength;
        return Utils.decodeText(uint8Array);
    };
    /**
   * image data 放在最后
   */ _proto.nextImageData = function nextImageData(count) {
        return new Uint8Array(this.data.buffer, this.data.byteOffset + this._position);
    };
    _proto.nextImagesData = function nextImagesData(count) {
        var imagesLen = new Array(count);
        // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
        for(var i = 0; i < count; i++){
            var len = this._dataView.getUint32(this._position, this._littleEndian);
            imagesLen[i] = len;
            this._position += 4;
        }
        var imagesData = [];
        for(var i1 = 0; i1 < count; i1++){
            var len1 = imagesLen[i1];
            var buffer = new Uint8Array(this.data.buffer, this._dataView.byteOffset + this._position, len1);
            this._position += len1;
            imagesData.push(buffer);
        }
        return imagesData;
    };
    _proto.skip = function skip(bytes) {
        this._position += bytes;
        return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
        if (term === void 0) term = 0x00;
        var byteOffset = this._position;
        var byteLength = 0;
        while(this._dataView.getUint8(this._position) !== term && byteLength < maxByteLength){
            byteLength++;
            this._position++;
        }
        if (byteLength < maxByteLength) this._position++;
        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _create_class(BufferReader, [
        {
            key: "position",
            get: function get() {
                return this._position;
            }
        },
        {
            key: "offset",
            get: function get() {
                return this._position + this._baseOffset;
            }
        }
    ]);
    return BufferReader;
}();

var decoderMap = {};
/**
 * Decoder decorator generator.
 * @param type - resource file type.
 * @returns Decoder decorator
 */ function decoder(type) {
    return function(target) {
        decoderMap[type] = target;
    };
}

var FileHeader = /*#__PURE__*/ function() {
    function FileHeader() {
        this.totalLength = 0;
        this.version = 0;
        this.type = "";
        this.name = "";
        this.headerLength = 0;
    }
    FileHeader.decode = function decode(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var totalLen = dataView.getUint32(0, true);
        var fileVersion = dataView.getUint8(4);
        var typeLen = dataView.getUint16(5, true);
        var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
        var nameLen = dataView.getUint16(7 + typeLen, true);
        var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
        var name = Utils.decodeText(nameUint8Array);
        var type = Utils.decodeText(typeUint8Array);
        var header = new FileHeader();
        header.totalLength = totalLen;
        header.name = name;
        header.type = type;
        header.version = fileVersion;
        header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
        return header;
    };
    _create_class(FileHeader, [
        {
            key: "dataLength",
            get: function get() {
                return this.totalLength - this.headerLength;
            }
        }
    ]);
    return FileHeader;
}();

var MeshDecoder = /*#__PURE__*/ function() {
    function MeshDecoder() {}
    MeshDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var modelMesh = new ModelMesh(engine);
            var jsonDataString = bufferReader.nextStr();
            var encodedMeshData = JSON.parse(jsonDataString);
            // @ts-ignore Vector3 is not compatible with {x: number, y: number, z: number}.
            encodedMeshData.bounds && modelMesh.bounds.copyFrom(encodedMeshData.bounds);
            var offset = Math.ceil(bufferReader.offset / 4) * 4 + bufferReader.data.byteOffset;
            var buffer = bufferReader.data.buffer;
            var float32Array = new Float32Array(buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
            var vertexCount = float32Array.length / 3;
            var positions = float32ArrayToVector3(float32Array, vertexCount);
            modelMesh.setPositions(positions);
            if (encodedMeshData.normals) {
                var float32Array1 = new Float32Array(buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
                var normals = float32ArrayToVector3(float32Array1, vertexCount);
                modelMesh.setNormals(normals);
            }
            if (encodedMeshData.uvs) {
                var float32Array2 = new Float32Array(buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array2, vertexCount));
            }
            if (encodedMeshData.uv1) {
                var float32Array3 = new Float32Array(buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array3, vertexCount), 1);
            }
            if (encodedMeshData.uv2) {
                var float32Array4 = new Float32Array(buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array4, vertexCount), 2);
            }
            if (encodedMeshData.uv3) {
                var float32Array5 = new Float32Array(buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array5, vertexCount), 3);
            }
            if (encodedMeshData.uv4) {
                var float32Array6 = new Float32Array(buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array6, vertexCount), 4);
            }
            if (encodedMeshData.uv5) {
                var float32Array7 = new Float32Array(buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array7, vertexCount), 5);
            }
            if (encodedMeshData.uv6) {
                var float32Array8 = new Float32Array(buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array8, vertexCount), 6);
            }
            if (encodedMeshData.uv7) {
                var float32Array9 = new Float32Array(buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array9, vertexCount), 7);
            }
            if (encodedMeshData.colors) {
                var float32Array10 = new Float32Array(buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
                modelMesh.setColors(float32ArrayToVColor(float32Array10, vertexCount));
            }
            if (encodedMeshData.boneWeights) {
                var float32Array11 = new Float32Array(buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
                modelMesh.setBoneWeights(float32ArrayToVector4(float32Array11, vertexCount));
            }
            if (encodedMeshData.boneIndices) {
                var float32Array12 = new Float32Array(buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
                modelMesh.setBoneIndices(float32ArrayToVector4(float32Array12, vertexCount));
            }
            if (encodedMeshData.blendShapes) {
                encodedMeshData.blendShapes.forEach(function(blendShapeData) {
                    var blendShape = new BlendShape(blendShapeData.name);
                    blendShapeData.frames.forEach(function(frameData) {
                        var positionArray = new Float32Array(buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
                        var count = positionArray.length / 3;
                        var deltaPosition = float32ArrayToVector3(positionArray, count);
                        if (frameData.deltaNormals) {
                            var normalsArray = new Float32Array(buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                            float32ArrayToVector3(normalsArray, count);
                        }
                        if (frameData.deltaTangents) {
                            var tangentsArray = new Float32Array(buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                            float32ArrayToVector4(tangentsArray, count);
                        }
                        blendShape.addFrame(frameData.weight, deltaPosition);
                    });
                    modelMesh.addBlendShape(blendShape);
                });
            }
            if (encodedMeshData.indices) {
                var indices = null;
                if (encodedMeshData.indices.type === 0) {
                    indices = new Uint16Array(buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
                } else {
                    indices = new Uint32Array(buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
                }
                modelMesh.setIndices(indices);
            }
            encodedMeshData.subMeshes.forEach(function(subMesh) {
                return modelMesh.addSubMesh(subMesh);
            });
            modelMesh.uploadData(false);
            resolve(modelMesh);
        });
    };
    return MeshDecoder;
}();
MeshDecoder = __decorate([
    decoder("Mesh")
], MeshDecoder);
function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
}

var Texture2DDecoder = /*#__PURE__*/ function() {
    function Texture2DDecoder() {}
    Texture2DDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve, reject) {
            var objectId = bufferReader.nextStr();
            var mipmap = !!bufferReader.nextUint8();
            var filterMode = bufferReader.nextUint8();
            var anisoLevel = bufferReader.nextUint8();
            var wrapModeU = bufferReader.nextUint8();
            var wrapModeV = bufferReader.nextUint8();
            var format = bufferReader.nextUint8();
            var width = bufferReader.nextUint16();
            var height = bufferReader.nextUint16();
            var isPixelBuffer = bufferReader.nextUint8();
            var mipCount = bufferReader.nextUint8();
            var imagesData = bufferReader.nextImagesData(mipCount);
            var texture2D = new Texture2D(engine, width, height, format, mipmap);
            texture2D.filterMode = filterMode;
            texture2D.anisoLevel = anisoLevel;
            texture2D.wrapModeU = wrapModeU;
            texture2D.wrapModeV = wrapModeV;
            if (isPixelBuffer) {
                var pixelBuffer = imagesData[0];
                texture2D.setPixelBuffer(pixelBuffer);
                if (mipmap) {
                    texture2D.generateMipmaps();
                    for(var i = 1; i < mipCount; i++){
                        var pixelBuffer1 = imagesData[i];
                        texture2D.setPixelBuffer(pixelBuffer1, i);
                    }
                }
                // @ts-ignore
                engine.resourceManager._objectPool[objectId] = texture2D;
                resolve(texture2D);
            } else {
                var blob = new window.Blob([
                    imagesData[0]
                ]);
                var img = new Image();
                img.onload = function() {
                    texture2D.setImageSource(img);
                    var completedCount = 0;
                    var onComplete = function() {
                        completedCount++;
                        if (completedCount >= mipCount) {
                            resolve(texture2D);
                        }
                    };
                    onComplete();
                    if (mipmap) {
                        var _loop = function(i) {
                            var blob = new window.Blob([
                                imagesData[i]
                            ]);
                            var img = new Image();
                            img.onload = function() {
                                texture2D.setImageSource(img, i);
                                onComplete();
                            };
                            img.src = URL.createObjectURL(blob);
                        };
                        texture2D.generateMipmaps();
                        for(var i = 1; i < mipCount; i++)_loop(i);
                    }
                };
                img.src = URL.createObjectURL(blob);
            }
        });
    };
    return Texture2DDecoder;
}();
Texture2DDecoder = __decorate([
    decoder("Texture2D")
], Texture2DDecoder);

function _is_native_reflect_construct() {
    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of(instance, Class.prototype);

            return instance;
        };
    }

    return _construct.apply(null, arguments);
}

var ParserType = /*#__PURE__*/ function(ParserType) {
    ParserType[ParserType["Prefab"] = 0] = "Prefab";
    ParserType[ParserType["Scene"] = 1] = "Scene";
    return ParserType;
}({});
/**
 * Parser context
 * @export
 * @class ParserContext
 * @template T
 * @template I
 */ var ParserContext = /*#__PURE__*/ function() {
    function ParserContext(engine, type, resource) {
        if (type === void 0) type = 1;
        this.engine = engine;
        this.type = type;
        this.resource = resource;
        this.entityMap = new Map();
        this.entityConfigMap = new Map();
        this.components = new Map();
        this.rootIds = [];
        this.strippedIds = [];
        this.resourceManager = engine.resourceManager;
    }
    var _proto = ParserContext.prototype;
    /**
   * Destroy the context.
   * @memberof ParserContext
   */ _proto.clear = function clear() {
        this.entityMap.clear();
        this.components.clear();
        this.entityConfigMap.clear();
        this.rootIds.length = 0;
        this.strippedIds.length = 0;
    };
    return ParserContext;
}();

var ReflectionParser = /*#__PURE__*/ function() {
    function ReflectionParser(_context) {
        this._context = _context;
    }
    var _proto = ReflectionParser.prototype;
    _proto.parseEntity = function parseEntity(entityConfig) {
        var _this = this;
        return this._getEntityByConfig(entityConfig).then(function(entity) {
            var _entityConfig_isActive;
            entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : true;
            var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
            if (position) entity.transform.position.copyFrom(position);
            if (rotation) entity.transform.rotation.copyFrom(rotation);
            if (scale) entity.transform.scale.copyFrom(scale);
            var _entityConfig_layer;
            entity.layer = (_entityConfig_layer = entityConfig.layer) != null ? _entityConfig_layer : entity.layer;
            // @ts-ignore
            _this._context.type === ParserType.Prefab && entity._markAsTemplate(_this._context.resource);
            return entity;
        });
    };
    _proto.parseClassObject = function parseClassObject(item) {
        var _this = this;
        var Class = Loader.getClass(item.class);
        var _item_constructParams;
        var params = (_item_constructParams = item.constructParams) != null ? _item_constructParams : [];
        return Promise.all(params.map(function(param) {
            return _this.parseBasicType(param);
        })).then(function(resultParams) {
            return _construct(Class, [].concat(resultParams));
        }).then(function(instance) {
            return _this.parsePropsAndMethods(instance, item);
        });
    };
    _proto.parsePropsAndMethods = function parsePropsAndMethods(instance, item) {
        var promises = [];
        if (item.methods) {
            for(var methodName in item.methods){
                var methodParams = item.methods[methodName];
                for(var i = 0, count = methodParams.length; i < count; i++){
                    promises.push(this.parseMethod(instance, methodName, methodParams[i]));
                }
            }
        }
        if (item.props) {
            var _this, _loop = function(key) {
                var value = item.props[key];
                var promise = _this.parseBasicType(value, instance[key]).then(function(v) {
                    return instance[key] = v;
                });
                promises.push(promise);
            };
            for(var key in item.props)_this = this, _loop(key);
        }
        return Promise.all(promises).then(function() {
            var handle = ReflectionParser.customParseComponentHandles[instance.constructor.name];
            if (handle) return handle(instance, item);
            else return instance;
        });
    };
    _proto.parseMethod = function parseMethod(instance, methodName, methodParams) {
        var _this = this;
        return Promise.all(methodParams.map(function(param) {
            return _this.parseBasicType(param);
        })).then(function(result) {
            var _instance;
            return (_instance = instance)[methodName].apply(_instance, [].concat(result));
        });
    };
    _proto.parseBasicType = function parseBasicType(value, originValue) {
        var _this = this;
        if (Array.isArray(value)) {
            return Promise.all(value.map(function(item) {
                return _this.parseBasicType(item);
            }));
        } else if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object" && value != null) {
            if (ReflectionParser._isClass(value)) {
                // class object
                return this.parseClassObject(value);
            } else if (ReflectionParser._isAssetRef(value)) {
                var _this1 = this, context = _this1._context;
                // reference object
                // @ts-ignore
                return context.resourceManager.getResourceByRef(value).then(function(resource) {
                    if (context.type === ParserType.Prefab) {
                        // @ts-ignore
                        context.resource._addDependenceAsset(resource);
                    }
                    return resource;
                });
            } else if (ReflectionParser._isEntityRef(value)) {
                // entity reference
                return Promise.resolve(this._context.entityMap.get(value.entityId));
            } else if (originValue) {
                var _this2, _loop = function(key) {
                    if (key === "methods") {
                        var methods = value[key];
                        for(var methodName in methods){
                            var methodParams = methods[methodName];
                            for(var i = 0, count = methodParams.length; i < count; i++){
                                var params = methodParams[i];
                                var promise = _this2.parseMethod(originValue, methodName, params);
                                promises.push(promise);
                            }
                        }
                    } else {
                        promises.push(_this2.parseBasicType(value[key], originValue[key]).then(function(v) {
                            return originValue[key] = v;
                        }));
                    }
                };
                var promises = [];
                for(var key in value)_this2 = this, _loop(key);
                return Promise.all(promises).then(function() {
                    return originValue;
                });
            }
        }
        // primitive type
        return Promise.resolve(value);
    };
    _proto._getEntityByConfig = function _getEntityByConfig(entityConfig) {
        var _this = this;
        // @ts-ignore
        var assetRefId = entityConfig.assetRefId;
        var engine = this._context.engine;
        if (assetRefId) {
            return engine.resourceManager// @ts-ignore
            .getResourceByRef({
                refId: assetRefId,
                key: entityConfig.key,
                isClone: entityConfig.isClone
            }).then(function(entity) {
                // @ts-ignore
                var resource = engine.resourceManager._objectPool[assetRefId];
                if (_this._context.type === ParserType.Prefab) {
                    // @ts-ignore
                    _this._context.resource._addDependenceAsset(resource);
                }
                entity.name = entityConfig.name;
                return entity;
            });
        } else {
            var entity = new Entity(engine, entityConfig.name);
            return Promise.resolve(entity);
        }
    };
    ReflectionParser.registerCustomParseComponent = function registerCustomParseComponent(componentType, handle) {
        this.customParseComponentHandles[componentType] = handle;
    };
    ReflectionParser._isClass = function _isClass(value) {
        return value["class"] != undefined;
    };
    ReflectionParser._isAssetRef = function _isAssetRef(value) {
        return value["refId"] != undefined;
    };
    ReflectionParser._isEntityRef = function _isEntityRef(value) {
        return value["entityId"] != undefined;
    };
    return ReflectionParser;
}();
ReflectionParser.customParseComponentHandles = new Map();

var InterpolableValueType = /*#__PURE__*/ function(InterpolableValueType) {
    InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
    InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
    InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
    InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
    InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
    InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
    InterpolableValueType[InterpolableValueType["Color"] = 6] = "Color";
    InterpolableValueType[InterpolableValueType["Array"] = 7] = "Array";
    InterpolableValueType[InterpolableValueType["Boolean"] = 8] = "Boolean";
    InterpolableValueType[InterpolableValueType["Rect"] = 9] = "Rect";
    InterpolableValueType[InterpolableValueType["ReferResource"] = 10] = "ReferResource";
    return InterpolableValueType;
}({});
var AnimationClipDecoder = /*#__PURE__*/ function() {
    function AnimationClipDecoder() {}
    AnimationClipDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var name = bufferReader.nextStr();
            var clip = new AnimationClip(name);
            var eventsLen = bufferReader.nextUint16();
            for(var i = 0; i < eventsLen; ++i){
                var event = new AnimationEvent();
                event.time = bufferReader.nextFloat32();
                event.functionName = bufferReader.nextStr();
                event.parameter = JSON.parse(bufferReader.nextStr()).val;
                clip.addEvent(event);
            }
            var curveBindingsLen = bufferReader.nextUint16();
            for(var i1 = 0; i1 < curveBindingsLen; ++i1){
                var relativePath = bufferReader.nextStr();
                var componentStr = bufferReader.nextStr();
                var componentType = Loader.getClass(componentStr);
                var property = bufferReader.nextStr();
                var getProperty = bufferReader.nextStr();
                var curve = void 0;
                var interpolation = bufferReader.nextUint8();
                var keysLen = bufferReader.nextUint16();
                var curveType = bufferReader.nextStr();
                switch(curveType){
                    case "AnimationFloatCurve":
                        {
                            curve = new AnimationFloatCurve();
                            curve.interpolation = interpolation;
                            for(var j = 0; j < keysLen; ++j){
                                var keyframe = new Keyframe();
                                keyframe.time = bufferReader.nextFloat32();
                                keyframe.value = bufferReader.nextFloat32();
                                keyframe.inTangent = bufferReader.nextFloat32();
                                keyframe.outTangent = bufferReader.nextFloat32();
                                curve.addKey(keyframe);
                            }
                            break;
                        }
                    case "AnimationArrayCurve":
                        {
                            curve = new AnimationArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j1 = 0; j1 < keysLen; ++j1){
                                var keyframe1 = new Keyframe();
                                keyframe1.time = bufferReader.nextFloat32();
                                var len = bufferReader.nextUint16();
                                keyframe1.value = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.inTangent = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.outTangent = Array.from(bufferReader.nextFloat32Array(len));
                                curve.addKey(keyframe1);
                            }
                            break;
                        }
                    case "AnimationFloatArrayCurve":
                        {
                            curve = new AnimationFloatArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j2 = 0; j2 < keysLen; ++j2){
                                var keyframe2 = new Keyframe();
                                keyframe2.time = bufferReader.nextFloat32();
                                var len1 = bufferReader.nextUint16();
                                keyframe2.value = bufferReader.nextFloat32Array(len1);
                                keyframe2.inTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                keyframe2.outTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                curve.addKey(keyframe2);
                            }
                            break;
                        }
                    case "AnimationVector2Curve":
                        {
                            curve = new AnimationVector2Curve();
                            curve.interpolation = interpolation;
                            for(var j3 = 0; j3 < keysLen; ++j3){
                                var keyframe3 = new Keyframe();
                                keyframe3.time = bufferReader.nextFloat32();
                                keyframe3.value = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.inTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.outTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe3);
                            }
                            break;
                        }
                    case "AnimationVector3Curve":
                        {
                            curve = new AnimationVector3Curve();
                            curve.interpolation = interpolation;
                            for(var j4 = 0; j4 < keysLen; ++j4){
                                var keyframe4 = new Keyframe();
                                keyframe4.time = bufferReader.nextFloat32();
                                keyframe4.value = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.inTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.outTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe4);
                            }
                            break;
                        }
                    case "AnimationVector4Curve":
                        {
                            curve = new AnimationVector4Curve();
                            curve.interpolation = interpolation;
                            var keyframe5 = new Keyframe();
                            keyframe5.time = bufferReader.nextFloat32();
                            keyframe5.value = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            curve.addKey(keyframe5);
                            break;
                        }
                    case "AnimationColorCurve":
                        {
                            curve = new AnimationColorCurve();
                            curve.interpolation = interpolation;
                            for(var j5 = 0; j5 < keysLen; ++j5){
                                var keyframe6 = new Keyframe();
                                keyframe6.time = bufferReader.nextFloat32();
                                keyframe6.value = new Color(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe6);
                            }
                            break;
                        }
                    case "AnimationQuaternionCurve":
                        {
                            curve = new AnimationQuaternionCurve();
                            curve.interpolation = interpolation;
                            for(var j6 = 0; j6 < keysLen; ++j6){
                                var keyframe7 = new Keyframe();
                                keyframe7.time = bufferReader.nextFloat32();
                                keyframe7.value = new Quaternion(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe7);
                            }
                            break;
                        }
                    case "AnimationRefCurve":
                        {
                            curve = new AnimationRefCurve();
                            curve.interpolation = interpolation;
                            for(var j7 = 0; j7 < keysLen; ++j7){
                                var keyframe8 = new Keyframe();
                                keyframe8.time = bufferReader.nextFloat32();
                                var str = bufferReader.nextStr();
                                if (str) {
                                    keyframe8.value = JSON.parse(str);
                                } else {
                                    keyframe8.value = null;
                                }
                                curve.addKey(keyframe8);
                            }
                            break;
                        }
                    case "AnimationBoolCurve":
                        {
                            curve = new AnimationBoolCurve();
                            curve.interpolation = interpolation;
                            for(var j8 = 0; j8 < keysLen; ++j8){
                                var keyframe9 = new Keyframe();
                                keyframe9.time = bufferReader.nextFloat32();
                                keyframe9.value = bufferReader.nextUint8() === 1;
                                curve.addKey(keyframe9);
                            }
                            break;
                        }
                    case "AnimationStringCurve":
                        {
                            curve = new AnimationStringCurve();
                            curve.interpolation = interpolation;
                            for(var j9 = 0; j9 < keysLen; ++j9){
                                var keyframe10 = new Keyframe();
                                keyframe10.time = bufferReader.nextFloat32();
                                keyframe10.value = bufferReader.nextStr();
                                curve.addKey(keyframe10);
                            }
                            break;
                        }
                }
                clip.addCurveBinding(relativePath, componentType, property, getProperty, curve);
            }
            resolve(clip);
        });
    };
    return AnimationClipDecoder;
}();
AnimationClipDecoder = __decorate([
    decoder("AnimationClip")
], AnimationClipDecoder);

var MaterialLoaderType = /*#__PURE__*/ function(MaterialLoaderType) {
    MaterialLoaderType["Vector2"] = "Vector2";
    MaterialLoaderType["Vector3"] = "Vector3";
    MaterialLoaderType["Vector4"] = "Vector4";
    MaterialLoaderType["Color"] = "Color";
    MaterialLoaderType["Float"] = "Float";
    MaterialLoaderType["Texture"] = "Texture";
    MaterialLoaderType["Boolean"] = "Boolean";
    MaterialLoaderType["Integer"] = "Integer";
    return MaterialLoaderType;
}({});

var SpecularMode = /*#__PURE__*/ function(SpecularMode) {
    SpecularMode["Sky"] = "Sky";
    SpecularMode["Custom"] = "Custom";
    return SpecularMode;
}({});

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * The Prefab resource.
 */ var PrefabResource = /*#__PURE__*/ function(ReferResource) {
    _inherits(PrefabResource, ReferResource);
    function PrefabResource(engine, url) {
        var _this;
        _this = ReferResource.call(this, engine) || this, _this.url = url, _this._dependenceAssets = new Set();
        return _this;
    }
    var _proto = PrefabResource.prototype;
    /**
   * Instantiate prefab.
   * @returns prefab's root entity
   */ _proto.instantiate = function instantiate() {
        var _this__root;
        return (_this__root = this._root) == null ? void 0 : _this__root.clone();
    };
    /**
   * @internal
   */ _proto._addDependenceAsset = function _addDependenceAsset(resource) {
        this._dependenceAssets.add(resource);
        // @ts-ignore
        resource._associationSuperResource(this);
    };
    _proto._onDestroy = function _onDestroy() {
        var _this = this;
        ReferResource.prototype._onDestroy.call(this);
        this._root.destroy();
        this._dependenceAssets.forEach(function(asset) {
            // @ts-ignore
            asset._disassociationSuperResource(_this);
        });
    };
    return PrefabResource;
}(ReferResource);

/** @Internal */ var HierarchyParser = /*#__PURE__*/ function() {
    function HierarchyParser(data, context) {
        var _this = this;
        this.data = data;
        this.context = context;
        this._prefabContextMap = new WeakMap();
        this._prefabPromiseMap = new Map();
        this._engine = this.context.engine;
        this._organizeEntities = this._organizeEntities.bind(this);
        this._parseComponents = this._parseComponents.bind(this);
        this._parsePrefabModification = this._parsePrefabModification.bind(this);
        this._parsePrefabRemovedEntities = this._parsePrefabRemovedEntities.bind(this);
        this._parsePrefabRemovedComponents = this._parsePrefabRemovedComponents.bind(this);
        this._clearAndResolve = this._clearAndResolve.bind(this);
        this.promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            _this._resolve = resolve;
        });
        this._reflectionParser = new ReflectionParser(context);
    }
    var _proto = HierarchyParser.prototype;
    /** start parse the scene or prefab or others */ _proto.start = function start() {
        this._parseEntities().then(this._organizeEntities).then(this._parseComponents).then(this._parsePrefabModification).then(this._parsePrefabRemovedEntities).then(this._parsePrefabRemovedComponents).then(this._clearAndResolve).then(this._resolve).catch(this._reject);
    };
    _proto._parseEntities = function _parseEntities() {
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityConfigMap = this.context.entityConfigMap;
        var entityMap = this.context.entityMap;
        var engine = this._engine;
        var promises = entitiesConfig.map(function(entityConfig) {
            var _entityConfig_strippedId;
            var id = (_entityConfig_strippedId = entityConfig.strippedId) != null ? _entityConfig_strippedId : entityConfig.id;
            entityConfig.id = id;
            entityConfigMap.set(id, entityConfig);
            return _this._getEntityByConfig(entityConfig, engine);
        });
        return Promise.all(promises).then(function(entities) {
            for(var i = 0, l = entities.length; i < l; i++){
                entityMap.set(entitiesConfig[i].id, entities[i]);
            }
            return entities;
        });
    };
    _proto._parseComponents = function _parseComponents() {
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var components = this.context.components;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++){
            var entityConfig = entitiesConfig[i];
            var entity = entityMap.get(entityConfig.id);
            for(var i1 = 0; i1 < entityConfig.components.length; i1++){
                var componentConfig = entityConfig.components[i1];
                var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
                var component = entity.addComponent(Loader.getClass(key));
                components.set(componentConfig.id, component);
                var promise = this._reflectionParser.parsePropsAndMethods(component, componentConfig);
                promises.push(promise);
            }
        }
        return Promise.all(promises);
    };
    _proto._parsePrefabModification = function _parsePrefabModification() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, modifications = entityConfig.modifications;
            if (modifications == null ? void 0 : modifications.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).push.apply(_promises, [].concat(modifications.map(function(modification) {
                    var target = modification.target, props = modification.props, methods = modification.methods;
                    var entityId = target.entityId, componentId = target.componentId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetEntity = context.entityMap.get(entityId);
                    var targetComponent = context.components.get(componentId);
                    if (targetComponent) {
                        return _this._reflectionParser.parsePropsAndMethods(targetComponent, {
                            props: props,
                            methods: methods
                        });
                    } else if (targetEntity) {
                        return Promise.resolve(_this._applyEntityData(targetEntity, props));
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._parsePrefabRemovedEntities = function _parsePrefabRemovedEntities() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, removedEntities = entityConfig.removedEntities;
            if (removedEntities == null ? void 0 : removedEntities.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).push.apply(_promises, [].concat(removedEntities.map(function(target) {
                    var entityId = target.entityId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetEntity = context.entityMap.get(entityId);
                    if (targetEntity) {
                        targetEntity.destroy();
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._parsePrefabRemovedComponents = function _parsePrefabRemovedComponents() {
        var _loop = function(i, l) {
            var entityConfig = entitiesConfig[i];
            var id = entityConfig.id, removedComponents = entityConfig.removedComponents;
            if (removedComponents == null ? void 0 : removedComponents.length) {
                var _promises;
                var rootEntity = entityMap.get(id);
                (_promises = promises).concat.apply(_promises, [].concat(removedComponents.map(function(target) {
                    var componentId = target.componentId;
                    var context = _this._prefabContextMap.get(rootEntity);
                    var targetComponent = context.components.get(componentId);
                    if (targetComponent) {
                        targetComponent.destroy();
                    }
                })));
            }
        };
        var _this = this;
        var entitiesConfig = this.data.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._organizeEntities = function _organizeEntities() {
        var _this_context = this.context, rootIds = _this_context.rootIds, strippedIds = _this_context.strippedIds;
        var parentIds = rootIds.concat(strippedIds);
        for(var _iterator = _create_for_of_iterator_helper_loose(parentIds), _step; !(_step = _iterator()).done;){
            var parentId = _step.value;
            this._parseChildren(parentId);
        }
        for(var i = 0; i < rootIds.length; i++){
            this._handleRootEntity(rootIds[i]);
        }
    };
    _proto._getEntityByConfig = function _getEntityByConfig(entityConfig, engine) {
        var _this = this;
        var entityPromise;
        if (entityConfig.assetRefId) {
            entityPromise = this._parsePrefab(entityConfig, engine);
        } else if (entityConfig.strippedId) {
            entityPromise = this._parseStrippedEntity(entityConfig);
        } else {
            entityPromise = this._parseEntity(entityConfig, engine);
        }
        return entityPromise.then(function(entity) {
            return _this._applyEntityData(entity, entityConfig);
        });
    };
    _proto._parseEntity = function _parseEntity(entityConfig, engine) {
        var entity = new Entity(engine, entityConfig.name);
        if (!entityConfig.parent) this.context.rootIds.push(entityConfig.id);
        return Promise.resolve(entity);
    };
    _proto._parsePrefab = function _parsePrefab(entityConfig, engine) {
        var _this = this;
        var assetRefId = entityConfig.assetRefId;
        return engine.resourceManager// @ts-ignore
        .getResourceByRef({
            refId: assetRefId
        }).then(function(prefabResource) {
            var entity = _instanceof(prefabResource, PrefabResource) ? prefabResource.instantiate() : prefabResource.instantiateSceneRoot();
            var instanceContext = new ParserContext(engine, ParserType.Prefab, null);
            if (!entityConfig.parent) _this.context.rootIds.push(entityConfig.id);
            _this._generateInstanceContext(entity, instanceContext, "");
            _this._prefabContextMap.set(entity, instanceContext);
            var cbArray = _this._prefabPromiseMap.get(entityConfig.id);
            if (cbArray) {
                for(var i = 0, n = cbArray.length; i < n; i++){
                    cbArray[i].resolve(instanceContext);
                }
            }
            return entity;
        });
    };
    _proto._parseStrippedEntity = function _parseStrippedEntity(entityConfig) {
        var _this = this;
        this.context.strippedIds.push(entityConfig.id);
        return new Promise(function(resolve, reject) {
            var _this__prefabPromiseMap_get;
            var cbArray = (_this__prefabPromiseMap_get = _this._prefabPromiseMap.get(entityConfig.prefabInstanceId)) != null ? _this__prefabPromiseMap_get : [];
            cbArray.push({
                resolve: resolve,
                reject: reject
            });
            _this._prefabPromiseMap.set(entityConfig.prefabInstanceId, cbArray);
        }).then(function(context) {
            var entityId = entityConfig.prefabSource.entityId;
            return context.entityMap.get(entityId);
        });
    };
    _proto._parseChildren = function _parseChildren(parentId) {
        var _this_context = this.context, entityConfigMap = _this_context.entityConfigMap, entityMap = _this_context.entityMap;
        var children = entityConfigMap.get(parentId).children;
        if (children && children.length > 0) {
            var parent = entityMap.get(parentId);
            for(var i = 0; i < children.length; i++){
                var childId = children[i];
                var entity = entityMap.get(childId);
                parent.addChild(entity);
                this._parseChildren(childId);
            }
        }
    };
    _proto._applyEntityData = function _applyEntityData(entity, entityConfig) {
        if (entityConfig === void 0) entityConfig = {};
        var _entityConfig_isActive;
        entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : entity.isActive;
        var _entityConfig_name;
        entity.name = (_entityConfig_name = entityConfig.name) != null ? _entityConfig_name : entity.name;
        var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale, layer = entityConfig.layer;
        if (position) entity.transform.position.copyFrom(position);
        if (rotation) entity.transform.rotation.copyFrom(rotation);
        if (scale) entity.transform.scale.copyFrom(scale);
        if (layer) entity.layer = layer;
        return entity;
    };
    _proto._generateInstanceContext = function _generateInstanceContext(entity, context, path) {
        var entityMap = context.entityMap, components = context.components;
        var componentsMap = {};
        var componentIndexMap = {};
        entityMap.set(path, entity);
        // @ts-ignore
        entity._components.forEach(function(component) {
            // @ts-ignore
            var name = Loader.getClassName(component.constructor);
            if (!componentsMap[name]) {
                componentsMap[name] = entity.getComponents(component.constructor, []);
                componentIndexMap[name] = 0;
            }
            components.set(path + ":" + name + "/" + componentIndexMap[name]++, component);
        });
        for(var i = 0, n = entity.children.length; i < n; i++){
            var child = entity.children[i];
            var childPath = path ? path + "/" + i : "" + i;
            this._generateInstanceContext(child, context, childPath);
        }
    };
    return HierarchyParser;
}();

/** @Internal */ var SceneParser = /*#__PURE__*/ function(HierarchyParser) {
    _inherits(SceneParser, HierarchyParser);
    function SceneParser(data, context, scene) {
        var _this;
        _this = HierarchyParser.call(this, data, context) || this, _this.scene = scene;
        return _this;
    }
    var _proto = SceneParser.prototype;
    _proto._handleRootEntity = function _handleRootEntity(id) {
        var entityMap = this.context.entityMap;
        this.scene.addRootEntity(entityMap.get(id));
    };
    _proto._clearAndResolve = function _clearAndResolve() {
        this.context.clear();
        return this.scene;
    };
    /**
   * Parse scene data.
   * @param engine - the engine of the parser context
   * @param sceneData - scene data which is exported by editor
   * @returns a promise of scene
   */ SceneParser.parse = function parse(engine, sceneData) {
        var scene = new Scene(engine);
        var context = new ParserContext(engine, ParserType.Scene, scene);
        var parser = new SceneParser(sceneData, context, scene);
        parser.start();
        return parser.promise.then(function() {
            return scene;
        });
    };
    return SceneParser;
}(HierarchyParser);

var EditorTextureLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EditorTextureLoader, Loader);
    function EditorTextureLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = EditorTextureLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                decode(data, resourceManager.engine).then(function(texture) {
                    resolve(texture);
                });
            }).catch(reject);
        });
    };
    return EditorTextureLoader;
}(Loader);
EditorTextureLoader = __decorate([
    resourceLoader("EditorTexture2D", [
        "prefab"
    ], true)
], EditorTextureLoader);

/**
 * Decode engine binary resource.
 * @param arrayBuffer - array buffer of decode binary file
 * @param engine - engine
 * @returns
 */ function decode(arrayBuffer, engine) {
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(new Uint8Array(arrayBuffer), header.headerLength, header.dataLength);
    return decoderMap[header.type].decode(engine, bufferReader).then(function(object) {
        object.name = header.name;
        return object;
    });
}

var AnimationClipLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AnimationClipLoader, Loader);
    function AnimationClipLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = AnimationClipLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine).then(function(clip) {
                    var curveBindingPromises = clip.curveBindings.map(function(curveBinding) {
                        var curve = curveBinding.curve;
                        var promises = curve.keys.map(function(key) {
                            return _this._parseKeyframeValue(key, resourceManager).then(function(actualValue) {
                                key.value = actualValue;
                            });
                        });
                        return Promise.all(promises);
                    });
                    return Promise.all(curveBindingPromises).then(function() {
                        resolve(clip);
                    });
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._parseKeyframeValue = function _parseKeyframeValue(keyframe, resourceManager) {
        var value = keyframe.value;
        if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object" && (value == null ? void 0 : value.refId)) {
            return new Promise(function(resolve) {
                resourceManager// @ts-ignore
                .getResourceByRef(value).then(function(asset) {
                    keyframe.value = asset;
                    resolve(keyframe.value);
                });
            });
        } else {
            return Promise.resolve(keyframe.value);
        }
    };
    return AnimationClipLoader;
}(Loader);
AnimationClipLoader = __decorate([
    resourceLoader(AssetType.AnimationClip, [
        "ani"
    ])
], AnimationClipLoader);

var AnimatorControllerLoader = /*#__PURE__*/ function(Loader1) {
    _inherits(AnimatorControllerLoader, Loader1);
    function AnimatorControllerLoader() {
        return Loader1.apply(this, arguments) || this;
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var animatorController = new AnimatorController(resourceManager.engine);
                var layers = data.layers, parameters = data.parameters;
                var promises = [];
                layers.forEach(function(layerData, layerIndex) {
                    var name = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
                    var layer = new AnimatorControllerLayer(name);
                    layer.blendingMode = blendingMode;
                    layer.weight = weight;
                    if (stateMachineData) {
                        var states = stateMachineData.states, transitions = stateMachineData.transitions, entryTransitions = stateMachineData.entryTransitions, anyTransitions = stateMachineData.anyTransitions;
                        var stateMachine = layer.stateMachine;
                        var statesMap = {};
                        var transitionsMap = {};
                        states.forEach(function(stateData, stateIndex) {
                            var id = stateData.id, name = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, clipData = stateData.clip, scripts = stateData.scripts;
                            var state = stateMachine.addState(name);
                            state.speed = speed;
                            state.wrapMode = wrapMode;
                            state.clipStartTime = clipStartNormalizedTime;
                            state.clipEndTime = clipEndNormalizedTime;
                            scripts.forEach(function(script) {
                                state.addStateMachineScript(Loader.getClass(script));
                            });
                            statesMap[id] = state;
                            if (clipData) {
                                promises.push(new Promise(function(resolve) {
                                    //@ts-ignore
                                    resourceManager.getResourceByRef(clipData).then(function(clip) {
                                        resolve({
                                            layerIndex: layerIndex,
                                            stateIndex: stateIndex,
                                            clip: clip
                                        });
                                    });
                                }));
                            }
                        });
                        transitions.forEach(function(transitionData) {
                            var transition = _this._createTransition(transitionData, statesMap[transitionData.destinationStateId]);
                            transitionsMap[transitionData.id] = transition;
                        });
                        states.forEach(function(stateData) {
                            var id = stateData.id, transitions = stateData.transitions;
                            transitions.forEach(function(transitionId) {
                                var transition = transitionsMap[transitionId];
                                transition && statesMap[id].addTransition(transition);
                            });
                        });
                        entryTransitions.forEach(function(entryTransitionData) {
                            stateMachine.addEntryStateTransition(_this._createTransition(entryTransitionData, statesMap[entryTransitionData.destinationStateId]));
                        });
                        anyTransitions.forEach(function(anyTransitionData) {
                            stateMachine.addAnyStateTransition(_this._createTransition(anyTransitionData, statesMap[anyTransitionData.destinationStateId]));
                        });
                    }
                    animatorController.addLayer(layer);
                });
                parameters.forEach(function(parameterData) {
                    if (parameterData.isTrigger) {
                        animatorController.addTriggerParameter(parameterData.name);
                    } else {
                        animatorController.addParameter(parameterData.name, parameterData.defaultValue);
                    }
                });
                Promise.all(promises).then(function(clipData) {
                    clipData.forEach(function(data) {
                        var layerIndex = data.layerIndex, stateIndex = data.stateIndex, clip = data.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                    });
                    resolve(animatorController);
                });
            }).catch(reject);
        });
    };
    _proto._createTransition = function _createTransition(transitionData, destinationState) {
        var transition = new AnimatorStateTransition();
        transition.hasExitTime = transitionData.hasExitTime;
        transition.isFixedDuration = transitionData.isFixedDuration;
        transition.duration = transitionData.duration;
        transition.offset = transitionData.offset;
        transition.exitTime = transitionData.exitTime;
        transition.solo = transitionData.solo;
        transition.mute = transitionData.mute;
        // @ts-ignore
        transition._isExit = transitionData.isExit;
        transition.destinationState = destinationState;
        transitionData.conditions.forEach(function(conditionData) {
            transition.addCondition(conditionData.parameterName, conditionData.mode, conditionData.threshold);
        });
        return transition;
    };
    return AnimatorControllerLoader;
}(Loader);
AnimatorControllerLoader = __decorate([
    resourceLoader(AssetType.AnimatorController, [
        "json"
    ], false)
], AnimatorControllerLoader);

function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
}
var BufferLoader = /*#__PURE__*/ function(Loader) {
    _inherits(BufferLoader, Loader);
    function BufferLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var url = item.url;
        if (isBase64(url)) {
            return new AssetPromise(function(resolve) {
                var base64Str = url.slice(13 + RegExp.$1.length);
                var result = Uint8Array.from(atob(base64Str), function(c) {
                    return c.charCodeAt(0);
                });
                resolve(result.buffer);
            });
        }
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "arraybuffer"
        }));
    };
    return BufferLoader;
}(Loader);
BufferLoader = __decorate([
    resourceLoader(AssetType.Buffer, [
        "bin",
        "r3bin"
    ], false)
], BufferLoader);

var EnvLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EnvLoader, Loader);
    function EnvLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(arraybuffer) {
                var _this;
                var shArray = new Float32Array(arraybuffer, 0, 27);
                var shByteLength = 27 * 4;
                var size = (_this = new Uint16Array(arraybuffer, shByteLength, 1)) == null ? void 0 : _this[0];
                var engine = resourceManager.engine;
                var texture = new TextureCube(engine, size);
                texture.filterMode = TextureFilterMode.Trilinear;
                var mipmapCount = texture.mipmapCount;
                var offset = shByteLength + 2;
                for(var mipLevel = 0; mipLevel < mipmapCount; mipLevel++){
                    var mipSize = size >> mipLevel;
                    for(var face = 0; face < 6; face++){
                        var dataSize = mipSize * mipSize * 4;
                        var data = new Uint8Array(arraybuffer, offset, dataSize);
                        offset += dataSize;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
                    }
                }
                var ambientLight = new AmbientLight(engine);
                var sh = new SphericalHarmonics3();
                ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
                sh.copyFromArray(shArray);
                ambientLight.diffuseSphericalHarmonics = sh;
                ambientLight.specularTexture = texture;
                ambientLight.specularTextureDecodeRGBM = true;
                resolve(ambientLight);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return EnvLoader;
}(Loader);
EnvLoader = __decorate([
    resourceLoader(AssetType.Env, [
        "env"
    ])
], EnvLoader);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;

        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
        });
    };
}

var FontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(FontLoader, Loader);
    function FontLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = FontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var fontName = data.fontName, fontUrl = data.fontUrl;
                if (fontUrl) {
                    _this._registerFont(fontName, fontUrl).then(function() {
                        var font = new Font(resourceManager.engine, fontName);
                        resolve(font);
                    }).catch(function(e) {
                        reject("load font " + fontUrl + " fail");
                    });
                } else {
                    var font = new Font(resourceManager.engine, fontName);
                    resolve(font);
                }
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return FontLoader;
}(Loader);
FontLoader = __decorate([
    resourceLoader(AssetType.Font, [
        "font"
    ], false)
], FontLoader);

/**
 * The glTF resource.
 */ var GLTFResource = /*#__PURE__*/ function(ReferResource) {
    _inherits(GLTFResource, ReferResource);
    function GLTFResource(engine, url) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this.url = url;
        return _this;
    }
    var _proto = GLTFResource.prototype;
    /**
   * Instantiate scene root entity.
   * @param sceneIndex - Scene index
   * @returns Root entity
   */ _proto.instantiateSceneRoot = function instantiateSceneRoot(sceneIndex) {
        var sceneRoot = sceneIndex === undefined ? this._defaultSceneRoot : this._sceneRoots[sceneIndex];
        return sceneRoot.clone();
    };
    _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var _this = this, textures = _this.textures, materials = _this.materials, meshes = _this.meshes;
        textures && this._disassociationSuperResource(textures);
        materials && this._disassociationSuperResource(materials);
        if (meshes) {
            for(var i = 0, n = meshes.length; i < n; i++){
                this._disassociationSuperResource(meshes[i]);
            }
        }
    };
    _proto._disassociationSuperResource = function _disassociationSuperResource(resources) {
        for(var i = 0, n = resources.length; i < n; i++){
            // @ts-ignore
            resources[i]._disassociationSuperResource(this);
        }
    };
    _create_class(GLTFResource, [
        {
            key: "extensionsData",
            get: /**
   * Extensions data.
   */ function get() {
                return this._extensionsData;
            }
        },
        {
            key: "sceneRoots",
            get: /**
   * @deprecated Please use `instantiateSceneRoot` instead.
   * RootEntities after SceneParser.
   */ function get() {
                return this._sceneRoots;
            }
        },
        {
            key: "defaultSceneRoot",
            get: /**
   * @deprecated Please use `instantiateSceneRoot` instead.
   * RootEntity after SceneParser.
   */ function get() {
                return this._defaultSceneRoot;
            }
        }
    ]);
    return GLTFResource;
}(ReferResource);

/**
 * Module for glTF 2.0 Interface
 */ /**
 * The datatype of the components in the attribute
 */ var AccessorComponentType = /*#__PURE__*/ function(AccessorComponentType) {
    /**
   * Byte
   */ AccessorComponentType[AccessorComponentType["BYTE"] = 5120] = "BYTE";
    /**
   * Unsigned Byte
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    /**
   * Short
   */ AccessorComponentType[AccessorComponentType["SHORT"] = 5122] = "SHORT";
    /**
   * Unsigned Short
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    /**
   * Unsigned Int
   */ AccessorComponentType[AccessorComponentType["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    /**
   * Float
   */ AccessorComponentType[AccessorComponentType["FLOAT"] = 5126] = "FLOAT";
    return AccessorComponentType;
}({});
/**
 * Specifies if the attirbute is a scalar, vector, or matrix
 */ var AccessorType = /*#__PURE__*/ function(AccessorType) {
    /**
   * Scalar
   */ AccessorType["SCALAR"] = "SCALAR";
    /**
   * Vector2
   */ AccessorType["VEC2"] = "VEC2";
    /**
   * Vector3
   */ AccessorType["VEC3"] = "VEC3";
    /**
   * Vector4
   */ AccessorType["VEC4"] = "VEC4";
    /**
   * Matrix2x2
   */ AccessorType["MAT2"] = "MAT2";
    /**
   * Matrix3x3
   */ AccessorType["MAT3"] = "MAT3";
    /**
   * Matrix4x4
   */ AccessorType["MAT4"] = "MAT4";
    return AccessorType;
}({});
/**
 * The name of the node's TRS property to modify, or the weights of the Morph Targets it instantiates
 */ var AnimationChannelTargetPath = /*#__PURE__*/ function(AnimationChannelTargetPath) {
    /**
   * Translation
   */ AnimationChannelTargetPath["TRANSLATION"] = "translation";
    /**
   * Rotation
   */ AnimationChannelTargetPath["ROTATION"] = "rotation";
    /**
   * Scale
   */ AnimationChannelTargetPath["SCALE"] = "scale";
    /**
   * Weights
   */ AnimationChannelTargetPath["WEIGHTS"] = "weights";
    return AnimationChannelTargetPath;
}({});
/**
 * Interpolation algorithm
 */ var AnimationSamplerInterpolation = /*#__PURE__*/ function(AnimationSamplerInterpolation) {
    /**
   * The animated values are linearly interpolated between keyframes
   */ AnimationSamplerInterpolation["Linear"] = "LINEAR";
    /**
   * The animated values remain constant to the output of the first keyframe, until the next keyframe
   */ AnimationSamplerInterpolation["Step"] = "STEP";
    /**
   * The animation's interpolation is computed using a cubic spline with specified tangents
   */ AnimationSamplerInterpolation["CubicSpine"] = "CUBICSPLINE";
    return AnimationSamplerInterpolation;
}({});
/**
 * A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene
 */ var CameraType = /*#__PURE__*/ function(CameraType) {
    /**
   * A perspective camera containing properties to create a perspective projection matrix
   */ CameraType["PERSPECTIVE"] = "perspective";
    /**
   * An orthographic camera containing properties to create an orthographic projection matrix
   */ CameraType["ORTHOGRAPHIC"] = "orthographic";
    return CameraType;
}({});
/**
 * The alpha rendering mode of the material
 */ var MaterialAlphaMode = /*#__PURE__*/ function(MaterialAlphaMode) {
    /**
   * The alpha value is ignored and the rendered output is fully opaque
   */ MaterialAlphaMode["OPAQUE"] = "OPAQUE";
    /**
   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value
   */ MaterialAlphaMode["MASK"] = "MASK";
    /**
   * The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
   */ MaterialAlphaMode["BLEND"] = "BLEND";
    return MaterialAlphaMode;
}({});
/**
 * Magnification filter.  Valid values correspond to WebGL enums: 9728 (NEAREST) and 9729 (LINEAR)
 */ var TextureMagFilter = /*#__PURE__*/ function(TextureMagFilter) {
    /**
   * Nearest
   */ TextureMagFilter[TextureMagFilter["NEAREST"] = 9728] = "NEAREST";
    /**
   * Linear
   */ TextureMagFilter[TextureMagFilter["LINEAR"] = 9729] = "LINEAR";
    return TextureMagFilter;
}({});
/**
 * Minification filter.  All valid values correspond to WebGL enums
 */ var TextureMinFilter = /*#__PURE__*/ function(TextureMinFilter) {
    /**
   * Nearest
   */ TextureMinFilter[TextureMinFilter["NEAREST"] = 9728] = "NEAREST";
    /**
   * Linear
   */ TextureMinFilter[TextureMinFilter["LINEAR"] = 9729] = "LINEAR";
    /**
   * Nearest Mip-Map Nearest
   */ TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    /**
   * Linear Mipmap Nearest
   */ TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    /**
   * Nearest Mipmap Linear
   */ TextureMinFilter[TextureMinFilter["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    /**
   * Linear Mipmap Linear
   */ TextureMinFilter[TextureMinFilter["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    return TextureMinFilter;
}({});
/**
 * S (U) wrapping mode.  All valid values correspond to WebGL enums
 */ var TextureWrapMode = /*#__PURE__*/ function(TextureWrapMode) {
    /**
   * Clamp to Edge
   */ TextureWrapMode[TextureWrapMode["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    /**
   * Mirrored Repeat
   */ TextureWrapMode[TextureWrapMode["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    /**
   * Repeat
   */ TextureWrapMode[TextureWrapMode["REPEAT"] = 10497] = "REPEAT";
    return TextureWrapMode;
}({});

/**
 * @internal
 */ var GLTFParserContext = /*#__PURE__*/ function() {
    function GLTFParserContext(glTFResource, resourceManager, params) {
        var _this = this;
        this.glTFResource = glTFResource;
        this.resourceManager = resourceManager;
        this.params = params;
        this.accessorBufferCache = {};
        this.needAnimatorController = false;
        this._resourceCache = new Map();
        this._progress = {
            taskDetail: {},
            taskComplete: {
                loaded: 0,
                total: 0
            }
        };
        this./**
   * @internal
   */ _onTaskDetail = function(url, loaded, total) {
            var _this__progress_taskDetail, _url;
            var detail = (_this__progress_taskDetail = _this._progress.taskDetail)[_url = url] || (_this__progress_taskDetail[_url] = {});
            detail.loaded = loaded;
            detail.total = total;
            _this._setTaskDetailProgress(url, loaded, total);
        };
        this.contentRestorer = new GLTFContentRestorer(glTFResource);
    }
    var _proto = GLTFParserContext.prototype;
    _proto.get = function get(type, index) {
        var _this = this;
        var parser = GLTFParserContext._parsers[type];
        if (!parser) {
            return Promise.resolve(null);
        }
        var cache = this._resourceCache;
        var cacheKey = index === undefined ? "" + type : type + ":" + index;
        var resource = cache.get(cacheKey);
        if (resource) {
            return resource;
        }
        var glTFSchemaKey = glTFSchemaMap[type];
        var isSubAsset = !!glTFResourceMap[type];
        if (glTFSchemaKey) {
            var glTFItems = this.glTF[glTFSchemaKey];
            if (glTFItems && (index === undefined || glTFItems[index])) {
                if (index === undefined) {
                    resource = type === 8 ? glTFItems.map(function(_, index) {
                        return _this.get(type, index);
                    }) : Promise.all(glTFItems.map(function(_, index) {
                        return _this.get(type, index);
                    }));
                } else {
                    resource = parser.parse(this, index);
                    isSubAsset && this._handleSubAsset(resource, type, index);
                }
            } else {
                resource = Promise.resolve(null);
            }
        } else {
            resource = parser.parse(this, index);
            isSubAsset && this._handleSubAsset(resource, type, index);
        }
        cache.set(cacheKey, resource);
        return resource;
    };
    _proto.parse = function parse() {
        var _this = this;
        var promise = this.get(0).then(function(json) {
            _this.glTF = json;
            _this.needAnimatorController = !!(json.skins || json.animations);
            return Promise.all([
                _this.get(1),
                _this.get(5),
                _this.get(6),
                _this.get(7),
                _this.get(9),
                _this.get(10),
                _this.get(11),
                _this.get(2)
            ]).then(function() {
                var glTFResource = _this.glTFResource;
                var animatorController = glTFResource.animatorController;
                if (animatorController) {
                    var animator = glTFResource._defaultSceneRoot.addComponent(Animator);
                    animator.animatorController = animatorController;
                }
                _this.resourceManager.addContentRestorer(_this.contentRestorer);
                return glTFResource;
            });
        });
        this._addTaskCompletePromise(promise);
        return promise;
    };
    /**
   * @internal
   */ _proto._addTaskCompletePromise = function _addTaskCompletePromise(taskPromise) {
        var _this = this;
        var task = this._progress.taskComplete;
        task.total += 1;
        taskPromise.then(function() {
            _this._setTaskCompleteProgress(++task.loaded, task.total);
        });
    };
    _proto._handleSubAsset = function _handleSubAsset(resource, type, index) {
        var _this = this;
        var glTFResourceKey = glTFResourceMap[type];
        if (type === 8) {
            var _this_glTFResource, _glTFResourceKey;
            ((_this_glTFResource = this.glTFResource)[_glTFResourceKey = glTFResourceKey] || (_this_glTFResource[_glTFResourceKey] = []))[index] = resource;
        } else {
            var url = this.glTFResource.url;
            resource.then(function(item) {
                if (index == undefined) {
                    _this.glTFResource[glTFResourceKey] = item;
                } else {
                    var _this_glTFResource, _glTFResourceKey;
                    ((_this_glTFResource = _this.glTFResource)[_glTFResourceKey = glTFResourceKey] || (_this_glTFResource[_glTFResourceKey] = []))[index] = item;
                }
                if (type === 7) {
                    for(var i = 0, length = item.length; i < length; i++){
                        var mesh = item[i];
                        // @ts-ignore
                        _this.resourceManager._onSubAssetSuccess(url, glTFResourceKey + "[" + index + "][" + i + "]", mesh);
                    }
                } else {
                    // @ts-ignore
                    _this.resourceManager._onSubAssetSuccess(url, "" + glTFResourceKey + (index === undefined ? "" : "[" + index + "]"), item);
                    var _this_glTF_scene;
                    if (type === 2 && ((_this_glTF_scene = _this.glTF.scene) != null ? _this_glTF_scene : 0) === index) {
                        // @ts-ignore
                        _this.resourceManager._onSubAssetSuccess(url, "defaultSceneRoot", item);
                    }
                }
            });
        }
    };
    GLTFParserContext.addParser = function addParser(parserType, parser) {
        this._parsers[parserType] = parser;
    };
    return GLTFParserContext;
}();
GLTFParserContext._parsers = {};
/**
 * @internal
 */ var BufferInfo = function BufferInfo(data, interleaved, stride) {
    this.data = data;
    this.interleaved = interleaved;
    this.stride = stride;
    this.vertexBindingInfos = {};
};
var GLTFParserType = /*#__PURE__*/ function(GLTFParserType) {
    GLTFParserType[GLTFParserType["Schema"] = 0] = "Schema";
    GLTFParserType[GLTFParserType["Validator"] = 1] = "Validator";
    GLTFParserType[GLTFParserType["Scene"] = 2] = "Scene";
    GLTFParserType[GLTFParserType["Buffer"] = 3] = "Buffer";
    GLTFParserType[GLTFParserType["BufferView"] = 4] = "BufferView";
    GLTFParserType[GLTFParserType["Texture"] = 5] = "Texture";
    GLTFParserType[GLTFParserType["Material"] = 6] = "Material";
    GLTFParserType[GLTFParserType["Mesh"] = 7] = "Mesh";
    GLTFParserType[GLTFParserType["Entity"] = 8] = "Entity";
    GLTFParserType[GLTFParserType["Skin"] = 9] = "Skin";
    GLTFParserType[GLTFParserType["Animation"] = 10] = "Animation";
    GLTFParserType[GLTFParserType["AnimatorController"] = 11] = "AnimatorController";
    return GLTFParserType;
}({});
var _obj$3;
var glTFSchemaMap = (_obj$3 = {}, _obj$3[2] = "scenes", _obj$3[3] = "buffers", _obj$3[5] = "textures", _obj$3[6] = "materials", _obj$3[7] = "meshes", _obj$3[8] = "nodes", _obj$3[9] = "skins", _obj$3[10] = "animations", _obj$3[4] = "bufferViews", _obj$3);
var _obj1;
var glTFResourceMap = (_obj1 = {}, _obj1[2] = "_sceneRoots", _obj1[5] = "textures", _obj1[6] = "materials", _obj1[7] = "meshes", _obj1[8] = "entities", _obj1[9] = "skins", _obj1[10] = "animations", _obj1[11] = "animatorController", _obj1);
function registerGLTFParser(pipeline) {
    return function(Parser) {
        var parser = new Parser();
        GLTFParserContext.addParser(pipeline, parser);
    };
}

/**
 * @internal
 */ var GLTFUtils = /*#__PURE__*/ function() {
    function GLTFUtils() {}
    GLTFUtils.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 2);
        for(var i = 0; i < bufferLen; i += 2){
            array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 3);
        for(var i = 0; i < bufferLen; i += 3){
            array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 4);
        for(var i = 0; i < bufferLen; i += 4){
            array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
        }
        return array;
    };
    GLTFUtils.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
        var bufferLen = buffer.length;
        var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
        if (isColor3) {
            for(var i = 0; i < bufferLen; i += 3){
                colors[i / 3] = new Color(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
            }
        } else {
            for(var i1 = 0; i1 < bufferLen; i1 += 4){
                colors[i1 / 4] = new Color(buffer[i1], buffer[i1 + 1], buffer[i1 + 2], buffer[i1 + 3]);
            }
        }
        return colors;
    };
    /**
   * Get the number of bytes occupied by accessor type.
   */ GLTFUtils.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
        switch(accessorType){
            case AccessorType.SCALAR:
                return 1;
            case AccessorType.VEC2:
                return 2;
            case AccessorType.VEC3:
                return 3;
            case AccessorType.VEC4:
                return 4;
            case AccessorType.MAT2:
                return 4;
            case AccessorType.MAT3:
                return 9;
            case AccessorType.MAT4:
                return 16;
        }
    };
    /**
   * Get the TypedArray corresponding to the component type.
   */ GLTFUtils.getComponentType = function getComponentType(componentType) {
        switch(componentType){
            case AccessorComponentType.BYTE:
                return Int8Array;
            case AccessorComponentType.UNSIGNED_BYTE:
                return Uint8Array;
            case AccessorComponentType.SHORT:
                return Int16Array;
            case AccessorComponentType.UNSIGNED_SHORT:
                return Uint16Array;
            case AccessorComponentType.UNSIGNED_INT:
                return Uint32Array;
            case AccessorComponentType.FLOAT:
                return Float32Array;
        }
    };
    GLTFUtils.getNormalizedComponentScale = function getNormalizedComponentScale(componentType) {
        // Reference: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
        switch(componentType){
            case AccessorComponentType.BYTE:
                return 1 / 127;
            case AccessorComponentType.UNSIGNED_BYTE:
                return 1 / 255;
            case AccessorComponentType.SHORT:
                return 1 / 32767;
            case AccessorComponentType.UNSIGNED_SHORT:
                return 1 / 65535;
            default:
                throw new Error("Galacean.GLTFLoader: Unsupported normalized accessor component type.");
        }
    };
    GLTFUtils.getAccessorBuffer = function getAccessorBuffer(context, bufferViews, accessor) {
        var componentType = accessor.componentType;
        var TypedArray = GLTFUtils.getComponentType(componentType);
        var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var dataElementBytes = TypedArray.BYTES_PER_ELEMENT;
        var elementStride = dataElementSize * dataElementBytes;
        var accessorCount = accessor.count;
        var promise;
        if (accessor.bufferView !== undefined) {
            var bufferViewIndex = accessor.bufferView;
            var bufferView = bufferViews[bufferViewIndex];
            promise = context.get(GLTFParserType.BufferView, accessor.bufferView).then(function(bufferViewData) {
                var bufferIndex = bufferView.buffer;
                var _bufferViewData_byteOffset;
                var bufferByteOffset = (_bufferViewData_byteOffset = bufferViewData.byteOffset) != null ? _bufferViewData_byteOffset : 0;
                var _accessor_byteOffset;
                var byteOffset = (_accessor_byteOffset = accessor.byteOffset) != null ? _accessor_byteOffset : 0;
                var bufferStride = bufferView.byteStride;
                var bufferInfo;
                // According to the glTF official documentation only byteStride not undefined is allowed
                if (bufferStride !== undefined && bufferStride !== elementStride) {
                    var bufferSlice = Math.floor(byteOffset / bufferStride);
                    var bufferCacheKey = bufferViewIndex + ":" + componentType + ":" + bufferSlice + ":" + accessorCount;
                    var accessorBufferCache = context.accessorBufferCache;
                    bufferInfo = accessorBufferCache[bufferCacheKey];
                    if (!bufferInfo) {
                        var offset = bufferByteOffset + bufferSlice * bufferStride;
                        var count = accessorCount * (bufferStride / dataElementBytes);
                        var data = new TypedArray(bufferViewData.buffer, offset, count);
                        accessorBufferCache[bufferCacheKey] = bufferInfo = new BufferInfo(data, true, bufferStride);
                        bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset, count));
                    }
                } else {
                    var offset1 = bufferByteOffset + byteOffset;
                    var count1 = accessorCount * dataElementSize;
                    var data1 = new TypedArray(bufferViewData.buffer, offset1, count1);
                    bufferInfo = new BufferInfo(data1, false, elementStride);
                    bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset1, count1));
                }
                return bufferInfo;
            });
        } else {
            var count = accessorCount * dataElementSize;
            var data = new TypedArray(count);
            var bufferInfo = new BufferInfo(data, false, elementStride);
            bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(undefined, TypedArray, undefined, count));
            promise = Promise.resolve(bufferInfo);
        }
        return accessor.sparse ? promise.then(function(bufferInfo) {
            return GLTFUtils.processingSparseData(context, accessor, bufferInfo).then(function() {
                return bufferInfo;
            });
        }) : promise;
    };
    GLTFUtils.bufferToVector3Array = function bufferToVector3Array(buffer, byteOffset, count, normalized, componentType) {
        var baseOffset = byteOffset / buffer.BYTES_PER_ELEMENT;
        var stride = buffer.length / count;
        var vertices = new Array(count);
        var factor = normalized ? GLTFUtils.getNormalizedComponentScale(componentType) : 1;
        for(var i = 0; i < count; i++){
            var index = baseOffset + i * stride;
            vertices[i] = new Vector3(buffer[index] * factor, buffer[index + 1] * factor, buffer[index + 2] * factor);
        }
        return vertices;
    };
    GLTFUtils.getBufferViewData = function getBufferViewData(bufferView, buffers) {
        var _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset;
        var arrayBuffer = buffers[bufferView.buffer];
        return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
    };
    /**
   * Get accessor data.
   */ GLTFUtils.processingSparseData = function processingSparseData(context, accessor, bufferInfo) {
        var restoreInfo = bufferInfo.restoreInfo;
        var bufferViews = context.glTF.bufferViews;
        var accessorTypeSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var TypedArray = GLTFUtils.getComponentType(accessor.componentType);
        var data = bufferInfo.data.slice();
        var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        return Promise.all([
            context.get(GLTFParserType.BufferView, indices.bufferView),
            context.get(GLTFParserType.BufferView, values.bufferView)
        ]).then(function(param) {
            var indicesUint8Array = param[0], valuesUin8Array = param[1];
            var _indices_byteOffset, _indicesUint8Array_byteOffset;
            var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesUint8Array_byteOffset = indicesUint8Array.byteOffset) != null ? _indicesUint8Array_byteOffset : 0);
            var indicesByteLength = indicesUint8Array.byteLength;
            var _values_byteOffset, _valuesUin8Array_byteOffset;
            var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesUin8Array_byteOffset = valuesUin8Array.byteOffset) != null ? _valuesUin8Array_byteOffset : 0);
            var valuesByteLength = valuesUin8Array.byteLength;
            restoreInfo.typeSize = accessorTypeSize;
            restoreInfo.sparseCount = count;
            var IndexTypeArray = GLTFUtils.getComponentType(indices.componentType);
            var indexLength = indicesByteLength / IndexTypeArray.BYTES_PER_ELEMENT;
            var indicesArray = new IndexTypeArray(indicesUint8Array.buffer, indicesByteOffset, indexLength);
            restoreInfo.sparseIndices = new RestoreDataAccessor(indicesBufferView.buffer, IndexTypeArray, indicesByteOffset, indexLength);
            var valueLength = valuesByteLength / TypedArray.BYTES_PER_ELEMENT;
            var valuesArray = new TypedArray(valuesUin8Array.buffer, valuesByteOffset, valueLength);
            restoreInfo.sparseValues = new RestoreDataAccessor(valuesBufferView.buffer, TypedArray, valuesByteOffset, valueLength);
            for(var i = 0; i < count; i++){
                var replaceIndex = indicesArray[i];
                for(var j = 0; j < accessorTypeSize; j++){
                    data[replaceIndex * accessorTypeSize + j] = valuesArray[i * accessorTypeSize + j];
                }
            }
            bufferInfo.data = data;
        });
    };
    GLTFUtils.getIndexFormat = function getIndexFormat(type) {
        switch(type){
            case AccessorComponentType.UNSIGNED_BYTE:
                return IndexFormat.UInt8;
            case AccessorComponentType.UNSIGNED_SHORT:
                return IndexFormat.UInt16;
            case AccessorComponentType.UNSIGNED_INT:
                return IndexFormat.UInt32;
        }
    };
    GLTFUtils.getElementFormat = function getElementFormat(type, size, normalized) {
        if (normalized === void 0) normalized = false;
        if (type == AccessorComponentType.FLOAT) {
            switch(size){
                case 1:
                    return VertexElementFormat.Float;
                case 2:
                    return VertexElementFormat.Vector2;
                case 3:
                    return VertexElementFormat.Vector3;
                case 4:
                    return VertexElementFormat.Vector4;
            }
        }
        if (type == AccessorComponentType.SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
            }
        }
        if (type == AccessorComponentType.BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
            }
        }
    };
    /**
   * Load image buffer
   */ GLTFUtils.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
        return new Promise(function(resolve, reject) {
            var blob = new window.Blob([
                imageBuffer
            ], {
                type: type
            });
            var img = new Image();
            img.onerror = function() {
                reject(new Error("Failed to load image buffer"));
            };
            img.onload = function() {
                // Call requestAnimationFrame to avoid iOS's bug.
                requestAnimationFrame(function() {
                    resolve(img);
                    img.onload = null;
                    img.onerror = null;
                    img.onabort = null;
                });
            };
            img.crossOrigin = "anonymous";
            img.src = URL.createObjectURL(blob);
        });
    };
    /**
   * Parse the glb format.
   */ GLTFUtils.parseGLB = function parseGLB(context, originBuffer) {
        var UINT32_LENGTH = 4;
        var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
        var GLB_HEADER_LENGTH = 12;
        var GLB_CHUNK_TYPES = {
            JSON: 0x4e4f534a,
            BIN: 0x004e4942
        };
        var dataView = new DataView(originBuffer);
        // Read header
        var header = {
            magic: dataView.getUint32(0, true),
            version: dataView.getUint32(UINT32_LENGTH, true),
            length: dataView.getUint32(2 * UINT32_LENGTH, true)
        };
        // Return the original buffer if it is not a glb
        if (header.magic !== GLB_HEADER_MAGIC) {
            return {
                originBuffer: originBuffer
            };
        }
        // Read main data
        var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
        var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
        // Read glTF json
        if (chunkType !== GLB_CHUNK_TYPES.JSON) {
            console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
            return null;
        }
        var glTFData = new Uint8Array(originBuffer, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
        var glTF = JSON.parse(Utils.decodeText(glTFData));
        // Read all buffers
        var buffers = [];
        var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
        var restoreGLBBufferSlice = context.contentRestorer.glbBufferSlices;
        while(byteOffset < header.length){
            chunkLength = dataView.getUint32(byteOffset, true);
            chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
            if (chunkType !== GLB_CHUNK_TYPES.BIN) {
                console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
                return null;
            }
            var currentOffset = byteOffset + 2 * UINT32_LENGTH;
            var buffer = originBuffer.slice(currentOffset, currentOffset + chunkLength);
            buffers.push(buffer);
            restoreGLBBufferSlice.push(new Vector2(currentOffset, chunkLength));
            byteOffset += chunkLength + 2 * UINT32_LENGTH;
        }
        return {
            glTF: glTF,
            buffers: buffers
        };
    };
    GLTFUtils.parseSampler = function parseSampler(texture, samplerInfo) {
        var filterMode = samplerInfo.filterMode, wrapModeU = samplerInfo.wrapModeU, wrapModeV = samplerInfo.wrapModeV;
        if (filterMode !== undefined) {
            texture.filterMode = filterMode;
        }
        if (wrapModeU !== undefined) {
            texture.wrapModeU = wrapModeU;
        }
        if (wrapModeV !== undefined) {
            texture.wrapModeV = wrapModeV;
        }
    };
    GLTFUtils.getSamplerInfo = function getSamplerInfo(sampler) {
        var minFilter = sampler.minFilter, magFilter = sampler.magFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
        var info = {};
        if (minFilter || magFilter) {
            info.mipmap = minFilter >= TextureMinFilter.NEAREST_MIPMAP_NEAREST;
            if (magFilter === TextureMagFilter.NEAREST) {
                info.filterMode = TextureFilterMode.Point;
            } else {
                if (minFilter <= TextureMinFilter.LINEAR_MIPMAP_NEAREST) {
                    info.filterMode = TextureFilterMode.Bilinear;
                } else {
                    info.filterMode = TextureFilterMode.Trilinear;
                }
            }
        }
        if (wrapS) {
            info.wrapModeU = GLTFTextureParser._wrapMap[wrapS];
        }
        if (wrapT) {
            info.wrapModeV = GLTFTextureParser._wrapMap[wrapT];
        }
        return info;
    };
    return GLTFUtils;
}();

var SupercompressionScheme = /*#__PURE__*/ function(SupercompressionScheme) {
    SupercompressionScheme[SupercompressionScheme["None"] = 0] = "None";
    SupercompressionScheme[SupercompressionScheme["BasisLZ"] = 1] = "BasisLZ";
    SupercompressionScheme[SupercompressionScheme["Zstd"] = 2] = "Zstd";
    SupercompressionScheme[SupercompressionScheme["ZLib"] = 3] = "ZLib";
    return SupercompressionScheme;
}({});
/** @internal */ var KTX2Container = /*#__PURE__*/ function() {
    function KTX2Container(buffer) {
        this.vkFormat = 0;
        this.typeSize = 1;
        this.pixelWidth = 0;
        this.pixelHeight = 0;
        this.pixelDepth = 0;
        this.layerCount = 0;
        this.faceCount = 1;
        this.supercompressionScheme = 0;
        this.levels = [];
        this.keyValue = {};
        this.globalData = null;
        this.parse(buffer);
    }
    var _proto = KTX2Container.prototype;
    _proto.parse = function parse(data) {
        var buffer = data.buffer;
        var byteOffset = data.byteOffset;
        var headerBufferReader = new BufferReader(data, 12);
        this.vkFormat = headerBufferReader.nextUint32();
        this.typeSize = headerBufferReader.nextUint32();
        this.pixelWidth = headerBufferReader.nextUint32();
        this.pixelHeight = headerBufferReader.nextUint32();
        this.pixelDepth = headerBufferReader.nextUint32();
        this.layerCount = headerBufferReader.nextUint32();
        this.faceCount = headerBufferReader.nextUint32();
        var levelCount = Math.max(1, headerBufferReader.nextUint32());
        this.supercompressionScheme = headerBufferReader.nextUint32();
        var dfdByteOffset = headerBufferReader.nextUint32();
        var dfdByteLength = headerBufferReader.nextUint32();
        var kvdByteOffset = headerBufferReader.nextUint32();
        var kvdByteLength = headerBufferReader.nextUint32();
        var sgdByteOffset = headerBufferReader.nextUint64();
        var sgdByteLength = headerBufferReader.nextUint64();
        // level index
        var ktxLevels = new Array(levelCount);
        var levelByteLength = levelCount * 3 * 8;
        var levelReader = new BufferReader(data, headerBufferReader.offset, levelByteLength);
        this.levels = ktxLevels;
        for(var i = 0; i < levelCount; i++){
            ktxLevels[i] = {
                levelData: new Uint8Array(buffer, byteOffset + levelReader.nextUint64(), levelReader.nextUint64()),
                uncompressedByteLength: levelReader.nextUint64()
            };
        }
        // Data Format Descriptor (DFD).
        var dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength);
        var dfd = {
            vendorId: dfdReader.skip(4 /* totalSize */ ).nextUint16(),
            descriptorType: dfdReader.nextUint16(),
            versionNumber: dfdReader.nextUint16(),
            descriptorBlockSize: dfdReader.nextUint16(),
            colorModel: dfdReader.nextUint8(),
            colorPrimaries: dfdReader.nextUint8(),
            transferFunction: dfdReader.nextUint8(),
            flags: dfdReader.nextUint8(),
            texelBlockDimension: [
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8()
            ],
            bytesPlane: [
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8(),
                dfdReader.nextUint8()
            ],
            samples: []
        };
        this.dataFormatDescriptor = dfd;
        var sampleStart = 6;
        var sampleWords = 4;
        var numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
        for(var i1 = 0; i1 < numSamples; i1++){
            var sample = {
                bitOffset: dfdReader.nextUint16(),
                bitLength: dfdReader.nextUint8(),
                channelType: dfdReader.nextUint8(),
                samplePosition: [
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8(),
                    dfdReader.nextUint8()
                ],
                sampleLower: -Infinity,
                sampleUpper: Infinity
            };
            if (sample.channelType & 0x40) {
                sample.sampleLower = dfdReader.nextInt32();
                sample.sampleUpper = dfdReader.nextInt32();
            } else {
                sample.sampleLower = dfdReader.nextUint32();
                sample.sampleUpper = dfdReader.nextUint32();
            }
            dfd.samples[i1] = sample;
        }
        var kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
        while(kvdReader.position < kvdByteLength){
            var keyValueByteLength = kvdReader.nextUint32();
            var keyData = kvdReader.scan(keyValueByteLength);
            var key = Utils.decodeText(keyData);
            // 4-byte alignment.
            var valueData = kvdReader.nextUint8Array(keyValueByteLength - keyData.byteLength - 1);
            this.keyValue[key] = key.match(/^ktx/i) ? Utils.decodeText(valueData).replace(/^(.*)\x00$/, "$1") : valueData;
            var kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0; // align(4)
            // 4-byte alignment.
            kvdReader.skip(kvPadding);
        }
        if (sgdByteLength <= 0) return this;
        var sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
        var endpointCount = sgdReader.nextUint16();
        var selectorCount = sgdReader.nextUint16();
        var endpointsByteLength = sgdReader.nextUint32();
        var selectorsByteLength = sgdReader.nextUint32();
        var tablesByteLength = sgdReader.nextUint32();
        var extendedByteLength = sgdReader.nextUint32();
        var imageDescs = new Array(levelCount);
        for(var i2 = 0; i2 < levelCount; i2++){
            imageDescs[i2] = {
                imageFlags: sgdReader.nextUint32(),
                rgbSliceByteOffset: sgdReader.nextUint32(),
                rgbSliceByteLength: sgdReader.nextUint32(),
                alphaSliceByteOffset: sgdReader.nextUint32(),
                alphaSliceByteLength: sgdReader.nextUint32()
            };
        }
        var endpointsByteOffset = sgdByteOffset + sgdReader.position;
        var selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
        var tablesByteOffset = selectorsByteOffset + selectorsByteLength;
        var extendedByteOffset = tablesByteOffset + tablesByteLength;
        var endpointsData = new Uint8Array(buffer, byteOffset + endpointsByteOffset, endpointsByteLength);
        var selectorsData = new Uint8Array(buffer, byteOffset + selectorsByteOffset, selectorsByteLength);
        var tablesData = new Uint8Array(buffer, byteOffset + tablesByteOffset, tablesByteLength);
        var extendedData = new Uint8Array(buffer, byteOffset + extendedByteOffset, extendedByteLength);
        this.globalData = {
            endpointCount: endpointCount,
            selectorCount: selectorCount,
            imageDescs: imageDescs,
            endpointsData: endpointsData,
            selectorsData: selectorsData,
            tablesData: tablesData,
            extendedData: extendedData
        };
    };
    _create_class(KTX2Container, [
        {
            key: "isSRGB",
            get: function get() {
                return this.dataFormatDescriptor.transferFunction === 2;
            }
        },
        {
            key: "isUASTC",
            get: function get() {
                return this.dataFormatDescriptor.colorModel === 166;
            }
        }
    ]);
    return KTX2Container;
}();

/**
 * KTX2 transcode target format.
 */ var KTX2TargetFormat = /*#__PURE__*/ function(KTX2TargetFormat) {
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ KTX2TargetFormat[KTX2TargetFormat["ASTC"] = 0] = "ASTC";
    /** RGB(A) compressed format, 128 bits per 4x4 pixel block. */ KTX2TargetFormat[KTX2TargetFormat["BC7"] = 1] = "BC7";
    /** RGB(A) compressed format, 4 bits per pixel if no alpha channel, 8 bits per pixel if has alpha channel. */ KTX2TargetFormat[KTX2TargetFormat["BC1_BC3"] = 2] = "BC1_BC3";
    /** RGB(A) compressed format, 4 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["PVRTC"] = 3] = "PVRTC";
    /** RGB(A) compressed format, 4 bits per pixel if no alpha channel, 8 bits per pixel if has alpha channel. */ KTX2TargetFormat[KTX2TargetFormat["ETC"] = 4] = "ETC";
    /** R format, 8 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8"] = 5] = "R8";
    /** RG format, 16 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8G8"] = 6] = "R8G8";
    /** RGBA format, 32 bits per pixel. */ KTX2TargetFormat[KTX2TargetFormat["R8G8B8A8"] = 7] = "R8G8B8A8";
    return KTX2TargetFormat;
}({});

/**
 * @internal
 * WorkerPool, T is is post message type, U is return type.
 */ var WorkerPool = /*#__PURE__*/ function() {
    function WorkerPool(limitedCount, _workerCreator) {
        if (limitedCount === void 0) limitedCount = 4;
        this.limitedCount = limitedCount;
        this._workerCreator = _workerCreator;
        this._taskQueue = [];
        this._workerStatus = 0;
        this._workerItems = new Array(limitedCount);
    }
    var _proto = WorkerPool.prototype;
    _proto.prepareWorker = function prepareWorker() {
        var count = this.limitedCount;
        var promises = new Array(count);
        for(var i = 0; i < count; i++){
            promises.push(this._initWorker(i));
        }
        return Promise.all(promises);
    };
    /**
   * Post message to worker.
   * @param message - Message which posted to worker
   * @returns Return a promise of message
   */ _proto.postMessage = function postMessage(message) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var workerId = _this._getIdleWorkerId();
            if (workerId !== -1) {
                _this._workerStatus |= 1 << workerId;
                var workerItems = _this._workerItems;
                var _workerItems_workerId;
                Promise.resolve((_workerItems_workerId = workerItems[workerId]) != null ? _workerItems_workerId : _this._initWorker(workerId)).then(function() {
                    var workerItem = workerItems[workerId];
                    workerItem.resolve = resolve;
                    workerItem.reject = reject;
                    workerItem.worker.postMessage(message);
                }).catch(reject);
            } else {
                _this._taskQueue.push({
                    resolve: resolve,
                    reject: reject,
                    message: message
                });
            }
        });
    };
    /**
   * Destroy the worker pool.
   */ _proto.destroy = function destroy() {
        var workerItems = this._workerItems;
        for(var i = 0, n = workerItems.length; i < n; i++){
            var workerItem = workerItems[i];
            workerItem.worker.terminate();
            workerItem.reject = null;
            workerItem.resolve = null;
        }
        workerItems.length = 0;
        this._taskQueue.length = 0;
        this._workerStatus = 0;
    };
    _proto._initWorker = function _initWorker(workerId) {
        var _this = this;
        return Promise.resolve(this._workerCreator()).then(function(worker) {
            worker.addEventListener("message", _this._onMessage.bind(_this, workerId));
            _this._workerItems[workerId] = {
                worker: worker,
                resolve: null,
                reject: null
            };
            return worker;
        });
    };
    _proto._getIdleWorkerId = function _getIdleWorkerId() {
        for(var i = 0, count = this.limitedCount; i < count; i++){
            if (!(this._workerStatus & 1 << i)) return i;
        }
        return -1;
    };
    _proto._onMessage = function _onMessage(workerId, msg) {
        // onerror of web worker can't catch error in promise
        var error = msg.data.error;
        if (error) {
            this._workerItems[workerId].reject(error);
        } else {
            this._workerItems[workerId].resolve(msg.data);
        }
        this._nextTask(workerId);
    };
    _proto._nextTask = function _nextTask(workerId) {
        if (this._taskQueue.length) {
            var taskItem = this._taskQueue.shift();
            var workerItem = this._workerItems[workerId];
            workerItem.resolve = taskItem.resolve;
            workerItem.reject = taskItem.reject;
            workerItem.worker.postMessage(taskItem.message);
        } else {
            this._workerStatus ^= 1 << workerId;
        }
    };
    return WorkerPool;
}();

var AbstractTranscoder = /*#__PURE__*/ function() {
    function AbstractTranscoder(workerLimitCount) {
        this.workerLimitCount = workerLimitCount;
    }
    var _proto = AbstractTranscoder.prototype;
    _proto.init = function init() {
        if (!this._initPromise) {
            this._initPromise = this._initTranscodeWorkerPool();
        }
        return this._initPromise;
    };
    _proto.destroy = function destroy() {
        this._transcodeWorkerPool.destroy();
    };
    _proto._createTranscodePool = function _createTranscodePool(workerURL, wasmBuffer) {
        this._transcodeWorkerPool = new WorkerPool(this.workerLimitCount, function() {
            return new Promise(function(resolve, reject) {
                var onMessage = function onMessage(e) {
                    if (e.data.error) {
                        reject(e.data.error);
                    } else {
                        resolve(worker);
                    }
                };
                var worker = new Worker(workerURL);
                var msg = {
                    type: "init",
                    transcoderWasm: wasmBuffer
                };
                worker.addEventListener("message", onMessage);
                worker.postMessage(msg);
            });
        });
        return this._transcodeWorkerPool.prepareWorker();
    };
    return AbstractTranscoder;
}();

/** @internal */ function TranscodeWorkerCode$1() {
    var initPromise;
    var init = function init(wasmBinary) {
        if (!initPromise) {
            initPromise = new Promise(function(resolve, reject) {
                var BasisModule = {
                    wasmBinary: wasmBinary,
                    onRuntimeInitialized: function() {
                        return resolve(BasisModule);
                    },
                    onAbort: reject
                };
                self["BASIS"](BasisModule);
            }).then(function(BasisModule) {
                BasisModule.initializeBasis();
                return BasisModule.KTX2File;
            });
        }
        return initPromise;
    };
    self.onmessage = function onmessage(event) {
        var message = event.data;
        switch(message.type){
            case "init":
                init(message.transcoderWasm).then(function() {
                    self.postMessage("init-completed");
                }).catch(function(e) {
                    return self.postMessage({
                        error: e
                    });
                });
                break;
            case "transcode":
                init().then(function(KTX2File) {
                    var result = transcode(message.buffer, message.format, KTX2File);
                    // @ts-ignore
                    result.type = "transcoded";
                    self.postMessage(result);
                }).catch(function(e) {
                    return self.postMessage({
                        error: e
                    });
                });
                break;
        }
    };
}
var _init = function init() {
    var initPromise;
    return function init(wasmBinary) {
        if (!initPromise) {
            initPromise = new Promise(function(resolve, reject) {
                var BasisModule = {
                    wasmBinary: wasmBinary,
                    onRuntimeInitialized: function() {
                        return resolve(BasisModule);
                    },
                    onAbort: reject
                };
                self["BASIS"](BasisModule);
            }).then(function(BasisModule) {
                BasisModule.initializeBasis();
                return BasisModule.KTX2File;
            });
        }
        return initPromise;
    };
};
var init = _init();
function transcode(buffer, targetFormat, KTX2File) {
    function getTranscodeFormatFromTarget(target, hasAlpha) {
        switch(target){
            case 2:
                return hasAlpha ? 3 : 2;
            case 4:
                return hasAlpha ? 1 : 0;
            case 3:
                return hasAlpha ? 9 : 8;
            case 7:
                return 13;
            case 0:
                return 10;
            case 1:
                return 7;
        }
    }
    function concat(arrays) {
        if (arrays.length === 1) return arrays[0];
        var totalByteLength = 0;
        for(var i = 0; i < arrays.length; i++){
            totalByteLength += arrays[i].byteLength;
        }
        var result = new Uint8Array(totalByteLength);
        var byteOffset = 0;
        for(var i1 = 0; i1 < arrays.length; i1++){
            result.set(arrays[i1], byteOffset);
            byteOffset += arrays[i1].byteLength;
        }
        return result;
    }
    var ktx2File = new KTX2File(new Uint8Array(buffer));
    function cleanup() {
        ktx2File.close();
        ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
        cleanup();
        throw new Error("Invalid or unsupported .ktx2 file");
    }
    if (!ktx2File.startTranscoding()) {
        cleanup();
        throw new Error("KTX2 startTranscoding failed");
    }
    var width = ktx2File.getWidth();
    var height = ktx2File.getHeight();
    var layerCount = ktx2File.getLayers() || 1;
    var levelCount = ktx2File.getLevels();
    var hasAlpha = ktx2File.getHasAlpha();
    var faceCount = ktx2File.getFaces();
    var format = getTranscodeFormatFromTarget(targetFormat, hasAlpha);
    var faces = new Array(faceCount);
    var isBC = format === 2 || format === 3 || format === 7;
    for(var face = 0; face < faceCount; face++){
        var mipmaps = new Array(levelCount);
        for(var mip = 0; mip < levelCount; mip++){
            var layerMips = new Array(layerCount);
            var mipWidth = void 0, mipHeight = void 0;
            for(var layer = 0; layer < layerCount; layer++){
                var levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
                // see: https://github.com/KhronosGroup/KTX-Software/issues/254
                if (isBC && mip === 0 && (width !== levelInfo.width || height !== levelInfo.height)) {
                    width = mipWidth = levelInfo.width;
                    height = mipHeight = levelInfo.height;
                    console.warn("KTX2 transcode to BC will resize to width: " + width + ", height: " + height + ". You'd better use an image whose size if multiple of 4.");
                } else {
                    mipWidth = levelInfo.origWidth;
                    mipHeight = levelInfo.origHeight;
                }
                var dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, format));
                var status = ktx2File.transcodeImage(dst, mip, layer, face, format, 0, -1, -1);
                if (!status) {
                    cleanup();
                    throw new Error("transcodeImage failed.");
                }
                layerMips[layer] = dst;
            }
            mipmaps[mip] = {
                data: concat(layerMips),
                width: mipWidth,
                height: mipHeight
            };
        }
        faces[face] = mipmaps;
    }
    cleanup();
    return {
        faces: faces,
        width: width,
        height: height,
        hasAlpha: hasAlpha,
        faceCount: faceCount,
        format: format
    };
}

/** @internal */ var BinomialLLCTranscoder = /*#__PURE__*/ function(AbstractTranscoder) {
    _inherits(BinomialLLCTranscoder, AbstractTranscoder);
    function BinomialLLCTranscoder(workerLimitCount) {
        return AbstractTranscoder.call(this, workerLimitCount) || this;
    }
    var _proto = BinomialLLCTranscoder.prototype;
    _proto._initTranscodeWorkerPool = function _initTranscodeWorkerPool() {
        var _this = this;
        return Promise.all([
            fetch("https://mdn.alipayobjects.com/rms/afts/file/A*nG8SR6vCgXgAAAAAAAAAAAAAARQnAQ/basis_transcoder.js").then(function(res) {
                return res.text();
            }),
            fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qEUfQ7317KsAAAAAAAAAAAAAARQnAQ/basis_transcoder.wasm").then(function(res) {
                return res.arrayBuffer();
            })
        ]).then(function(param) {
            var jsCode = param[0], wasmBuffer = param[1];
            if (_this.workerLimitCount === 0) {
                return new Promise(function(resolve, reject) {
                    var scriptDom = document.createElement("script");
                    scriptDom.src = URL.createObjectURL(new Blob([
                        jsCode
                    ], {
                        type: "application/javascript"
                    }));
                    document.body.appendChild(scriptDom);
                    scriptDom.onload = function() {
                        init(wasmBuffer).then(function() {
                            resolve(null);
                        });
                    };
                    scriptDom.onerror = function() {
                        reject();
                    };
                });
            } else {
                var funcCode = TranscodeWorkerCode$1.toString();
                var transcodeString = funcCode.substring(funcCode.indexOf("{"), funcCode.lastIndexOf("}") + 1);
                var workerCode = "\n        " + jsCode + "\n        " + transcode.toString() + "\n        " + transcodeString + "\n        ";
                var workerURL = URL.createObjectURL(new Blob([
                    workerCode
                ], {
                    type: "application/javascript"
                }));
                return _this._createTranscodePool(workerURL, wasmBuffer);
            }
        });
    };
    _proto.transcode = function transcode1(buffer, format) {
        if (this.workerLimitCount === 0) {
            return init().then(function(KTX2File) {
                return transcode(buffer, format, KTX2File);
            });
        } else {
            return this._transcodeWorkerPool.postMessage({
                buffer: buffer,
                format: format,
                type: "transcode"
            });
        }
    };
    return BinomialLLCTranscoder;
}(AbstractTranscoder);

function TranscodeWorkerCode() {
    var wasmPromise;
    /**
   * ZSTD (Zstandard) decoder.
   */ var ZSTDDecoder = /*#__PURE__*/ function() {
        function ZSTDDecoder() {}
        var _proto = ZSTDDecoder.prototype;
        _proto.init = function init() {
            if (!this._initPromise) {
                this._initPromise = fetch(ZSTDDecoder.WasmModuleURL).then(function(response) {
                    if (response.ok) {
                        return response.arrayBuffer();
                    }
                    throw new Error("Could not fetch the wasm component for the Zstandard decompression lib: " + response.status + " - " + response.statusText);
                }).then(function(arrayBuffer) {
                    return WebAssembly.instantiate(arrayBuffer, ZSTDDecoder.IMPORT_OBJECT);
                }).then(this._init);
            }
            return this._initPromise;
        };
        _proto._init = function _init(result) {
            ZSTDDecoder.instance = result.instance;
            ZSTDDecoder.IMPORT_OBJECT.env.emscripten_notify_memory_growth(); // initialize heap.
        };
        _proto.decode = function decode(array, uncompressedSize) {
            if (uncompressedSize === void 0) uncompressedSize = 0;
            if (!ZSTDDecoder.instance) {
                throw new Error("ZSTDDecoder: Await .init() before decoding.");
            }
            var exports = ZSTDDecoder.instance.exports;
            // Write compressed data into WASM memory
            var compressedSize = array.byteLength;
            var compressedPtr = exports.malloc(compressedSize);
            ZSTDDecoder.heap.set(array, compressedPtr);
            // Decompress into WASM memory
            uncompressedSize = uncompressedSize || Number(exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));
            var uncompressedPtr = exports.malloc(uncompressedSize);
            var actualSize = exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);
            // Read decompressed data and free WASM memory
            var dec = ZSTDDecoder.heap.slice(uncompressedPtr, uncompressedPtr + actualSize);
            exports.free(compressedPtr);
            exports.free(uncompressedPtr);
            return dec;
        };
        return ZSTDDecoder;
    }();
    ZSTDDecoder.IMPORT_OBJECT = {
        env: {
            emscripten_notify_memory_growth: function emscripten_notify_memory_growth() {
                ZSTDDecoder.heap = new Uint8Array(ZSTDDecoder.instance.exports.memory.buffer);
            }
        }
    };
    ZSTDDecoder.WasmModuleURL = "https://mdn.alipayobjects.com/rms/afts/file/A*awNJR7KqIAEAAAAAAAAAAAAAARQnAQ/zstddec.wasm";
    function transcodeASTCAndBC7(wasmTranscoder, compressedData, width, height) {
        var nBlocks = (width + 3 >> 2) * (height + 3 >> 2);
        var texMemoryPages = nBlocks * 16 + 65535 >> 16;
        var memory = wasmTranscoder.memory;
        var delta = texMemoryPages + 1 - (memory.buffer.byteLength >> 16);
        if (delta > 0) memory.grow(delta);
        var textureView = new Uint8Array(memory.buffer, 65536, nBlocks * 16);
        textureView.set(compressedData);
        return wasmTranscoder.transcode(nBlocks) === 0 ? textureView : null;
    }
    function initWasm(buffer) {
        wasmPromise = WebAssembly.instantiate(buffer, {
            env: {
                memory: new WebAssembly.Memory({
                    initial: 16
                })
            }
        }).then(function(moduleWrapper) {
            return moduleWrapper.instance.exports;
        });
        return wasmPromise;
    }
    var zstdDecoder = new ZSTDDecoder();
    function transcode(data, needZstd, wasmModule) {
        var faceCount = data.length;
        var result = new Array(faceCount);
        var promise = Promise.resolve();
        if (needZstd) {
            zstdDecoder.init();
            promise = zstdDecoder._initPromise;
        }
        return promise.then(function() {
            for(var faceIndex = 0; faceIndex < faceCount; faceIndex++){
                var mipmapCount = data[faceIndex].length;
                var decodedData = new Array(mipmapCount);
                for(var i = 0; i < mipmapCount; i++){
                    var _data_faceIndex_i = data[faceIndex][i], buffer = _data_faceIndex_i.buffer, levelHeight = _data_faceIndex_i.levelHeight, levelWidth = _data_faceIndex_i.levelWidth, uncompressedByteLength = _data_faceIndex_i.uncompressedByteLength;
                    if (needZstd) buffer = zstdDecoder.decode(buffer.slice(), uncompressedByteLength);
                    var faceByteLength = buffer.byteLength / faceCount;
                    var originByteOffset = buffer.byteOffset;
                    var decodedBuffer = transcodeASTCAndBC7(wasmModule, new Uint8Array(buffer.buffer, originByteOffset + faceIndex * faceByteLength, faceByteLength), levelWidth, levelHeight);
                    if (decodedBuffer) {
                        decodedData[i] = {
                            // use wasm memory as buffer, should slice to avoid duplicate
                            data: decodedBuffer.slice(),
                            width: levelWidth,
                            height: levelHeight
                        };
                    } else {
                        throw "buffer decoded error";
                    }
                }
                result[faceIndex] = decodedData;
            }
            return result;
        });
    }
    self.onmessage = function onmessage(event) {
        var message = event.data;
        switch(message.type){
            case "init":
                initWasm(message.transcoderWasm).then(function() {
                    self.postMessage("init-completed");
                }).catch(function(e) {
                    self.postMessage({
                        error: e
                    });
                });
                break;
            case "transcode":
                wasmPromise.then(function(module) {
                    transcode(message.data, message.needZstd, module).then(function(decodedData) {
                        self.postMessage(decodedData);
                    }).catch(function(e) {
                        return self.postMessage({
                            error: e
                        });
                    });
                });
                break;
        }
    };
}

/** @internal */ var KhronosTranscoder = /*#__PURE__*/ function(AbstractTranscoder) {
    _inherits(KhronosTranscoder, AbstractTranscoder);
    function KhronosTranscoder(workerLimitCount, type) {
        var _this;
        _this = AbstractTranscoder.call(this, workerLimitCount) || this, _this.type = type;
        return _this;
    }
    var _proto = KhronosTranscoder.prototype;
    _proto._initTranscodeWorkerPool = function _initTranscodeWorkerPool() {
        var _this = this;
        return fetch(KhronosTranscoder.transcoderMap[this.type]).then(function(res) {
            return res.arrayBuffer();
        }).then(function(wasmBuffer) {
            var funcCode = TranscodeWorkerCode.toString();
            var workerURL = URL.createObjectURL(new Blob([
                funcCode.substring(funcCode.indexOf("{") + 1, funcCode.lastIndexOf("}"))
            ], {
                type: "application/javascript"
            }));
            return _this._createTranscodePool(workerURL, wasmBuffer);
        });
    };
    _proto.transcode = function transcode(ktx2Container) {
        var needZstd = ktx2Container.supercompressionScheme === SupercompressionScheme.Zstd;
        var levelCount = ktx2Container.levels.length;
        var faceCount = ktx2Container.faceCount;
        var decodedData = {
            width: ktx2Container.pixelWidth,
            height: ktx2Container.pixelHeight,
            mipmaps: null
        };
        var postMessageData = {
            type: "transcode",
            format: 0,
            needZstd: needZstd,
            data: new Array(faceCount)
        };
        var messageData = postMessageData.data;
        for(var faceIndex = 0; faceIndex < faceCount; faceIndex++){
            var mipmapData = new Array(levelCount);
            for(var mipmapIndex = 0; mipmapIndex < levelCount; mipmapIndex++){
                var level = ktx2Container.levels[mipmapIndex];
                var levelWidth = Math.floor(ktx2Container.pixelWidth / (1 << mipmapIndex)) || 1;
                var levelHeight = Math.floor(ktx2Container.pixelHeight / (1 << mipmapIndex)) || 1;
                var originBuffer = level.levelData.buffer;
                var originOffset = level.levelData.byteOffset;
                var originByteLength = level.levelData.byteLength;
                mipmapData[mipmapIndex] = {
                    buffer: new Uint8Array(originBuffer, originOffset, originByteLength),
                    levelWidth: levelWidth,
                    levelHeight: levelHeight,
                    uncompressedByteLength: level.uncompressedByteLength
                };
            }
            messageData[faceIndex] = mipmapData;
        }
        return this._transcodeWorkerPool.postMessage(postMessageData).then(function(data) {
            decodedData.faces = data;
            decodedData.hasAlpha = true;
            return decodedData;
        });
    };
    return KhronosTranscoder;
}(AbstractTranscoder);
var _obj$2;
KhronosTranscoder.transcoderMap = (_obj$2 = {}, // TODO: support bc7
_obj$2[KTX2TargetFormat.ASTC] = "https://mdn.alipayobjects.com/rms/afts/file/A*0jiKRK6D1-kAAAAAAAAAAAAAARQnAQ/uastc_astc.wasm", _obj$2);

var KTX2Loader = /*#__PURE__*/ function(Loader) {
    _inherits(KTX2Loader, Loader);
    function KTX2Loader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTX2Loader.prototype;
    _proto.initialize = function initialize(_, configuration) {
        if (configuration.ktx2Loader) {
            var options = configuration.ktx2Loader;
            if (options.priorityFormats) {
                KTX2Loader._priorityFormats["etc1s"] = options.priorityFormats;
                KTX2Loader._priorityFormats["uastc"] = options.priorityFormats;
            }
            if (options.transcoder === 1) {
                return KTX2Loader._getKhronosTranscoder(options.workerCount).init();
            } else {
                return KTX2Loader._getBinomialLLCTranscoder(options.workerCount).init();
            }
        }
    };
    /**
   * @internal
   */ _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
            resourceManager// @ts-ignore
            ._request(item.url, {
                type: "arraybuffer"
            }).onProgress(setTaskCompleteProgress, setTaskDetailProgress).then(function(buffer) {
                return KTX2Loader._parseBuffer(new Uint8Array(buffer), resourceManager.engine, item.params).then(function(param) {
                    var engine = param.engine, result = param.result, targetFormat = param.targetFormat, params = param.params;
                    return KTX2Loader._createTextureByBuffer(engine, result, targetFormat, params);
                });
            }).then(resolve).catch(reject);
        });
    };
    /**
   * Release ktx2 transcoder worker.
   * @remarks If use loader after releasing, we should release again.
   */ KTX2Loader.release = function release() {
        if (this._binomialLLCTranscoder) this._binomialLLCTranscoder.destroy();
        if (this._khronosTranscoder) this._khronosTranscoder.destroy();
        this._binomialLLCTranscoder = null;
        this._khronosTranscoder = null;
        this._isBinomialInit = false;
    };
    /** @internal */ KTX2Loader._parseBuffer = function _parseBuffer(buffer, engine, params) {
        var ktx2Container = new KTX2Container(buffer);
        var _params_priorityFormats;
        var formatPriorities = (_params_priorityFormats = params == null ? void 0 : params.priorityFormats) != null ? _params_priorityFormats : KTX2Loader._priorityFormats[ktx2Container.isUASTC ? "uastc" : "etc1s"];
        var targetFormat = KTX2Loader._decideTargetFormat(engine, ktx2Container, formatPriorities);
        var transcodeResultPromise;
        if (KTX2Loader._isBinomialInit || !KhronosTranscoder.transcoderMap[targetFormat] || !ktx2Container.isUASTC) {
            var binomialLLCWorker = KTX2Loader._getBinomialLLCTranscoder();
            transcodeResultPromise = binomialLLCWorker.init().then(function() {
                return binomialLLCWorker.transcode(buffer, targetFormat);
            });
        } else {
            var khronosWorker = KTX2Loader._getKhronosTranscoder();
            transcodeResultPromise = khronosWorker.init().then(function() {
                return khronosWorker.transcode(ktx2Container);
            });
        }
        return transcodeResultPromise.then(function(result) {
            return {
                engine: engine,
                result: result,
                targetFormat: targetFormat,
                params: ktx2Container.keyValue["GalaceanTextureParams"]
            };
        });
    };
    /** @internal */ KTX2Loader._createTextureByBuffer = function _createTextureByBuffer(engine, transcodeResult, targetFormat, params) {
        var width = transcodeResult.width, height = transcodeResult.height, faces = transcodeResult.faces;
        var faceCount = faces.length;
        var mipmaps = faces[0];
        var mipmap = mipmaps.length > 1;
        var engineFormat = this._getEngineTextureFormat(targetFormat, transcodeResult);
        var texture;
        if (faceCount !== 6) {
            texture = new Texture2D(engine, width, height, engineFormat, mipmap);
            for(var mipLevel = 0; mipLevel < mipmaps.length; mipLevel++){
                var data = mipmaps[mipLevel].data;
                texture.setPixelBuffer(data, mipLevel);
            }
        } else {
            texture = new TextureCube(engine, height, engineFormat, mipmap);
            for(var i = 0; i < faces.length; i++){
                var faceData = faces[i];
                for(var mipLevel1 = 0; mipLevel1 < mipmaps.length; mipLevel1++){
                    texture.setPixelBuffer(TextureCubeFace.PositiveX + i, faceData[mipLevel1].data, mipLevel1);
                }
            }
        }
        if (params) {
            texture.wrapModeU = params[0];
            texture.wrapModeV = params[1];
            texture.filterMode = params[2];
            texture.anisoLevel = params[3];
        }
        return texture;
    };
    KTX2Loader._decideTargetFormat = function _decideTargetFormat(engine, ktx2Container, priorityFormats) {
        var renderer = engine._hardwareRenderer;
        var targetFormat = this._detectSupportedFormat(renderer, priorityFormats);
        if (targetFormat === KTX2TargetFormat.PVRTC && (!MathUtil.isPowerOf2(ktx2Container.pixelWidth) || !MathUtil.isPowerOf2(ktx2Container.pixelHeight) || ktx2Container.pixelWidth !== ktx2Container.pixelHeight)) {
            Logger.warn("PVRTC image need power of 2 and width===height, downgrade to RGBA8");
            return KTX2TargetFormat.R8G8B8A8;
        }
        if (targetFormat === null) {
            Logger.warn("Can't support any compressed texture, downgrade to RGBA8");
            return KTX2TargetFormat.R8G8B8A8;
        }
        return targetFormat;
    };
    KTX2Loader._detectSupportedFormat = function _detectSupportedFormat(renderer, priorityFormats) {
        for(var i = 0; i < priorityFormats.length; i++){
            var format = priorityFormats[i];
            var capabilities = this._supportedMap[format];
            if (capabilities) {
                for(var j = 0; j < capabilities.length; j++){
                    if (renderer.canIUse(capabilities[j])) {
                        return format;
                    }
                }
            } else {
                switch(priorityFormats[i]){
                    case KTX2TargetFormat.R8G8B8A8:
                        return format;
                    case KTX2TargetFormat.R8:
                    case KTX2TargetFormat.R8G8:
                        if (renderer.isWebGL2) return format;
                }
            }
        }
        return null;
    };
    KTX2Loader._getBinomialLLCTranscoder = function _getBinomialLLCTranscoder(workerCount) {
        if (workerCount === void 0) workerCount = 4;
        KTX2Loader._isBinomialInit = true;
        var _this__binomialLLCTranscoder;
        return (_this__binomialLLCTranscoder = this._binomialLLCTranscoder) != null ? _this__binomialLLCTranscoder : this._binomialLLCTranscoder = new BinomialLLCTranscoder(workerCount);
    };
    KTX2Loader._getKhronosTranscoder = function _getKhronosTranscoder(workerCount) {
        if (workerCount === void 0) workerCount = 4;
        var _this__khronosTranscoder;
        return (_this__khronosTranscoder = this._khronosTranscoder) != null ? _this__khronosTranscoder : this._khronosTranscoder = new KhronosTranscoder(workerCount, KTX2TargetFormat.ASTC);
    };
    KTX2Loader._getEngineTextureFormat = function _getEngineTextureFormat(basisFormat, transcodeResult) {
        var hasAlpha = transcodeResult.hasAlpha;
        switch(basisFormat){
            case KTX2TargetFormat.ASTC:
                return TextureFormat.ASTC_4x4;
            case KTX2TargetFormat.ETC:
                return hasAlpha ? TextureFormat.ETC2_RGBA8 : TextureFormat.ETC2_RGB;
            case KTX2TargetFormat.BC7:
                return TextureFormat.BC7;
            case KTX2TargetFormat.BC1_BC3:
                return hasAlpha ? TextureFormat.BC3 : TextureFormat.BC1;
            case KTX2TargetFormat.PVRTC:
                return hasAlpha ? TextureFormat.PVRTC_RGBA4 : TextureFormat.PVRTC_RGB4;
            case KTX2TargetFormat.R8G8B8A8:
                return TextureFormat.R8G8B8A8;
        }
    };
    return KTX2Loader;
}(Loader);
KTX2Loader._isBinomialInit = false;
KTX2Loader._priorityFormats = {
    etc1s: [
        KTX2TargetFormat.ETC,
        KTX2TargetFormat.BC7,
        KTX2TargetFormat.ASTC,
        KTX2TargetFormat.BC1_BC3,
        KTX2TargetFormat.PVRTC
    ],
    uastc: [
        KTX2TargetFormat.ASTC,
        KTX2TargetFormat.BC7,
        KTX2TargetFormat.ETC,
        KTX2TargetFormat.BC1_BC3,
        KTX2TargetFormat.PVRTC
    ]
};
var _obj$1;
KTX2Loader._supportedMap = (_obj$1 = {}, _obj$1[KTX2TargetFormat.ASTC] = [
    GLCapabilityType.astc
], _obj$1[KTX2TargetFormat.ETC] = [
    GLCapabilityType.etc
], _obj$1[KTX2TargetFormat.BC7] = [
    GLCapabilityType.bptc
], _obj$1[KTX2TargetFormat.BC1_BC3] = [
    GLCapabilityType.s3tc
], _obj$1[KTX2TargetFormat.PVRTC] = [
    GLCapabilityType.pvrtc,
    GLCapabilityType.pvrtc_webkit
], _obj$1);
KTX2Loader = __decorate([
    resourceLoader(AssetType.KTX2, [
        "ktx2"
    ])
], KTX2Loader);
/** Used for initialize KTX2 transcoder. */ var KTX2Transcoder = /*#__PURE__*/ function(KTX2Transcoder) {
    /** BinomialLLC transcoder. */ KTX2Transcoder[KTX2Transcoder["BinomialLLC"] = 0] = "BinomialLLC";
    /** Khronos transcoder. */ KTX2Transcoder[KTX2Transcoder["Khronos"] = 1] = "Khronos";
    return KTX2Transcoder;
}({});

/**
 * @internal
 */ var GLTFContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GLTFContentRestorer, ContentRestorer);
    function GLTFContentRestorer() {
        var _this;
        _this = ContentRestorer.apply(this, arguments) || this, _this.bufferRequests = [], _this.glbBufferSlices = [], _this.bufferTextures = [], _this.meshes = [];
        return _this;
    }
    var _proto = GLTFContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.bufferRequests.map(function(bufferRequestInfo) {
                return request(bufferRequestInfo.url, bufferRequestInfo.config);
            })).then(function(buffers) {
                // Buffer parse
                if (_this.isGLB) {
                    var glbBufferSlice = _this.glbBufferSlices;
                    var bigBuffer = buffers[0];
                    var bufferCount = glbBufferSlice.length;
                    buffers.length = bufferCount;
                    for(var i = 0; i < bufferCount; i++){
                        var slice = glbBufferSlice[i];
                        buffers[i] = bigBuffer.slice(slice.x, slice.x + slice.y);
                    }
                }
                // Restore texture
                AssetPromise.all(_this.bufferTextures.map(function(textureRestoreInfo) {
                    var bufferView = textureRestoreInfo.bufferView;
                    var buffer = buffers[bufferView.buffer];
                    var _bufferView_byteOffset;
                    var bufferData = new Uint8Array(buffer, (_bufferView_byteOffset = bufferView.byteOffset) != null ? _bufferView_byteOffset : 0, bufferView.byteLength);
                    var texture = textureRestoreInfo.texture;
                    if (textureRestoreInfo.mimeType === "image/ktx2") {
                        return KTX2Loader._parseBuffer(bufferData, texture.engine).then(function(param) {
                            var result = param.result;
                            var faces = result.faces;
                            var mipmaps = faces[0];
                            for(var i = 0; i < mipmaps.length; i++){
                                texture.setPixelBuffer(mipmaps[i].data, i);
                            }
                        });
                    } else {
                        return GLTFUtils.loadImageBuffer(bufferData, textureRestoreInfo.mimeType).then(function(image) {
                            texture.setImageSource(image);
                            texture.generateMipmaps();
                        });
                    }
                })).then(function() {
                    // Restore mesh
                    for(var _iterator = _create_for_of_iterator_helper_loose(_this.meshes), _step; !(_step = _iterator()).done;){
                        var meshInfo = _step.value;
                        var mesh = meshInfo.mesh;
                        for(var _iterator1 = _create_for_of_iterator_helper_loose(meshInfo.vertexBuffers), _step1; !(_step1 = _iterator1()).done;){
                            var bufferRestoreInfo = _step1.value;
                            var vertexData = _this._getBufferData(buffers, bufferRestoreInfo.data);
                            bufferRestoreInfo.buffer.setData(vertexData);
                        }
                        if (meshInfo.indexBuffer) {
                            var indexData = _this._getBufferData(buffers, meshInfo.indexBuffer);
                            mesh.setIndices(indexData);
                        }
                        for(var _iterator2 = _create_for_of_iterator_helper_loose(meshInfo.blendShapes), _step2; !(_step2 = _iterator2()).done;){
                            var restoreInfo = _step2.value;
                            var frame = restoreInfo.blendShape.frames[0];
                            var position = restoreInfo.position;
                            var positionData = _this._getBufferData(buffers, position.buffer);
                            frame.deltaPositions = GLTFUtils.bufferToVector3Array(positionData, position.byteOffset, position.count, position.normalized, position.componentType);
                            if (restoreInfo.normal) {
                                var normal = restoreInfo.normal;
                                var normalData = _this._getBufferData(buffers, normal.buffer);
                                frame.deltaNormals = GLTFUtils.bufferToVector3Array(normalData, normal.byteOffset, normal.count, normal.normalized, normal.componentType);
                            }
                            if (restoreInfo.tangent) {
                                var tangent = restoreInfo.tangent;
                                var tangentData = _this._getBufferData(buffers, tangent.buffer);
                                frame.deltaTangents = GLTFUtils.bufferToVector3Array(tangentData, tangent.byteOffset, tangent.count, tangent.normalized, tangent.componentType);
                            }
                        }
                        mesh.uploadData(true);
                    }
                    resolve(_this.resource);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._getBufferData = function _getBufferData(buffers, restoreInfo) {
        var main = restoreInfo.main;
        var data;
        if (main) {
            var buffer = buffers[main.bufferIndex];
            data = new main.TypedArray(buffer, main.byteOffset, main.length);
        } else {
            data = new main.TypedArray(main.length);
        }
        var sparseCount = restoreInfo.sparseCount;
        if (sparseCount) {
            var sparseIndex = restoreInfo.sparseIndices;
            var sparseIndexBuffer = buffers[sparseIndex.bufferIndex];
            var sparseIndexData = new sparseIndex.TypedArray(sparseIndexBuffer, sparseIndex.byteOffset, sparseIndex.length);
            var sparseValue = restoreInfo.sparseValues;
            var sparseValueBuffer = buffers[sparseValue.bufferIndex];
            var sparseValueData = new sparseValue.TypedArray(sparseValueBuffer, sparseValue.byteOffset, sparseValue.length);
            var typeSize = restoreInfo.typeSize;
            for(var i = 0; i < sparseCount; i++){
                var replaceIndex = sparseIndexData[i];
                for(var j = 0; j < typeSize; j++){
                    data[replaceIndex * typeSize + j] = sparseValueData[i * typeSize + j];
                }
            }
        }
        return data;
    };
    return GLTFContentRestorer;
}(ContentRestorer);
/**
 * @internal
 */ var BufferRequestInfo = function BufferRequestInfo(url, config) {
    this.url = url;
    this.config = config;
};
/**
 * @internal
 */ var BufferTextureRestoreInfo = function BufferTextureRestoreInfo(texture, bufferView, mimeType) {
    this.texture = texture;
    this.bufferView = bufferView;
    this.mimeType = mimeType;
};
/**
 * @internal
 */ var ModelMeshRestoreInfo = function ModelMeshRestoreInfo() {
    this.vertexBuffers = [];
    this.blendShapes = [];
};
/**
 * @internal
 */ var BufferRestoreInfo = function BufferRestoreInfo(buffer, data) {
    this.buffer = buffer;
    this.data = data;
};
/**
 * @internal
 */ var BufferDataRestoreInfo = function BufferDataRestoreInfo(main, typeSize, sparseCount, sparseIndices, sparseValues) {
    this.main = main;
    this.typeSize = typeSize;
    this.sparseCount = sparseCount;
    this.sparseIndices = sparseIndices;
    this.sparseValues = sparseValues;
};
/**
 * @internal
 */ var RestoreDataAccessor = function RestoreDataAccessor(bufferIndex, TypedArray, byteOffset, length) {
    this.bufferIndex = bufferIndex;
    this.TypedArray = TypedArray;
    this.byteOffset = byteOffset;
    this.length = length;
};
/**
 * @internal
 */ var BlendShapeRestoreInfo = function BlendShapeRestoreInfo(blendShape, position, normal, tangent) {
    this.blendShape = blendShape;
    this.position = position;
    this.normal = normal;
    this.tangent = tangent;
};
/**
 * @internal
 */ var BlendShapeDataRestoreInfo = function BlendShapeDataRestoreInfo(buffer, byteOffset, count, normalized, componentType) {
    this.buffer = buffer;
    this.byteOffset = byteOffset;
    this.count = count;
    this.normalized = normalized;
    this.componentType = componentType;
};

/**
 * Base class of glTF extension parser.
 */ var GLTFExtensionParser = /*#__PURE__*/ function() {
    function GLTFExtensionParser() {}
    var _proto = GLTFExtensionParser.prototype;
    /**
   * Create and parse the resource.
   * @remarks This method overrides the default resource creation.
   * @param context - The parser context
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The resource or promise
   */ _proto.createAndParse = function createAndParse(context, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        throw "Not implemented.";
    };
    /**
   * Additive parse to the resource.
   * @param context - The parser context
   * @param parseResource - The parsed resource
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The void or promise
   */ _proto.additiveParse = function additiveParse(context, parseResource, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        throw "Not implemented.";
    };
    return GLTFExtensionParser;
}();
/**
 * glTF Extension mode.
 */ var GLTFExtensionMode = /*#__PURE__*/ function(GLTFExtensionMode) {
    /**
   * Cerate instance and parse mode.
   * @remarks
   * If the glTF property has multiple extensions of `CreateAndParse` mode, only execute the last one.
   * If this method is registered, the default pipeline processing will be ignored.
   */ GLTFExtensionMode[GLTFExtensionMode["CreateAndParse"] = 0] = "CreateAndParse";
    /** Additive parse mode. */ GLTFExtensionMode[GLTFExtensionMode["AdditiveParse"] = 1] = "AdditiveParse";
    return GLTFExtensionMode;
}({});

/**
 * Base class of glTF parser.
 */ var GLTFParser = /*#__PURE__*/ function() {
    function GLTFParser() {}
    /**
   * Execute all parses of extension to create resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   * @returns
   */ GLTFParser.executeExtensionsCreateAndParse = function executeExtensionsCreateAndParse(extensions, context, ownerSchema) {
        if (extensions === void 0) extensions = {};
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        var resource = null;
        var extensionArray = Object.keys(extensions);
        for(var i = extensionArray.length - 1; i >= 0; --i){
            var _GLTFParser;
            var extensionName = extensionArray[i];
            var extensionSchema = extensions[extensionName];
            resource = (_GLTFParser = GLTFParser)._createAndParse.apply(_GLTFParser, [].concat([
                extensionName,
                context,
                extensionSchema,
                ownerSchema
            ], extra));
            if (resource) {
                return resource;
            }
        }
    };
    /**
   * Execute all parses of extension to parse resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param parseResource -  The parsed resource
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   */ GLTFParser.executeExtensionsAdditiveAndParse = function executeExtensionsAdditiveAndParse(extensions, context, parseResource, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        for(var extensionName in extensions){
            var _GLTFParser;
            var extensionSchema = extensions[extensionName];
            (_GLTFParser = GLTFParser)._additiveParse.apply(_GLTFParser, [].concat([
                extensionName,
                context,
                parseResource,
                extensionSchema,
                ownerSchema
            ], extra));
        }
    };
    /**
   * Whether the plugin is registered.
   * @param extensionName - Extension name
   * @returns Boolean
   */ GLTFParser.hasExtensionParser = function hasExtensionParser(extensionName) {
        var _GLTFParser__extensionParsers_extensionName;
        return !!((_GLTFParser__extensionParsers_extensionName = GLTFParser._extensionParsers[extensionName]) == null ? void 0 : _GLTFParser__extensionParsers_extensionName.length);
    };
    /**
   * Get the last plugin by glTF extension mode.
   * @param extensionName - Extension name
   * @param mode - GLTF extension mode
   * @returns GLTF extension parser
   */ GLTFParser.getExtensionParser = function getExtensionParser(extensionName, mode) {
        var parsers = GLTFParser._extensionParsers[extensionName];
        var length = parsers == null ? void 0 : parsers.length;
        if (length) {
            // only use the last parser.
            for(var i = length - 1; i >= 0; --i){
                var currentParser = parsers[i];
                if (currentParser._mode === mode) {
                    return currentParser;
                }
            }
        }
    };
    /**
   * @internal
   */ GLTFParser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
        if (!GLTFParser._extensionParsers[extensionName]) {
            GLTFParser._extensionParsers[extensionName] = [];
        }
        GLTFParser._extensionParsers[extensionName].push(extensionParser);
    };
    GLTFParser._createAndParse = function _createAndParse(extensionName, context, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.CreateAndParse);
        if (parser) {
            var _parser;
            return (_parser = parser).createAndParse.apply(_parser, [].concat([
                context,
                extensionSchema,
                ownerSchema
            ], extra));
        }
    };
    GLTFParser._additiveParse = function _additiveParse(extensionName, context, parseResource, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            extra[_key - 5] = arguments[_key];
        }
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.AdditiveParse);
        if (parser) {
            var _parser;
            (_parser = parser).additiveParse.apply(_parser, [].concat([
                context,
                parseResource,
                extensionSchema,
                ownerSchema
            ], extra));
        }
    };
    return GLTFParser;
}();
GLTFParser._extensionParsers = {};
/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */ function registerGLTFExtension(extensionName, mode) {
    return function(parser) {
        var extensionParser = new parser();
        extensionParser._mode = mode;
        GLTFParser._addExtensionParser(extensionName, extensionParser);
    };
}

var GLTFSchemaParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFSchemaParser, GLTFParser);
    function GLTFSchemaParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFSchemaParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer, resourceManager = context.resourceManager;
        var url = glTFResource.url;
        var restoreBufferRequests = contentRestorer.bufferRequests;
        var requestConfig = {
            type: "arraybuffer"
        };
        // @ts-ignore
        var remoteUrl = resourceManager._getRemoteUrl(url);
        return resourceManager// @ts-ignore
        ._requestByRemoteUrl(remoteUrl, requestConfig).onProgress(undefined, context._onTaskDetail).then(function(buffer) {
            var parseResult = GLTFUtils.parseGLB(context, buffer);
            // If the buffer is a GLB file, we need to restore the buffer data
            if (parseResult == null ? void 0 : parseResult.glTF) {
                restoreBufferRequests.push(new BufferRequestInfo(remoteUrl, requestConfig));
            }
            return parseResult;
        }).then(function(result) {
            if (result == null ? void 0 : result.glTF) {
                contentRestorer.isGLB = true;
                context.buffers = result.buffers;
                return result.glTF;
            } else {
                contentRestorer.isGLB = false;
                return JSON.parse(Utils.decodeText(new Uint8Array(result.originBuffer)));
            }
        });
    };
    return GLTFSchemaParser;
}(GLTFParser);
GLTFSchemaParser = __decorate([
    registerGLTFParser(GLTFParserType.Schema)
], GLTFSchemaParser);

var GLTFAnimationParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFAnimationParser, GLTFParser1);
    function GLTFAnimationParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFAnimationParser.prototype;
    _proto.parse = function parse(context, index) {
        var animationInfo = context.glTF.animations[index];
        var _animationInfo_name = animationInfo.name, name = _animationInfo_name === void 0 ? "AnimationClip" + index : _animationInfo_name;
        var animationClipPromise = GLTFParser.executeExtensionsCreateAndParse(animationInfo.extensions, context, animationInfo) || GLTFAnimationParser._parseStandardProperty(context, new AnimationClip(name), animationInfo);
        return Promise.resolve(animationClipPromise).then(function(animationClip) {
            GLTFParser.executeExtensionsAdditiveAndParse(animationInfo.extensions, context, animationClip, animationInfo);
            return animationClip;
        });
    };
    /**
   * @internal
   */ GLTFAnimationParser._parseStandardProperty = function _parseStandardProperty(context, animationClip, animationInfo) {
        var _loop = function(j, m) {
            var glTFSampler = samplers[j];
            var inputAccessor = accessors[glTFSampler.input];
            var outputAccessor = accessors[glTFSampler.output];
            var promise = Promise.all([
                GLTFUtils.getAccessorBuffer(context, bufferViews, inputAccessor),
                GLTFUtils.getAccessorBuffer(context, bufferViews, outputAccessor)
            ]).then(function(bufferInfos) {
                var input = bufferInfos[0].data;
                var output = bufferInfos[1].data;
                if (outputAccessor.normalized) {
                    var scale = GLTFUtils.getNormalizedComponentScale(outputAccessor.componentType);
                    var scaled = new Float32Array(output.length);
                    for(var k = 0, v = output.length; k < v; k++){
                        scaled[k] = output[k] * scale;
                    }
                    output = scaled;
                }
                var outputStride = output.length / input.length;
                var _glTFSampler_interpolation;
                var interpolation = (_glTFSampler_interpolation = glTFSampler.interpolation) != null ? _glTFSampler_interpolation : AnimationSamplerInterpolation.Linear;
                var samplerInterpolation;
                switch(interpolation){
                    case AnimationSamplerInterpolation.CubicSpine:
                        samplerInterpolation = InterpolationType.CubicSpine;
                        break;
                    case AnimationSamplerInterpolation.Step:
                        samplerInterpolation = InterpolationType.Step;
                        break;
                    case AnimationSamplerInterpolation.Linear:
                        samplerInterpolation = InterpolationType.Linear;
                        break;
                }
                input[input.length - 1];
                sampleDataCollection[j] = {
                    type: outputAccessor.type,
                    interpolation: samplerInterpolation,
                    input: input,
                    output: output,
                    outputSize: outputStride
                };
            });
            promises.push(promise);
        };
        var _this = this;
        var glTF = context.glTF;
        var accessors = glTF.accessors, bufferViews = glTF.bufferViews;
        var channels = animationInfo.channels, samplers = animationInfo.samplers;
        var len = samplers.length;
        var sampleDataCollection = new Array(len);
        var entities = context.get(GLTFParserType.Entity);
        var promises = new Array();
        // parse samplers
        for(var j = 0, m = len; j < m; j++)_loop(j);
        promises.push(context.get(GLTFParserType.Scene));
        return Promise.all(promises).then(function() {
            for(var j = 0, m = channels.length; j < m; j++){
                var glTFChannel = channels[j];
                var target = glTFChannel.target;
                var channelTargetEntity = entities[target.node];
                var relativePath = "";
                var entity = channelTargetEntity;
                while(entity.parent){
                    relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
                    entity = entity.parent;
                }
                // If the target node is in the default scene, relativePath will be empty
                if (context.glTFResource.sceneRoots.indexOf(entity) === -1) {
                    continue;
                }
                var ComponentType = void 0;
                var propertyName = void 0;
                switch(target.path){
                    case AnimationChannelTargetPath.TRANSLATION:
                        ComponentType = Transform;
                        propertyName = "position";
                        break;
                    case AnimationChannelTargetPath.ROTATION:
                        ComponentType = Transform;
                        propertyName = "rotationQuaternion";
                        break;
                    case AnimationChannelTargetPath.SCALE:
                        ComponentType = Transform;
                        propertyName = "scale";
                        break;
                    case AnimationChannelTargetPath.WEIGHTS:
                        ComponentType = SkinnedMeshRenderer;
                        propertyName = "blendShapeWeights";
                        break;
                }
                var curve = _this._addCurve(target.path, glTFChannel, sampleDataCollection);
                if (target.path === AnimationChannelTargetPath.WEIGHTS) {
                    var mesh = glTF.nodes[target.node].mesh;
                    for(var i = 0, n = glTF.meshes[mesh].primitives.length; i < n; i++){
                        animationClip.addCurveBinding(relativePath, ComponentType, i, propertyName, curve);
                    }
                } else {
                    animationClip.addCurveBinding(relativePath, ComponentType, propertyName, curve);
                }
            }
            return animationClip;
        });
    };
    GLTFAnimationParser._addCurve = function _addCurve(animationChannelTargetPath, glTFChannel, sampleDataCollection) {
        var sampleData = sampleDataCollection[glTFChannel.sampler];
        var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
        switch(animationChannelTargetPath){
            case AnimationChannelTargetPath.TRANSLATION:
            case AnimationChannelTargetPath.SCALE:
                {
                    var curve = new AnimationVector3Curve();
                    var interpolation = curve.interpolation = sampleData.interpolation;
                    var offset = 0;
                    for(var i = 0, n = input.length; i < n; i++){
                        var keyframe = new Keyframe();
                        keyframe.time = input[i];
                        if (interpolation === InterpolationType.CubicSpine) {
                            keyframe.inTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.outTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                        } else {
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                        }
                        curve.addKey(keyframe);
                    }
                    return curve;
                }
            case AnimationChannelTargetPath.ROTATION:
                {
                    var curve1 = new AnimationQuaternionCurve();
                    var interpolation1 = curve1.interpolation = sampleData.interpolation;
                    var offset1 = 0;
                    for(var i1 = 0, n1 = input.length; i1 < n1; i1++){
                        var keyframe1 = new Keyframe();
                        keyframe1.time = input[i1];
                        if (interpolation1 === InterpolationType.CubicSpine) {
                            keyframe1.inTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.outTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        } else {
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        }
                        curve1.addKey(keyframe1);
                    }
                    return curve1;
                }
            case AnimationChannelTargetPath.WEIGHTS:
                {
                    var curve2 = new AnimationFloatArrayCurve();
                    curve2.interpolation = sampleData.interpolation;
                    var offset2 = 0;
                    for(var i2 = 0, n2 = input.length; i2 < n2; i2++){
                        var keyframe2 = new Keyframe();
                        keyframe2.time = input[i2];
                        if (curve2.interpolation === InterpolationType.CubicSpine) {
                            keyframe2.inTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                            keyframe2.value = output.slice(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                            keyframe2.outTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                        } else {
                            keyframe2.value = output.slice(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                        }
                        curve2.addKey(keyframe2);
                    }
                    return curve2;
                }
        }
    };
    return GLTFAnimationParser;
}(GLTFParser);
GLTFAnimationParser = __decorate([
    registerGLTFParser(GLTFParserType.Animation)
], GLTFAnimationParser);

var GLTFBufferParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFBufferParser, GLTFParser);
    function GLTFBufferParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFBufferParser.prototype;
    _proto.parse = function parse(context, index) {
        var buffers = context.glTF.buffers;
        return context.buffers ? Promise.resolve(context.buffers[index]) : this._parseSingleBuffer(context, buffers[index]);
    };
    _proto._parseSingleBuffer = function _parseSingleBuffer(context, bufferInfo) {
        var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer, resourceManager = context.resourceManager;
        var url = glTFResource.url;
        // @ts-ignore
        var remoteUrl = resourceManager._getRemoteUrl(url);
        var restoreBufferRequests = contentRestorer.bufferRequests;
        var requestConfig = {
            type: "arraybuffer"
        };
        var absoluteUrl = Utils.resolveAbsoluteUrl(remoteUrl, bufferInfo.uri);
        restoreBufferRequests.push(new BufferRequestInfo(absoluteUrl, requestConfig));
        var promise = resourceManager// @ts-ignore
        ._requestByRemoteUrl(absoluteUrl, requestConfig).onProgress(undefined, context._onTaskDetail);
        context._addTaskCompletePromise(promise);
        return promise;
    };
    return GLTFBufferParser;
}(GLTFParser);
GLTFBufferParser = __decorate([
    registerGLTFParser(GLTFParserType.Buffer)
], GLTFBufferParser);

var GLTFEntityParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFEntityParser, GLTFParser1);
    function GLTFEntityParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFEntityParser.prototype;
    _proto.parse = function parse(context, index) {
        var glTFResource = context.glTFResource;
        var entityInfo = context.glTF.nodes[index];
        var engine = glTFResource.engine;
        var matrix = entityInfo.matrix, translation = entityInfo.translation, rotation = entityInfo.rotation, scale = entityInfo.scale, extensions = entityInfo.extensions;
        var entity = new Entity(engine, entityInfo.name || "_GLTF_ENTITY_" + index);
        // @ts-ignore
        entity._markAsTemplate(glTFResource);
        var transform = entity.transform;
        if (matrix) {
            var localMatrix = transform.localMatrix;
            localMatrix.copyFromArray(matrix);
            transform.localMatrix = localMatrix;
        } else {
            if (translation) {
                transform.setPosition(translation[0], translation[1], translation[2]);
            }
            if (rotation) {
                transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
            }
            if (scale) {
                transform.setScale(scale[0], scale[1], scale[2]);
            }
        }
        var children = entityInfo.children;
        if (children) {
            for(var i = 0; i < children.length; i++){
                var childIndex = children[i];
                var childEntity = context.get(GLTFParserType.Entity, childIndex);
                entity.addChild(childEntity);
            }
        }
        GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, entity, entityInfo);
        return entity;
    };
    return GLTFEntityParser;
}(GLTFParser);
GLTFEntityParser = __decorate([
    registerGLTFParser(GLTFParserType.Entity)
], GLTFEntityParser);

var GLTFMaterialParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMaterialParser, GLTFParser1);
    function GLTFMaterialParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFMaterialParser.prototype;
    _proto.parse = function parse(context, index) {
        var materialInfo = context.glTF.materials[index];
        var glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var material = GLTFParser.executeExtensionsCreateAndParse(materialInfo.extensions, context, materialInfo);
        if (!material) {
            material = new PBRMaterial(engine);
            material.name = materialInfo.name;
            GLTFMaterialParser._parseStandardProperty(context, material, materialInfo);
        }
        return Promise.resolve(material).then(function(material) {
            material || (material = GLTFMaterialParser._getDefaultMaterial(engine));
            GLTFParser.executeExtensionsAdditiveAndParse(materialInfo.extensions, context, material, materialInfo);
            // @ts-ignore
            material._associationSuperResource(glTFResource);
            return material;
        });
    };
    /** @internal */ GLTFMaterialParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
        var _GLTFMaterialParser;
        return (_GLTFMaterialParser = GLTFMaterialParser)._defaultMaterial || (_GLTFMaterialParser._defaultMaterial = new BlinnPhongMaterial(engine));
    };
    /**
   * @internal
   */ GLTFMaterialParser._checkOtherTextureTransform = function _checkOtherTextureTransform(texture, textureName) {
        var _texture_extensions;
        if ((_texture_extensions = texture.extensions) == null ? void 0 : _texture_extensions.KHR_texture_transform) {
            Logger.warn("" + textureName + " texture always use the KHR_texture_transform of the base texture.");
        }
    };
    /**
   * @internal
   */ GLTFMaterialParser._parseStandardProperty = function _parseStandardProperty(context, material, materialInfo) {
        var pbrMetallicRoughness = materialInfo.pbrMetallicRoughness, normalTexture = materialInfo.normalTexture, occlusionTexture = materialInfo.occlusionTexture, emissiveTexture = materialInfo.emissiveTexture, emissiveFactor = materialInfo.emissiveFactor, alphaMode = materialInfo.alphaMode, alphaCutoff = materialInfo.alphaCutoff, doubleSided = materialInfo.doubleSided;
        if (pbrMetallicRoughness) {
            var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
            if (baseColorFactor) {
                material.baseColor = new Color(Color.linearToGammaSpace(baseColorFactor[0]), Color.linearToGammaSpace(baseColorFactor[1]), Color.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
            }
            if (baseColorTexture) {
                context.get(GLTFParserType.Texture, baseColorTexture.index).then(function(texture) {
                    material.baseTexture = texture;
                    GLTFParser.executeExtensionsAdditiveAndParse(baseColorTexture.extensions, context, material, baseColorTexture);
                });
            }
            if (material.constructor === PBRMaterial) {
                material.metallic = metallicFactor != null ? metallicFactor : 1;
                material.roughness = roughnessFactor != null ? roughnessFactor : 1;
                if (metallicRoughnessTexture) {
                    GLTFMaterialParser._checkOtherTextureTransform(metallicRoughnessTexture, "Roughness metallic");
                    context.get(GLTFParserType.Texture, metallicRoughnessTexture.index).then(function(texture) {
                        material.roughnessMetallicTexture = texture;
                    });
                }
            }
        }
        if (material.constructor === PBRMaterial || material.constructor === PBRSpecularMaterial) {
            if (emissiveTexture) {
                GLTFMaterialParser._checkOtherTextureTransform(emissiveTexture, "Emissive");
                context.get(GLTFParserType.Texture, emissiveTexture.index).then(function(texture) {
                    material.emissiveTexture = texture;
                });
            }
            if (emissiveFactor) {
                material.emissiveColor = new Color(Color.linearToGammaSpace(emissiveFactor[0]), Color.linearToGammaSpace(emissiveFactor[1]), Color.linearToGammaSpace(emissiveFactor[2]));
            }
            if (normalTexture) {
                var index = normalTexture.index, scale = normalTexture.scale;
                GLTFMaterialParser._checkOtherTextureTransform(normalTexture, "Normal");
                context.get(GLTFParserType.Texture, index).then(function(texture) {
                    material.normalTexture = texture;
                });
                if (scale !== undefined) {
                    material.normalTextureIntensity = scale;
                }
            }
            if (occlusionTexture) {
                var index1 = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
                GLTFMaterialParser._checkOtherTextureTransform(occlusionTexture, "Occlusion");
                context.get(GLTFParserType.Texture, index1).then(function(texture) {
                    material.occlusionTexture = texture;
                });
                if (strength !== undefined) {
                    material.occlusionTextureIntensity = strength;
                }
                if (texCoord === TextureCoordinate.UV1) {
                    material.occlusionTextureCoord = TextureCoordinate.UV1;
                } else if (texCoord > TextureCoordinate.UV1) {
                    Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                }
            }
        }
        if (doubleSided) {
            material.renderFace = RenderFace.Double;
        } else {
            material.renderFace = RenderFace.Front;
        }
        switch(alphaMode){
            case MaterialAlphaMode.OPAQUE:
                material.isTransparent = false;
                break;
            case MaterialAlphaMode.BLEND:
                material.isTransparent = true;
                break;
            case MaterialAlphaMode.MASK:
                material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
                break;
        }
    };
    return GLTFMaterialParser;
}(GLTFParser);
GLTFMaterialParser = __decorate([
    registerGLTFParser(GLTFParserType.Material)
], GLTFMaterialParser);

var GLTFMeshParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMeshParser, GLTFParser1);
    function GLTFMeshParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFMeshParser.prototype;
    _proto.parse = function parse(context, index) {
        var _loop = function(i, length) {
            var gltfPrimitive = meshInfo.primitives[i];
            primitivePromises[i] = new Promise(function(resolve) {
                var mesh = GLTFParser.executeExtensionsCreateAndParse(gltfPrimitive.extensions, context, gltfPrimitive, meshInfo);
                if (mesh) {
                    if (_instanceof(mesh, ModelMesh)) {
                        // @ts-ignore
                        mesh._associationSuperResource(glTFResource);
                        resolve(mesh);
                    } else {
                        mesh.then(function(mesh) {
                            // @ts-ignore
                            mesh._associationSuperResource(glTFResource);
                            resolve(mesh);
                        });
                    }
                } else {
                    var mesh1 = new ModelMesh(engine, meshInfo.name || i + "");
                    // @ts-ignore
                    mesh1._associationSuperResource(glTFResource);
                    var meshRestoreInfo = new ModelMeshRestoreInfo();
                    meshRestoreInfo.mesh = mesh1;
                    context.contentRestorer.meshes.push(meshRestoreInfo);
                    GLTFMeshParser._parseMeshFromGLTFPrimitive(context, mesh1, meshRestoreInfo, meshInfo, gltfPrimitive, glTF, context.params.keepMeshData).then(resolve);
                }
            });
        };
        var meshInfo = context.glTF.meshes[index];
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var primitivePromises = new Array();
        for(var i = 0, length = meshInfo.primitives.length; i < length; i++)_loop(i);
        return Promise.all(primitivePromises);
    };
    /**
   * @internal
   */ GLTFMeshParser._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, gltf, keepMeshData) {
        var _loop = function(attribute) {
            var accessor = accessors[attributes[attribute]];
            var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, accessor).then(function(accessorBuffer) {
                var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
                var accessorCount = accessor.count;
                var vertices = accessorBuffer.data;
                var vertexElement;
                var meshId = mesh.instanceId;
                var vertexBindingInfos = accessorBuffer.vertexBindingInfos;
                var elementNormalized = accessor.normalized;
                var elementFormat = GLTFUtils.getElementFormat(accessor.componentType, dataElementSize, elementNormalized);
                var scaleFactor;
                elementNormalized && (scaleFactor = GLTFUtils.getNormalizedComponentScale(accessor.componentType));
                var elementOffset;
                if (accessorBuffer.interleaved) {
                    var byteOffset = accessor.byteOffset || 0;
                    var stride = accessorBuffer.stride;
                    elementOffset = byteOffset % stride;
                    if (vertexBindingInfos[meshId] === undefined) {
                        vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                        var vertexBuffer = accessorBuffer.vertexBuffer;
                        if (!vertexBuffer) {
                            vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, keepMeshData);
                            accessorBuffer.vertexBuffer = vertexBuffer;
                            meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer, accessorBuffer.restoreInfo));
                        }
                        mesh.setVertexBufferBinding(vertexBuffer, stride, bufferBindIndex);
                        vertexBindingInfos[meshId] = bufferBindIndex++;
                    } else {
                        vertexElement = new VertexElement(attribute, elementOffset, elementFormat, vertexBindingInfos[meshId]);
                    }
                } else {
                    elementOffset = 0;
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                    var vertexBuffer1 = accessorBuffer.vertexBuffer;
                    if (!vertexBuffer1) {
                        vertexBuffer1 = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices, BufferUsage.Static, keepMeshData);
                        meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer1, accessorBuffer.restoreInfo));
                    }
                    mesh.setVertexBufferBinding(vertexBuffer1, accessorBuffer.stride, bufferBindIndex);
                    vertexBindingInfos[meshId] = bufferBindIndex++;
                }
                vertexElements.push(vertexElement);
                if (attribute === "POSITION") {
                    vertexCount = accessorCount;
                    var _mesh_bounds = mesh.bounds, min = _mesh_bounds.min, max = _mesh_bounds.max;
                    if (accessor.min && accessor.max) {
                        min.copyFromArray(accessor.min);
                        max.copyFromArray(accessor.max);
                    } else {
                        var position = GLTFMeshParser._tempVector3;
                        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        var baseOffset = elementOffset / vertices.BYTES_PER_ELEMENT;
                        var stride1 = vertices.length / accessorCount;
                        for(var j = 0; j < accessorCount; j++){
                            var offset = baseOffset + j * stride1;
                            position.copyFromArray(vertices, offset);
                            Vector3.min(min, position, min);
                            Vector3.max(max, position, max);
                        }
                    }
                    if (elementNormalized) {
                        min.scale(scaleFactor);
                        max.scale(scaleFactor);
                    }
                }
            });
            promises.push(promise);
        };
        var accessors = gltf.accessors;
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var engine = mesh.engine;
        var vertexElements = new Array();
        var vertexCount;
        var bufferBindIndex = 0;
        var promises = new Array();
        for(var attribute in attributes)_loop(attribute);
        return Promise.all(promises).then(function() {
            mesh.setVertexElements(vertexElements);
            // Indices
            if (indices !== undefined) {
                var indexAccessor = gltf.accessors[indices];
                var promise = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, indexAccessor).then(function(accessorBuffer) {
                    mesh.setIndices(accessorBuffer.data);
                    mesh.addSubMesh(0, indexAccessor.count, mode);
                    meshRestoreInfo.indexBuffer = accessorBuffer.restoreInfo;
                });
                promises.push(promise);
            } else {
                mesh.addSubMesh(0, vertexCount, mode);
            }
            // BlendShapes
            if (targets) {
                promises.push(GLTFMeshParser._createBlendShape(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, targets));
            }
            return Promise.all(promises).then(function() {
                mesh.uploadData(!keepMeshData);
                return mesh;
            });
        });
    };
    GLTFMeshParser._getBlendShapeData = function _getBlendShapeData(context, glTF, accessor) {
        return GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).then(function(bufferInfo) {
            var buffer = bufferInfo.data;
            var _accessor_byteOffset;
            var byteOffset = bufferInfo.interleaved ? ((_accessor_byteOffset = accessor.byteOffset) != null ? _accessor_byteOffset : 0) % bufferInfo.stride : 0;
            var count = accessor.count, normalized = accessor.normalized, componentType = accessor.componentType;
            var vertices = GLTFUtils.bufferToVector3Array(buffer, byteOffset, count, normalized, componentType);
            var restoreInfo = new BlendShapeDataRestoreInfo(bufferInfo.restoreInfo, byteOffset, count, normalized, componentType);
            return {
                vertices: vertices,
                restoreInfo: restoreInfo
            };
        });
    };
    /**
   * @internal
   */ GLTFMeshParser._createBlendShape = function _createBlendShape(context, mesh, meshRestoreInfo, glTFMesh, gltfPrimitive, glTFTargets) {
        var _this, _loop = function(i) {
            var blendShapeData = {};
            blendShapeCollection[i] = blendShapeData;
            var name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
            var targets = gltfPrimitive.targets[i];
            var normalTarget = targets["NORMAL"];
            var tangentTarget = targets["TANGENT"];
            var hasNormal = normalTarget !== undefined;
            var hasTangent = tangentTarget !== undefined;
            var promise = Promise.all([
                _this._getBlendShapeData(context, glTF, accessors[targets["POSITION"]]),
                hasNormal ? _this._getBlendShapeData(context, glTF, accessors[normalTarget]) : null,
                hasTangent ? _this._getBlendShapeData(context, glTF, accessors[tangentTarget]) : null
            ]).then(function(vertices) {
                var positionData = vertices[0], normalData = vertices[1], tangentData = vertices[2];
                var blendShape = new BlendShape(name);
                blendShape.addFrame(1.0, positionData.vertices, hasNormal ? normalData.vertices : null, hasTangent ? tangentData.vertices : null);
                blendShapeData.blendShape = blendShape;
                blendShapeData.restoreInfo = new BlendShapeRestoreInfo(blendShape, positionData.restoreInfo, hasNormal ? normalData.restoreInfo : null, hasTangent ? tangentData == null ? void 0 : tangentData.restoreInfo : null);
            });
            promises.push(promise);
        };
        var glTF = context.glTF;
        var accessors = glTF.accessors;
        var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
        var promises = new Array();
        var blendShapeCount = glTFTargets.length;
        var blendShapeCollection = new Array(blendShapeCount);
        for(var i = 0; i < blendShapeCount; i++)_this = this, _loop(i);
        return Promise.all(promises).then(function() {
            for(var _iterator = _create_for_of_iterator_helper_loose(blendShapeCollection), _step; !(_step = _iterator()).done;){
                var blendShape = _step.value;
                mesh.addBlendShape(blendShape.blendShape);
                meshRestoreInfo.blendShapes.push(blendShape.restoreInfo);
            }
        });
    };
    return GLTFMeshParser;
}(GLTFParser);
GLTFMeshParser._tempVector3 = new Vector3();
GLTFMeshParser = __decorate([
    registerGLTFParser(GLTFParserType.Mesh)
], GLTFMeshParser);

var GLTFSceneParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFSceneParser, GLTFParser1);
    function GLTFSceneParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFSceneParser.prototype;
    _proto.parse = function parse(context, index) {
        var _context_glTF = context.glTF, scenes = _context_glTF.scenes, _context_glTF_scene = _context_glTF.scene, scene = _context_glTF_scene === void 0 ? 0 : _context_glTF_scene, glTFResource = context.glTFResource;
        var sceneInfo = scenes[index];
        var sceneExtensions = sceneInfo.extensions;
        var engine = glTFResource.engine;
        var isDefaultScene = scene === index;
        var sceneNodes = sceneInfo.nodes || [];
        var sceneRoot;
        if (sceneNodes.length === 1) {
            sceneRoot = context.get(GLTFParserType.Entity, sceneNodes[0]);
        } else {
            sceneRoot = new Entity(engine, "GLTF_ROOT");
            // @ts-ignore
            sceneRoot._markAsTemplate(glTFResource);
            for(var i = 0; i < sceneNodes.length; i++){
                var childEntity = context.get(GLTFParserType.Entity, sceneNodes[i]);
                sceneRoot.addChild(childEntity);
            }
        }
        if (isDefaultScene) {
            glTFResource._defaultSceneRoot = sceneRoot;
        }
        var promises = new Array();
        for(var i1 = 0; i1 < sceneNodes.length; i1++){
            promises.push(this._parseEntityComponent(context, sceneNodes[i1]));
        }
        return Promise.all(promises).then(function() {
            GLTFParser.executeExtensionsAdditiveAndParse(sceneExtensions, context, sceneRoot, sceneInfo);
            return sceneRoot;
        });
    };
    _proto._parseEntityComponent = function _parseEntityComponent(context, index) {
        var _this = this;
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var entityInfo = glTF.nodes[index];
        var cameraID = entityInfo.camera, meshID = entityInfo.mesh;
        var entity = context.get(GLTFParserType.Entity, index);
        var promise;
        if (cameraID !== undefined) {
            this._createCamera(glTFResource, glTF.cameras[cameraID], entity);
        }
        if (meshID !== undefined) {
            promise = this._createRenderer(context, entityInfo, entity);
        }
        return Promise.resolve(promise).then(function() {
            var promises = [];
            var children = entityInfo.children;
            if (children) {
                for(var i = 0; i < children.length; i++){
                    promises.push(_this._parseEntityComponent(context, children[i]));
                }
            }
            return Promise.all(promises);
        });
    };
    _proto._createCamera = function _createCamera(resource, cameraSchema, entity) {
        var _resource;
        var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
        var camera = entity.addComponent(Camera);
        if (type === CameraType.ORTHOGRAPHIC) {
            var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
            camera.isOrthographic = true;
            if (znear !== undefined) {
                camera.nearClipPlane = znear;
            }
            if (zfar !== undefined) {
                camera.farClipPlane = zfar;
            }
            camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
        } else if (type === CameraType.PERSPECTIVE) {
            var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, zfar1 = perspective.zfar, znear1 = perspective.znear;
            if (aspectRatio !== undefined) {
                camera.aspectRatio = aspectRatio;
            }
            if (yfov !== undefined) {
                camera.fieldOfView = yfov * 180 / Math.PI;
            }
            if (zfar1 !== undefined) {
                camera.farClipPlane = zfar1;
            }
            if (znear1 !== undefined) {
                camera.nearClipPlane = znear1;
            }
        }
        (_resource = resource).cameras || (_resource.cameras = []);
        resource.cameras.push(camera);
        // @todo: use engine camera by default
        camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, entityInfo, entity) {
        var _this = this;
        var meshID = entityInfo.mesh, skinID = entityInfo.skin;
        var glTFMesh = context.glTF.meshes[meshID];
        var glTFMeshPrimitives = glTFMesh.primitives;
        var rendererCount = glTFMeshPrimitives.length;
        var blendShapeWeights = entityInfo.weights || glTFMesh.weights;
        var materialPromises = new Array(rendererCount);
        for(var i = 0; i < rendererCount; i++){
            var _glTFMeshPrimitives_i_material;
            materialPromises[i] = context.get(GLTFParserType.Material, (_glTFMeshPrimitives_i_material = glTFMeshPrimitives[i].material) != null ? _glTFMeshPrimitives_i_material : -1);
        }
        return Promise.all([
            context.get(GLTFParserType.Mesh, meshID),
            skinID !== undefined && context.get(GLTFParserType.Skin, skinID),
            Promise.all(materialPromises)
        ]).then(function(param) {
            var _loop = function(i) {
                var material = materials[i] || GLTFMaterialParser._getDefaultMaterial(context.glTFResource.engine);
                var glTFPrimitive = glTFMeshPrimitives[i];
                var mesh = meshes[i];
                var renderer = void 0;
                if (skin || blendShapeWeights) {
                    var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
                    skinRenderer.mesh = mesh;
                    if (skin) {
                        _this._computeLocalBounds(skinRenderer, mesh, skin.bones, skin.rootBone, skin.inverseBindMatrices);
                        skinRenderer.skin = skin;
                    }
                    if (blendShapeWeights) {
                        skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
                    }
                    renderer = skinRenderer;
                } else {
                    renderer = entity.addComponent(MeshRenderer);
                    renderer.mesh = mesh;
                }
                renderer.setMaterial(material);
                // Enable vertex color if mesh has COLOR_0 vertex element
                mesh.vertexElements.forEach(function(element) {
                    if (element.semantic === "COLOR_0") {
                        renderer.enableVertexColor = true;
                    }
                });
                GLTFParser.executeExtensionsAdditiveAndParse(glTFPrimitive.extensions, context, renderer, glTFPrimitive);
            };
            var meshes = param[0], skin = param[1], materials = param[2];
            for(var i = 0; i < rendererCount; i++)_loop(i);
        });
    };
    _proto._computeLocalBounds = function _computeLocalBounds(skinnedMeshRenderer, mesh, bones, rootBone, inverseBindMatrices) {
        var rootBoneIndex = bones.indexOf(rootBone);
        if (rootBoneIndex !== -1) {
            BoundingBox.transform(mesh.bounds, inverseBindMatrices[rootBoneIndex], skinnedMeshRenderer.localBounds);
        } else {
            // Root bone is not in joints list, we can only compute approximate inverse bind matrix
            // Average all root bone's children inverse bind matrix
            var approximateBindMatrix = new Matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var subRootBoneCount = this._computeApproximateBindMatrix(bones, inverseBindMatrices, rootBone, approximateBindMatrix);
            if (subRootBoneCount !== 0) {
                Matrix.multiplyScalar(approximateBindMatrix, 1.0 / subRootBoneCount, approximateBindMatrix);
                BoundingBox.transform(mesh.bounds, approximateBindMatrix, skinnedMeshRenderer.localBounds);
            } else {
                skinnedMeshRenderer.localBounds.copyFrom(mesh.bounds);
            }
        }
    };
    _proto._computeApproximateBindMatrix = function _computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootEntity, approximateBindMatrix) {
        var subRootBoneCount = 0;
        var children = rootEntity.children;
        for(var i = 0, n = children.length; i < n; i++){
            var rootChild = children[i];
            var index = jointEntities.indexOf(rootChild);
            if (index !== -1) {
                Matrix.add(approximateBindMatrix, inverseBindMatrices[index], approximateBindMatrix);
                subRootBoneCount++;
            } else {
                subRootBoneCount += this._computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootChild, approximateBindMatrix);
            }
        }
        return subRootBoneCount;
    };
    return GLTFSceneParser;
}(GLTFParser);
GLTFSceneParser = __decorate([
    registerGLTFParser(GLTFParserType.Scene)
], GLTFSceneParser);

var GLTFSkinParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFSkinParser, GLTFParser);
    function GLTFSkinParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFSkinParser.prototype;
    _proto.parse = function parse(context, index) {
        var _this = this;
        var glTF = context.glTF;
        var skinInfo = glTF.skins[index];
        var inverseBindMatrices = skinInfo.inverseBindMatrices, skeleton = skinInfo.skeleton, joints = skinInfo.joints, _skinInfo_name = skinInfo.name, name = _skinInfo_name === void 0 ? "SKIN_" + index : _skinInfo_name;
        var jointCount = joints.length;
        var skin = new Skin(name);
        skin.inverseBindMatrices.length = jointCount;
        var bones = new Array(jointCount);
        // parse IBM
        var accessor = glTF.accessors[inverseBindMatrices];
        var skinPromise = GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).then(function(bufferInfo) {
            var entities = context.get(GLTFParserType.Entity);
            var buffer = bufferInfo.data;
            for(var i = 0; i < jointCount; i++){
                var inverseBindMatrix = new Matrix();
                inverseBindMatrix.copyFromArray(buffer, i * 16);
                skin.inverseBindMatrices[i] = inverseBindMatrix;
                // Get bones
                var bone = entities[joints[i]];
                bones[i] = bone;
                skin.joints[i] = bone.name;
            }
            skin.bones = bones;
            // Get skeleton
            if (skeleton !== undefined) {
                var rootBone = entities[skeleton];
                skin.rootBone = rootBone;
            } else {
                var rootBone1 = _this._findSkeletonRootBone(joints, entities);
                if (rootBone1) {
                    skin.rootBone = rootBone1;
                } else {
                    throw "Failed to find skeleton root bone.";
                }
            }
            return skin;
        });
        return Promise.resolve(skinPromise);
    };
    _proto._findSkeletonRootBone = function _findSkeletonRootBone(joints, entities) {
        var paths = {};
        for(var _iterator = _create_for_of_iterator_helper_loose(joints), _step; !(_step = _iterator()).done;){
            var index = _step.value;
            var path = new Array();
            var entity = entities[index];
            while(entity){
                path.unshift(entity);
                entity = entity.parent;
            }
            paths[index] = path;
        }
        var rootNode = null;
        for(var i = 0;; i++){
            var path1 = paths[joints[0]];
            if (i >= path1.length) {
                return rootNode;
            }
            var entity1 = path1[i];
            for(var j = 1, m = joints.length; j < m; j++){
                path1 = paths[joints[j]];
                if (i >= path1.length || entity1 !== path1[i]) {
                    return rootNode;
                }
            }
            rootNode = entity1;
        }
    };
    return GLTFSkinParser;
}(GLTFParser);
GLTFSkinParser = __decorate([
    registerGLTFParser(GLTFParserType.Skin)
], GLTFSkinParser);

var GLTFTextureParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFTextureParser, GLTFParser1);
    function GLTFTextureParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFTextureParser.prototype;
    _proto.parse = function parse(context, textureIndex) {
        var textureInfo = context.glTF.textures[textureIndex];
        var glTFResource = context.glTFResource;
        var sampler = textureInfo.sampler, tmp = textureInfo.source, imageIndex = tmp === void 0 ? 0 : tmp, textureName = textureInfo.name, extensions = textureInfo.extensions;
        var texture = GLTFParser.executeExtensionsCreateAndParse(extensions, context, textureInfo, textureIndex);
        if (!texture) {
            texture = GLTFTextureParser._parseTexture(context, imageIndex, textureIndex, sampler, textureName);
        }
        return Promise.resolve(texture).then(function(texture) {
            GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, texture, textureInfo);
            // @ts-ignore
            texture._associationSuperResource(glTFResource);
            return texture;
        });
    };
    /** @internal */ GLTFTextureParser._parseTexture = function _parseTexture(context, imageIndex, textureIndex, sampler, textureName) {
        var glTFResource = context.glTFResource, glTF = context.glTF;
        var engine = glTFResource.engine, url = glTFResource.url;
        var _glTF_images_imageIndex = glTF.images[imageIndex], uri = _glTF_images_imageIndex.uri, bufferViewIndex = _glTF_images_imageIndex.bufferView, mimeType = _glTF_images_imageIndex.mimeType, imageName = _glTF_images_imageIndex.name;
        var useSampler = sampler !== undefined;
        var samplerInfo = useSampler && GLTFUtils.getSamplerInfo(glTF.samplers[sampler]);
        var texture;
        if (uri) {
            var extIndex = uri.lastIndexOf(".");
            var ext = uri.substring(extIndex + 1);
            var type = ext.startsWith("ktx") ? AssetType.KTX : AssetType.Texture2D;
            texture = engine.resourceManager.load({
                url: Utils.resolveAbsoluteUrl(url, uri),
                type: type,
                params: {
                    mipmap: samplerInfo == null ? void 0 : samplerInfo.mipmap
                }
            }).onProgress(undefined, context._onTaskDetail).then(function(texture) {
                texture.name = textureName || imageName || texture.name || "texture_" + textureIndex;
                useSampler && GLTFUtils.parseSampler(texture, samplerInfo);
                return texture;
            });
            context._addTaskCompletePromise(texture);
        } else {
            var bufferView = glTF.bufferViews[bufferViewIndex];
            texture = context.get(GLTFParserType.Buffer).then(function(buffers) {
                var buffer = buffers[bufferView.buffer];
                var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
                return GLTFUtils.loadImageBuffer(imageBuffer, mimeType).then(function(image) {
                    var texture = new Texture2D(engine, image.width, image.height, undefined, samplerInfo == null ? void 0 : samplerInfo.mipmap);
                    texture.setImageSource(image);
                    texture.generateMipmaps();
                    texture.name = textureName || imageName || "texture_" + textureIndex;
                    useSampler && GLTFUtils.parseSampler(texture, samplerInfo);
                    var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType);
                    context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
                    return texture;
                });
            });
        }
        return texture;
    };
    return GLTFTextureParser;
}(GLTFParser);
var _obj;
/** @internal */ GLTFTextureParser._wrapMap = (_obj = {}, _obj[TextureWrapMode.CLAMP_TO_EDGE] = TextureWrapMode$1.Clamp, _obj[TextureWrapMode.MIRRORED_REPEAT] = TextureWrapMode$1.Mirror, _obj[TextureWrapMode.REPEAT] = TextureWrapMode$1.Repeat, _obj);
GLTFTextureParser = __decorate([
    registerGLTFParser(GLTFParserType.Texture)
], GLTFTextureParser);

var GLTFValidator = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFValidator, GLTFParser1);
    function GLTFValidator() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFValidator.prototype;
    _proto.parse = function parse(context) {
        var _context_glTF = context.glTF, version = _context_glTF.asset.version, extensionsUsed = _context_glTF.extensionsUsed, extensionsRequired = _context_glTF.extensionsRequired;
        var glTFVersion = Number(version);
        if (!(glTFVersion >= 2 && glTFVersion < 3)) {
            throw "Only support glTF 2.x.";
        }
        if (extensionsUsed) {
            Logger.info("extensionsUsed: ", extensionsUsed);
            for(var i = 0; i < extensionsUsed.length; i++){
                var extensionUsed = extensionsUsed[i];
                if (!GLTFParser.hasExtensionParser(extensionUsed)) {
                    Logger.warn("Extension " + extensionUsed + " is not implemented, you can customize this extension in gltf.");
                }
            }
        }
        if (extensionsRequired) {
            Logger.info("extensionsRequired: " + extensionsRequired);
            for(var i1 = 0; i1 < extensionsRequired.length; i1++){
                var extensionRequired = extensionsRequired[i1];
                if (!GLTFParser.hasExtensionParser(extensionRequired)) {
                    Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
                }
            }
        }
        return Promise.resolve(null);
    };
    return GLTFValidator;
}(GLTFParser);
GLTFValidator = __decorate([
    registerGLTFParser(GLTFParserType.Validator)
], GLTFValidator);

var GLTFBufferViewParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFBufferViewParser, GLTFParser1);
    function GLTFBufferViewParser() {
        return GLTFParser1.apply(this, arguments) || this;
    }
    var _proto = GLTFBufferViewParser.prototype;
    _proto.parse = function parse(context, index) {
        var bufferView = context.glTF.bufferViews[index];
        var extensions = bufferView.extensions, _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset, byteLength = bufferView.byteLength, bufferIndex = bufferView.buffer;
        return extensions ? GLTFParser.executeExtensionsCreateAndParse(extensions, context, bufferView) : context.get(GLTFParserType.Buffer, bufferIndex).then(function(buffer) {
            return new Uint8Array(buffer, byteOffset, byteLength);
        });
    };
    return GLTFBufferViewParser;
}(GLTFParser);
GLTFBufferViewParser = __decorate([
    registerGLTFParser(GLTFParserType.BufferView)
], GLTFBufferViewParser);

var GLTFAnimatorControllerParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFAnimatorControllerParser, GLTFParser);
    function GLTFAnimatorControllerParser() {
        return GLTFParser.apply(this, arguments) || this;
    }
    var _proto = GLTFAnimatorControllerParser.prototype;
    _proto.parse = function parse(context) {
        var _this = this;
        if (!context.needAnimatorController) {
            return Promise.resolve(null);
        }
        return context.get(GLTFParserType.Animation).then(function(animations) {
            var animatorController = _this._createAnimatorController(context, animations);
            return Promise.resolve(animatorController);
        });
    };
    _proto._createAnimatorController = function _createAnimatorController(context, animations) {
        var glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        var animatorController = new AnimatorController(engine);
        var layer = new AnimatorControllerLayer("layer");
        var animatorStateMachine = new AnimatorStateMachine();
        animatorController.addLayer(layer);
        layer.stateMachine = animatorStateMachine;
        if (animations) {
            for(var i = 0; i < animations.length; i++){
                var animationClip = animations[i];
                var name = animationClip.name;
                var uniqueName = animatorStateMachine.makeUniqueStateName(name);
                if (uniqueName !== name) {
                    console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
                }
                var animatorState = animatorStateMachine.addState(uniqueName);
                animatorState.clip = animationClip;
            }
        }
        return animatorController;
    };
    return GLTFAnimatorControllerParser;
}(GLTFParser);
GLTFAnimatorControllerParser = __decorate([
    registerGLTFParser(GLTFParserType.AnimatorController)
], GLTFAnimatorControllerParser);

// Source: https://github.com/zeux/meshoptimizer/blob/master/js/meshopt_decoder.js
var ready;
function getMeshoptDecoder() {
    if (ready) return ready;
    var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
    var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
    var wasmpack = new Uint8Array([
        32,
        0,
        65,
        2,
        1,
        106,
        34,
        33,
        3,
        128,
        11,
        4,
        13,
        64,
        6,
        253,
        10,
        7,
        15,
        116,
        127,
        5,
        8,
        12,
        40,
        16,
        19,
        54,
        20,
        9,
        27,
        255,
        113,
        17,
        42,
        67,
        24,
        23,
        146,
        148,
        18,
        14,
        22,
        45,
        70,
        69,
        56,
        114,
        101,
        21,
        25,
        63,
        75,
        136,
        108,
        28,
        118,
        29,
        73,
        115
    ]);
    // @ts-ignore
    var wasm = SystemInfo._detectSIMDSupported() ? wasm_simd : wasm_base;
    var instance;
    ready = WebAssembly.instantiate(unpack(wasm)).then(function(result) {
        instance = result.instance;
        instance.exports.__wasm_call_ctors();
    }).then(function() {
        return {
            workerCount: 4,
            ready: ready,
            useWorkers: function useWorkers(workerCount) {
                this.workerCount = workerCount != null ? workerCount : this.workerCount;
                initWorkers(this.workerCount);
            },
            decodeGltfBuffer: function decodeGltfBuffer(count, stride, source, mode, filter) {
                if (this.workerCount > 0 && workers.length === 0) this.useWorkers();
                if (workers.length > 0) return decodeWorker(count, stride, source, decoders[mode], filters[filter]);
                return ready.then(function() {
                    var target = new Uint8Array(count * stride);
                    decode(instance.exports[decoders[mode]], target, count, stride, source, instance.exports[filters[filter]]);
                    return target;
                });
            },
            release: function release() {
                for(var i = 0; i < workers.length; i++){
                    workers[i].object.terminate();
                }
            }
        };
    });
    function unpack(data) {
        var result = new Uint8Array(data.length);
        for(var i = 0; i < data.length; ++i){
            var ch = data.charCodeAt(i);
            result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
        }
        var write = 0;
        for(var i1 = 0; i1 < data.length; ++i1){
            result[write++] = result[i1] < 60 ? wasmpack[result[i1]] : (result[i1] - 60) * 64 + result[++i1];
        }
        return result.buffer.slice(0, write);
    }
    function decode(fun, target, count, size, source, filter) {
        var sbrk = instance.exports.sbrk;
        var count4 = count + 3 & ~3;
        var tp = sbrk(count4 * size);
        var sp = sbrk(source.length);
        var heap = new Uint8Array(instance.exports.memory.buffer);
        heap.set(source, sp);
        var res = fun(tp, count, size, sp, source.length);
        if (res == 0 && filter) {
            filter(tp, count4, size);
        }
        target.set(heap.subarray(tp, tp + count * size));
        sbrk(tp - sbrk(0));
        if (res != 0) {
            throw new Error("Malformed buffer data: " + res);
        }
    }
    var filters = {
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp"
    };
    var decoders = {
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence"
    };
    var workers = [];
    var requestId = 0;
    function createWorker(url) {
        var worker = {
            object: new Worker(url),
            pending: 0,
            requests: {}
        };
        worker.object.onmessage = function(event) {
            var data = event.data;
            worker.pending -= data.count;
            worker.requests[data.id][data.action](data.value);
            delete worker.requests[data.id];
        };
        return worker;
    }
    function initWorkers(count) {
        var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {})" + ".then(function(result) {instance = result.instance; instance.exports.__wasm_call_ctors();});\n" + "self.onmessage = workerProcess;\n" + 'function decode(fun, target, count, size, source, filter) {\n      const sbrk = instance.exports.sbrk;\n      const count4 = (count + 3) & ~3;\n      const tp = sbrk(count4 * size);\n      const sp = sbrk(source.length);\n      const heap = new Uint8Array(instance.exports.memory.buffer);\n      heap.set(source, sp);\n      const res = fun(tp, count, size, sp, source.length);\n      if (res == 0 && filter) {\n        filter(tp, count4, size);\n      }\n      target.set(heap.subarray(tp, tp + count * size));\n      sbrk(tp - sbrk(0));\n      if (res != 0) {\n        throw new Error("Malformed buffer data: " + res);\n      }\n    }\n' + 'function workerProcess(event) {\n      ready.then(function () {\n        const data = event.data;\n        try {\n          const target = new Uint8Array(data.count * data.size);\n          decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);\n          self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);\n        } catch (error) {\n          self.postMessage({\n            id: data.id,\n            count: data.count,\n            action: "reject",\n            value: error\n          });\n        }\n      });\n    }';
        var blob = new Blob([
            source
        ], {
            type: "text/javascript"
        });
        var url = URL.createObjectURL(blob);
        for(var i = 0; i < count; ++i){
            workers[i] = createWorker(url);
        }
        URL.revokeObjectURL(url);
    }
    function decodeWorker(count, size, source, mode, filter) {
        var worker = workers[0];
        for(var i = 1; i < workers.length; ++i){
            if (workers[i].pending < worker.pending) {
                worker = workers[i];
            }
        }
        return new Promise(function(resolve, reject) {
            var data = new Uint8Array(source);
            var id = requestId++;
            worker.pending += count;
            worker.requests[id] = {
                resolve: resolve,
                reject: reject
            };
            worker.object.postMessage({
                id: id,
                count: count,
                size: size,
                source: data,
                mode: mode,
                filter: filter
            }, [
                data.buffer
            ]);
        });
    }
    return ready;
}

var GLTFLoader = /*#__PURE__*/ function(Loader) {
    _inherits(GLTFLoader, Loader);
    function GLTFLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = GLTFLoader.prototype;
    _proto.initialize = function initialize(_, configuration) {
        var _configuration_glTFLoader, _configuration_glTF;
        var _configuration_glTFLoader_meshOpt;
        var meshOptOptions = (_configuration_glTFLoader_meshOpt = (_configuration_glTFLoader = configuration.glTFLoader) == null ? void 0 : _configuration_glTFLoader.meshOpt) != null ? _configuration_glTFLoader_meshOpt : (_configuration_glTF = configuration.glTF) == null ? void 0 : _configuration_glTF.meshOpt;
        if (meshOptOptions) {
            return getMeshoptDecoder().then(function(meshoptDecoder) {
                meshoptDecoder.useWorkers(meshOptOptions.workerCount);
            });
        }
        return Promise.resolve();
    };
    _proto.load = function load(item, resourceManager) {
        var params = item.params;
        var glTFResource = new GLTFResource(resourceManager.engine, item.url);
        var context = new GLTFParserContext(glTFResource, resourceManager, _extends({
            keepMeshData: false
        }, params));
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
            context._setTaskCompleteProgress = setTaskCompleteProgress;
            context._setTaskDetailProgress = setTaskDetailProgress;
            context.parse().then(resolve).catch(reject);
        });
    };
    /**
   * Release glTF loader memory(includes meshopt workers).
   * @remarks If use loader after releasing, we should release again.
   */ GLTFLoader.release = function release() {
        if (ready) {
            getMeshoptDecoder().then(function(meshoptDecoder) {
                meshoptDecoder.release();
            });
        }
    };
    return GLTFLoader;
}(Loader);
GLTFLoader = __decorate([
    resourceLoader(AssetType.GLTF, [
        "gltf",
        "glb"
    ])
], GLTFLoader);

var PrefabParser = /*#__PURE__*/ function(HierarchyParser) {
    _inherits(PrefabParser, HierarchyParser);
    function PrefabParser(data, context, prefabResource) {
        var _this;
        _this = HierarchyParser.call(this, data, context) || this, _this.prefabResource = prefabResource;
        return _this;
    }
    var _proto = PrefabParser.prototype;
    _proto._handleRootEntity = function _handleRootEntity(id) {
        this.prefabResource._root = this.context.entityMap.get(id);
    };
    _proto._clearAndResolve = function _clearAndResolve() {
        this.context.clear();
        return this.prefabResource;
    };
    PrefabParser.parse = function parse(engine, url, data) {
        var prefabResource = new PrefabResource(engine, url);
        var context = new ParserContext(engine, ParserType.Prefab, prefabResource);
        var parser = new PrefabParser(data, context, prefabResource);
        parser.start();
        return parser.promise.then(function() {
            return prefabResource;
        });
    };
    return PrefabParser;
}(HierarchyParser);

var PrefabLoader = /*#__PURE__*/ function(Loader) {
    _inherits(PrefabLoader, Loader);
    function PrefabLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = PrefabLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                PrefabParser.parse(engine, item.url, data).then(resolve).catch(reject);
            });
        });
    };
    return PrefabLoader;
}(Loader);
PrefabLoader = __decorate([
    resourceLoader(AssetType.Prefab, [
        "prefab"
    ])
], PrefabLoader);

var PI = Math.PI;
// referenece: https://www.flipcode.com/archives/HDR_Image_Reader.shtml
var HDRLoader = /*#__PURE__*/ function(Loader) {
    _inherits(HDRLoader, Loader);
    function HDRLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = HDRLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var engine = resourceManager.engine;
            var requestConfig = _extends({}, item, {
                type: "arraybuffer"
            });
            resourceManager// @ts-ignore
            ._request(item.url, requestConfig).then(function(buffer) {
                var texture = HDRLoader._setTextureByBuffer(engine, buffer);
                engine.resourceManager.addContentRestorer(new HDRContentRestorer(texture, item.url, requestConfig));
                resolve(texture);
            }).catch(reject);
        });
    };
    /**
   * @internal
   */ HDRLoader._setTextureByBuffer = function _setTextureByBuffer(engine, buffer, texture) {
        var bufferArray = new Uint8Array(buffer);
        var _HDRLoader__parseHeader = HDRLoader._parseHeader(bufferArray), width = _HDRLoader__parseHeader.width, height = _HDRLoader__parseHeader.height, dataPosition = _HDRLoader__parseHeader.dataPosition;
        var cubeSize = height >> 1;
        texture || (texture = new TextureCube(engine, cubeSize));
        var pixels = HDRLoader._readPixels(bufferArray.subarray(dataPosition), width, height);
        var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
        for(var faceIndex = 0; faceIndex < 6; faceIndex++){
            texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
        }
        texture.generateMipmaps();
        return texture;
    };
    HDRLoader._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
        if (!pixels) {
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (pixels.length != inputWidth * inputHeight * 4) {
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
        var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
        var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
        var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
        var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
        var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
        return [
            textureRight,
            textureLeft,
            textureUp,
            textureDown,
            textureFront,
            textureBack
        ];
    };
    HDRLoader._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
        var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
        var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
        var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
        var dy = 1 / texSize;
        var fy = 0;
        for(var y = 0; y < texSize; y++){
            var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
            var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
            for(var x = 0; x < texSize; x++){
                var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
                v.normalize();
                var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
                this._RGBEToLinear(color);
                this._linearToRGBM(color, 5);
                // 4 channels per pixels
                var index = y * texSize * 4 + x * 4;
                textureArray[index] = color.r;
                textureArray[index + 1] = color.g;
                textureArray[index + 2] = color.b;
                textureArray[index + 3] = color.a;
                xv1.add(rotDX1);
                xv2.add(rotDX2);
            }
            fy += dy;
        }
        return textureArray;
    };
    HDRLoader._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
        var theta = Math.atan2(vDir.z, vDir.x);
        var phi = Math.acos(vDir.y);
        while(theta < -PI){
            theta += 2 * PI;
        }
        while(theta > PI){
            theta -= 2 * PI;
        }
        var dx = theta / PI;
        var dy = phi / PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        var px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        } else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        var py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        } else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        var inputY = inputHeight - py - 1;
        var index = inputY * inputWidth * 4 + px * 4;
        var r = pixels[index];
        var g = pixels[index + 1];
        var b = pixels[index + 2];
        var a = pixels[index + 3];
        return new Color(r, g, b, a);
    };
    HDRLoader._readStringLine = function _readStringLine(uint8array, startIndex) {
        var line = "";
        var character = "";
        for(var i = startIndex; i < uint8array.length - startIndex; i++){
            character = String.fromCharCode(uint8array[i]);
            if (character == "\n") {
                break;
            }
            line += character;
        }
        return line;
    };
    HDRLoader._parseHeader = function _parseHeader(uint8array) {
        var height = 0;
        var width = 0;
        var line = this._readStringLine(uint8array, 0);
        if (line[0] != "#" || line[1] != "?") {
            throw "Bad HDR Format.";
        }
        var endOfHeader = false;
        var findFormat = false;
        var lineIndex = 0;
        do {
            lineIndex += line.length + 1;
            line = this._readStringLine(uint8array, lineIndex);
            if (line == "FORMAT=32-bit_rle_rgbe") {
                findFormat = true;
            } else if (line.length == 0) {
                endOfHeader = true;
            }
        }while (!endOfHeader);
        if (!findFormat) {
            throw "HDR Bad header format, unsupported FORMAT";
        }
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
        var match = sizeRegexp.exec(line);
        // TODO. Support +Y and -X if needed.
        if (!match || match.length < 3) {
            throw "HDR Bad header format, no size";
        }
        width = parseInt(match[2]);
        height = parseInt(match[1]);
        if (width < 8 || width > 0x7fff) {
            throw "HDR Bad header format, unsupported size";
        }
        lineIndex += line.length + 1;
        return {
            height: height,
            width: width,
            dataPosition: lineIndex
        };
    };
    HDRLoader._readPixels = function _readPixels(buffer, width, height) {
        var scanLineWidth = width;
        var byteLength = buffer.byteLength;
        var dataRGBA = new Uint8Array(4 * width * height);
        var offset = 0, pos = 0;
        var ptrEnd = 4 * scanLineWidth;
        var scanLineBuffer = new Uint8Array(ptrEnd);
        var numScanLines = height; // read in each successive scanLine
        while(numScanLines > 0 && pos < byteLength){
            var a = buffer[pos++];
            var b = buffer[pos++];
            var c = buffer[pos++];
            var d = buffer[pos++];
            if (a != 2 || b != 2 || c & 0x80 || width < 8 || width > 32767) {
                // this file is not run length encoded
                // read values sequentially
                return buffer;
            }
            if ((c << 8 | d) != scanLineWidth) {
                // eslint-disable-next-line no-throw-literal
                throw "HDR Bad header format, wrong scan line width";
            }
            // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent
            var ptr = 0, count = void 0;
            while(ptr < ptrEnd && pos < byteLength){
                count = buffer[pos++];
                var isEncodedRun = count > 128;
                if (isEncodedRun) count -= 128;
                if (0 === count || ptr + count > ptrEnd) {
                    throw "HDR Bad Format, bad scanline data (run)";
                }
                if (isEncodedRun) {
                    // a (encoded) run of the same value
                    var byteValue = buffer[pos++];
                    for(var i = 0; i < count; i++){
                        scanLineBuffer[ptr++] = byteValue;
                    } //ptr += count;
                } else {
                    // a literal-run
                    scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
                    ptr += count;
                    pos += count;
                }
            } // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)
            var l = scanLineWidth; //scanLine_buffer.byteLength;
            for(var i1 = 0; i1 < l; i1++){
                var off = 0;
                dataRGBA[offset] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 1] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 2] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 3] = scanLineBuffer[i1 + off];
                offset += 4;
            }
            numScanLines--;
        }
        return dataRGBA;
    };
    HDRLoader._RGBEToLinear = function _RGBEToLinear(color) {
        var scaleFactor = Math.pow(2, color.a - 128) / 255;
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a = 1;
    };
    HDRLoader._linearToRGBM = function _linearToRGBM(color, maxRange) {
        var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
        var M = Math.min(maxRGB / maxRange, 1);
        M = Math.ceil(M * 255);
        var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a *= M;
    };
    return HDRLoader;
}(Loader);
HDRLoader._rightBottomBack = new Vector3(1.0, -1.0, -1.0);
HDRLoader._rightBottomFront = new Vector3(1.0, -1.0, 1.0);
HDRLoader._rightUpBack = new Vector3(1.0, 1.0, -1.0);
HDRLoader._rightUpFront = new Vector3(1.0, 1.0, 1.0);
HDRLoader._leftBottomBack = new Vector3(-1.0, -1.0, -1.0);
HDRLoader._leftBottomFront = new Vector3(-1.0, -1.0, 1.0);
HDRLoader._leftUpBack = new Vector3(-1.0, 1.0, -1.0);
HDRLoader._leftUpFront = new Vector3(-1.0, 1.0, 1.0);
HDRLoader._faceRight = [
    HDRLoader._rightBottomBack,
    HDRLoader._rightBottomFront,
    HDRLoader._rightUpBack,
    HDRLoader._rightUpFront
];
HDRLoader._faceLeft = [
    HDRLoader._leftBottomFront,
    HDRLoader._leftBottomBack,
    HDRLoader._leftUpFront,
    HDRLoader._leftUpBack
];
HDRLoader._faceUp = [
    HDRLoader._leftBottomFront,
    HDRLoader._rightBottomFront,
    HDRLoader._leftBottomBack,
    HDRLoader._rightBottomBack
];
HDRLoader._faceBottom = [
    HDRLoader._leftUpBack,
    HDRLoader._rightUpBack,
    HDRLoader._leftUpFront,
    HDRLoader._rightUpFront
];
HDRLoader._faceFront = [
    HDRLoader._leftBottomBack,
    HDRLoader._rightBottomBack,
    HDRLoader._leftUpBack,
    HDRLoader._rightUpBack
];
HDRLoader._faceBack = [
    HDRLoader._rightBottomFront,
    HDRLoader._leftBottomFront,
    HDRLoader._rightUpFront,
    HDRLoader._leftUpFront
];
HDRLoader._tempVector3 = new Vector3();
HDRLoader._temp2Vector3 = new Vector3();
HDRLoader._temp3Vector3 = new Vector3();
HDRLoader._temp4Vector3 = new Vector3();
HDRLoader._temp5Vector3 = new Vector3();
HDRLoader = __decorate([
    resourceLoader(AssetType.HDR, [
        "hdr"
    ])
], HDRLoader);
/**
 * @internal
 */ var HDRContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(HDRContentRestorer, ContentRestorer);
    function HDRContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = HDRContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            request(_this.url, _this.requestConfig).then(function(buffer) {
                HDRLoader._setTextureByBuffer(_this.resource.engine, buffer, _this.resource);
                resolve(_this.resource);
            }).catch(reject);
        });
    };
    return HDRContentRestorer;
}(ContentRestorer);

var JSONLoader = /*#__PURE__*/ function(Loader) {
    _inherits(JSONLoader, Loader);
    function JSONLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        // @ts-ignore
        return resourceManager._request(item.url, _extends({}, item, {
            type: "json"
        }));
    };
    return JSONLoader;
}(Loader);
JSONLoader = __decorate([
    resourceLoader(AssetType.JSON, [
        "json"
    ], false)
], JSONLoader);

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    // initialize width & height for level 1
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
    for(var level = 0; level < mipmapCount; level++){
        var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
        dataOffset += 4; // size of the image + 4 for the imageSize field
        for(var face = 0; face < ktxContainer.numberOfFaces; face++){
            var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
            mipmaps.push({
                data: byteArray,
                width: width,
                height: height
            });
            dataOffset += imageSize;
            dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
        }
        width = Math.max(1.0, width * 0.5);
        height = Math.max(1.0, height * 0.5);
    }
    return mipmaps;
}
/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */ function isValid(data) {
    if (data.byteLength >= 12) {
        // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
        var identifier = new Uint8Array(data, 0, 12);
        if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
            return true;
        }
    }
    return false;
}
function getEngineFormat(internalFormat) {
    switch(internalFormat){
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        // break;
        case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
            return TextureFormat.BC1;
        case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
            return TextureFormat.BC3;
        case GLCompressedTextureInternalFormat.RGBA_BPTC_UNORM_EXT:
            return TextureFormat.BC7;
        case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
            return TextureFormat.ETC1_RGB;
        case GLCompressedTextureInternalFormat.RGB8_ETC2:
            return TextureFormat.ETC2_RGB;
        case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
            return TextureFormat.ETC2_RGBA5;
        case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
            return TextureFormat.ETC2_RGBA8;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGB2;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA2;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGB4;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
            return TextureFormat.ASTC_4x4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
            return TextureFormat.ASTC_5x5;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
            return TextureFormat.ASTC_6x6;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
            return TextureFormat.ASTC_8x8;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
            return TextureFormat.ASTC_10x10;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
            return TextureFormat.ASTC_12x12;
        default:
            var formatName = GLCompressedTextureInternalFormat[internalFormat];
            throw new Error("this format is not supported in Galacean Engine: " + formatName);
    }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */ var khronosTextureContainerParser = {
    /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Galacean Engine native TextureFormat?
   */ parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
        if (mapEngineFormat === void 0) mapEngineFormat = false;
        if (!isValid(buffer)) {
            throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(buffer, 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        var parsedResult = {
            buffer: buffer,
            glType: headerDataView.getUint32(1 * dataSize, littleEndian),
            glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
            glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
            glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
            glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
            pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
            pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
            pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
            numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
            numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
            numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
            bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
            // would need to make this more elaborate & adjust checks above to support more than one load type
            loadType: COMPRESSED_2D
        };
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (parsedResult.glType !== 0) {
            throw new Error("only compressed formats currently supported");
        } else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
        }
        if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
            throw new Error("only 2D textures currently supported");
        }
        if (parsedResult.numberOfArrayElements !== 0) {
            throw new Error("texture arrays not currently supported");
        }
        if (parsedResult.numberOfFaces !== facesExpected) {
            throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
        }
        if (withMipmaps) {
            parsedResult.mipmaps = getMipmaps(parsedResult, true);
        }
        if (mapEngineFormat) {
            parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
        }
        return parsedResult;
    }
};

function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
        mipmaps: ktx.mipmaps,
        engineFormat: ktx.engineFormat,
        internalFormat: ktx.glInternalFormat,
        width: ktx.pixelWidth,
        height: ktx.pixelHeight
    };
}
function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for(var i = 0; i < dataArray.length; i++){
        var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
        mipmapsFaces.push(ktx.mipmaps);
        if (i === 0) {
            width = ktx.pixelWidth;
            height = ktx.pixelHeight;
            internalFormat = ktx.glInternalFormat;
            engineFormat = ktx.engineFormat;
        }
    }
    return {
        mipmapsFaces: mipmapsFaces,
        engineFormat: engineFormat,
        internalFormat: internalFormat,
        width: width,
        height: height
    };
}

var KTXCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXCubeLoader, Loader);
    function KTXCubeLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            Promise.all(item.urls.map(function(url) {
                return(// @ts-ignore
                resourceManager._request(url, _extends({}, item, {
                    type: "arraybuffer"
                })));
            })).then(function(data) {
                var parsedData = parseCubeKTX(data);
                var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
                var mipmap = mipmapsFaces[0].length > 1;
                var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
                for(var face = 0; face < 6; face++){
                    var length = mipmapsFaces[face].length;
                    for(var miplevel = 0; miplevel < length; miplevel++){
                        var _mipmapsFaces_face_miplevel = mipmapsFaces[face][miplevel], _$data = _mipmapsFaces_face_miplevel.data, width1 = _mipmapsFaces_face_miplevel.width, height = _mipmapsFaces_face_miplevel.height;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _$data, miplevel, 0, 0, width1, height);
                    }
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXCubeLoader;
}(Loader);
KTXCubeLoader = __decorate([
    resourceLoader(AssetType.KTXCube, [])
], KTXCubeLoader);

var KTXLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXLoader, Loader);
    function KTXLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(bin) {
                var parsedData = parseSingleKTX(bin);
                var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
                var mipmap = mipmaps.length > 1;
                var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
                for(var miplevel = 0; miplevel < mipmaps.length; miplevel++){
                    var _mipmaps_miplevel = mipmaps[miplevel], width1 = _mipmaps_miplevel.width, height1 = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
                    texture.setPixelBuffer(data, miplevel, 0, 0, width1, height1);
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXLoader;
}(Loader);
KTXLoader = __decorate([
    resourceLoader(AssetType.KTX, [
        "ktx"
    ])
], KTXLoader);

function parseProperty(object, key, value) {
    if ((typeof value === "undefined" ? "undefined" : _type_of(value)) === "object") {
        for(var subKey in value){
            parseProperty(object[key], subKey, value[subKey]);
        }
    } else {
        object[key] = value;
    }
}
var MaterialLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MaterialLoader, Loader);
    function MaterialLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(materialSchema) {
                var engine = resourceManager.engine;
                var shaderRef = materialSchema.shaderRef, shaderName = materialSchema.shader;
                var shader = Shader.find(shaderName);
                if (shader) {
                    resolve(_this._getMaterialByShader(materialSchema, shader, engine));
                } else if (shaderRef) {
                    resolve(resourceManager// @ts-ignore
                    .getResourceByRef(shaderRef).then(function(shader) {
                        return _this._getMaterialByShader(materialSchema, shader, engine);
                    }));
                }
            }).catch(reject);
        });
    };
    _proto._getMaterialByShader = function _getMaterialByShader(materialSchema, shader, engine) {
        var _loop = function(key) {
            var _shaderData_key = shaderData[key], type = _shaderData_key.type, value = _shaderData_key.value;
            switch(type){
                case MaterialLoaderType.Vector2:
                    materialShaderData.setVector2(key, new Vector2(value.x, value.y));
                    break;
                case MaterialLoaderType.Vector3:
                    materialShaderData.setVector3(key, new Vector3(value.x, value.y, value.z));
                    break;
                case MaterialLoaderType.Vector4:
                    materialShaderData.setVector4(key, new Vector4(value.x, value.y, value.z, value.w));
                    break;
                case MaterialLoaderType.Color:
                    materialShaderData.setColor(key, new Color(value.r, value.g, value.b, value.a));
                    break;
                case MaterialLoaderType.Float:
                    materialShaderData.setFloat(key, value);
                    break;
                case MaterialLoaderType.Texture:
                    texturePromises.push(// @ts-ignore
                    engine.resourceManager.getResourceByRef(value).then(function(texture) {
                        materialShaderData.setTexture(key, texture);
                    }));
                    break;
                case MaterialLoaderType.Boolean:
                    materialShaderData.setInt(key, value ? 1 : 0);
                    break;
                case MaterialLoaderType.Integer:
                    materialShaderData.setInt(key, Number(value));
                    break;
            }
        };
        var name = materialSchema.name, shaderData = materialSchema.shaderData, macros = materialSchema.macros, renderState = materialSchema.renderState;
        var material = new Material(engine, shader);
        material.name = name;
        var texturePromises = new Array();
        var materialShaderData = material.shaderData;
        for(var key in shaderData)_loop(key);
        for(var i = 0, length = macros.length; i < length; i++){
            var _macros_i = macros[i], name1 = _macros_i.name, value = _macros_i.value;
            if (value == undefined) {
                materialShaderData.enableMacro(name1);
            } else {
                materialShaderData.enableMacro(name1, value);
            }
        }
        parseProperty(material, "renderState", renderState);
        return Promise.all(texturePromises).then(function() {
            return material;
        });
    };
    return MaterialLoader;
}(Loader);
MaterialLoader = __decorate([
    resourceLoader(AssetType.Material, [
        "json"
    ])
], MaterialLoader);

var MeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine);
            }).then(function(mesh) {
                resolve(mesh);
            }).catch(reject);
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader = __decorate([
    resourceLoader(AssetType.Mesh, [
        "mesh"
    ])
], MeshLoader);

var PrimitiveMeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(PrimitiveMeshLoader, Loader);
    function PrimitiveMeshLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = PrimitiveMeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return resourceManager// @ts-ignore
        ._request(item.url, _extends({}, item, {
            type: "json"
        })).then(function(data) {
            switch(data.type){
                case "sphere":
                    return PrimitiveMesh.createSubdivisionSurfaceSphere(engine, data.sphereRadius, data.sphereStep);
                case "capsule":
                    return PrimitiveMesh.createCapsule(engine, data.capsuleRadius, data.capsuleHeight, data.capsuleRadialSegments, data.capsuleHeightSegments);
                case "cone":
                    return PrimitiveMesh.createCone(engine, data.coneRadius, data.coneHeight, data.coneRadialSegment, data.coneHeightSegment);
                case "cuboid":
                    return PrimitiveMesh.createCuboid(engine, data.cuboidWidth, data.cuboidHeight, data.cuboidDepth);
                case "cylinder":
                    return PrimitiveMesh.createCylinder(engine, data.cylinderRadiusTop, data.cylinderRadiusBottom, data.cylinderHeight, data.cylinderRadialSegment, data.cylinderHeightSegment);
                case "plane":
                    return PrimitiveMesh.createPlane(engine, data.planeWidth, data.planeHeight, data.planeHorizontalSegments, data.planeVerticalSegments);
                case "torus":
                    return PrimitiveMesh.createTorus(engine, data.torusRadius, data.torusTubeRadius, data.torusRadialSegments, data.torusTubularSegments, data.torusArc);
            }
        });
    };
    return PrimitiveMeshLoader;
}(Loader);
PrimitiveMeshLoader = __decorate([
    resourceLoader(AssetType.PrimitiveMesh, [
        "mesh"
    ], false)
], PrimitiveMeshLoader);

var ProjectLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ProjectLoader, Loader);
    function ProjectLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ProjectLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                // @ts-ignore
                engine.resourceManager.initVirtualResources(data.files);
                return resourceManager.load({
                    type: AssetType.Scene,
                    url: data.scene
                }).then(function(scene) {
                    engine.sceneManager.activeScene = scene;
                    resolve();
                });
            }).catch(reject);
        });
    };
    return ProjectLoader;
}(Loader);
ProjectLoader = __decorate([
    resourceLoader(AssetType.Project, [
        "proj"
    ], false)
], ProjectLoader);

var SourceFontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SourceFontLoader, Loader);
    function SourceFontLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SourceFontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            // @ts-ignore
            var url = resourceManager._getRemoteUrl(item.url);
            _this._registerFont(url, url).then(function() {
                var font = new Font(resourceManager.engine, url);
                resolve(font);
            }).catch(function(e) {
                reject("load font " + url + " fail");
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return SourceFontLoader;
}(Loader);
SourceFontLoader = __decorate([
    resourceLoader(AssetType.SourceFont, [
        "ttf",
        "otf",
        "woff"
    ], false)
], SourceFontLoader);

var SpriteAtlasLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteAtlasLoader, Loader);
    function SpriteAtlasLoader() {
        var _this;
        _this = Loader.apply(this, arguments) || this, _this._tempRect = new Rect(), _this._tempVec2 = new Vector2(), _this._tempVec4 = new Vector4();
        return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject, _, __, onCancel) {
            var chainPromises = [];
            onCancel(function() {
                for(var i = 0; i < chainPromises.length; i++){
                    chainPromises[i].cancel();
                }
            });
            // @ts-ignore
            var configPromise = resourceManager._request(item.url, _extends({}, item, {
                type: "json"
            }));
            chainPromises.push(configPromise);
            configPromise.then(function(atlasData) {
                var _loop = function(i) {
                    var atlasItem = atlasItems[i];
                    if (atlasItem.img) {
                        var _atlasItem_type;
                        chainPromises.push(resourceManager.load({
                            url: Utils.resolveAbsoluteUrl(item.url, atlasItem.img),
                            type: (_atlasItem_type = atlasItem.type) != null ? _atlasItem_type : AssetType.Texture2D,
                            params: {
                                format: format,
                                mipmap: mipmap
                            }
                        }).then(function(texture) {
                            anisoLevel && (texture.anisoLevel = anisoLevel);
                            filterMode !== undefined && (texture.filterMode = filterMode);
                            wrapModeU !== undefined && (texture.wrapModeU = wrapModeU);
                            wrapModeV !== undefined && (texture.wrapModeV = wrapModeV);
                            for(var i = 0; i < atlasItem.sprites.length; i++){
                                // @ts-ignore
                                spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i], texture));
                            }
                        }).catch(reject));
                    } else {
                        for(var i1 = 0; i1 < atlasItem.sprites.length; i1++){
                            // @ts-ignore
                            spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i1]));
                        }
                    }
                };
                var atlasItems = atlasData.atlasItems, mipmap = atlasData.mipmap, anisoLevel = atlasData.anisoLevel, filterMode = atlasData.filterMode, wrapModeU = atlasData.wrapModeU, wrapModeV = atlasData.wrapModeV, format = atlasData.format;
                var atlasItemsLen = atlasItems ? atlasItems.length : 0;
                var engine = resourceManager.engine;
                var spriteAtlas = new SpriteAtlas(engine);
                if (atlasItemsLen <= 0) {
                    resolve(spriteAtlas);
                    return;
                }
                chainPromises.length = 0;
                for(var i = 0; i < atlasItemsLen; i++)_loop(i);
                AssetPromise.all(chainPromises).then(function() {
                    resolve(spriteAtlas);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._makeSprite = function _makeSprite(engine, config, texture) {
        // Generate a SpriteAtlas object.
        var region = config.region, atlasRegionOffset = config.atlasRegionOffset, atlasRegion = config.atlasRegion, pivot = config.pivot, border = config.border, width = config.width, height = config.height;
        var sprite = new Sprite(engine, texture, region ? this._tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? this._tempVec2.set(pivot.x, pivot.y) : undefined, border ? this._tempVec4.set(border.x, border.y, border.z, border.w) : undefined, config.name);
        if (texture) {
            var invW = 1 / texture.width;
            var invH = 1 / texture.height;
            sprite.atlasRegion.set(atlasRegion.x * invW, atlasRegion.y * invH, atlasRegion.w * invW, atlasRegion.h * invH);
            if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                sprite.atlasRegionOffset.set(offsetLeft * invW, offsetTop * invH, offsetRight * invW, offsetBottom * invH);
            }
            config.atlasRotated && (sprite.atlasRotated = true);
        }
        isNaN(width) || (sprite.width = width);
        isNaN(height) || (sprite.height = height);
        return sprite;
    };
    return SpriteAtlasLoader;
}(Loader);
SpriteAtlasLoader = __decorate([
    resourceLoader(AssetType.SpriteAtlas, [
        "atlas"
    ], false)
], SpriteAtlasLoader);

var SpriteLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteLoader, Loader);
    function SpriteLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return resourceManager// @ts-ignore
        ._request(item.url, _extends({}, item, {
            type: "json"
        })).then(function(data) {
            return data.belongToAtlas ? _this._loadFromAtlas(resourceManager, data) : _this._loadFromTexture(resourceManager, data);
        });
    };
    _proto._loadFromAtlas = function _loadFromAtlas(resourceManager, data) {
        var _this = this;
        return resourceManager// @ts-ignore
        .getResourceByRef(data.belongToAtlas).then(function(atlas) {
            return atlas.getSprite(data.fullPath) || _this._loadFromTexture(resourceManager, data);
        });
    };
    _proto._loadFromTexture = function _loadFromTexture(resourceManager, data) {
        if (data.texture) {
            return resourceManager// @ts-ignore
            .getResourceByRef(data.texture).then(function(texture) {
                var sprite = new Sprite(resourceManager.engine, texture, data.region, data.pivot, data.border);
                var width = data.width, height = data.height;
                isNaN(width) || (sprite.width = width);
                isNaN(height) || (sprite.height = height);
                return sprite;
            });
        } else {
            return new AssetPromise(function(resolve) {
                var sprite = new Sprite(resourceManager.engine, null, data.region, data.pivot, data.border);
                var width = data.width, height = data.height;
                isNaN(width) || (sprite.width = width);
                isNaN(height) || (sprite.height = height);
                resolve(sprite);
            });
        }
    };
    return SpriteLoader;
}(Loader);
SpriteLoader = __decorate([
    resourceLoader(AssetType.Sprite, [
        "sprite"
    ], false)
], SpriteLoader);

/**
 * @internal
 */ var Texture2DContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(Texture2DContentRestorer, ContentRestorer);
    function Texture2DContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.url = url, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = Texture2DContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return request(this.url, this.requestConfig).then(function(image) {
            var resource = _this.resource;
            resource.setImageSource(image);
            resource.generateMipmaps();
            return resource;
        });
    };
    return Texture2DContentRestorer;
}(ContentRestorer);

var Texture2DLoader = /*#__PURE__*/ function(Loader) {
    _inherits(Texture2DLoader, Loader);
    function Texture2DLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject, setTaskCompleteProgress, setTaskDetailProgress) {
            var url = item.url;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            resourceManager// @ts-ignore
            ._request(url, requestConfig).onProgress(setTaskCompleteProgress, setTaskDetailProgress).then(function(image) {
                var _item_params;
                var _ref = (_item_params = item.params) != null ? _item_params : {}, format = _ref.format, mipmap = _ref.mipmap, anisoLevel = _ref.anisoLevel, wrapModeU = _ref.wrapModeU, wrapModeV = _ref.wrapModeV, filterMode = _ref.filterMode;
                var texture = new Texture2D(resourceManager.engine, image.width, image.height, format, mipmap);
                texture.anisoLevel = anisoLevel != null ? anisoLevel : texture.anisoLevel;
                texture.filterMode = filterMode != null ? filterMode : texture.filterMode;
                texture.wrapModeU = wrapModeU != null ? wrapModeU : texture.wrapModeU;
                texture.wrapModeV = wrapModeV != null ? wrapModeV : texture.wrapModeV;
                texture.setImageSource(image);
                texture.generateMipmaps();
                if (url.indexOf("data:") !== 0) {
                    var index = url.lastIndexOf("/");
                    texture.name = url.substring(index + 1);
                }
                resourceManager.addContentRestorer(new Texture2DContentRestorer(texture, url, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return Texture2DLoader;
}(Loader);
Texture2DLoader = __decorate([
    resourceLoader(AssetType.Texture2D, [
        "png",
        "jpg",
        "webp",
        "jpeg"
    ])
], Texture2DLoader);

/**
 * @internal
 */ var TextureCubeContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(TextureCubeContentRestorer, ContentRestorer);
    function TextureCubeContentRestorer(resource, urls, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this, _this.urls = urls, _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = TextureCubeContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.urls.map(function(url) {
                return request(url, _this.requestConfig);
            })).then(function(images) {
                var resource = _this.resource;
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    resource.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                resource.generateMipmaps();
                resolve(resource);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeContentRestorer;
}(ContentRestorer);

var TextureCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(TextureCubeLoader, Loader);
    function TextureCubeLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        return new AssetPromise(function(resolve, reject) {
            var urls = item.urls;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            // @ts-ignore
            Promise.all(urls.map(function(url) {
                return resourceManager._request(url, requestConfig);
            })).then(function(images) {
                var _images_ = images[0], width = _images_.width, height = _images_.height;
                if (width !== height) {
                    console.error("The cube texture must have the same width and height");
                    return;
                }
                var texture = new TextureCube(resourceManager.engine, width);
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    texture.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                texture.generateMipmaps();
                resourceManager.addContentRestorer(new TextureCubeContentRestorer(texture, urls, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeLoader;
}(Loader);
TextureCubeLoader = __decorate([
    resourceLoader(AssetType.TextureCube, [
        ""
    ])
], TextureCubeLoader);

var ShaderChunkLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ShaderChunkLoader, Loader);
    function ShaderChunkLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ShaderChunkLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var url = item.url;
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "text"
        })).then(function(code) {
            ShaderFactory.registerInclude(url.substring(1), code);
            return ShaderChunkLoader._loadChunksInCode(code, url, resourceManager);
        });
    };
    /**
   * @internal
   */ ShaderChunkLoader._loadChunksInCode = function _loadChunksInCode(code, basePath, resourceManager) {
        var shaderChunkPaths = new Array();
        var matches = code.matchAll(ShaderChunkLoader._shaderIncludeRegex);
        for(var _iterator = _create_for_of_iterator_helper_loose(matches), _step; !(_step = _iterator()).done;){
            var match = _step.value;
            var chunkPath = Utils.resolveAbsoluteUrl(basePath, match[1]);
            if (!ShaderLib[chunkPath.substring(1)]) {
                shaderChunkPaths.push(chunkPath);
            }
        }
        return Promise.all(shaderChunkPaths.map(function(chunkPath) {
            return resourceManager.load({
                type: "ShaderChunk",
                url: chunkPath
            });
        }));
    };
    return ShaderChunkLoader;
}(Loader);
ShaderChunkLoader._shaderIncludeRegex = /\s#include\s+"([./][^\\"]+)"/gm;
ShaderChunkLoader = __decorate([
    resourceLoader("ShaderChunk", [
        "glsl"
    ])
], ShaderChunkLoader);

var ShaderLoader = /*#__PURE__*/ function(Loader) {
    _inherits(ShaderLoader, Loader);
    function ShaderLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = ShaderLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        var url = item.url;
        // @ts-ignore
        return resourceManager._request(url, _extends({}, item, {
            type: "text"
        })).then(function(code) {
            var builtinShader = _this._getBuiltinShader(code);
            if (builtinShader) {
                return Shader.find(builtinShader);
            }
            return ShaderChunkLoader._loadChunksInCode(code, url, resourceManager).then(function() {
                var shader = Shader.create(code);
                // @ts-ignore
                shader._registerPath(url);
                return shader;
            });
        });
    };
    _proto._getBuiltinShader = function _getBuiltinShader(code) {
        var match = code.match(ShaderLoader._builtinRegex);
        if (match && match[1]) return match[1];
    };
    return ShaderLoader;
}(Loader);
ShaderLoader._builtinRegex = /^\s*\/\/\s*@builtin\s+(\w+)/;
ShaderLoader = __decorate([
    resourceLoader(AssetType.Shader, [
        "gs",
        "gsl"
    ])
], ShaderLoader);

var SceneLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SceneLoader, Loader);
    function SceneLoader() {
        return Loader.apply(this, arguments) || this;
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            resourceManager// @ts-ignore
            ._request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                return SceneParser.parse(engine, data).then(function(scene) {
                    var promises = [];
                    // parse ambient light
                    var ambient = data.scene.ambient;
                    if (ambient) {
                        var useCustomAmbient = ambient.specularMode === SpecularMode.Custom;
                        var useSH = ambient.diffuseMode === DiffuseMode.SphericalHarmonics;
                        scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                        scene.ambientLight.specularIntensity = ambient.specularIntensity;
                        scene.ambientLight.diffuseMode = ambient.diffuseMode;
                        scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
                        scene.ambientLight.specularTextureDecodeRGBM = true;
                        if (useCustomAmbient && ambient.customAmbientLight) {
                            promises.push(// @ts-ignore
                            resourceManager.getResourceByRef(ambient.customAmbientLight).then(function(ambientLight) {
                                scene.ambientLight.specularTexture = ambientLight == null ? void 0 : ambientLight.specularTexture;
                            }));
                        }
                        if (ambient.ambientLight && (!useCustomAmbient || useSH)) {
                            promises.push(// @ts-ignore
                            resourceManager.getResourceByRef(ambient.ambientLight).then(function(ambientLight) {
                                if (!useCustomAmbient) {
                                    scene.ambientLight.specularTexture = ambientLight == null ? void 0 : ambientLight.specularTexture;
                                }
                                if (useSH) {
                                    scene.ambientLight.diffuseSphericalHarmonics = ambientLight == null ? void 0 : ambientLight.diffuseSphericalHarmonics;
                                }
                            }));
                        }
                    }
                    // parse background
                    var background = data.scene.background;
                    scene.background.mode = background.mode;
                    switch(scene.background.mode){
                        case BackgroundMode.SolidColor:
                            scene.background.solidColor.copyFrom(background.color);
                            break;
                        case BackgroundMode.Sky:
                            if (background.skyMesh && background.skyMaterial) {
                                // @ts-ignore
                                var skyMeshPromise = resourceManager.getResourceByRef(background.skyMesh).then(function(mesh) {
                                    scene.background.sky.mesh = mesh;
                                });
                                // @ts-ignore
                                // prettier-ignore
                                var skyMaterialPromise = resourceManager.getResourceByRef(background.skyMaterial).then(function(material) {
                                    scene.background.sky.material = material;
                                });
                                promises.push(skyMeshPromise, skyMaterialPromise);
                            } else {
                                Logger.warn("Sky background mode requires skyMesh and skyMaterial");
                            }
                            break;
                        case BackgroundMode.Texture:
                            if (background.texture) {
                                // @ts-ignore
                                // prettier-ignore
                                var backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                                    scene.background.texture = texture;
                                });
                                promises.push(backgroundPromise);
                                var _background_textureFillMode;
                                scene.background.textureFillMode = (_background_textureFillMode = background.textureFillMode) != null ? _background_textureFillMode : scene.background.textureFillMode;
                            }
                            break;
                    }
                    // parse shadow
                    var shadow = data.scene.shadow;
                    if (shadow) {
                        if (shadow.castShadows != undefined) scene.castShadows = shadow.castShadows;
                        if (shadow.shadowResolution != undefined) scene.shadowResolution = shadow.shadowResolution;
                        if (shadow.shadowDistance != undefined) scene.shadowDistance = shadow.shadowDistance;
                        if (shadow.shadowCascades != undefined) scene.shadowCascades = shadow.shadowCascades;
                        if (shadow.enableTransparentShadow != undefined) {
                            scene.enableTransparentShadow = shadow.enableTransparentShadow;
                        }
                        var _shadow_shadowTwoCascadeSplits;
                        scene.shadowTwoCascadeSplits = (_shadow_shadowTwoCascadeSplits = shadow.shadowTwoCascadeSplits) != null ? _shadow_shadowTwoCascadeSplits : scene.shadowTwoCascadeSplits;
                        shadow.shadowFourCascadeSplits && scene.shadowFourCascadeSplits.copyFrom(shadow.shadowFourCascadeSplits);
                        var _shadow_shadowFadeBorder;
                        scene.shadowFadeBorder = (_shadow_shadowFadeBorder = shadow.shadowFadeBorder) != null ? _shadow_shadowFadeBorder : scene.shadowFadeBorder;
                    }
                    // parse fog
                    var fog = data.scene.fog;
                    if (fog) {
                        if (fog.fogMode != undefined) scene.fogMode = fog.fogMode;
                        if (fog.fogStart != undefined) scene.fogStart = fog.fogStart;
                        if (fog.fogEnd != undefined) scene.fogEnd = fog.fogEnd;
                        if (fog.fogDensity != undefined) scene.fogDensity = fog.fogDensity;
                        if (fog.fogColor != undefined) scene.fogColor.copyFrom(fog.fogColor);
                    }
                    // Post Process
                    var postProcessData = data.scene.postProcess;
                    if (postProcessData) {
                        // @ts-ignore
                        var postProcessManager = scene._postProcessManager;
                        var bloomEffect = postProcessManager._bloomEffect;
                        var tonemappingEffect = postProcessManager._tonemappingEffect;
                        postProcessManager.isActive = postProcessData.isActive;
                        bloomEffect.enabled = postProcessData.bloom.enabled;
                        bloomEffect.downScale = postProcessData.bloom.downScale;
                        bloomEffect.threshold = postProcessData.bloom.threshold;
                        bloomEffect.scatter = postProcessData.bloom.scatter;
                        bloomEffect.intensity = postProcessData.bloom.intensity;
                        bloomEffect.tint.copyFrom(postProcessData.bloom.tint);
                        bloomEffect.dirtIntensity = postProcessData.bloom.dirtIntensity;
                        tonemappingEffect.enabled = postProcessData.tonemapping.enabled;
                        tonemappingEffect.mode = postProcessData.tonemapping.mode;
                        if (postProcessData.bloom.dirtTexture) {
                            // @ts-ignore
                            // prettier-ignore
                            var dirtTexturePromise = resourceManager.getResourceByRef(postProcessData.bloom.dirtTexture).then(function(texture) {
                                bloomEffect.dirtTexture = texture;
                            });
                            promises.push(dirtTexturePromise);
                        }
                    }
                    return Promise.all(promises).then(function() {
                        resolve(scene);
                    });
                });
            }).catch(reject);
        });
    };
    return SceneLoader;
}(Loader);
SceneLoader = __decorate([
    resourceLoader(AssetType.Scene, [
        "scene"
    ], true)
], SceneLoader);
ReflectionParser.registerCustomParseComponent("TextRenderer", /*#__PURE__*/ _async_to_generator(function(instance, item) {
    var props;
    return __generator(this, function(_state) {
        props = item.props;
        if (!props.font) {
            // @ts-ignore
            instance.font = Font.createFromOS(instance.engine, props.fontFamily || "Arial");
        }
        return [
            2,
            instance
        ];
    });
}));

var KHR_lights_punctual = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_lights_punctual, GLTFExtensionParser);
    function KHR_lights_punctual() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.additiveParse = function additiveParse(context, entity, extensionSchema) {
        var _glTFResource;
        var lightsSchema = context.glTF.extensions.KHR_lights_punctual.lights;
        var lightSchema = lightsSchema[extensionSchema.light];
        var color = lightSchema.color, _lightSchema_intensity = lightSchema.intensity, intensity = _lightSchema_intensity === void 0 ? 1 : _lightSchema_intensity, type = lightSchema.type, range = lightSchema.range, spot = lightSchema.spot;
        var glTFResource = context.glTFResource;
        var light;
        if (type === "directional") {
            light = entity.addComponent(DirectLight);
        } else if (type === "point") {
            light = entity.addComponent(PointLight);
        } else if (type === "spot") {
            light = entity.addComponent(SpotLight);
        }
        if (color) {
            light.color.set(color[0], color[1], color[2], 1);
        }
        light.intensity = intensity;
        if (range && !_instanceof(light, DirectLight)) {
            light.distance = range;
        }
        if (spot && _instanceof(light, SpotLight)) {
            var _spot_innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot_innerConeAngle === void 0 ? 0 : _spot_innerConeAngle, _spot_outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot_outerConeAngle === void 0 ? Math.PI / 4 : _spot_outerConeAngle;
            light.angle = innerConeAngle;
            light.penumbra = outerConeAngle - innerConeAngle;
        }
        (_glTFResource = glTFResource).lights || (_glTFResource.lights = []);
        glTFResource.lights.push(light);
    };
    return KHR_lights_punctual;
}(GLTFExtensionParser);
KHR_lights_punctual = __decorate([
    registerGLTFExtension("KHR_lights_punctual", GLTFExtensionMode.AdditiveParse)
], KHR_lights_punctual);

var KHR_materials_clearcoat = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_clearcoat, GLTFExtensionParser);
    function KHR_materials_clearcoat() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_clearcoatFactor = schema.clearcoatFactor, clearcoatFactor = _schema_clearcoatFactor === void 0 ? 0 : _schema_clearcoatFactor, clearcoatTexture = schema.clearcoatTexture, _schema_clearcoatRoughnessFactor = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema_clearcoatRoughnessFactor === void 0 ? 0 : _schema_clearcoatRoughnessFactor, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
        material.clearCoat = clearcoatFactor;
        material.clearCoatRoughness = clearcoatRoughnessFactor;
        if (clearcoatTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatTexture, "Clear coat");
            context.get(GLTFParserType.Texture, clearcoatTexture.index).then(function(texture) {
                material.clearCoatTexture = texture;
            });
        }
        if (clearcoatRoughnessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatRoughnessTexture, "Clear coat roughness");
            context.get(GLTFParserType.Texture, clearcoatRoughnessTexture.index).then(function(texture) {
                material.clearCoatRoughnessTexture = texture;
            });
        }
        if (clearcoatNormalTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatNormalTexture, "Clear coat normal");
            context.get(GLTFParserType.Texture, clearcoatNormalTexture.index).then(function(texture) {
                material.clearCoatNormalTexture = texture;
            });
        }
    };
    return KHR_materials_clearcoat;
}(GLTFExtensionParser);
KHR_materials_clearcoat = __decorate([
    registerGLTFExtension("KHR_materials_clearcoat", GLTFExtensionMode.AdditiveParse)
], KHR_materials_clearcoat);

var KHR_materials_ior = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_ior, GLTFExtensionParser);
    function KHR_materials_ior() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_ior.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_ior = schema.ior, ior = _schema_ior === void 0 ? 1.5 : _schema_ior;
        material.ior = ior;
    };
    return KHR_materials_ior;
}(GLTFExtensionParser);
KHR_materials_ior = __decorate([
    registerGLTFExtension("KHR_materials_ior", GLTFExtensionMode.AdditiveParse)
], KHR_materials_ior);

var KHR_materials_pbrSpecularGlossiness = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_pbrSpecularGlossiness, GLTFExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createAndParse = function createAndParse(context, schema, ownerSchema) {
        var engine = context.glTFResource.engine;
        var material = new PBRSpecularMaterial(engine);
        var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
        if (diffuseFactor) {
            material.baseColor = new Color(Color.linearToGammaSpace(diffuseFactor[0]), Color.linearToGammaSpace(diffuseFactor[1]), Color.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
        }
        if (diffuseTexture) {
            context.get(GLTFParserType.Texture, diffuseTexture.index).then(function(texture) {
                material.baseTexture = texture;
                GLTFParser.executeExtensionsAdditiveAndParse(diffuseTexture.extensions, context, material, diffuseTexture);
            });
        }
        if (specularFactor) {
            material.specularColor = new Color(Color.linearToGammaSpace(specularFactor[0]), Color.linearToGammaSpace(specularFactor[1]), Color.linearToGammaSpace(specularFactor[2]));
        }
        if (glossinessFactor !== undefined) {
            material.glossiness = glossinessFactor;
        }
        if (specularGlossinessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(specularGlossinessTexture, "Specular glossiness");
            context.get(GLTFParserType.Texture, specularGlossinessTexture.index).then(function(texture) {
                material.specularGlossinessTexture = texture;
            });
        }
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
}(GLTFExtensionParser);
KHR_materials_pbrSpecularGlossiness = __decorate([
    registerGLTFExtension("KHR_materials_pbrSpecularGlossiness", GLTFExtensionMode.CreateAndParse)
], KHR_materials_pbrSpecularGlossiness);

var KHR_materials_unlit = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_unlit, GLTFExtensionParser);
    function KHR_materials_unlit() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createAndParse = function createAndParse(context, _, ownerSchema) {
        var engine = context.glTFResource.engine;
        var material = new UnlitMaterial(engine);
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_unlit;
}(GLTFExtensionParser);
KHR_materials_unlit = __decorate([
    registerGLTFExtension("KHR_materials_unlit", GLTFExtensionMode.CreateAndParse)
], KHR_materials_unlit);

var KHR_materials_variants = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_variants, GLTFExtensionParser);
    function KHR_materials_variants() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_variants.prototype;
    _proto.additiveParse = function additiveParse(context, renderer, schema) {
        var _loop = function(i) {
            var _mappings_i = mappings[i], materialIndex = _mappings_i.material, variants = _mappings_i.variants;
            context.get(GLTFParserType.Material, materialIndex).then(function(material) {
                extensionData.push({
                    renderer: renderer,
                    material: material,
                    variants: variants.map(function(index) {
                        return variantNames[index].name;
                    })
                });
            });
        };
        var _glTFResource;
        var _context_glTF = context.glTF, _context_glTF_extensions = _context_glTF.extensions, _context_glTF_extensions_KHR_materials_variants = _context_glTF_extensions.KHR_materials_variants, variantNames = _context_glTF_extensions_KHR_materials_variants.variants, glTFResource = context.glTFResource;
        var mappings = schema.mappings;
        (_glTFResource = glTFResource)._extensionsData || (_glTFResource._extensionsData = {});
        var extensionData = [];
        glTFResource.extensionsData.variants = extensionData;
        for(var i = 0; i < mappings.length; i++)_loop(i);
    };
    return KHR_materials_variants;
}(GLTFExtensionParser);
KHR_materials_variants = __decorate([
    registerGLTFExtension("KHR_materials_variants", GLTFExtensionMode.AdditiveParse)
], KHR_materials_variants);

var KHR_mesh_quantization = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_mesh_quantization, GLTFExtensionParser);
    function KHR_mesh_quantization() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    return KHR_mesh_quantization;
}(GLTFExtensionParser);
KHR_mesh_quantization = __decorate([
    registerGLTFExtension("KHR_mesh_quantization", GLTFExtensionMode.AdditiveParse)
], KHR_mesh_quantization);

var KHR_texture_basisu = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_texture_basisu, GLTFExtensionParser);
    function KHR_texture_basisu() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_basisu.prototype;
    _proto.createAndParse = function createAndParse(context, schema, textureInfo) {
        return _async_to_generator(function() {
            var glTF, glTFResource, engine, url, sampler, textureName, source, _glTF_images_source, uri, bufferViewIndex, mimeType, imageName, samplerInfo, index, promise, bufferView;
            return __generator(this, function(_state) {
                glTF = context.glTF, glTFResource = context.glTFResource;
                engine = glTFResource.engine, url = glTFResource.url;
                sampler = textureInfo.sampler, textureName = textureInfo.name;
                source = schema.source;
                _glTF_images_source = glTF.images[source], uri = _glTF_images_source.uri, bufferViewIndex = _glTF_images_source.bufferView, mimeType = _glTF_images_source.mimeType, imageName = _glTF_images_source.name;
                samplerInfo = sampler !== undefined && GLTFUtils.getSamplerInfo(glTF.samplers[sampler]);
                if (uri) {
                    index = uri.lastIndexOf(".");
                    promise = engine.resourceManager.load({
                        url: Utils.resolveAbsoluteUrl(url, uri),
                        type: AssetType.KTX2
                    }).onProgress(undefined, context._onTaskDetail).then(function(texture) {
                        if (!texture.name) {
                            texture.name = textureName || imageName || "texture_" + index;
                        }
                        if (sampler !== undefined) {
                            GLTFUtils.parseSampler(texture, samplerInfo);
                        }
                        return texture;
                    });
                    context._addTaskCompletePromise(promise);
                    return [
                        2,
                        promise
                    ];
                } else {
                    bufferView = glTF.bufferViews[bufferViewIndex];
                    return [
                        2,
                        context.get(GLTFParserType.Buffer, bufferView.buffer).then(function(buffer) {
                            var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
                            return KTX2Loader._parseBuffer(imageBuffer, engine).then(function(param) {
                                var engine = param.engine, result = param.result, targetFormat = param.targetFormat, params = param.params;
                                return KTX2Loader._createTextureByBuffer(engine, result, targetFormat, params);
                            }).then(function(texture) {
                                texture.name = textureName || imageName || "texture_" + bufferViewIndex;
                                if (sampler !== undefined) {
                                    GLTFUtils.parseSampler(texture, samplerInfo);
                                }
                                var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType);
                                context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
                                return texture;
                            });
                        })
                    ];
                }
            });
        })();
    };
    return KHR_texture_basisu;
}(GLTFExtensionParser);
KHR_texture_basisu = __decorate([
    registerGLTFExtension("KHR_texture_basisu", GLTFExtensionMode.CreateAndParse)
], KHR_texture_basisu);

var KHR_texture_transform = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_texture_transform, GLTFExtensionParser);
    function KHR_texture_transform() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
        if (offset) {
            material.tilingOffset.z = offset[0];
            material.tilingOffset.w = offset[1];
        }
        if (scale) {
            material.tilingOffset.x = scale[0];
            material.tilingOffset.y = scale[1];
        }
        if (rotation) {
            Logger.warn("rotation in KHR_texture_transform is not supported now");
        }
        if (texCoord) {
            Logger.warn("texCoord in KHR_texture_transform is not supported now");
        }
    };
    return KHR_texture_transform;
}(GLTFExtensionParser);
KHR_texture_transform = __decorate([
    registerGLTFExtension("KHR_texture_transform", GLTFExtensionMode.AdditiveParse)
], KHR_texture_transform);

var GALACEAN_materials_remap = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_materials_remap, GLTFExtensionParser);
    function GALACEAN_materials_remap() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = GALACEAN_materials_remap.prototype;
    _proto.createAndParse = function createAndParse(context, schema) {
        var engine = context.glTFResource.engine;
        // @ts-ignore
        var promise = engine.resourceManager.getResourceByRef(schema);
        context._addTaskCompletePromise(promise);
        return promise;
    };
    return GALACEAN_materials_remap;
}(GLTFExtensionParser);
GALACEAN_materials_remap = __decorate([
    registerGLTFExtension("GALACEAN_materials_remap", GLTFExtensionMode.CreateAndParse)
], GALACEAN_materials_remap);

var GALACEAN_animation_event = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_animation_event, GLTFExtensionParser);
    function GALACEAN_animation_event() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = GALACEAN_animation_event.prototype;
    _proto.additiveParse = function additiveParse(context, animationClip, schema) {
        context.glTFResource.engine;
        var events = schema.events;
        events.map(function(eventData) {
            var event = new AnimationEvent();
            event.functionName = eventData.functionName;
            event.time = eventData.time;
            event.parameter = eventData.parameter;
            animationClip.addEvent(event);
        });
    };
    return GALACEAN_animation_event;
}(GLTFExtensionParser);
GALACEAN_animation_event = __decorate([
    registerGLTFExtension("GALACEAN_animation_event", GLTFExtensionMode.AdditiveParse)
], GALACEAN_animation_event);

var EXT_meshopt_compression = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(EXT_meshopt_compression, GLTFExtensionParser);
    function EXT_meshopt_compression() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = EXT_meshopt_compression.prototype;
    _proto.createAndParse = function createAndParse(context, schema) {
        return context.get(GLTFParserType.Buffer, schema.buffer).then(function(arrayBuffer) {
            return getMeshoptDecoder().then(function(decoder) {
                return decoder.decodeGltfBuffer(schema.count, schema.byteStride, new Uint8Array(arrayBuffer, schema.byteOffset, schema.byteLength), schema.mode, schema.filter);
            });
        });
    };
    return EXT_meshopt_compression;
}(GLTFExtensionParser);
EXT_meshopt_compression = __decorate([
    registerGLTFExtension("EXT_meshopt_compression", GLTFExtensionMode.CreateAndParse)
], EXT_meshopt_compression);

var KHR_materials_anisotropy = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_anisotropy, GLTFExtensionParser);
    function KHR_materials_anisotropy() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_anisotropy.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_anisotropyStrength = schema.anisotropyStrength, anisotropyStrength = _schema_anisotropyStrength === void 0 ? 0 : _schema_anisotropyStrength, _schema_anisotropyRotation = schema.anisotropyRotation, anisotropyRotation = _schema_anisotropyRotation === void 0 ? 0 : _schema_anisotropyRotation, anisotropyTexture = schema.anisotropyTexture;
        material.anisotropy = anisotropyStrength;
        material.anisotropyRotation = anisotropyRotation;
        if (anisotropyTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(anisotropyTexture, "Anisotropy texture");
            context.get(GLTFParserType.Texture, anisotropyTexture.index).then(function(texture) {
                material.anisotropyTexture = texture;
            });
        }
    };
    return KHR_materials_anisotropy;
}(GLTFExtensionParser);
KHR_materials_anisotropy = __decorate([
    registerGLTFExtension("KHR_materials_anisotropy", GLTFExtensionMode.AdditiveParse)
], KHR_materials_anisotropy);

var KHR_materials_iridescence = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_iridescence, GLTFExtensionParser);
    function KHR_materials_iridescence() {
        return GLTFExtensionParser.apply(this, arguments) || this;
    }
    var _proto = KHR_materials_iridescence.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_iridescenceFactor = schema.iridescenceFactor, iridescenceFactor = _schema_iridescenceFactor === void 0 ? 0 : _schema_iridescenceFactor, iridescenceTexture = schema.iridescenceTexture, _schema_iridescenceIor = schema.iridescenceIor, iridescenceIor = _schema_iridescenceIor === void 0 ? 1.3 : _schema_iridescenceIor, _schema_iridescenceThicknessMinimum = schema.iridescenceThicknessMinimum, iridescenceThicknessMinimum = _schema_iridescenceThicknessMinimum === void 0 ? 100 : _schema_iridescenceThicknessMinimum, _schema_iridescenceThicknessMaximum = schema.iridescenceThicknessMaximum, iridescenceThicknessMaximum = _schema_iridescenceThicknessMaximum === void 0 ? 400 : _schema_iridescenceThicknessMaximum, iridescenceThicknessTexture = schema.iridescenceThicknessTexture;
        material.iridescence = iridescenceFactor;
        material.iridescenceIOR = iridescenceIor;
        material.iridescenceThicknessRange.set(iridescenceThicknessMinimum, iridescenceThicknessMaximum);
        if (iridescenceTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(iridescenceTexture, "Iridescence texture");
            context.get(GLTFParserType.Texture, iridescenceTexture.index).then(function(texture) {
                material.iridescenceTexture = texture;
            });
        }
        if (iridescenceThicknessTexture) {
            GLTFMaterialParser._checkOtherTextureTransform(iridescenceThicknessTexture, "IridescenceThickness texture");
            context.get(GLTFParserType.Texture, iridescenceThicknessTexture.index).then(function(texture) {
                material.iridescenceThicknessTexture = texture;
            });
        }
    };
    return KHR_materials_iridescence;
}(GLTFExtensionParser);
KHR_materials_iridescence = __decorate([
    registerGLTFExtension("KHR_materials_iridescence", GLTFExtensionMode.AdditiveParse)
], KHR_materials_iridescence);

var EXT_texture_webp = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(EXT_texture_webp, GLTFExtensionParser);
    function EXT_texture_webp() {
        var _this;
        _this = GLTFExtensionParser.call(this) || this, _this._supportWebP = false;
        // @ts-ignore
        if (SystemInfo._isBrowser) {
            var testCanvas = document.createElement("canvas");
            testCanvas.width = testCanvas.height = 1;
            _this._supportWebP = testCanvas.toDataURL("image/webp").indexOf("data:image/webp") == 0;
        } else {
            _this._supportWebP = false;
        }
        return _this;
    }
    var _proto = EXT_texture_webp.prototype;
    _proto.createAndParse = function createAndParse(context, schema, textureInfo, textureIndex) {
        var _this = this;
        return _async_to_generator(function() {
            var webPIndex, sampler, tmp, fallbackIndex, textureName, texture;
            return __generator(this, function(_state) {
                webPIndex = schema.source;
                sampler = textureInfo.sampler, tmp = textureInfo.source, fallbackIndex = tmp === void 0 ? 0 : tmp, textureName = textureInfo.name;
                texture = GLTFTextureParser._parseTexture(context, _this._supportWebP ? webPIndex : fallbackIndex, textureIndex, sampler, textureName);
                return [
                    2,
                    texture
                ];
            });
        })();
    };
    return EXT_texture_webp;
}(GLTFExtensionParser);
EXT_texture_webp = __decorate([
    registerGLTFExtension("EXT_texture_webp", GLTFExtensionMode.CreateAndParse)
], EXT_texture_webp);

export { AccessorType, AnimationClipDecoder, BufferInfo, BufferReader, EditorTextureLoader, FileHeader, GLTFAnimationParser, GLTFAnimatorControllerParser, GLTFBufferParser, GLTFBufferViewParser, GLTFEntityParser, GLTFExtensionMode, GLTFExtensionParser, GLTFLoader, GLTFMaterialParser, GLTFMeshParser, GLTFParser, GLTFParserContext, GLTFParserType, GLTFResource, GLTFSceneParser, GLTFSchemaParser, GLTFSkinParser, GLTFTextureParser, GLTFUtils, GLTFValidator, InterpolableValueType, KTX2Loader, KTX2TargetFormat, KTX2Transcoder, MaterialLoaderType, MeshDecoder, ParserContext, ParserType, PrefabResource, ReflectionParser, SceneParser, SpecularMode, Texture2DDecoder, decode, decoder, decoderMap, parseSingleKTX, registerGLTFExtension, registerGLTFParser };
//# sourceMappingURL=module.js.map
