'use strict';

var engine = require('@galacean/engine');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var fs = "#define GLSLIFY 1\n#include <common>\nuniform vec3 u_pickColor;void main(){gl_FragColor=vec4(u_pickColor,1.0);}"; // eslint-disable-line

var vs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <position_vert>\n}"; // eslint-disable-line

var pickShader = engine.Shader.create("framebuffer-picker-color", vs, fs);
pickShader.subShaders.forEach(function(subShader) {
    subShader.passes.forEach(function(pass) {
        pass.setTag("spriteDisableBatching", true);
    });
});
exports.FramebufferPicker = /*#__PURE__*/ function(Script) {
    _inherits(FramebufferPicker, Script);
    function FramebufferPicker() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._renderersMap = [];
        _this._frameBufferSize = new engine.Vector2(1024, 1024);
        return _this;
    }
    var _proto = FramebufferPicker.prototype;
    _proto.onAwake = function onAwake() {
        this._camera = this.entity.getComponent(engine.Camera);
    };
    /**
   * Pick up renderer at screen coordinate.
   * @param x - The x coordinate of screen
   * @param y - The y coordinate of screen
   * @returns Promise<Renderer>
   */ _proto.pick = function pick(x, y) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this._setupRenderTarget();
            // Pick up renderer
            var pickedPixel = _this._readPixelFromRenderTarget(x, y);
            var renderer = _this._getRendererByPixel(pickedPixel);
            resolve(renderer);
        });
    };
    /**
   * Pick up renderers in a rectangular region of the screen.
   * @param startX - The start x coordinate of screen
   * @param startY - The start y coordinate of screen
   * @param endX - The end x coordinate of screen
   * @param endY - The end y coordinate of screen
   * @returns Promise<Array<Renderer>>
   */ _proto.regionPick = function regionPick(startX, startY, endX, endY) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this._setupRenderTarget();
            var pickedPixel = _this._readPixelFromRenderTarget(startX, startY, endX, endY);
            var renderer = _this._getRenderersByPixel(pickedPixel);
            resolve(renderer);
        });
    };
    _proto._checkFrameBufferSize = function _checkFrameBufferSize() {
        var pickRenderTarget = this._pickRenderTarget;
        var engine$1 = this.engine;
        var size = this._frameBufferSize;
        if (!pickRenderTarget || size.x != pickRenderTarget.width || size.y != pickRenderTarget.height) {
            pickRenderTarget && pickRenderTarget.destroy();
            this._pickRenderTarget = new engine.RenderTarget(engine$1, size.x, size.y, new engine.Texture2D(engine$1, size.x, size.y, engine.TextureFormat.R8G8B8A8, false));
        }
    };
    _proto._updateRenderersPickColor = function _updateRenderersPickColor(scene) {
        var currentRendererIndex = 0;
        var renderersMap = this._renderersMap;
        var rootEntityRenderers = FramebufferPicker._rootEntityRenderers;
        var rootEntities = scene.rootEntities;
        var pickColorProperty = FramebufferPicker._pickColorProperty;
        for(var i = 0, n = rootEntities.length; i < n; i++){
            rootEntities[i].getComponentsIncludeChildren(engine.Renderer, rootEntityRenderers);
            for(var j = 0, m = rootEntityRenderers.length; j < m; j++){
                var renderer = rootEntityRenderers[j];
                var shaderData = renderer.shaderData;
                // Init pick color
                var pickColor = shaderData.getVector3(pickColorProperty);
                if (!pickColor) {
                    pickColor = new engine.Vector3();
                    shaderData.setVector3(pickColorProperty, pickColor);
                }
                // Set pick color
                this._uniqueId2Color(++currentRendererIndex, pickColor);
                renderersMap[currentRendererIndex] = renderer;
            }
        }
    };
    _proto._setupRenderTarget = function _setupRenderTarget() {
        // Check frame buffer size
        this._checkFrameBufferSize();
        var camera = this._camera;
        var originalPostProcessEnabled = camera.enablePostProcess;
        var originalHDR = camera.enableHDR;
        var originalDepthMode = camera.depthTextureMode;
        var originalOpaqueTextureEnabled = camera.opaqueTextureEnabled;
        this._updateRenderersPickColor(camera.scene);
        // Prepare render target and shader
        var lastRenderTarget = camera.renderTarget;
        var lastRatio = camera.aspectRatio;
        camera.renderTarget = this._pickRenderTarget;
        camera.setReplacementShader(pickShader);
        camera.aspectRatio = lastRatio;
        // Reset internal RT and useless pass
        camera.enablePostProcess = false;
        camera.enableHDR = false;
        camera.depthTextureMode = engine.DepthTextureMode.None;
        camera.opaqueTextureEnabled = false;
        camera.render();
        // Revert render target and shader
        camera.resetReplacementShader();
        camera.renderTarget = lastRenderTarget;
        camera.resetAspectRatio();
        // Revert internal RT and original pass
        camera.enablePostProcess = originalPostProcessEnabled;
        camera.enableHDR = originalHDR;
        camera.depthTextureMode = originalDepthMode;
        camera.opaqueTextureEnabled = originalOpaqueTextureEnabled;
    };
    _proto._readPixelFromRenderTarget = function _readPixelFromRenderTarget(x, y, xEnd, yEnd) {
        var pickPixel, width, height;
        var startCoord = this._getCoordOnRenderTarget(x, y);
        var argsLength = arguments.length;
        if (argsLength === 2) {
            pickPixel = FramebufferPicker._pickPixel;
            width = height = 1;
        } else if (argsLength === 4) {
            var endCoord = this._getCoordOnRenderTarget(xEnd, yEnd);
            width = Math.abs(startCoord.x - endCoord.x);
            height = Math.abs(startCoord.y - endCoord.y);
            startCoord.x = startCoord.x < endCoord.x ? startCoord.x : endCoord.x;
            startCoord.y = startCoord.y < endCoord.y ? startCoord.y : endCoord.y;
            pickPixel = new Uint8Array(width * height * 4);
        }
        this._pickRenderTarget.getColorTexture().getPixelBuffer(startCoord.x, startCoord.y, width, height, 0, pickPixel);
        return pickPixel;
    };
    _proto._getCoordOnRenderTarget = function _getCoordOnRenderTarget(x, y) {
        var pickRenderTarget = this._pickRenderTarget;
        var canvas = this.engine.canvas;
        var viewport = this._camera.viewport;
        var viewWidth = (viewport.z - viewport.x) * canvas.width;
        var viewHeight = (viewport.w - viewport.y) * canvas.height;
        return {
            x: Math.floor((x - viewport.x) / viewWidth * (pickRenderTarget.width - 1)),
            y: Math.floor((y - viewport.y) / viewHeight * (pickRenderTarget.height - 1))
        };
    };
    _proto._getRendererByPixel = function _getRendererByPixel(color) {
        return this._renderersMap[this._color2UniqueId(color)];
    };
    _proto._getRenderersByPixel = function _getRenderersByPixel(color) {
        var _this = this;
        var pickedRenderers = [];
        var rendererIds = this._color2UniqueIds(color);
        rendererIds.forEach(function(value) {
            _this._renderersMap[value] && pickedRenderers.push(_this._renderersMap[value]);
        });
        return pickedRenderers;
    };
    _proto._uniqueId2Color = function _uniqueId2Color(uniqueId, outColor) {
        if (uniqueId >= 0xffffff) {
            engine.Logger.warn("Framebuffer Picker encounter primitive's id greater than " + 0xffffff);
            outColor.set(0, 0, 0);
        }
        outColor.set((uniqueId & 0xff) / 255, ((uniqueId & 0xff00) >> 8) / 255, ((uniqueId & 0xff0000) >> 16) / 255);
    };
    _proto._color2UniqueId = function _color2UniqueId(color) {
        return color[0] | color[1] << 8 | color[2] << 16;
    };
    _proto._color2UniqueIds = function _color2UniqueIds(color) {
        FramebufferPicker._pickIds.clear();
        for(var i = 0; i < color.length; i += 4){
            var a = color[i] | color[i + 1] << 8 | color[i + 2] << 16;
            FramebufferPicker._pickIds.add(a);
        }
        return FramebufferPicker._pickIds;
    };
    _create_class(FramebufferPicker, [
        {
            key: "frameBufferSize",
            get: function get() {
                return this._frameBufferSize;
            },
            set: function set(value) {
                this._frameBufferSize = value;
            }
        }
    ]);
    return FramebufferPicker;
}(engine.Script);
exports.FramebufferPicker._rootEntityRenderers = [];
exports.FramebufferPicker._pickPixel = new Uint8Array(4);
exports.FramebufferPicker._pickIds = new Set();
exports.FramebufferPicker._pickColorProperty = engine.ShaderProperty.getByName("u_pickColor");
exports.FramebufferPicker = __decorate([
    engine.dependentComponents(engine.Camera, engine.DependentMode.CheckOnly)
], exports.FramebufferPicker);
//# sourceMappingURL=browser.js.map
