import { BoxSelectionComponent } from './BoxSelectionComponent.js';
import { _ as _inherits } from '../_inherits-5a51c3d0.js';
import { BoundingFrustum, Vector3, Vector2, Matrix, Camera, PointerButton, Plane, CollisionUtil, ContainmentType, Script } from '@galacean/engine';
import { BoxSelectionSSHelper } from './BoxSelectionSSHelper.js';
import '../_create_class-8d4b456b.js';
import './PlaneMesh.js';
import './BoxSelectionSSMaterial.js';

var _frustum = new BoundingFrustum();
var _center = new Vector3();
var _tmpPoint = new Vector2();
var _vecNear = new Vector3();
var _vecTopLeft = new Vector3();
var _vecTopRight = new Vector3();
var _vecDownRight = new Vector3();
var _vecDownLeft = new Vector3();
var _vecFarTopLeft = new Vector3();
var _vecFarTopRight = new Vector3();
var _vecFarDownRight = new Vector3();
var _vecFarDownLeft = new Vector3();
var _vectemp1 = new Vector3();
var _vectemp2 = new Vector3();
var _vectemp3 = new Vector3();
var pojectInvertMatrix = new Matrix();
function unproject(vec, entity) {
    Vector3.transformCoordinate(vec, pojectInvertMatrix, vec);
    return Vector3.transformCoordinate(vec, entity.transform.worldMatrix, vec);
}
var BoxSelectionControls = /*#__PURE__*/ function(Script) {
    _inherits(BoxSelectionControls, Script);
    function BoxSelectionControls() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this.startPoint = new Vector2();
        _this.endPoint = new Vector2();
        _this.collection = [];
        _this.instances = {};
        _this.deep = Number.MAX_VALUE;
        _this.isDeep = true;
        return _this;
    }
    var _proto = BoxSelectionControls.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.camera = entity.getComponent(Camera);
        this.input = engine.inputManager;
        this.helper = new BoxSelectionSSHelper(this.engine, this.scene.getRootEntity());
    };
    _proto.onUpdate = function onUpdate() {
        var p = this.input.pointers[0];
        if (!p) {
            return;
        }
        var canvas = this.engine.canvas;
        if (this.input.isPointerDown(PointerButton.Primary)) {
            var _this_helper;
            var x = p.position.x / canvas.width * 2 - 1;
            var y = 1 - p.position.y / canvas.height * 2;
            this.startPoint.set(x, y);
            (_this_helper = this.helper) == null ? void 0 : _this_helper.onSelectStart(p.position);
        }
        if (this.input.isPointerUp(PointerButton.Primary)) {
            var _this_helper1;
            var x1 = p.position.x / canvas.width * 2 - 1;
            var y1 = 1 - p.position.y / canvas.height * 2;
            this.endPoint.set(x1, y1);
            (_this_helper1 = this.helper) == null ? void 0 : _this_helper1.onSelectEnd(p.position);
        }
        if (this.input.isPointerHeldDown(PointerButton.Primary)) {
            var _this_helper2;
            var x2 = p.position.x / canvas.width * 2 - 1;
            var y2 = 1 - p.position.y / canvas.height * 2;
            this.endPoint.set(x2, y2);
            this.select();
            (_this_helper2 = this.helper) == null ? void 0 : _this_helper2.onSelecting(p.position);
        }
    };
    _proto.select = function select(startPoint, endPoint) {
        this.startPoint = startPoint || this.startPoint;
        this.endPoint = endPoint || this.endPoint;
        this.collection.length = 0;
        pojectInvertMatrix.copyFrom(this.camera.projectionMatrix);
        pojectInvertMatrix.invert();
        this.updateBoundingFrustum(this.startPoint, this.endPoint);
        return this.searchChildInBoundingFrustum(_frustum, this.scene.getRootEntity(), this.isDeep);
    };
    _proto.updateBoundingFrustum = function updateBoundingFrustum(startPoint, endPoint) {
        startPoint = startPoint || this.startPoint;
        endPoint = endPoint || this.endPoint;
        // Avoid invalid BoundingFrustum
        if (startPoint.x === endPoint.x) {
            endPoint.x += Number.EPSILON;
        }
        if (startPoint.y === endPoint.y) {
            endPoint.y += Number.EPSILON;
        }
        if (!this.camera.isOrthographic) {
            _tmpPoint.set(Math.min(startPoint.x, endPoint.x), Math.max(startPoint.y, endPoint.y));
            endPoint.set(Math.max(startPoint.x, endPoint.x), Math.min(startPoint.y, endPoint.y));
            this.entity.transform.worldMatrix.getTranslation(_vecNear);
            _vecTopLeft.set(_tmpPoint.x, _tmpPoint.y, 0.5);
            _vecTopRight.set(endPoint.x, _tmpPoint.y, 0);
            _vecDownRight.set(endPoint.x, endPoint.y, 0.5);
            _vecDownLeft.set(_tmpPoint.x, endPoint.y, 0);
            unproject(_vecTopLeft, this.entity);
            unproject(_vecTopRight, this.entity);
            unproject(_vecDownRight, this.entity);
            unproject(_vecDownLeft, this.entity);
            _vectemp1.copyFrom(_vecTopLeft).subtract(_vecNear);
            _vectemp2.copyFrom(_vecTopRight).subtract(_vecNear);
            _vectemp3.copyFrom(_vecDownRight).subtract(_vecNear);
            _vectemp1.normalize();
            _vectemp2.normalize();
            _vectemp3.normalize();
            _vectemp1.scale(this.deep);
            _vectemp2.scale(this.deep);
            _vectemp3.scale(this.deep);
            _vectemp1.add(_vecNear);
            _vectemp2.add(_vecNear);
            _vectemp3.add(_vecNear);
            Plane.fromPoints(_vecNear, _vecTopLeft, _vecTopRight, _frustum.top);
            Plane.fromPoints(_vecNear, _vecTopRight, _vecDownRight, _frustum.right);
            Plane.fromPoints(_vecDownRight, _vecDownLeft, _vecNear, _frustum.bottom);
            Plane.fromPoints(_vecDownLeft, _vecTopLeft, _vecNear, _frustum.left);
            Plane.fromPoints(_vecTopRight, _vecDownRight, _vecDownLeft, _frustum.near);
            Plane.fromPoints(_vectemp3, _vectemp2, _vectemp1, _frustum.far);
            _frustum.far.normal.scale(-1);
        } else {
            var left = Math.min(startPoint.x, endPoint.x);
            var top = Math.max(startPoint.y, endPoint.y);
            var right = Math.max(startPoint.x, endPoint.x);
            var down = Math.min(startPoint.y, endPoint.y);
            _vecTopLeft.set(left, top, -1);
            _vecTopRight.set(right, top, -1);
            _vecDownRight.set(right, down, -1);
            _vecDownLeft.set(left, down, -1);
            _vecFarTopLeft.set(left, top, 1);
            _vecFarTopRight.set(right, top, 1);
            _vecFarDownRight.set(right, down, 1);
            _vecFarDownLeft.set(left, down, 1);
            unproject(_vecTopLeft, this.entity);
            unproject(_vecTopRight, this.entity);
            unproject(_vecDownRight, this.entity);
            unproject(_vecDownLeft, this.entity);
            unproject(_vecFarTopLeft, this.entity);
            unproject(_vecFarTopRight, this.entity);
            unproject(_vecFarDownRight, this.entity);
            unproject(_vecFarDownLeft, this.entity);
            Plane.fromPoints(_vecTopLeft, _vecFarTopLeft, _vecFarTopRight, _frustum.top);
            Plane.fromPoints(_vecTopRight, _vecFarTopRight, _vecFarDownRight, _frustum.right);
            Plane.fromPoints(_vecFarDownRight, _vecFarDownLeft, _vecDownLeft, _frustum.bottom);
            Plane.fromPoints(_vecFarDownLeft, _vecFarTopLeft, _vecTopLeft, _frustum.left);
            Plane.fromPoints(_vecTopRight, _vecDownRight, _vecDownLeft, _frustum.near);
            Plane.fromPoints(_vecFarDownRight, _vecFarTopRight, _vecFarTopLeft, _frustum.far);
            _frustum.far.normal.scale(-1);
        }
    };
    _proto.searchChildInBoundingFrustum = function searchChildInBoundingFrustum(frustum, entity, isDeep) {
        if (isDeep === void 0) isDeep = false;
        var c = entity.getComponent(BoxSelectionComponent);
        if (c && c.enabled) {
            _center.copyFrom(entity.transform.worldPosition);
            c.isSelect = CollisionUtil.frustumContainsPoint(frustum, _center) !== ContainmentType.Disjoint;
            if (c.isSelect) {
                this.collection.push(entity);
            }
        }
        var len = entity.children.length;
        if (isDeep && len) {
            for(var x = 0; x < len; x++){
                this.searchChildInBoundingFrustum(frustum, entity.children[x], isDeep);
            }
        }
        return this.collection;
    };
    return BoxSelectionControls;
}(Script);

export { BoxSelectionControls };
//# sourceMappingURL=BoxSelectionControls.js.map
