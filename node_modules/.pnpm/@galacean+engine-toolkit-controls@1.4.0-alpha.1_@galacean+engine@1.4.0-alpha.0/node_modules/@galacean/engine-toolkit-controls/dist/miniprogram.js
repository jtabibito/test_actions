'use strict';

var miniprogram = require('@galacean/engine/dist/miniprogram');
var engineMiniprogramAdapter = require('@galacean/engine-miniprogram-adapter');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

var BoxSelectionComponent = /*#__PURE__*/ function(Component) {
    _inherits(BoxSelectionComponent, Component);
    function BoxSelectionComponent() {
        var _this;
        _this = Component.apply(this, arguments) || this;
        _this._isSelected = false;
        _this.onSelect = function() {};
        _this.onUnselect = function() {};
        return _this;
    }
    _create_class(BoxSelectionComponent, [
        {
            key: "isSelect",
            get: function get() {
                return this._isSelected;
            },
            set: function set(v) {
                if (this._isSelected !== v) {
                    this._isSelected = v;
                    if (v) {
                        this.onSelect();
                    } else {
                        this.onUnselect();
                    }
                }
            }
        }
    ]);
    return BoxSelectionComponent;
}(miniprogram.Component);

var PlaneMesh = /*#__PURE__*/ function() {
    function PlaneMesh() {}
    PlaneMesh.createPlane = function createPlane(engine) {
        var mesh = new miniprogram.ModelMesh(engine);
        PlaneMesh._initGeometryData(mesh);
        return mesh;
    };
    PlaneMesh._initGeometryData = function _initGeometryData(mesh) {
        var positions = new Array(4);
        positions[0] = new miniprogram.Vector3(-1, -1, 0);
        positions[1] = new miniprogram.Vector3(1, -1, 0);
        positions[2] = new miniprogram.Vector3(1, 1, 0);
        positions[3] = new miniprogram.Vector3(-1, 1, 0);
        var indices = new Uint8Array(6);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;
        mesh.setPositions(positions);
        mesh.setIndices(indices);
        mesh.uploadData(true);
        mesh.addSubMesh(0, 6);
        return mesh;
    };
    return PlaneMesh;
}();

var BoxSelectionSSMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(BoxSelectionSSMaterial, BaseMaterial);
    function BoxSelectionSSMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, miniprogram.Shader.find("box")) || this;
        _this.isTransparent = true;
        _this.boxColor = new miniprogram.Vector4(0.29, 0.63, 1, 0.3);
        _this.borderColor = new miniprogram.Vector4(0.22, 0.48, 1, 0.9);
        _this.borderWidth = engineMiniprogramAdapter.devicePixelRatio;
        return _this;
    }
    _create_class(BoxSelectionSSMaterial, [
        {
            key: "minPoint",
            get: function get() {
                return this.shaderData.getVector2(BoxSelectionSSMaterial._minPoint);
            },
            set: function set(value) {
                this.shaderData.setVector2(BoxSelectionSSMaterial._minPoint, value);
            }
        },
        {
            key: "maxPoint",
            get: function get() {
                return this.shaderData.getVector2(BoxSelectionSSMaterial._maxPoint);
            },
            set: function set(value) {
                this.shaderData.setVector2(BoxSelectionSSMaterial._maxPoint, value);
            }
        },
        {
            key: "boxColor",
            get: function get() {
                return this.shaderData.getVector4(BoxSelectionSSMaterial._boxColor);
            },
            set: function set(value) {
                this.shaderData.setVector4(BoxSelectionSSMaterial._boxColor, value);
            }
        },
        {
            key: "borderColor",
            get: function get() {
                return this.shaderData.getVector4(BoxSelectionSSMaterial._borderColor);
            },
            set: function set(value) {
                this.shaderData.setVector4(BoxSelectionSSMaterial._borderColor, value);
            }
        },
        {
            key: "borderWidth",
            get: function get() {
                return this.shaderData.getFloat(BoxSelectionSSMaterial._borderWidth);
            },
            set: function set(value) {
                this.shaderData.setFloat(BoxSelectionSSMaterial._borderWidth, value);
            }
        }
    ]);
    return BoxSelectionSSMaterial;
}(miniprogram.BaseMaterial);
BoxSelectionSSMaterial._borderWidth = miniprogram.ShaderProperty.getByName("u_width");
BoxSelectionSSMaterial._minPoint = miniprogram.ShaderProperty.getByName("u_min");
BoxSelectionSSMaterial._maxPoint = miniprogram.ShaderProperty.getByName("u_max");
BoxSelectionSSMaterial._boxColor = miniprogram.ShaderProperty.getByName("u_boxColor");
BoxSelectionSSMaterial._borderColor = miniprogram.ShaderProperty.getByName("u_borderColor");
miniprogram.Shader.create("box", "\n#include <common>\n#include <common_vert>\n\nvoid main() {\n  gl_Position = vec4(POSITION, 1.0);\n}", "\nuniform vec2 u_min;\nuniform vec2 u_max;\nuniform vec4 u_boxColor;\nuniform vec4 u_borderColor;\nuniform float u_width;\n\nvoid main() {\n  float vColor = step(u_min.x + u_width, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x - u_width) * step(u_min.y + u_width, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y - u_width);\n  float vBorder = step(u_min.x, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x) * step(u_min.y, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y);\n  gl_FragColor = u_boxColor * vColor + (1. - vColor) * vBorder * u_borderColor;\n}\n");

// draw according to screen space
var BoxSelectionSSHelper = /*#__PURE__*/ function() {
    function BoxSelectionSSHelper(engine, sceneRoot) {
        this.engine = engine;
        this.element = new miniprogram.Entity(engine);
        this.sceneRoot = sceneRoot;
        this.startPoint = new miniprogram.Vector2();
        this.pointBottomLeft = new miniprogram.Vector2();
        this.pointTopRight = new miniprogram.Vector2();
        this.input = engine.inputManager;
        this.init();
    }
    var _proto = BoxSelectionSSHelper.prototype;
    _proto.init = function init() {
        var renderer = this.element.addComponent(miniprogram.MeshRenderer);
        renderer.receiveShadows = false;
        renderer.castShadows = false;
        renderer.mesh = PlaneMesh.createPlane(this.engine); // PrimitiveMesh.createPlane is xoz plane, but we need xoy plane
        this.material = new BoxSelectionSSMaterial(this.engine);
        renderer.setMaterial(this.material);
        this.element.transform.rotation.x = Math.PI * 0.5;
    };
    _proto.onSelectStart = function onSelectStart(vec2) {
        this.startPoint.x = vec2.x;
        this.startPoint.y = this.engine.canvas.height - vec2.y;
        this.sceneRoot.addChild(this.element);
    };
    _proto.onSelecting = function onSelecting(vec2) {
        this.pointTopRight.x = Math.max(this.startPoint.x, vec2.x);
        this.pointTopRight.y = Math.max(this.startPoint.y, this.engine.canvas.height - vec2.y);
        this.pointBottomLeft.x = Math.min(this.startPoint.x, vec2.x);
        this.pointBottomLeft.y = Math.min(this.startPoint.y, this.engine.canvas.height - vec2.y);
        this.material.maxPoint = this.pointTopRight;
        this.material.minPoint = this.pointBottomLeft;
    };
    _proto.onSelectEnd = function onSelectEnd() {
        this.sceneRoot.removeChild(this.element);
    };
    return BoxSelectionSSHelper;
}();

var _frustum = new miniprogram.BoundingFrustum();
var _center = new miniprogram.Vector3();
var _tmpPoint = new miniprogram.Vector2();
var _vecNear = new miniprogram.Vector3();
var _vecTopLeft = new miniprogram.Vector3();
var _vecTopRight = new miniprogram.Vector3();
var _vecDownRight = new miniprogram.Vector3();
var _vecDownLeft = new miniprogram.Vector3();
var _vecFarTopLeft = new miniprogram.Vector3();
var _vecFarTopRight = new miniprogram.Vector3();
var _vecFarDownRight = new miniprogram.Vector3();
var _vecFarDownLeft = new miniprogram.Vector3();
var _vectemp1 = new miniprogram.Vector3();
var _vectemp2 = new miniprogram.Vector3();
var _vectemp3 = new miniprogram.Vector3();
var pojectInvertMatrix = new miniprogram.Matrix();
function unproject(vec, entity) {
    miniprogram.Vector3.transformCoordinate(vec, pojectInvertMatrix, vec);
    return miniprogram.Vector3.transformCoordinate(vec, entity.transform.worldMatrix, vec);
}
var BoxSelectionControls = /*#__PURE__*/ function(Script) {
    _inherits(BoxSelectionControls, Script);
    function BoxSelectionControls() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this.startPoint = new miniprogram.Vector2();
        _this.endPoint = new miniprogram.Vector2();
        _this.collection = [];
        _this.instances = {};
        _this.deep = Number.MAX_VALUE;
        _this.isDeep = true;
        return _this;
    }
    var _proto = BoxSelectionControls.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.camera = entity.getComponent(miniprogram.Camera);
        this.input = engine.inputManager;
        this.helper = new BoxSelectionSSHelper(this.engine, this.scene.getRootEntity());
    };
    _proto.onUpdate = function onUpdate() {
        var p = this.input.pointers[0];
        if (!p) {
            return;
        }
        var canvas = this.engine.canvas;
        if (this.input.isPointerDown(miniprogram.PointerButton.Primary)) {
            var _this_helper;
            var x = p.position.x / canvas.width * 2 - 1;
            var y = 1 - p.position.y / canvas.height * 2;
            this.startPoint.set(x, y);
            (_this_helper = this.helper) == null ? void 0 : _this_helper.onSelectStart(p.position);
        }
        if (this.input.isPointerUp(miniprogram.PointerButton.Primary)) {
            var _this_helper1;
            var x1 = p.position.x / canvas.width * 2 - 1;
            var y1 = 1 - p.position.y / canvas.height * 2;
            this.endPoint.set(x1, y1);
            (_this_helper1 = this.helper) == null ? void 0 : _this_helper1.onSelectEnd(p.position);
        }
        if (this.input.isPointerHeldDown(miniprogram.PointerButton.Primary)) {
            var _this_helper2;
            var x2 = p.position.x / canvas.width * 2 - 1;
            var y2 = 1 - p.position.y / canvas.height * 2;
            this.endPoint.set(x2, y2);
            this.select();
            (_this_helper2 = this.helper) == null ? void 0 : _this_helper2.onSelecting(p.position);
        }
    };
    _proto.select = function select(startPoint, endPoint) {
        this.startPoint = startPoint || this.startPoint;
        this.endPoint = endPoint || this.endPoint;
        this.collection.length = 0;
        pojectInvertMatrix.copyFrom(this.camera.projectionMatrix);
        pojectInvertMatrix.invert();
        this.updateBoundingFrustum(this.startPoint, this.endPoint);
        return this.searchChildInBoundingFrustum(_frustum, this.scene.getRootEntity(), this.isDeep);
    };
    _proto.updateBoundingFrustum = function updateBoundingFrustum(startPoint, endPoint) {
        startPoint = startPoint || this.startPoint;
        endPoint = endPoint || this.endPoint;
        // Avoid invalid BoundingFrustum
        if (startPoint.x === endPoint.x) {
            endPoint.x += Number.EPSILON;
        }
        if (startPoint.y === endPoint.y) {
            endPoint.y += Number.EPSILON;
        }
        if (!this.camera.isOrthographic) {
            _tmpPoint.set(Math.min(startPoint.x, endPoint.x), Math.max(startPoint.y, endPoint.y));
            endPoint.set(Math.max(startPoint.x, endPoint.x), Math.min(startPoint.y, endPoint.y));
            this.entity.transform.worldMatrix.getTranslation(_vecNear);
            _vecTopLeft.set(_tmpPoint.x, _tmpPoint.y, 0.5);
            _vecTopRight.set(endPoint.x, _tmpPoint.y, 0);
            _vecDownRight.set(endPoint.x, endPoint.y, 0.5);
            _vecDownLeft.set(_tmpPoint.x, endPoint.y, 0);
            unproject(_vecTopLeft, this.entity);
            unproject(_vecTopRight, this.entity);
            unproject(_vecDownRight, this.entity);
            unproject(_vecDownLeft, this.entity);
            _vectemp1.copyFrom(_vecTopLeft).subtract(_vecNear);
            _vectemp2.copyFrom(_vecTopRight).subtract(_vecNear);
            _vectemp3.copyFrom(_vecDownRight).subtract(_vecNear);
            _vectemp1.normalize();
            _vectemp2.normalize();
            _vectemp3.normalize();
            _vectemp1.scale(this.deep);
            _vectemp2.scale(this.deep);
            _vectemp3.scale(this.deep);
            _vectemp1.add(_vecNear);
            _vectemp2.add(_vecNear);
            _vectemp3.add(_vecNear);
            miniprogram.Plane.fromPoints(_vecNear, _vecTopLeft, _vecTopRight, _frustum.top);
            miniprogram.Plane.fromPoints(_vecNear, _vecTopRight, _vecDownRight, _frustum.right);
            miniprogram.Plane.fromPoints(_vecDownRight, _vecDownLeft, _vecNear, _frustum.bottom);
            miniprogram.Plane.fromPoints(_vecDownLeft, _vecTopLeft, _vecNear, _frustum.left);
            miniprogram.Plane.fromPoints(_vecTopRight, _vecDownRight, _vecDownLeft, _frustum.near);
            miniprogram.Plane.fromPoints(_vectemp3, _vectemp2, _vectemp1, _frustum.far);
            _frustum.far.normal.scale(-1);
        } else {
            var left = Math.min(startPoint.x, endPoint.x);
            var top = Math.max(startPoint.y, endPoint.y);
            var right = Math.max(startPoint.x, endPoint.x);
            var down = Math.min(startPoint.y, endPoint.y);
            _vecTopLeft.set(left, top, -1);
            _vecTopRight.set(right, top, -1);
            _vecDownRight.set(right, down, -1);
            _vecDownLeft.set(left, down, -1);
            _vecFarTopLeft.set(left, top, 1);
            _vecFarTopRight.set(right, top, 1);
            _vecFarDownRight.set(right, down, 1);
            _vecFarDownLeft.set(left, down, 1);
            unproject(_vecTopLeft, this.entity);
            unproject(_vecTopRight, this.entity);
            unproject(_vecDownRight, this.entity);
            unproject(_vecDownLeft, this.entity);
            unproject(_vecFarTopLeft, this.entity);
            unproject(_vecFarTopRight, this.entity);
            unproject(_vecFarDownRight, this.entity);
            unproject(_vecFarDownLeft, this.entity);
            miniprogram.Plane.fromPoints(_vecTopLeft, _vecFarTopLeft, _vecFarTopRight, _frustum.top);
            miniprogram.Plane.fromPoints(_vecTopRight, _vecFarTopRight, _vecFarDownRight, _frustum.right);
            miniprogram.Plane.fromPoints(_vecFarDownRight, _vecFarDownLeft, _vecDownLeft, _frustum.bottom);
            miniprogram.Plane.fromPoints(_vecFarDownLeft, _vecFarTopLeft, _vecTopLeft, _frustum.left);
            miniprogram.Plane.fromPoints(_vecTopRight, _vecDownRight, _vecDownLeft, _frustum.near);
            miniprogram.Plane.fromPoints(_vecFarDownRight, _vecFarTopRight, _vecFarTopLeft, _frustum.far);
            _frustum.far.normal.scale(-1);
        }
    };
    _proto.searchChildInBoundingFrustum = function searchChildInBoundingFrustum(frustum, entity, isDeep) {
        if (isDeep === void 0) isDeep = false;
        var c = entity.getComponent(BoxSelectionComponent);
        if (c && c.enabled) {
            _center.copyFrom(entity.transform.worldPosition);
            c.isSelect = miniprogram.CollisionUtil.frustumContainsPoint(frustum, _center) !== miniprogram.ContainmentType.Disjoint;
            if (c.isSelect) {
                this.collection.push(entity);
            }
        }
        var len = entity.children.length;
        if (isDeep && len) {
            for(var x = 0; x < len; x++){
                this.searchChildInBoundingFrustum(frustum, entity.children[x], isDeep);
            }
        }
        return this.collection;
    };
    return BoxSelectionControls;
}(miniprogram.Script);

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

exports.ControlHandlerType = void 0;
(function(ControlHandlerType) {
    ControlHandlerType[ControlHandlerType["None"] = 0] = "None";
    ControlHandlerType[ControlHandlerType["ROTATE"] = 1] = "ROTATE";
    ControlHandlerType[ControlHandlerType["ZOOM"] = 2] = "ZOOM";
    ControlHandlerType[ControlHandlerType["PAN"] = 4] = "PAN";
    ControlHandlerType[ControlHandlerType["All"] = 7] = "All";
})(exports.ControlHandlerType || (exports.ControlHandlerType = {}));

var ControlFreeKeyboard = /*#__PURE__*/ function() {
    function ControlFreeKeyboard() {}
    var _proto = ControlFreeKeyboard.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowLeft) || input.isKeyHeldDown(miniprogram.Keys.KeyA) || input.isKeyHeldDown(miniprogram.Keys.ArrowUp) || input.isKeyHeldDown(miniprogram.Keys.KeyW) || input.isKeyHeldDown(miniprogram.Keys.ArrowDown) || input.isKeyHeldDown(miniprogram.Keys.KeyS) || input.isKeyHeldDown(miniprogram.Keys.ArrowRight) || input.isKeyHeldDown(miniprogram.Keys.KeyD)) {
            return exports.ControlHandlerType.PAN;
        } else {
            return exports.ControlHandlerType.None;
        }
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var movementSpeed = control.movementSpeed, input = control.input;
        outDelta.x = outDelta.y = outDelta.z = 0;
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowLeft) || input.isKeyHeldDown(miniprogram.Keys.KeyA)) {
            outDelta.x -= movementSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowRight) || input.isKeyHeldDown(miniprogram.Keys.KeyD)) {
            outDelta.x += movementSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowUp) || input.isKeyHeldDown(miniprogram.Keys.KeyW)) {
            outDelta.z -= movementSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowDown) || input.isKeyHeldDown(miniprogram.Keys.KeyS)) {
            outDelta.z += movementSpeed;
        }
    };
    return ControlFreeKeyboard;
}();

var DeltaType$1;
(function(DeltaType) {
    DeltaType[DeltaType["Moving"] = 0] = "Moving";
    DeltaType[DeltaType["Distance"] = 1] = "Distance";
    DeltaType[DeltaType["None"] = 2] = "None";
})(DeltaType$1 || (DeltaType$1 = {}));
var ControlFreePointer = /*#__PURE__*/ function() {
    function ControlFreePointer() {
        this._deltaType = 0;
        this._handlerType = exports.ControlHandlerType.None;
        this._frameIndex = 0;
        this._lastUsefulFrameIndex = -1;
    }
    var _proto = ControlFreePointer.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        ++this._frameIndex;
        if (input.pointers.length === 1) {
            if (input.isPointerHeldDown(miniprogram.PointerButton.Primary)) {
                this._updateType(exports.ControlHandlerType.ROTATE, 0);
            } else {
                var deltaPosition = input.pointers[0].deltaPosition;
                if ((deltaPosition.x !== 0 || deltaPosition.y !== 0) && input.isPointerUp(miniprogram.PointerButton.Primary)) {
                    this._updateType(exports.ControlHandlerType.ROTATE, 0);
                } else {
                    this._updateType(exports.ControlHandlerType.None, 2);
                }
            }
        } else {
            this._updateType(exports.ControlHandlerType.None, 2);
        }
        return this._handlerType;
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var _this = this, frameIndex = _this._frameIndex;
        switch(this._deltaType){
            case 0:
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    var deltaPosition = control.input.pointers[0].deltaPosition;
                    outDelta.x = deltaPosition.x;
                    outDelta.y = deltaPosition.y;
                } else {
                    outDelta.x = 0;
                    outDelta.y = 0;
                }
                break;
        }
        this._lastUsefulFrameIndex = frameIndex;
    };
    _proto._updateType = function _updateType(handlerType, deltaType) {
        if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
            this._handlerType = handlerType;
            this._deltaType = deltaType;
            this._lastUsefulFrameIndex = -1;
        }
    };
    return ControlFreePointer;
}();

// Prevent gimbal lock.
var ESP = miniprogram.MathUtil.zeroTolerance;
// Spherical.
var Spherical = /*#__PURE__*/ function() {
    function Spherical(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        this._matrix = new miniprogram.Matrix();
        this._matrixInv = new miniprogram.Matrix();
        this.radius = radius !== undefined ? radius : 1.0;
        this.phi = phi !== undefined ? phi : 0;
        this.theta = theta !== undefined ? theta : 0;
    }
    var _proto = Spherical.prototype;
    _proto.makeSafe = function makeSafe() {
        var count = Math.floor(this.phi / Math.PI);
        this.phi = miniprogram.MathUtil.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
        return this;
    };
    _proto.set = function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    _proto.setYAxis = function setYAxis(up) {
        var xAxis = Spherical._xAxis, yAxis = Spherical._yAxis, zAxis = Spherical._zAxis;
        if (miniprogram.Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
            xAxis.set(0, 1, 0);
        }
        miniprogram.Vector3.cross(xAxis, yAxis, zAxis);
        zAxis.normalize();
        miniprogram.Vector3.cross(yAxis, zAxis, xAxis);
        var _this__matrix = this._matrix, es = _this__matrix.elements;
        es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
        es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
        es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
        var _this__matrixInv = this._matrixInv, eInv = _this__matrixInv.elements;
        eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
        eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
        eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
    };
    _proto.setFromVec3 = function setFromVec3(value, atTheBack) {
        if (atTheBack === void 0) atTheBack = false;
        value.transformNormal(this._matrixInv);
        this.radius = value.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            if (atTheBack) {
                this.phi = 2 * Math.PI - Math.acos(miniprogram.MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(-value.x, -value.z);
            } else {
                this.phi = Math.acos(miniprogram.MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(value.x, value.z);
            }
        }
        return this;
    };
    _proto.setToVec3 = function setToVec3(value) {
        var _this = this, radius = _this.radius, phi = _this.phi, theta = _this.theta;
        var sinPhiRadius = Math.sin(phi) * radius;
        this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
        value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
        value.transformNormal(this._matrix);
        return this.phi > Math.PI;
    };
    return Spherical;
}();
Spherical._xAxis = new miniprogram.Vector3();
Spherical._yAxis = new miniprogram.Vector3();
Spherical._zAxis = new miniprogram.Vector3();

/**
 * The camera's roaming controller, can move up and down, left and right, and rotate the viewing angle.
 */ var FreeControl = /*#__PURE__*/ function(Script) {
    _inherits(FreeControl, Script);
    function FreeControl(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.inputDevices = [
            new ControlFreeKeyboard(),
            new ControlFreePointer()
        ];
        /** Movement distance per second, the unit is the unit before MVP conversion. */ _this.movementSpeed = 1.0;
        /** Rotate speed. */ _this.rotateSpeed = 1.0;
        /** Simulate a ground. */ _this.floorMock = true;
        /** Simulated ground height. */ _this.floorY = 0;
        _this._spherical = new Spherical();
        _this._tempVec = new miniprogram.Vector3();
        _this._atTheBack = false;
        _this._topVec = new miniprogram.Vector3(0, 1, 0);
        _this._bottomVec = new miniprogram.Vector3(0, -1, 0);
        _this.input = _this.engine.inputManager;
        var transform = _this._cameraTransform = entity.transform;
        /** Init spherical. */ var _$_assert_this_initialized = _assert_this_initialized(_this), tempVec = _$_assert_this_initialized._tempVec, spherical = _$_assert_this_initialized._spherical;
        miniprogram.Vector3.transformByQuat(tempVec.set(0, 0, -1), transform.rotationQuaternion, tempVec);
        spherical.setFromVec3(tempVec, _this._atTheBack);
        return _this;
    }
    var _proto = FreeControl.prototype;
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        if (this.enabled === false) return;
        exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType) {
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta, deltaTime);
                        break;
                }
            }
        }
        if (this.floorMock) {
            var position = this._cameraTransform.position;
            if (position.y !== this.floorY) {
                this._cameraTransform.setPosition(position.x, this.floorY, position.z);
            }
        }
    };
    _proto._pan = function _pan(moveDelta, delta) {
        var actualMoveSpeed = delta * this.movementSpeed;
        moveDelta.normalize().scale(actualMoveSpeed);
        this._cameraTransform.translate(moveDelta, true);
    };
    _proto._rotate = function _rotate(moveDelta) {
        if (moveDelta.x !== 0 || moveDelta.y !== 0) {
            var canvas = this.engine.canvas;
            var deltaAlpha = -moveDelta.x * 180 / canvas.width;
            var deltaPhi = moveDelta.y * 180 / canvas.height;
            this._spherical.theta += miniprogram.MathUtil.degreeToRadian(deltaAlpha);
            this._spherical.phi += miniprogram.MathUtil.degreeToRadian(deltaPhi);
            this._spherical.makeSafe();
            this._atTheBack = this._spherical.setToVec3(this._tempVec);
            miniprogram.Vector3.add(this._cameraTransform.position, this._tempVec, this._tempVec);
            this._atTheBack ? this._cameraTransform.lookAt(this._tempVec, this._bottomVec) : this._cameraTransform.lookAt(this._tempVec, this._topVec);
        }
    };
    return FreeControl;
}(miniprogram.Script);

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

var ControlKeyboard = /*#__PURE__*/ function() {
    function ControlKeyboard() {}
    var _proto = ControlKeyboard.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowLeft) || input.isKeyHeldDown(miniprogram.Keys.ArrowRight) || input.isKeyHeldDown(miniprogram.Keys.ArrowUp) || input.isKeyHeldDown(miniprogram.Keys.ArrowDown)) {
            return exports.ControlHandlerType.PAN;
        } else {
            return exports.ControlHandlerType.None;
        }
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var keyPanSpeed = control.keyPanSpeed, input = control.input;
        outDelta.x = outDelta.y = 0;
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowLeft)) {
            outDelta.x += keyPanSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowRight)) {
            outDelta.x -= keyPanSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowUp)) {
            outDelta.y += keyPanSpeed;
        }
        if (input.isKeyHeldDown(miniprogram.Keys.ArrowDown)) {
            outDelta.y -= keyPanSpeed;
        }
    };
    return ControlKeyboard;
}();

var DeltaType;
(function(DeltaType) {
    DeltaType[DeltaType["Moving"] = 0] = "Moving";
    DeltaType[DeltaType["Distance"] = 1] = "Distance";
    DeltaType[DeltaType["None"] = 2] = "None";
})(DeltaType || (DeltaType = {}));
var ControlPointer = /*#__PURE__*/ function() {
    function ControlPointer() {
        this._deltaType = 2;
        this._handlerType = exports.ControlHandlerType.None;
        this._frameIndex = 0;
        this._lastUsefulFrameIndex = -1;
        this._distanceOfPointers = 0;
    }
    var _proto = ControlPointer.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        ++this._frameIndex;
        var pointers = input.pointers;
        switch(pointers.length){
            case 1:
                if (input.isPointerHeldDown(miniprogram.PointerButton.Secondary)) {
                    this._updateType(exports.ControlHandlerType.PAN, 0);
                } else if (input.isPointerHeldDown(miniprogram.PointerButton.Auxiliary)) {
                    this._updateType(exports.ControlHandlerType.ZOOM, 0);
                } else if (input.isPointerHeldDown(miniprogram.PointerButton.Primary)) {
                    this._updateType(exports.ControlHandlerType.ROTATE, 0);
                } else {
                    // When `onPointerMove` happens on the same frame as `onPointerUp`
                    // Need to record the movement of this frame
                    var deltaPosition = input.pointers[0].deltaPosition;
                    if (deltaPosition.x !== 0 && deltaPosition.y !== 0) {
                        if (input.isPointerUp(miniprogram.PointerButton.Secondary)) {
                            this._updateType(exports.ControlHandlerType.PAN, 0);
                        } else if (input.isPointerUp(miniprogram.PointerButton.Auxiliary)) {
                            this._updateType(exports.ControlHandlerType.ZOOM, 0);
                        } else if (input.isPointerUp(miniprogram.PointerButton.Primary)) {
                            this._updateType(exports.ControlHandlerType.ROTATE, 0);
                        } else {
                            this._updateType(exports.ControlHandlerType.None, 2);
                        }
                    } else {
                        this._updateType(exports.ControlHandlerType.None, 2);
                    }
                }
                break;
            case 2:
                this._updateType(exports.ControlHandlerType.ZOOM, 1);
                break;
            case 3:
                this._updateType(exports.ControlHandlerType.PAN, 0);
                break;
            default:
                this._updateType(exports.ControlHandlerType.None, 2);
                break;
        }
        return this._handlerType;
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var _this = this, frameIndex = _this._frameIndex;
        switch(this._deltaType){
            case 0:
                outDelta.x = 0;
                outDelta.y = 0;
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    var pointers = control.input.pointers;
                    var length = pointers.length;
                    for(var i = length - 1; i >= 0; i--){
                        var deltaPosition = pointers[i].deltaPosition;
                        outDelta.x += deltaPosition.x;
                        outDelta.y += deltaPosition.y;
                    }
                    outDelta.x /= length;
                    outDelta.y /= length;
                }
                break;
            case 1:
                var pointers1 = control.input.pointers;
                var pointer1 = pointers1[0];
                var pointer2 = pointers1[1];
                var curDistance = miniprogram.Vector2.distance(pointer1.position, pointer2.position);
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    outDelta.set(0, this._distanceOfPointers - curDistance, 0);
                } else {
                    outDelta.set(0, 0, 0);
                }
                this._distanceOfPointers = curDistance;
                break;
        }
        this._lastUsefulFrameIndex = frameIndex;
    };
    _proto._updateType = function _updateType(handlerType, deltaType) {
        if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
            this._handlerType = handlerType;
            this._deltaType = deltaType;
            this._lastUsefulFrameIndex = -1;
        }
    };
    return ControlPointer;
}();

var ControlWheel = /*#__PURE__*/ function() {
    function ControlWheel() {}
    var _proto = ControlWheel.prototype;
    _proto.onUpdateHandler = function onUpdateHandler(input) {
        var wheelDelta = input.wheelDelta;
        if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
            return exports.ControlHandlerType.None;
        } else {
            return exports.ControlHandlerType.ZOOM;
        }
    };
    _proto.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        outDelta.copyFrom(control.input.wheelDelta);
    };
    return ControlWheel;
}();

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrbitControl = /*#__PURE__*/ function(Script) {
    _inherits(OrbitControl, Script);
    function OrbitControl() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this.inputDevices = [
            new ControlKeyboard(),
            new ControlPointer(),
            new ControlWheel()
        ];
        /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false;
        /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI;
        /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true;
        /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0;
        /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0;
        /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0;
        /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1;
        /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2;
        /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1;
        /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity;
        /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0;
        /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity;
        /** The minimum radian in the vertical direction, the default is 1 degree. */ _this.minPolarAngle = 1 / 180 * Math.PI;
        /** The maximum radian in the vertical direction,  the default is 179 degree.  */ _this.maxPolarAngle = 179 / 180 * Math.PI;
        /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity;
        /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity;
        _this._enableKeys = true;
        _this._up = new miniprogram.Vector3(0, 1, 0);
        _this._target = new miniprogram.Vector3();
        _this._atTheBack = false;
        _this._spherical = new Spherical();
        _this._sphericalDelta = new Spherical();
        _this._sphericalDump = new Spherical();
        _this._zoomFrag = 0;
        _this._scale = 1;
        _this._panOffset = new miniprogram.Vector3();
        _this._tempVec3 = new miniprogram.Vector3();
        _this._enableHandler = exports.ControlHandlerType.All;
        return _this;
    }
    var _proto = OrbitControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.canvas = engine.canvas;
        this.input = engine.inputManager;
        this.camera = entity.getComponent(miniprogram.Camera);
        this.cameraTransform = entity.transform;
        this._spherical.setYAxis(this._up);
        this._atTheBack = false;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateTransform();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        var curHandlerType = exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                curHandlerType |= handlerType;
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case exports.ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
        var _this2 = this, _sphericalDump = _this2._sphericalDump, _sphericalDelta = _this2._sphericalDelta;
        if (this.enableDamping) {
            if (enableHandler & exports.ControlHandlerType.ZOOM && curHandlerType ^ exports.ControlHandlerType.ZOOM) {
                this._zoomFrag *= 1 - this.zoomFactor;
            }
            if (enableHandler & exports.ControlHandlerType.ROTATE && curHandlerType ^ exports.ControlHandlerType.ROTATE) {
                _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
                _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
            }
        }
        if (curHandlerType === exports.ControlHandlerType.None && this.autoRotate) {
            var rotateAngle = this.autoRotateSpeed * deltaTime;
            _sphericalDelta.theta -= rotateAngle;
        }
    };
    _proto._rotate = function _rotate(delta) {
        var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
        this._sphericalDelta.theta -= radianLeft;
        var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
        this._sphericalDelta.phi -= radianUp;
        if (this.enableDamping) {
            this._sphericalDump.theta = -radianLeft;
            this._sphericalDump.phi = -radianUp;
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        var cameraTransform = this.cameraTransform;
        var elements = cameraTransform.worldMatrix.elements;
        var height = this.canvas.height;
        var targetDistance = miniprogram.Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
        var distanceLeft = -2 * delta.x * (targetDistance / height);
        var distanceUp = 2 * delta.y * (targetDistance / height);
        this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
        this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
        this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
    };
    _proto._updateTransform = function _updateTransform() {
        var _this = this, cameraTransform = _this.cameraTransform, target = _this.target, _tempVec3 = _this._tempVec3, _spherical = _this._spherical, _sphericalDelta = _this._sphericalDelta, _panOffset = _this._panOffset;
        _tempVec3.copyFrom(cameraTransform.worldUp);
        this._atTheBack = _tempVec3.y <= 0;
        miniprogram.Vector3.subtract(cameraTransform.position, target, _tempVec3);
        _spherical.setFromVec3(_tempVec3, this._atTheBack);
        _spherical.theta += _sphericalDelta.theta;
        _spherical.phi += _sphericalDelta.phi;
        _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
        _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
        _spherical.makeSafe();
        if (this._scale !== 1) {
            this._zoomFrag = _spherical.radius * (this._scale - 1);
        }
        _spherical.radius += this._zoomFrag;
        _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
        this._atTheBack = _spherical.setToVec3(_tempVec3);
        miniprogram.Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
        cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
        /** Reset cache value. */ this._zoomFrag = 0;
        this._scale = 1;
        _sphericalDelta.set(0, 0, 0);
        _panOffset.set(0, 0, 0);
    };
    _create_class(OrbitControl, [
        {
            key: "enableKeys",
            get: /**
   * Return whether to enable keyboard.
   */ function get() {
                return this._enableKeys;
            },
            set: function set(value) {
                if (this._enableKeys !== value) {
                    this._enableKeys = value;
                    var inputDevices = this.inputDevices;
                    if (value) {
                        inputDevices.push(new ControlKeyboard());
                    } else {
                        for(var i = inputDevices.length - 1; i >= 0; i--){
                            if (_instanceof(inputDevices[i], ControlKeyboard)) {
                                inputDevices.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "up",
            get: /*
   * Return up vector.
   */ function get() {
                return this._up;
            },
            set: function set(value) {
                this._up.copyFrom(value);
                this._spherical.setYAxis(value);
                this._atTheBack = false;
            }
        },
        {
            key: "target",
            get: /**
   * Return target position.
   * */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
                this._atTheBack = false;
            }
        },
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrbitControl;
}(miniprogram.Script);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrthoControl = /*#__PURE__*/ function(Script) {
    _inherits(OrthoControl, Script);
    function OrthoControl(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.inputDevices = [
            new ControlKeyboard(),
            new ControlPointer(),
            new ControlWheel()
        ];
        /** Target position. */ _this.target = new miniprogram.Vector3();
        /** Up vector */ _this.up = new miniprogram.Vector3(0, 1, 0);
        /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false;
        /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI;
        /** Whether to enable keyboard. */ _this.enableKeys = false;
        /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true;
        /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0;
        /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0;
        /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0;
        /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1;
        /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2;
        /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1;
        /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity;
        /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0;
        /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity;
        /** The minimum radian in the vertical direction, the default is 0 radian, the value range is 0 - Math.PI. */ _this.minPolarAngle = 0.0;
        /** The maximum radian in the vertical direction, the default is Math.PI, and the value range is 0 - Math.PI. */ _this.maxPolarAngle = Math.PI;
        /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity;
        /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity;
        _this._zoomScaleUnit = 2;
        _this._scale = 1;
        _this._panOffset = new miniprogram.Vector3();
        _this._tempVec3 = new miniprogram.Vector3();
        _this._enableHandler = exports.ControlHandlerType.All;
        _this.enableRotate = false;
        return _this;
    }
    var _proto = OrthoControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.canvas = engine.canvas;
        this.input = engine.inputManager;
        this.camera = entity.getComponent(miniprogram.Camera);
        this.cameraTransform = entity.transform;
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateCamera();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        this._panOffset.copyFrom(delta);
    };
    _proto._updateCamera = function _updateCamera() {
        var _this = this, cameraTransform = _this.cameraTransform, camera = _this.camera, _panOffset = _this._panOffset;
        // Update Zoom
        var sizeDiff = this._zoomScaleUnit * Math.log1p(camera.orthographicSize) * (this._scale - 1);
        var size = camera.orthographicSize + sizeDiff;
        camera.orthographicSize = Math.max(this.minZoom, Math.min(this.maxZoom, size));
        // Update X and Y
        var _this_canvas = this.canvas, width = _this_canvas.width, height = _this_canvas.height;
        var x = _panOffset.x, y = _panOffset.y;
        var doubleOrthographicSize = camera.orthographicSize * 2;
        var width3D = doubleOrthographicSize * camera.aspectRatio;
        var height3D = doubleOrthographicSize;
        var cameraPosition = cameraTransform.position;
        var curPosition = this._tempVec3;
        curPosition.x = cameraPosition.x - x * width3D / width;
        curPosition.y = cameraPosition.y + y * height3D / height;
        curPosition.z = cameraPosition.z;
        // Update camera transform
        cameraTransform.position = curPosition;
        /** Reset cache value. */ this._scale = 1;
        _panOffset.set(0, 0, 0);
    };
    _create_class(OrthoControl, [
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrthoControl;
}(miniprogram.Script);

exports.BoxSelectionComponent = BoxSelectionComponent;
exports.BoxSelectionControls = BoxSelectionControls;
exports.BoxSelectionSSHelper = BoxSelectionSSHelper;
exports.ControlFreeKeyboard = ControlFreeKeyboard;
exports.ControlFreePointer = ControlFreePointer;
exports.ControlKeyboard = ControlKeyboard;
exports.ControlPointer = ControlPointer;
exports.ControlWheel = ControlWheel;
exports.FreeControl = FreeControl;
exports.OrbitControl = OrbitControl;
exports.OrthoControl = OrthoControl;
