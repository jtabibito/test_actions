import shadingPBR from './shadingPBR/index.js';

var BlendShape = "#ifndef BLENDSHAPE_INCLUDED\n#define BLENDSHAPE_INCLUDED\n\n#ifdef RENDERER_HAS_BLENDSHAPE\n\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\n\t\tmediump sampler2DArray renderer_BlendShapeTexture;\n\t\tivec3 renderer_BlendShapeTextureInfo;\n\t\tfloat renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n\n\t\tvec3 getBlendShapeVertexElement(int blendShapeIndex, int vertexElementIndex){\t\t\t\n\t\t\tint y = vertexElementIndex / renderer_BlendShapeTextureInfo.y;\n\t\t\tint x = vertexElementIndex - y * renderer_BlendShapeTextureInfo.y;\n\t\t\tivec3 uv = ivec3(x, y , blendShapeIndex);\n\t\t\treturn (texelFetch(renderer_BlendShapeTexture, uv, 0)).xyz;\n\t\t}\n\t#else\n\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\tfloat renderer_BlendShapeWeights[2];\n\t\t#else\n\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\t\tfloat renderer_BlendShapeWeights[4];\n\t\t\t#else\n\t\t\t\tfloat renderer_BlendShapeWeights[8];\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\n\tvoid calculateBlendShape(Attributes attributes, inout vec4 position\n        #ifdef RENDERER_HAS_NORMAL\n            ,inout vec3 normal\n\t\t\t #ifdef RENDERER_HAS_TANGENT\n            \t,inout vec4 tangent\n        \t#endif\n        #endif\n       \n\t){\n\t\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\t\n    \t\tint vertexOffset = gl_VertexID * renderer_BlendShapeTextureInfo.x;\n    \t\tfor(int i = 0; i < RENDERER_BLENDSHAPE_COUNT; i++){\n    \t\t\tint vertexElementOffset = vertexOffset;\n    \t\t\tfloat weight = renderer_BlendShapeWeights[i];\n    \t\t\t// Warnning: Multiplying by 0 creates weird precision issues, causing rendering anomalies in Ace2 Android13\n    \t\t\tif(weight != 0.0){\n    \t\t\t\tposition.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \n    \t\t\t\t#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\n    \t\t\t\t\tvertexElementOffset += 1;\n    \t\t\t\t\tnormal += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \t\t\t\t#endif\n    \n    \t\t\t\t#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT)\n    \t\t\t\t\tvertexElementOffset += 1;\n    \t\t\t\t\ttangent.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \t\t\t\t#endif\n    \t\t\t}\n    \n    \t\t}\n    \t#else\n    \t\tposition.xyz += attributes.POSITION_BS0 * renderer_BlendShapeWeights[0];\n    \t\tposition.xyz += attributes.POSITION_BS1 * renderer_BlendShapeWeights[1];\n\n    \t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t\t\t#ifdef RENDERER_HAS_NORMAL\n    \t\t\t\tnormal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\tnormal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t#endif\n                    \n    \t\t\t#ifdef RENDERER_HAS_TANGENT\n    \t\t\t\ttangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\ttangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t#endif\t\t\t\t\n    \t\t#else\n    \t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t\t\t\tposition.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n\n    \t\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\n    \t\t\t\t\tnormal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\t#endif\n\n    \t\t\t\t#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT )\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\t#endif\n    \t\t\t#else\n    \t\t\t\tposition.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS4 * renderer_BlendShapeWeights[4];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS5 * renderer_BlendShapeWeights[5];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS6 * renderer_BlendShapeWeights[6];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS7 * renderer_BlendShapeWeights[7];\n    \t\t\t#endif\n    \t\t#endif\n    \t#endif\n\t}\n\n#endif\n\n\n#endif";

var Common = "#ifndef COMMON_INCLUDED\n#define COMMON_INCLUDED\n\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n\nfloat pow2(float x ) {\n    return x * x;\n}\n\nvec4 RGBMToLinear(vec4 value, float maxRange ) {\n    return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 gammaToLinear(vec4 srgbIn){\n    return vec4( pow(srgbIn.rgb, vec3(2.2)), srgbIn.a);\n}\n\nvec4 linearToGamma(vec4 linearIn){\n\tlinearIn = max(linearIn, 0.0);\n    return vec4( pow(linearIn.rgb, vec3(1.0 / 2.2)), linearIn.a);\n}\n\nvec4 camera_DepthBufferParams;\n\nfloat remapDepthBufferLinear01(float z){\n\treturn 1.0/ (camera_DepthBufferParams.x * z + camera_DepthBufferParams.y);\n}\n\n\n#ifdef GRAPHICS_API_WEBGL2\n\t#define INVERSE_MAT(mat) inverse(mat)\n#else\n\tmat2 inverseMat(mat2 m) {\n\t\treturn mat2(m[1][1],-m[0][1],\n\t\t\t\t-m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n\t}\n\tmat3 inverseMat(mat3 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n\t\tfloat b01 = a22 * a11 - a12 * a21;\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\n\t\tfloat b21 = a21 * a10 - a11 * a20;\n\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\n\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n\t}\n\tmat4 inverseMat(mat4 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n\t\t\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n\t\t\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n\t\t\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n\t\t\tb00 = a00 * a11 - a01 * a10,\n\t\t\tb01 = a00 * a12 - a02 * a10,\n\t\t\tb02 = a00 * a13 - a03 * a10,\n\t\t\tb03 = a01 * a12 - a02 * a11,\n\t\t\tb04 = a01 * a13 - a03 * a11,\n\t\t\tb05 = a02 * a13 - a03 * a12,\n\t\t\tb06 = a20 * a31 - a21 * a30,\n\t\t\tb07 = a20 * a32 - a22 * a30,\n\t\t\tb08 = a20 * a33 - a23 * a30,\n\t\t\tb09 = a21 * a32 - a22 * a31,\n\t\t\tb10 = a21 * a33 - a23 * a31,\n\t\t\tb11 = a22 * a33 - a23 * a32,\n\n\t\t\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\t\treturn mat4(\n\t\t\ta11 * b11 - a12 * b10 + a13 * b09,\n\t\t\ta02 * b10 - a01 * b11 - a03 * b09,\n\t\t\ta31 * b05 - a32 * b04 + a33 * b03,\n\t\t\ta22 * b04 - a21 * b05 - a23 * b03,\n\t\t\ta12 * b08 - a10 * b11 - a13 * b07,\n\t\t\ta00 * b11 - a02 * b08 + a03 * b07,\n\t\t\ta32 * b02 - a30 * b05 - a33 * b01,\n\t\t\ta20 * b05 - a22 * b02 + a23 * b01,\n\t\t\ta10 * b10 - a11 * b08 + a13 * b06,\n\t\t\ta01 * b08 - a00 * b10 - a03 * b06,\n\t\t\ta30 * b04 - a31 * b02 + a33 * b00,\n\t\t\ta21 * b02 - a20 * b04 - a23 * b00,\n\t\t\ta11 * b07 - a10 * b09 - a12 * b06,\n\t\t\ta00 * b09 - a01 * b07 + a02 * b06,\n\t\t\ta31 * b01 - a30 * b03 - a32 * b00,\n\t\t\ta20 * b03 - a21 * b01 + a22 * b00) / det;\n\t}\n\n\t#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n\n\n#endif";

var Fog = "#ifndef FOG_INCLUDED\n#define FOG_INCLUDED\n\n#if SCENE_FOG_MODE != 0\n    vec4 scene_FogColor;\n    vec4 scene_FogParams; // (-1/(end-start), end/(end-start), density/ln(2),density/sprt(ln(2)));\n\n    vec4 fog(vec4 color, vec3 positionVS){\n        float fogDepth = length(positionVS);\n\n        #if SCENE_FOG_MODE == 1\n            // (end-z) / (end-start) = z * (-1/(end-start)) + (end/(end-start))\n            float fogIntensity = clamp(fogDepth * scene_FogParams.x + scene_FogParams.y, 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 2\n            // exp(-z * density) = exp2((-z * density)/ln(2)) = exp2(-z * density/ln(2))\n            float fogIntensity = clamp(exp2(-fogDepth * scene_FogParams.z), 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 3\n            // exp(-(z * density)^2) = exp2(-(z * density)^2/ln(2)) = exp2(-(z * density/sprt(ln(2)))^2)\n            float factor = fogDepth * scene_FogParams.w;\n            float fogIntensity = clamp(exp2(-factor * factor), 0.0, 1.0);\n        #endif\n\n        color.rgb = mix(scene_FogColor.rgb, color.rgb, fogIntensity);\n\n        return color;\n    }\n#endif\n\n\n#endif";

var Light = "#ifndef LIGHT_INCLUDED\n#define LIGHT_INCLUDED\n\n\nivec4 renderer_Layer;\n#ifndef GRAPHICS_API_WEBGL2\n    bool isBitSet(float value, float mask, float bitIndex){\n        return mod(floor(value / pow(2.0, bitIndex)), 2.0) == 1.0 && mod(floor(mask / pow(2.0, bitIndex)), 2.0) == 1.0;\n    }\n#endif\n\nbool isRendererCulledByLight(ivec2 rendererLayer, ivec2 lightCullingMask){\n    #ifdef GRAPHICS_API_WEBGL2\n    return !((rendererLayer.x & lightCullingMask.x) != 0 || (rendererLayer.y & lightCullingMask.y) != 0);\n    #else\n    for (int i = 0; i < 16; i++) {\n        if (isBitSet( float(rendererLayer.x), float(lightCullingMask.x), float(i)) || isBitSet( float(rendererLayer.y), float(lightCullingMask.y), float(i))) {\n            return false;\n        }\n    }\n    return true;\n    #endif\n}\n\n// Directional light\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    struct DirectLight {\n        vec3 color;\n        vec3 direction;\n    };\n\n    ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        DirectLight getDirectLight(int index){\n            DirectLight light;\n            light.color = scene_DirectLightColor[index];\n            light.direction = scene_DirectLightDirection[index];\n    \n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Point light\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n    struct PointLight {\n        vec3 color;\n        vec3 position;\n        float distance;\n    };\n\n    ivec2 scene_PointLightCullingMask[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightColor[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightPosition[ SCENE_POINT_LIGHT_COUNT ];\n    float scene_PointLightDistance[ SCENE_POINT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        PointLight getPointLight(int index){\n            PointLight light;\n            light.color = scene_PointLightColor[index];\n            light.position = scene_PointLightPosition[index];\n            light.distance = scene_PointLightDistance[index];\n\n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Spot light\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n        vec3 color;\n        vec3 position;\n        vec3 direction;\n        float distance;\n        float angleCos;\n        float penumbraCos;\n    };\n\n    ivec2 scene_SpotLightCullingMask[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightColor[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightPosition[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightDirection[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightDistance[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightAngleCos[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightPenumbraCos[ SCENE_SPOT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        SpotLight getSpotLight(int index){\n            SpotLight light;\n            light.color = scene_SpotLightColor[index];\n            light.position = scene_SpotLightPosition[index];\n            light.direction = scene_SpotLightDirection[index];\n            light.distance = scene_SpotLightDistance[index];\n            light.angleCos = scene_SpotLightAngleCos[index];\n            light.penumbraCos = scene_SpotLightPenumbraCos[index];\n\n            return light;\n        }\n    #endif\n\n\n#endif\n\n// Ambient light\nstruct EnvMapLight {\n    vec3 diffuse;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n};\n\n\nEnvMapLight scene_EnvMapLight;\n\n#ifdef SCENE_USE_SH\n    vec3 scene_EnvSH[9];\n#endif\n\n#ifdef SCENE_USE_SPECULAR_ENV\n    samplerCube scene_EnvSpecularSampler;\n#endif\n\n\n\n\n#endif\n";

var Normal = "#ifndef NORMAL_INCLUDED\n#define NORMAL_INCLUDED\n\n\nvec3 getNormalByNormalTexture(mat3 tbn, sampler2D normalTexture, float normalIntensity, vec2 uv, bool isFrontFacing){\n    vec3 normal = (texture2D(normalTexture, uv)).rgb;\n    normal = normalize(tbn * ((2.0 * normal - 1.0) * vec3(normalIntensity, normalIntensity, 1.0)));\n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n\n    return normal;\n}\n\nmat3 getTBNByDerivatives(vec2 uv, vec3 normal, vec3 position, bool isFrontFacing){\n    #ifdef HAS_DERIVATIVES\n        uv = isFrontFacing? uv: -uv;\n        // ref: http://www.thetenthplanet.de/archives/1180\n        // get edge vectors of the pixel triangle\n\t    vec3 dp1 = dFdx(position);\n\t    vec3 dp2 = dFdy(position);\n\t    vec2 duv1 = dFdx(uv);\n\t    vec2 duv2 = dFdy(uv);\n\t    // solve the linear system\n\t    vec3 dp2perp = cross(dp2, normal);\n\t    vec3 dp1perp = cross(normal, dp1);\n\t    vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n\t    vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n\t    // construct a scale-invariant frame \n        float denom = max( dot(tangent, tangent), dot(bitangent, bitangent) );\n        float invmax = (denom == 0.0) ? 0.0 : camera_ProjectionParams.x / sqrt( denom );\n\t    return mat3(tangent * invmax, bitangent * invmax, normal);\n    #else\n        return mat3(vec3(0.0), vec3(0.0), normal);\n    #endif\n}\n\n\n#endif";

var PBRSource = "Shader \"PBR.gs\" {\n    EditorProperties {\n      Header(\"Base\"){\n        material_IOR(\"IOR\", Range(0, 5, 0.01)) = 1.5;\n        material_BaseColor(\"BaseColor\", Color) = (1, 1, 1, 1);\n        material_BaseTexture(\"BaseTexture\", Texture2D);\n      }\n\n      Header(\"Metal Roughness\") {\n        material_Metal( \"Metal\", Range(0,1,0.01) ) = 1;\n        material_Roughness( \"Roughness\", Range( 0, 1, 0.01 ) ) = 1;\n        material_RoughnessMetallicTexture(\"RoughnessMetallicTexture\", Texture2D);\n      }\n\n      Header(\"Anisotropy\") {\n        material_AnisotropyInfo(\"AnisotropyInfo\", Vector3) = (1, 0, 0);\n        material_AnisotropyTexture(\"AnisotropyTexture\", Texture2D);\n      }\n\n      Header(\"Normal\") {\n        material_NormalTexture(\"NormalTexture\", Texture2D);\n        material_NormalIntensity(\"NormalIntensity\", Range(0, 5, 0.01)) = 1;\n      }\n\n      Header(\"Emissive\") {\n        material_EmissiveColor(\"EmissiveColor\", Color ) = (0, 0, 0, 1);\n        material_EmissiveTexture(\"EmissiveTexture\", Texture2D);\n      }\n\n      Header(\"Occlusion\") {\n        material_OcclusionTexture(\"OcclusionTexture\", Texture2D);\n        material_OcclusionIntensity(\"OcclusionIntensity\", Range(0, 5, 0.01)) = 1;\n        material_OcclusionTextureCoord(\"OcclusionTextureCoord\", Float) = 0;\n      }\n      \n      Header(\"Clear Coat\") {\n        material_ClearCoat(\"ClearCoat\", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatTexture(\"ClearCoatTexture\", Texture2D);\n        material_ClearCoatRoughness(\"ClearCoatRoughness\", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatRoughnessTexture(\"ClearCoatRoughnessTexture\", Texture2D);\n        material_ClearCoatNormalTexture(\"ClearCoatNormalTexture\", Texture2D);\n      }\n\n      Header(\"Common\") {\n        material_AlphaCutoff( \"AlphaCutoff\", Range(0, 1, 0.01) ) = 0;\n        material_TilingOffset(\"TilingOffset\", Vector4) = (1, 1, 0, 0);\n      }\n    }\n\n    EditorMacros {\n      Header(\"Conditional Macors\") {\n        MATERIAL_HAS_BASETEXTURE(\"HAS_BASETEXTURE\");\n        MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE(\"HAS_ROUGHNESS_METALLIC_TEXTURE\");\n        MATERIAL_ENABLE_ANISOTROPY(\"ENABLE_ANISOTROPY\");\n        MATERIAL_HAS_ANISOTROPY_TEXTURE(\"HAS_ANISOTROPY_TEXTURE\")\n        MATERIAL_HAS_NORMALTEXTURE(\"HAS_NORMALTEXTURE\");\n        MATERIAL_HAS_EMISSIVETEXTURE(\"HAS_EMISSIVETEXTURE\");\n        MATERIAL_HAS_OCCLUSION_TEXTURE(\"HAS_OCCLUSION_TEXTURE\");\n        MATERIAL_ENABLE_CLEAR_COAT(\"ENABLE_CLEAR_COAT\");\n        MATERIAL_HAS_CLEAR_COAT_TEXTURE(\"HAS_CLEAR_COAT_TEXTURE\");\n        MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE(\"HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\");\n        MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE(\"HAS_CLEAR_COAT_NORMAL_TEXTURE\");\n        MATERIAL_IS_TRANSPARENT(\"IS_TRANSPARENT\");\n        MATERIAL_IS_ALPHA_CUTOFF(\"IS_ALPHA_CUTOFF\");\n      }\n    }\n    \n    SubShader \"Default\" {\n      UsePass \"pbr/Default/ShadowCaster\"\n\n      Pass \"Forward Pass\" {\n        Tags { pipelineStage = \"Forward\"} \n\n        #define IS_METALLIC_WORKFLOW\n        \n        VertexShader = PBRVertex;\n        FragmentShader = PBRFragment;\n\n        #include \"ForwardPassPBR.glsl\"\n      }\n    }\n  }";

var Shadow = "#ifndef SHADOW_INCLUDED\n#define SHADOW_INCLUDED\n\n#include \"Transform.glsl\"\n#include \"Common.glsl\"\n\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n    #define NEED_CALCULATE_SHADOWS\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n\n        mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT + 1];\n        vec4 scene_ShadowSplitSpheres[4];\n\n        mediump int computeCascadeIndex(vec3 positionWS) {\n            vec3 fromCenter0 = positionWS - scene_ShadowSplitSpheres[0].xyz;\n            vec3 fromCenter1 = positionWS - scene_ShadowSplitSpheres[1].xyz;\n            vec3 fromCenter2 = positionWS - scene_ShadowSplitSpheres[2].xyz;\n            vec3 fromCenter3 = positionWS - scene_ShadowSplitSpheres[3].xyz;\n\n            mediump vec4 comparison = vec4(\n                (dot(fromCenter0, fromCenter0) < scene_ShadowSplitSpheres[0].w),\n                (dot(fromCenter1, fromCenter1) < scene_ShadowSplitSpheres[1].w),\n                (dot(fromCenter2, fromCenter2) < scene_ShadowSplitSpheres[2].w),\n                (dot(fromCenter3, fromCenter3) < scene_ShadowSplitSpheres[3].w));\n            comparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\n            mediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\n            mediump int index = 4 - int(dot(comparison, indexCoefficient));\n            return index;\n        }\n\n        vec3 getShadowCoord(vec3 positionWS) {\n            #if SCENE_SHADOW_CASCADED_COUNT == 1\n                mediump int cascadeIndex = 0;\n            #else\n                mediump int cascadeIndex = computeCascadeIndex(positionWS);\n            #endif\n        \n            #ifdef GRAPHICS_API_WEBGL2\n                mat4 shadowMatrix = scene_ShadowMatrices[cascadeIndex];\n            #else\n                mat4 shadowMatrix;\n                #if SCENE_SHADOW_CASCADED_COUNT == 4\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else if (cascadeIndex == 2) {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } else if (cascadeIndex == 3) {\n                        shadowMatrix = scene_ShadowMatrices[3];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[4];\n                    }\n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 2\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } \n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 1\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else  {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } \n                #endif\n            #endif\n        \n            vec4 shadowCoord = shadowMatrix * vec4(positionWS, 1.0);\n            return shadowCoord.xyz;\n        }\n\n    #endif\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    // intensity, null, fadeScale, fadeBias\n    vec4 scene_ShadowInfo;\n    vec4 scene_ShadowMapSize;\n\n    #ifdef GRAPHICS_API_WEBGL2\n        mediump sampler2DShadow scene_ShadowMap;\n        #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n    #else\n        sampler2D scene_ShadowMap;\n        #ifdef ENGINE_NO_DEPTH_TEXTURE\n            const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n            /**\n            * Unpack depth value.\n            */\n            float unpack(in vec4 rgbaDepth) {\n                return dot(rgbaDepth, bitShift);\n            }\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n        #else\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) ((texture2D(textureName, coord3.xy)).r < coord3.z ? 0.0 : 1.0)\n        #endif\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 2\n        float sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowMapSize) {\n            float attenuation;\n            vec4 attenuation4;\n            vec2 offset=shadowMapSize.xy/2.0;\n            vec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\n            vec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\n            vec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\n            vec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\n            attenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\n            attenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\n            attenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\n            attenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\n            attenuation = dot(attenuation4, vec4(0.25));\n            return attenuation;\n        }\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 3\n        #include \"ShadowSampleTent.glsl\"\n\n        float sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowmapSize) {\n            float attenuation;\n            float fetchesWeights[9];\n            vec2 fetchesUV[9];\n            sampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\n            attenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\n            attenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\n            attenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\n            attenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\n            attenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\n            attenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\n            attenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\n            attenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\n            attenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\n            return attenuation;\n        }\n    #endif\n\n\n    float getShadowFade(vec3 positionWS){\n        vec3 camToPixel = positionWS - camera_Position;\n        float distanceCamToPixel2 = dot(camToPixel, camToPixel);\n        return saturate( distanceCamToPixel2 * scene_ShadowInfo.z + scene_ShadowInfo.w );\n    }\n\n\n    float sampleShadowMap(vec3 positionWS, vec3 shadowCoord) {\n        float attenuation = 1.0;\n        if(shadowCoord.z > 0.0 && shadowCoord.z < 1.0) {\n        #if SCENE_SHADOW_TYPE == 1\n            attenuation = SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap, shadowCoord);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 2\n            attenuation = sampleShadowMapFiltered4(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 3\n            attenuation = sampleShadowMapFiltered9(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n            attenuation = mix(1.0, attenuation, scene_ShadowInfo.x);\n        }\n\n        float shadowFade = getShadowFade(positionWS);\n        attenuation = mix(1.0, mix(attenuation, 1.0, shadowFade), scene_ShadowInfo.x);\n\n        return attenuation;\n    }\n#endif\n\n\n#endif";

var ShadowSampleTent = "#ifndef SHADOW_SAMPLE_TENT_INCLUDED\n#define SHADOW_SAMPLE_TENT_INCLUDED\n\n// ------------------------------------------------------------------\n//  PCF Filtering Tent Functions\n// ------------------------------------------------------------------\n\n// Assuming a isoceles right angled triangle of height \"triangleHeight\" (as drawn below).\n// This function return the area of the triangle above the first texel(in Y the first texel).\n//\n// |\\      <-- 45 degree slop isosceles right angled triangle\n// | \\\n// ----    <-- length of this side is \"triangleHeight\"\n// _ _ _ _ <-- texels\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight) {\n    return triangleHeight - 0.5;\n}\n\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\n// This function return the area of the triangle above each of those texels.\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\n//  /   \\\n// _ _ _ _ <-- texels\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut) {\n    // Compute the exterior areas,a and h is same.\n    float a = offset + 0.5;\n    float offsetSquaredHalved = a * a * 0.5;\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\n\n    // Compute the middle areas\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\n    // intersect the axis between Y and Z (ie where offset = 0).\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\n    float clampedOffsetLeft = min(offset,0.0);\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\n\n    // We do the same for the Z but with the right part of the isoceles triangle\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\n    float clampedOffsetRight = max(offset,0.0);\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\n}\n\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\n// This function return the weight of each texels area relative to the full triangle area.\n//  /       \\\n// _ _ _ _ _ _ <-- texels\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB) {\n    vec4 areaFrom3texelTriangle;\n    vec4 areaUncutFrom3texelTriangle;\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\n\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\n    // 0.16 is 1/(the triangle area)\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\n}\n\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\n{\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    vec3 texelsWeightsUA, texelsWeightsUB;\n    vec3 texelsWeightsVA, texelsWeightsVB;\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\n\n    // move the PCF bilinear fetches to respect texels weights\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\n\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\n\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\n}\n\n\n#endif";

var Skin = "#ifndef SKIN_INCLUDED\n#define SKIN_INCLUDED\n\n\n#ifdef RENDERER_HAS_SKIN\n    #ifdef RENDERER_USE_JOINT_TEXTURE\n        sampler2D renderer_JointSampler;\n        float renderer_JointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index){\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n    #else\n        mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n    #endif\n\n    mat4 getSkinMatrix(Attributes attributes){\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.x ) +\n                attributes.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.y ) +\n                attributes.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.z ) +\n                attributes.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.w );\n        #else\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * renderer_JointMatrix[ int( attributes.JOINTS_0.x ) ] +\n                attributes.WEIGHTS_0.y * renderer_JointMatrix[ int( attributes.JOINTS_0.y ) ] +\n                attributes.WEIGHTS_0.z * renderer_JointMatrix[ int( attributes.JOINTS_0.z ) ] +\n                attributes.WEIGHTS_0.w * renderer_JointMatrix[ int( attributes.JOINTS_0.w ) ];\n        #endif\n\n        return skinMatrix;\n    }\n\n#endif\n\n\n#endif";

var Transform = "#ifndef TRANSFORM_INCLUDED\n#define TRANSFORM_INCLUDED\n\nmat4 renderer_LocalMat;\nmat4 renderer_ModelMat;\nmat4 camera_ViewMat;\nmat4 camera_ProjMat;\nmat4 renderer_MVMat;\nmat4 renderer_MVPMat;\nmat4 renderer_NormalMat;\n\nvec3 camera_Position;\nvec3 camera_Forward; \nvec4 camera_ProjectionParams;\n\n#endif";

var fragmentList = [].concat([
    {
        source: BlendShape,
        includeKey: "BlendShape.glsl"
    },
    {
        source: Common,
        includeKey: "Common.glsl"
    },
    {
        source: Fog,
        includeKey: "Fog.glsl"
    },
    {
        source: Light,
        includeKey: "Light.glsl"
    },
    {
        source: Normal,
        includeKey: "Normal.glsl"
    },
    {
        source: ShadowSampleTent,
        includeKey: "ShadowSampleTent.glsl"
    },
    {
        source: Shadow,
        includeKey: "Shadow.glsl"
    },
    {
        source: Transform,
        includeKey: "Transform.glsl"
    },
    {
        source: Skin,
        includeKey: "Skin.glsl"
    }
], shadingPBR);

export { PBRSource, fragmentList };
//# sourceMappingURL=index.js.map
