var AttributesPBR = "#ifndef ATTRIBUTES_PBR_INCLUDED\n#define ATTRIBUTES_PBR_INCLUDED\n\n\nstruct Attributes{\n  \tvec3 POSITION;\n\n\t#ifdef RENDERER_HAS_BLENDSHAPE\n    \t#ifndef RENDERER_BLENDSHAPE_USE_TEXTURE\n    \t\tvec3 POSITION_BS0;\n    \t  \tvec3 POSITION_BS1;\n    \t  \t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t    \tvec3 NORMAL_BS0;\n    \t    \tvec3 NORMAL_BS1;\n    \t    \tvec3 TANGENT_BS0;\n    \t    \tvec3 TANGENT_BS1;\n    \t  \t#else\n    \t    \t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t    \t  vec3 POSITION_BS2;\n    \t    \t  vec3 POSITION_BS3;\n\n    \t    \t  #ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\n    \t    \t    vec3 NORMAL_BS0;\n    \t    \t    vec3 NORMAL_BS1;\n    \t    \t    vec3 NORMAL_BS2;\n    \t    \t    vec3 NORMAL_BS3;\n    \t    \t  #endif\n\n    \t    \t  #ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\n    \t    \t    vec3 TANGENT_BS0;\n    \t    \t    vec3 TANGENT_BS1;\n    \t    \t    vec3 TANGENT_BS2;\n    \t    \t    vec3 TANGENT_BS3;\n    \t    \t  #endif\n\n    \t    \t#else\n    \t    \t  vec3 POSITION_BS2;\n    \t    \t  vec3 POSITION_BS3;\n    \t    \t  vec3 POSITION_BS4;\n    \t    \t  vec3 POSITION_BS5;\n    \t    \t  vec3 POSITION_BS6;\n    \t    \t  vec3 POSITION_BS7;\n    \t    #endif\n    \t#endif\n    #endif\n  #endif\n\n\n  \t#ifdef RENDERER_HAS_UV\n  \t    vec2 TEXCOORD_0;\n  \t#endif\n\n  \t#ifdef RENDERER_HAS_UV1\n  \t    vec2 TEXCOORD_1;\n  \t#endif\n\n  \t#ifdef RENDERER_HAS_SKIN\n  \t    vec4 JOINTS_0;\n  \t    vec4 WEIGHTS_0;\n  \t#endif\n\n  \t#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  \t    vec4 COLOR_0;\n  \t#endif\n\n\t#ifdef RENDERER_HAS_NORMAL\n\t    vec3 NORMAL;\n\t#endif\n\n    #ifdef RENDERER_HAS_TANGENT\n        vec4 TANGENT;\n    #endif\n};\n\n\n#endif";

var BRDF = "\n#ifndef BRDF_INCLUDED\n#define BRDF_INCLUDED\n\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS            0.002025\n\n#if defined(RENDERER_HAS_TANGENT) || defined(MATERIAL_ENABLE_ANISOTROPY) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_HAS_NORMALTEXTURE)\n    #define NEED_TANGENT\n#endif\n\n\nstruct SurfaceData{\n    // common\n\tvec3  albedoColor;\n    vec3  specularColor;\n\tvec3  emissiveColor;\n    float metallic;\n    float roughness;\n    float diffuseAO;\n    float specularAO;\n    float f0;\n    float opacity;\n\n    // geometry\n    vec3 position;\n    vec3 normal;\n\n    #ifdef NEED_TANGENT\n        vec3  tangent;\n        vec3  bitangent;\n    #endif\n\n    vec3  viewDir;\n    float dotNV;\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy;\n        vec3  anisotropicT;\n        vec3  anisotropicB;\n        vec3  anisotropicN;\n    #endif\n\n    // Clear coat\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoat;\n        float clearCoatRoughness;\n        vec3  clearCoatNormal;\n        float clearCoatDotNV;\n    #endif\n};\n\n\nstruct BRDFData{\n    vec3  diffuseColor;\n    vec3  specularColor;\n    float roughness;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3  clearCoatSpecularColor;\n        float clearCoatRoughness;\n    #endif\n};\n\n\nfloat getAARoughnessFactor(vec3 normal) {\n    // Kaplanyan 2016, \"Stable specular highlights\"\n    // Tokuyoshi 2017, \"Error Reduction and Simplification for Shading Anti-Aliasing\"\n    // Tokuyoshi and Kaplanyan 2019, \"Improved Geometric Specular Antialiasing\"\n    #ifdef HAS_DERIVATIVES\n        vec3 dxy = max( abs(dFdx(normal)), abs(dFdy(normal)) );\n        return max( max(dxy.x, dxy.y), dxy.z );\n    #else\n        return 0.0;\n    #endif\n}\n\n\nfloat F_Schlick(float f0, float dotLH) {\n\treturn f0 + 0.96 * (pow(1.0 - dotLH, 5.0));\n}\n\nvec3 F_Schlick(vec3 specularColor, float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(float alpha, float dotNL, float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n    float G_GGX_SmithCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL) {\n        float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n        float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n        return 0.5 / max(lambdaV + lambdaL, EPSILON);\n    }\n#endif\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX(float alpha, float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // GGX Distribution Anisotropic\n    // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\n    float D_GGX_Anisotropic(float at, float ab, float ToH, float BoH, float NoH) {\n        float a2 = at * ab;\n        highp vec3 d = vec3(ab * ToH, at * BoH, a2 * NoH);\n        highp float d2 = dot(d, d);\n        float b2 = a2 / d2;\n        return a2 * b2 * b2 * RECIPROCAL_PI;\n    }\n#endif\n\nvec3 isotropicLobe(vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat D = D_GGX( alpha, dotNH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\treturn F * ( G * D );\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 anisotropicLobe(vec3 h, vec3 l, SurfaceData surfaceData, vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n        vec3 t = surfaceData.anisotropicT;\n        vec3 b = surfaceData.anisotropicB;\n        vec3 v = surfaceData.viewDir;\n\n        float dotTV = dot(t, v);\n        float dotBV = dot(b, v);\n        float dotTL = dot(t, l);\n        float dotBL = dot(b, l);\n        float dotTH = dot(t, h);\n        float dotBH = dot(b, h);\n\n        // Aniso parameter remapping\n        // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf page 24\n        float at = max(alpha * (1.0 + surfaceData.anisotropy), MIN_ROUGHNESS);\n        float ab = max(alpha * (1.0 - surfaceData.anisotropy), MIN_ROUGHNESS);\n\n        // specular anisotropic BRDF\n    \tvec3 F = F_Schlick( specularColor, dotLH );\n        float D = D_GGX_Anisotropic(at, ab, dotTH, dotBH, dotNH);\n        float G = G_GGX_SmithCorrelated_Anisotropic(at, ab, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL);\n\n        return F * ( G * D );\n    }\n#endif\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX(vec3 incidentDirection, SurfaceData surfaceData, vec3 normal, vec3 specularColor, float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentDirection + surfaceData.viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentDirection ) );\n    float dotNV = saturate( dot( normal, surfaceData.viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentDirection, halfDir ) );\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        return anisotropicLobe(halfDir, incidentDirection, surfaceData, specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #else\n        return isotropicLobe(specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\n\n\nvoid initBRDFData(SurfaceData surfaceData, out BRDFData brdfData){\n    vec3 albedoColor = surfaceData.albedoColor;\n    vec3 specularColor = surfaceData.specularColor;\n    float metallic = surfaceData.metallic;\n    float roughness = surfaceData.roughness;\n    float f0 = surfaceData.f0;\n\n    #ifdef IS_METALLIC_WORKFLOW\n        brdfData.diffuseColor = albedoColor * ( 1.0 - metallic );\n        brdfData.specularColor = mix( vec3(f0), albedoColor, metallic );\n    #else\n        float specularStrength = max( max( specularColor.r, specularColor.g ), specularColor.b );\n        brdfData.diffuseColor = albedoColor * ( 1.0 - specularStrength );\n        brdfData.specularColor = specularColor;\n    #endif\n\n    brdfData.roughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(roughness + getAARoughnessFactor(surfaceData.normal), 1.0));\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        brdfData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n        brdfData.clearCoatSpecularColor = vec3(0.04);\n    #endif\n}\n\n#endif";

var LightProbe = "#ifndef LIGHT_PROBE\n#define LIGHT_PROBE\n\n// ------------------------Specular------------------------\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float dotNV ) {\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n}\n\n\nvec3 getReflectedVector(SurfaceData surfaceData, vec3 n) {\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        vec3 r = reflect(-surfaceData.viewDir, surfaceData.anisotropicN);\n    #else\n        vec3 r = reflect(-surfaceData.viewDir, n);\n    #endif\n\n    return r;\n}\n\nfloat getSpecularMIPLevel(float roughness, int maxMIPLevel ) {\n    return roughness * float(maxMIPLevel);\n}\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeRadiance(SurfaceData surfaceData, vec3 normal, float roughness) {\n\n    #ifndef SCENE_USE_SPECULAR_ENV\n        return vec3(0);\n    #else\n        vec3 reflectVec = getReflectedVector(surfaceData, normal);\n        reflectVec.x = -reflectVec.x; // TextureCube is left-hand,so x need inverse\n        \n        float specularMIPLevel = getSpecularMIPLevel(roughness, int(scene_EnvMapLight.mipMapLevel) );\n\n        #ifdef HAS_TEX_LOD\n            vec4 envMapColor = textureCubeLodEXT( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #else\n            vec4 envMapColor = textureCube( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #endif\n\n        #ifdef SCENE_IS_DECODE_ENV_RGBM\n            envMapColor.rgb = (RGBMToLinear(envMapColor, 5.0)).rgb;\n            #ifdef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = linearToGamma(envMapColor);\n            #endif\n        #else\n             #ifndef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = gammaToLinear(envMapColor);\n            #endif\n        #endif\n        \n        return envMapColor.rgb * scene_EnvMapLight.specularIntensity;\n\n    #endif\n}\n\n#endif";

var ForwardPassPBR = "#ifndef FORWARD_PASS_PBR_INCLUDED\n#define FORWARD_PASS_PBR_INCLUDED\n\n#include \"Common.glsl\"\n#include \"Fog.glsl\"\n\n#include \"AttributesPBR.glsl\"\n#include \"VaryingsPBR.glsl\"\n#include \"LightDirectPBR.glsl\"\n#include \"LightIndirectPBR.glsl\"\n\n#include \"VertexPBR.glsl\"\n#include \"FragmentPBR.glsl\"\n\n\nVaryings PBRVertex(Attributes attributes) {\n  Varyings varyings;\n\n  varyings.uv = getUV0(attributes);\n  #ifdef RENDERER_HAS_UV1\n      varyings.uv1 = attributes.TEXCOORD_1;\n  #endif\n\n  #ifdef RENDERER_ENABLE_VERTEXCOLOR\n    varyings.vertexColor = attributes.COLOR_0;\n  #endif\n\n\n  VertexInputs vertexInputs = getVertexInputs(attributes);\n\n  // positionWS\n  varyings.positionWS = vertexInputs.positionWS;\n\n  // positionVS\n  #if SCENE_FOG_MODE != 0\n\t  varyings.positionVS = vertexInputs.positionVS;\n\t#endif\n\n  // normalWS、tangentWS、bitangentWS\n  #ifdef RENDERER_HAS_NORMAL\n    varyings.normalWS = vertexInputs.normalWS;\n    #ifdef RENDERER_HAS_TANGENT\n      varyings.tangentWS = vertexInputs.tangentWS;\n      varyings.bitangentWS = vertexInputs.bitangentWS;\n    #endif\n  #endif\n\n  // ShadowCoord\n  #if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n      varyings.shadowCoord = getShadowCoord(vertexInputs.positionWS);\n  #endif\n\n  gl_Position = renderer_MVPMat * vertexInputs.positionOS;\n\n  return varyings;\n}\n\n\nvoid PBRFragment(Varyings varyings) {\n  BRDFData brdfData;\n\n  // Get aoUV\n  vec2 aoUV = varyings.uv;\n  #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(RENDERER_HAS_UV1)\n    if(material_OcclusionTextureCoord == 1.0){\n        aoUV = varyings.uv1;\n    }\n  #endif\n\n  SurfaceData surfaceData = getSurfaceData(varyings, aoUV, gl_FrontFacing);\n\n  // Can modify surfaceData here\n  initBRDFData(surfaceData, brdfData);\n\n  vec4 color = vec4(0, 0, 0, surfaceData.opacity);\n\n  // Get shadow attenuation\n  float shadowAttenuation = 1.0;\n  #if defined(SCENE_DIRECT_LIGHT_COUNT) && defined(NEED_CALCULATE_SHADOWS)\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n      vec3 shadowCoord = varyings.shadowCoord;\n    #else\n      vec3 shadowCoord = getShadowCoord(varyings.positionWS);\n    #endif\n    shadowAttenuation *= sampleShadowMap(varyings.positionWS, shadowCoord);\n  #endif\n\n  // Evaluate direct lighting\n  evaluateDirectRadiance(varyings, surfaceData, brdfData, shadowAttenuation, color.rgb);\n\n  // IBL\n  evaluateIBL(varyings, surfaceData, brdfData, color.rgb);\n\n  // Emissive\n  color.rgb += surfaceData.emissiveColor;\n\n\n  #if SCENE_FOG_MODE != 0\n      color = fog(color, varyings.positionVS);\n  #endif\n\n  #ifndef ENGINE_IS_COLORSPACE_GAMMA\n      color = linearToGamma(color);\n  #endif\n\n  gl_FragColor = color;\n}\n\n\n#endif";

var FragmentPBR = "#ifndef MATERIAL_INPUT_PBR_INCLUDED\n#define MATERIAL_INPUT_PBR_INCLUDED\n\n#include \"Normal.glsl\"\n\nfloat material_AlphaCutoff;\nvec4 material_BaseColor;\nfloat material_Metal;\nfloat material_Roughness;\nfloat material_IOR;\nvec3 material_PBRSpecularColor;\nfloat material_Glossiness;\nvec3 material_EmissiveColor;\nfloat material_NormalIntensity;\nfloat material_OcclusionIntensity;\nfloat material_OcclusionTextureCoord;\n\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n    float material_ClearCoat;\n    float material_ClearCoatRoughness;\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n        sampler2D material_ClearCoatTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n        sampler2D material_ClearCoatRoughnessTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n        sampler2D material_ClearCoatNormalTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 material_AnisotropyInfo;\n    #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n        sampler2D material_AnisotropyTexture;\n    #endif\n#endif\n\n// Texture\n#ifdef MATERIAL_HAS_BASETEXTURE\n    sampler2D material_BaseTexture;\n#endif\n\n#ifdef MATERIAL_HAS_NORMALTEXTURE\n    sampler2D material_NormalTexture;\n#endif\n\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n    sampler2D material_RoughnessMetallicTexture;\n#endif\n\n\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n    sampler2D material_SpecularGlossinessTexture;\n#endif\n\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n    sampler2D material_OcclusionTexture;\n#endif\n\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Aniso Bent Normals\n    // Mc Alley https://www.gdcvault.com/play/1022235/Rendering-the-World-of-Far \n    vec3 getAnisotropicBentNormal(SurfaceData surfaceData) {\n        vec3  anisotropyDirection = (surfaceData.anisotropy >= 0.0) ? surfaceData.anisotropicB : surfaceData.anisotropicT;\n        vec3  anisotropicTangent  = cross(anisotropyDirection, surfaceData.viewDir);\n        vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n        // reduce stretching for (roughness < 0.2), refer to https://advances.realtimerendering.com/s2018/Siggraph%202018%20HDRP%20talk_with%20notes.pdf 80\n        vec3  bentNormal          = normalize( mix(surfaceData.normal, anisotropicNormal, abs(surfaceData.anisotropy) * saturate( 5.0 * surfaceData.roughness)) );\n\n        return bentNormal;\n    }\n#endif\n\n\nSurfaceData getSurfaceData(Varyings v, vec2 aoUV, bool isFrontFacing){\n    SurfaceData surfaceData;\n\n    vec2 uv = v.uv;\n\n    // common\n    vec4 baseColor = material_BaseColor;\n    float metallic = material_Metal;\n    float roughness = material_Roughness;\n    vec3 specularColor = material_PBRSpecularColor;\n    float glossiness = material_Glossiness;\n    float f0 = pow2( (material_IOR - 1.0) / (material_IOR + 1.0) );\n    vec3 emissiveRadiance = material_EmissiveColor;\n\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        vec4 baseTextureColor = texture2D(material_BaseTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            baseTextureColor = gammaToLinear(baseTextureColor);\n        #endif\n        baseColor *= baseTextureColor;\n    #endif\n\n    #ifdef RENDERER_ENABLE_VERTEXCOLOR\n        baseColor *= v.vertexColor;\n    #endif\n\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    #ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n        vec4 metalRoughMapColor = texture2D( material_RoughnessMetallicTexture, uv );\n        roughness *= metalRoughMapColor.g;\n        metallic *= metalRoughMapColor.b;\n    #endif\n\n    #ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n        vec4 specularGlossinessColor = texture2D(material_SpecularGlossinessTexture, uv );\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            specularGlossinessColor = gammaToLinear(specularGlossinessColor);\n        #endif\n        specularColor *= specularGlossinessColor.rgb;\n        glossiness *= specularGlossinessColor.a;\n        roughness =  1.0 - glossiness;\n    #endif\n\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n\n    surfaceData.albedoColor = baseColor.rgb;\n    surfaceData.specularColor = specularColor;\n    surfaceData.emissiveColor = emissiveRadiance;\n    surfaceData.metallic = metallic;\n    surfaceData.roughness = roughness;\n    surfaceData.f0 = f0;\n\n    #ifdef MATERIAL_IS_TRANSPARENT\n        surfaceData.opacity = baseColor.a;\n    #else\n        surfaceData.opacity = 1.0;\n    #endif\n\n\n    // Geometry\n    surfaceData.position = v.positionWS;\n    \n    #ifdef CAMERA_ORTHOGRAPHIC\n        surfaceData.viewDir = -camera_Forward;\n    #else\n        surfaceData.viewDir = normalize(camera_Position - v.positionWS);\n    #endif\n\n    // Normal\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = normalize(v.normalWS);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v.positionWS);\n        vec3 pos_dy = dFdy(v.positionWS);\n        vec3 normal = normalize( cross(pos_dx, pos_dy) );\n        normal *= camera_ProjectionParams.x;\n    #else\n        vec3 normal = vec3(0, 0, 1);\n    #endif\n    \n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n    surfaceData.normal = normal;\n\n    // Tangent\n    #ifdef NEED_TANGENT\n        #if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT)\n            surfaceData.tangent = v.tangentWS;\n            surfaceData.bitangent = v.bitangentWS;\n            mat3 tbn = mat3(v.tangentWS, v.bitangentWS, v.normalWS);\n        #else\n            mat3 tbn = getTBNByDerivatives(uv, normal, v.positionWS, isFrontFacing);\n            surfaceData.tangent = tbn[0];\n            surfaceData.bitangent = tbn[1];\n        #endif\n\n        #ifdef MATERIAL_HAS_NORMALTEXTURE\n            surfaceData.normal = getNormalByNormalTexture(tbn, material_NormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #endif\n    #endif\n\n    surfaceData.dotNV = saturate( dot(surfaceData.normal, surfaceData.viewDir) );\n\n    // Clear Coat\n     #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n            surfaceData.clearCoatNormal = getNormalByNormalTexture(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal), material_ClearCoatNormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #else\n            surfaceData.clearCoatNormal = normal;\n        #endif\n        surfaceData.clearCoatDotNV = saturate( dot(surfaceData.clearCoatNormal, surfaceData.viewDir) );\n\n        surfaceData.clearCoat = material_ClearCoat;\n        surfaceData.clearCoatRoughness = material_ClearCoatRoughness;\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n            surfaceData.clearCoat *= (texture2D( material_ClearCoatTexture, uv )).r;\n        #endif\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n            surfaceData.clearCoatRoughness *= (texture2D( material_ClearCoatRoughnessTexture, uv )).g;\n        #endif\n\n        surfaceData.clearCoat = saturate( surfaceData.clearCoat );\n        surfaceData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n    #endif\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy = material_AnisotropyInfo.z;\n        vec3 anisotropicDirection = vec3(material_AnisotropyInfo.xy, 0.0);\n        #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n            vec3 anisotropyTextureInfo = (texture2D( material_AnisotropyTexture, uv )).rgb;\n            anisotropy *= anisotropyTextureInfo.b;\n            anisotropicDirection.xy *= anisotropyTextureInfo.rg * 2.0 - 1.0;\n        #endif\n\n        surfaceData.anisotropy = anisotropy;\n        surfaceData.anisotropicT = normalize(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal) * anisotropicDirection);\n        surfaceData.anisotropicB = normalize(cross(surfaceData.normal, surfaceData.anisotropicT));\n        surfaceData.anisotropicN = getAnisotropicBentNormal(surfaceData);\n    #endif\n\n    // AO\n    float diffuseAO = 1.0;\n    float specularAO = 1.0;\n\n    #ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n        diffuseAO = ((texture2D(material_OcclusionTexture, aoUV)).r - 1.0) * material_OcclusionIntensity + 1.0;\n    #endif\n\n    #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(SCENE_USE_SPECULAR_ENV) \n        specularAO = saturate( pow( surfaceData.dotNV + diffuseAO, exp2( - 16.0 * surfaceData.roughness - 1.0 ) ) - 1.0 + diffuseAO );\n    #endif\n\n    surfaceData.diffuseAO = diffuseAO;\n    surfaceData.specularAO = specularAO;\n\n    return surfaceData;\n}\n\n\n\n#endif";

var LightDirectPBR = "\n#ifndef LIGHT_DIRECT_PBR_INCLUDED\n#define LIGHT_DIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_SURFACE_SHADING\n    #define FUNCTION_SURFACE_SHADING surfaceShading\n#endif\n#ifndef FUNCTION_DIFFUSE_LOBE\n    #define FUNCTION_DIFFUSE_LOBE diffuseLobe\n#endif\n#ifndef FUNCTION_SPECULAR_LOBE\n    #define FUNCTION_SPECULAR_LOBE specularLobe\n#endif\n#ifndef FUNCTION_CLEAR_COAT_LOBE\n    #define FUNCTION_CLEAR_COAT_LOBE clearCoatLobe\n#endif\n\n#include \"BRDF.glsl\"\n#include \"Light.glsl\"\n#include \"ReflectionLobe.glsl\"\n\nvoid surfaceShading(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 lightColor, inout vec3 color) {\n\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n    float dotNL = saturate( dot( surfaceData.normal, incidentDirection ) );\n    vec3 irradiance = dotNL * lightColor * PI;\n\n    // ClearCoat Lobe\n    float attenuation = FUNCTION_CLEAR_COAT_LOBE(varyings, surfaceData, brdfData, incidentDirection, lightColor, specularColor);\n\n    vec3 attenuationIrradiance = attenuation * irradiance;\n    // Diffuse Lobe\n    FUNCTION_DIFFUSE_LOBE(varyings, surfaceData, brdfData, attenuationIrradiance, diffuseColor);\n    // Specular Lobe\n    FUNCTION_SPECULAR_LOBE(varyings, surfaceData, brdfData, incidentDirection, attenuationIrradiance, specularColor);\n\n    color += diffuseColor + specularColor;\n\n}\n\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    void addDirectionalDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, DirectLight directionalLight, inout vec3 color) {\n        vec3 lightColor = directionalLight.color;\n        vec3 direction = -directionalLight.direction;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n    }\n\n#endif\n\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n\tvoid addPointDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, PointLight pointLight, inout vec3 color) {\n\t\tvec3 lVector = pointLight.position - surfaceData.position;\n\t\tvec3 direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\n\t\tvec3 lightColor = pointLight.color;\n\t\tlightColor *= clamp(1.0 - pow(lightDistance/pointLight.distance, 4.0), 0.0, 1.0);\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\t}\n\n#endif\n\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n\tvoid addSpotDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, SpotLight spotLight, inout vec3 color) {\n\n\t\tvec3 lVector = spotLight.position - surfaceData.position;\n\t\tvec3 direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( direction, -spotLight.direction );\n\n\t\tfloat spotEffect = smoothstep( spotLight.penumbraCos, spotLight.angleCos, angleCos );\n\t\tfloat decayEffect = clamp(1.0 - pow(lightDistance/spotLight.distance, 4.0), 0.0, 1.0);\n\n\t\tvec3 lightColor = spotLight.color;\n\t\tlightColor *= spotEffect * decayEffect;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n\t}\n\n\n#endif\n\nvoid evaluateDirectRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float shadowAttenuation, inout vec3 color){\n    #ifdef SCENE_DIRECT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_DIRECT_LIGHT_COUNT; i ++ ) {\n            // warning: use `continue` syntax may trigger flickering bug in safri 16.1.\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_DirectLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    DirectLight directionalLight = getDirectLight(i);\n                #else\n                    DirectLight directionalLight;\n                    directionalLight.color = scene_DirectLightColor[i];\n                    directionalLight.direction = scene_DirectLightDirection[i];\n                #endif\n                \n                #ifdef NEED_CALCULATE_SHADOWS\n                    if (i == 0) { // Sun light index is always 0\n                        directionalLight.color *= shadowAttenuation;\n                    }\n                #endif\n                addDirectionalDirectLightRadiance(varyings, surfaceData, brdfData, directionalLight, color );\n            }\n        }\n\n    #endif\n\n    #ifdef SCENE_POINT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_POINT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_PointLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    PointLight pointLight = getPointLight(i);\n                #else\n                    PointLight pointLight;\n                    pointLight.color = scene_PointLightColor[i];\n                    pointLight.position = scene_PointLightPosition[i];\n                    pointLight.distance = scene_PointLightDistance[i];\n                #endif\n                addPointDirectLightRadiance(varyings, surfaceData, brdfData, pointLight, color );\n            } \n        }\n\n    #endif\n\n    #ifdef SCENE_SPOT_LIGHT_COUNT\n      \n        for ( int i = 0; i < SCENE_SPOT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_SpotLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    SpotLight spotLight = getSpotLight(i);\n                #else\n                    SpotLight spotLight;\n                    spotLight.color = scene_SpotLightColor[i];\n                    spotLight.position = scene_SpotLightPosition[i];\n                    spotLight.direction = scene_SpotLightDirection[i];\n                    spotLight.distance = scene_SpotLightDistance[i];\n                    spotLight.angleCos = scene_SpotLightAngleCos[i];\n                    spotLight.penumbraCos = scene_SpotLightPenumbraCos[i];\n                #endif\n                addSpotDirectLightRadiance( varyings, surfaceData, brdfData, spotLight, color );\n            } \n        }\n\n    #endif\n}\n\n\n#endif";

var LightIndirectPBR = "\n#ifndef LIGHT_INDIRECT_PBR_INCLUDED\n#define LIGHT_INDIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_DIFFUSE_IBL\n    #define FUNCTION_DIFFUSE_IBL evaluateDiffuseIBL\n#endif\n#ifndef FUNCTION_SPECULAR_IBL\n    #define FUNCTION_SPECULAR_IBL evaluateSpecularIBL\n#endif\n#ifndef FUNCTION_CLEAR_COAT_IBL\n    #define FUNCTION_CLEAR_COAT_IBL evaluateClearCoatIBL\n#endif\n\n\n#include \"BRDF.glsl\"\n#include \"Light.glsl\"\n#include \"LightProbe.glsl\"\n\n// ------------------------Diffuse------------------------\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeIrradiance(vec3 sh[9], vec3 normal){\n      normal.x = -normal.x;\n      vec3 result = sh[0] +\n\n            sh[1] * (normal.y) +\n            sh[2] * (normal.z) +\n            sh[3] * (normal.x) +\n\n            sh[4] * (normal.y * normal.x) +\n            sh[5] * (normal.y * normal.z) +\n            sh[6] * (3.0 * normal.z * normal.z - 1.0) +\n            sh[7] * (normal.z * normal.x) +\n            sh[8] * (normal.x * normal.x - normal.y * normal.y);\n    \n    return max(result, vec3(0.0));\n\n}\n\n\nvoid evaluateDiffuseIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 diffuseColor){\n    #ifdef SCENE_USE_SH\n        vec3 irradiance = getLightProbeIrradiance(scene_EnvSH, surfaceData.normal);\n        #ifdef ENGINE_IS_COLORSPACE_GAMMA\n            irradiance = (linearToGamma(vec4(irradiance, 1.0))).rgb;\n        #endif\n        irradiance *= scene_EnvMapLight.diffuseIntensity;\n    #else\n       vec3 irradiance = scene_EnvMapLight.diffuse * scene_EnvMapLight.diffuseIntensity;\n       irradiance *= PI;\n    #endif\n\n    diffuseColor += surfaceData.diffuseAO * irradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nfloat evaluateClearCoatIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 specularColor){\n    float radianceAttenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3 clearCoatRadiance = getLightProbeRadiance(surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatRoughness);\n        specularColor += surfaceData.specularAO * clearCoatRadiance * surfaceData.clearCoat * envBRDFApprox(brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness, surfaceData.clearCoatDotNV);\n        radianceAttenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return radianceAttenuation;\n}\n\nvoid evaluateSpecularIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float radianceAttenuation, inout vec3 specularColor){\n    vec3 radiance = getLightProbeRadiance(surfaceData, surfaceData.normal, brdfData.roughness);\n    specularColor += surfaceData.specularAO * radianceAttenuation * radiance * envBRDFApprox(brdfData.specularColor, brdfData.roughness, surfaceData.dotNV );\n}\n\n\nvoid evaluateIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 color){\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n\n    // IBL diffuse\n    FUNCTION_DIFFUSE_IBL(varyings, surfaceData, brdfData, diffuseColor);\n\n    // IBL ClearCoat\n    float radianceAttenuation = FUNCTION_CLEAR_COAT_IBL(varyings, surfaceData, brdfData, specularColor);\n\n    // IBL specular\n    FUNCTION_SPECULAR_IBL(varyings, surfaceData, brdfData, radianceAttenuation, specularColor);\n\n    color += diffuseColor + specularColor;\n}\n\n\n#endif";

var ReflectionLobe = "#ifndef REFLECTION_LOBE_INCLUDED\n#define REFLECTION_LOBE_INCLUDED\n\nvoid diffuseLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 attenuationIrradiance, inout vec3 diffuseColor){\n    diffuseColor += attenuationIrradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nvoid specularLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 attenuationIrradiance, inout vec3 specularColor){\n    specularColor += attenuationIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.normal, brdfData.specularColor, brdfData.roughness);\n}\n\nfloat clearCoatLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 color, inout vec3 specularColor){\n    float attenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoatDotNL = saturate( dot( surfaceData.clearCoatNormal, incidentDirection ) );\n        vec3 clearCoatIrradiance = clearCoatDotNL * color;\n\n        specularColor += surfaceData.clearCoat * clearCoatIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness );\n        attenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return attenuation;\n}\n\n\n\n#endif";

var VaryingsPBR = "#ifndef VARYINGS_PBR_INCLUDED\n#define VARYINGS_PBR_INCLUDED\n\n#include \"Shadow.glsl\"\n\nstruct Varyings{\n\tvec2 uv;\n\t#ifdef RENDERER_HAS_UV1\n\t    vec2 uv1;\n\t#endif\n\n\t#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  \t\tvec4 vertexColor;\n\t#endif\n\n\tvec3 positionWS;\n\n\t#if SCENE_FOG_MODE != 0\n\t    vec3 positionVS;\n\t#endif\n\n\t#ifdef RENDERER_HAS_NORMAL\n\t    vec3 normalWS;\n\t    #ifdef RENDERER_HAS_TANGENT\n\t\t\tvec3 tangentWS;\n\t\t\tvec3 bitangentWS;\n\t    #endif\n\t#endif\n\n\n\t#if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n\t    vec3 shadowCoord;\n\t#endif\n};\n\n\n#endif";

var VertexPBR = "#ifndef VERTEX_INCLUDE\n#define VERTEX_INCLUDE\n\n#include \"Transform.glsl\"\n#include \"Skin.glsl\"\n#include \"BlendShape.glsl\"\n#include \"Shadow.glsl\"\n\n\nstruct VertexInputs{\n    vec4 positionOS;\n    vec3 positionWS;\n\n    #if SCENE_FOG_MODE != 0\n        vec3 positionVS;\n    #endif\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normalWS;\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS;\n            vec3 bitangentWS;\n        #endif\n    #endif\n};\n\nvec4 material_TilingOffset;\nvec2 getUV0(Attributes attributes){\n    vec2 uv0 = vec2(0);\n\n    #ifdef RENDERER_HAS_UV\n        uv0 = attributes.TEXCOORD_0;\n    #endif\n\n    return uv0 * material_TilingOffset.xy + material_TilingOffset.zw;\n}\n\nVertexInputs getVertexInputs(Attributes attributes){\n    VertexInputs inputs;\n    vec4 position = vec4(attributes.POSITION, 1.0);\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = vec3( attributes.NORMAL );\n        #ifdef RENDERER_HAS_TANGENT\n            vec4 tangent = vec4( attributes.TANGENT );\n        #endif\n    #endif\n\n   \n    // BlendShape\n    #ifdef RENDERER_HAS_BLENDSHAPE\n        calculateBlendShape(attributes, position\n        #ifdef RENDERER_HAS_NORMAL\n            ,normal\n             #ifdef RENDERER_HAS_TANGENT\n                ,tangent\n            #endif\n        #endif\n        );\n    #endif\n\n    // Skin\n    #ifdef RENDERER_HAS_SKIN\n        mat4 skinMatrix = getSkinMatrix(attributes);\n        position = skinMatrix * position;\n\n        #if defined(RENDERER_HAS_NORMAL)\n            mat3 skinNormalMatrix = INVERSE_MAT(mat3(skinMatrix));\n            normal = normal * skinNormalMatrix;\n            #ifdef RENDERER_HAS_TANGENT\n                tangent.xyz = tangent.xyz * skinNormalMatrix;\n            #endif\n        #endif\n    #endif\n\n    // TBN world space\n    #ifdef RENDERER_HAS_NORMAL\n        inputs.normalWS = normalize( mat3(renderer_NormalMat) * normal );\n\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS = normalize( mat3(renderer_NormalMat) * tangent.xyz );\n            vec3 bitangentWS = cross( inputs.normalWS, tangentWS ) * tangent.w;\n\n            inputs.tangentWS = tangentWS;\n            inputs.bitangentWS = bitangentWS;\n        #endif\n    #endif\n\n\n    inputs.positionOS = position;\n    vec4 positionWS = renderer_ModelMat * position;\n    inputs.positionWS = positionWS.xyz / positionWS.w;\n\n     #if SCENE_FOG_MODE != 0\n        vec4 positionVS = renderer_MVMat * position;\n        inputs.positionVS = positionVS.xyz / positionVS.w;\n    #endif\n\n    return inputs;\n}\n\n#endif";

var shadingPBR = [
    {
        source: ForwardPassPBR,
        includeKey: "ForwardPassPBR.glsl"
    },
    {
        source: AttributesPBR,
        includeKey: "AttributesPBR.glsl"
    },
    {
        source: VaryingsPBR,
        includeKey: "VaryingsPBR.glsl"
    },
    {
        source: FragmentPBR,
        includeKey: "FragmentPBR.glsl"
    },
    {
        source: LightDirectPBR,
        includeKey: "LightDirectPBR.glsl"
    },
    {
        source: LightIndirectPBR,
        includeKey: "LightIndirectPBR.glsl"
    },
    {
        source: VertexPBR,
        includeKey: "VertexPBR.glsl"
    },
    {
        source: BRDF,
        includeKey: "BRDF.glsl"
    },
    {
        source: LightProbe,
        includeKey: "LightProbe.glsl"
    },
    {
        source: ReflectionLobe,
        includeKey: "ReflectionLobe.glsl"
    }
];

export { shadingPBR as default };
//# sourceMappingURL=index.js.map
