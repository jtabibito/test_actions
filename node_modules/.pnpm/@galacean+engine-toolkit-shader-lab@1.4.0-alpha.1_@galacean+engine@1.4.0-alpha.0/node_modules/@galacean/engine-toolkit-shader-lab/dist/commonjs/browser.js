'use strict';

var engine = require('@galacean/engine');

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var BlendShape = "#ifndef BLENDSHAPE_INCLUDED\n#define BLENDSHAPE_INCLUDED\n\n#ifdef RENDERER_HAS_BLENDSHAPE\n\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\n\t\tmediump sampler2DArray renderer_BlendShapeTexture;\n\t\tivec3 renderer_BlendShapeTextureInfo;\n\t\tfloat renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n\n\t\tvec3 getBlendShapeVertexElement(int blendShapeIndex, int vertexElementIndex){\t\t\t\n\t\t\tint y = vertexElementIndex / renderer_BlendShapeTextureInfo.y;\n\t\t\tint x = vertexElementIndex - y * renderer_BlendShapeTextureInfo.y;\n\t\t\tivec3 uv = ivec3(x, y , blendShapeIndex);\n\t\t\treturn (texelFetch(renderer_BlendShapeTexture, uv, 0)).xyz;\n\t\t}\n\t#else\n\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\tfloat renderer_BlendShapeWeights[2];\n\t\t#else\n\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n\t\t\t\tfloat renderer_BlendShapeWeights[4];\n\t\t\t#else\n\t\t\t\tfloat renderer_BlendShapeWeights[8];\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\n\tvoid calculateBlendShape(Attributes attributes, inout vec4 position\n        #ifdef RENDERER_HAS_NORMAL\n            ,inout vec3 normal\n\t\t\t #ifdef RENDERER_HAS_TANGENT\n            \t,inout vec4 tangent\n        \t#endif\n        #endif\n       \n\t){\n\t\t#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\t\n    \t\tint vertexOffset = gl_VertexID * renderer_BlendShapeTextureInfo.x;\n    \t\tfor(int i = 0; i < RENDERER_BLENDSHAPE_COUNT; i++){\n    \t\t\tint vertexElementOffset = vertexOffset;\n    \t\t\tfloat weight = renderer_BlendShapeWeights[i];\n    \t\t\t// Warnning: Multiplying by 0 creates weird precision issues, causing rendering anomalies in Ace2 Android13\n    \t\t\tif(weight != 0.0){\n    \t\t\t\tposition.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \n    \t\t\t\t#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\n    \t\t\t\t\tvertexElementOffset += 1;\n    \t\t\t\t\tnormal += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \t\t\t\t#endif\n    \n    \t\t\t\t#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT)\n    \t\t\t\t\tvertexElementOffset += 1;\n    \t\t\t\t\ttangent.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \t\t\t\t#endif\n    \t\t\t}\n    \n    \t\t}\n    \t#else\n    \t\tposition.xyz += attributes.POSITION_BS0 * renderer_BlendShapeWeights[0];\n    \t\tposition.xyz += attributes.POSITION_BS1 * renderer_BlendShapeWeights[1];\n\n    \t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t\t\t#ifdef RENDERER_HAS_NORMAL\n    \t\t\t\tnormal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\tnormal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t#endif\n                    \n    \t\t\t#ifdef RENDERER_HAS_TANGENT\n    \t\t\t\ttangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\ttangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t#endif\t\t\t\t\n    \t\t#else\n    \t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t\t\t\tposition.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n\n    \t\t\t\t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\n    \t\t\t\t\tnormal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\t\tnormal += attributes.NORMAL_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\t#endif\n\n    \t\t\t\t#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT )\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\t\ttangent.xyz += attributes.TANGENT_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\t#endif\n    \t\t\t#else\n    \t\t\t\tposition.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS4 * renderer_BlendShapeWeights[4];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS5 * renderer_BlendShapeWeights[5];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS6 * renderer_BlendShapeWeights[6];\n    \t\t\t\tposition.xyz += attributes.POSITION_BS7 * renderer_BlendShapeWeights[7];\n    \t\t\t#endif\n    \t\t#endif\n    \t#endif\n\t}\n\n#endif\n\n\n#endif";

var Common = "#ifndef COMMON_INCLUDED\n#define COMMON_INCLUDED\n\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n\nfloat pow2(float x ) {\n    return x * x;\n}\n\nvec4 RGBMToLinear(vec4 value, float maxRange ) {\n    return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 gammaToLinear(vec4 srgbIn){\n    return vec4( pow(srgbIn.rgb, vec3(2.2)), srgbIn.a);\n}\n\nvec4 linearToGamma(vec4 linearIn){\n\tlinearIn = max(linearIn, 0.0);\n    return vec4( pow(linearIn.rgb, vec3(1.0 / 2.2)), linearIn.a);\n}\n\nvec4 camera_DepthBufferParams;\n\nfloat remapDepthBufferLinear01(float z){\n\treturn 1.0/ (camera_DepthBufferParams.x * z + camera_DepthBufferParams.y);\n}\n\n\n#ifdef GRAPHICS_API_WEBGL2\n\t#define INVERSE_MAT(mat) inverse(mat)\n#else\n\tmat2 inverseMat(mat2 m) {\n\t\treturn mat2(m[1][1],-m[0][1],\n\t\t\t\t-m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n\t}\n\tmat3 inverseMat(mat3 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n\t\tfloat b01 = a22 * a11 - a12 * a21;\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\n\t\tfloat b21 = a21 * a10 - a11 * a20;\n\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\n\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n\t}\n\tmat4 inverseMat(mat4 m) {\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n\t\t\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n\t\t\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n\t\t\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n\t\t\tb00 = a00 * a11 - a01 * a10,\n\t\t\tb01 = a00 * a12 - a02 * a10,\n\t\t\tb02 = a00 * a13 - a03 * a10,\n\t\t\tb03 = a01 * a12 - a02 * a11,\n\t\t\tb04 = a01 * a13 - a03 * a11,\n\t\t\tb05 = a02 * a13 - a03 * a12,\n\t\t\tb06 = a20 * a31 - a21 * a30,\n\t\t\tb07 = a20 * a32 - a22 * a30,\n\t\t\tb08 = a20 * a33 - a23 * a30,\n\t\t\tb09 = a21 * a32 - a22 * a31,\n\t\t\tb10 = a21 * a33 - a23 * a31,\n\t\t\tb11 = a22 * a33 - a23 * a32,\n\n\t\t\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n\t\treturn mat4(\n\t\t\ta11 * b11 - a12 * b10 + a13 * b09,\n\t\t\ta02 * b10 - a01 * b11 - a03 * b09,\n\t\t\ta31 * b05 - a32 * b04 + a33 * b03,\n\t\t\ta22 * b04 - a21 * b05 - a23 * b03,\n\t\t\ta12 * b08 - a10 * b11 - a13 * b07,\n\t\t\ta00 * b11 - a02 * b08 + a03 * b07,\n\t\t\ta32 * b02 - a30 * b05 - a33 * b01,\n\t\t\ta20 * b05 - a22 * b02 + a23 * b01,\n\t\t\ta10 * b10 - a11 * b08 + a13 * b06,\n\t\t\ta01 * b08 - a00 * b10 - a03 * b06,\n\t\t\ta30 * b04 - a31 * b02 + a33 * b00,\n\t\t\ta21 * b02 - a20 * b04 - a23 * b00,\n\t\t\ta11 * b07 - a10 * b09 - a12 * b06,\n\t\t\ta00 * b09 - a01 * b07 + a02 * b06,\n\t\t\ta31 * b01 - a30 * b03 - a32 * b00,\n\t\t\ta20 * b03 - a21 * b01 + a22 * b00) / det;\n\t}\n\n\t#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n\n\n#endif";

var Fog = "#ifndef FOG_INCLUDED\n#define FOG_INCLUDED\n\n#if SCENE_FOG_MODE != 0\n    vec4 scene_FogColor;\n    vec4 scene_FogParams; // (-1/(end-start), end/(end-start), density/ln(2),density/sprt(ln(2)));\n\n    vec4 fog(vec4 color, vec3 positionVS){\n        float fogDepth = length(positionVS);\n\n        #if SCENE_FOG_MODE == 1\n            // (end-z) / (end-start) = z * (-1/(end-start)) + (end/(end-start))\n            float fogIntensity = clamp(fogDepth * scene_FogParams.x + scene_FogParams.y, 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 2\n            // exp(-z * density) = exp2((-z * density)/ln(2)) = exp2(-z * density/ln(2))\n            float fogIntensity = clamp(exp2(-fogDepth * scene_FogParams.z), 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 3\n            // exp(-(z * density)^2) = exp2(-(z * density)^2/ln(2)) = exp2(-(z * density/sprt(ln(2)))^2)\n            float factor = fogDepth * scene_FogParams.w;\n            float fogIntensity = clamp(exp2(-factor * factor), 0.0, 1.0);\n        #endif\n\n        color.rgb = mix(scene_FogColor.rgb, color.rgb, fogIntensity);\n\n        return color;\n    }\n#endif\n\n\n#endif";

var Light = "#ifndef LIGHT_INCLUDED\n#define LIGHT_INCLUDED\n\n\nivec4 renderer_Layer;\n#ifndef GRAPHICS_API_WEBGL2\n    bool isBitSet(float value, float mask, float bitIndex){\n        return mod(floor(value / pow(2.0, bitIndex)), 2.0) == 1.0 && mod(floor(mask / pow(2.0, bitIndex)), 2.0) == 1.0;\n    }\n#endif\n\nbool isRendererCulledByLight(ivec2 rendererLayer, ivec2 lightCullingMask){\n    #ifdef GRAPHICS_API_WEBGL2\n    return !((rendererLayer.x & lightCullingMask.x) != 0 || (rendererLayer.y & lightCullingMask.y) != 0);\n    #else\n    for (int i = 0; i < 16; i++) {\n        if (isBitSet( float(rendererLayer.x), float(lightCullingMask.x), float(i)) || isBitSet( float(rendererLayer.y), float(lightCullingMask.y), float(i))) {\n            return false;\n        }\n    }\n    return true;\n    #endif\n}\n\n// Directional light\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    struct DirectLight {\n        vec3 color;\n        vec3 direction;\n    };\n\n    ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        DirectLight getDirectLight(int index){\n            DirectLight light;\n            light.color = scene_DirectLightColor[index];\n            light.direction = scene_DirectLightDirection[index];\n    \n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Point light\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n    struct PointLight {\n        vec3 color;\n        vec3 position;\n        float distance;\n    };\n\n    ivec2 scene_PointLightCullingMask[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightColor[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightPosition[ SCENE_POINT_LIGHT_COUNT ];\n    float scene_PointLightDistance[ SCENE_POINT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        PointLight getPointLight(int index){\n            PointLight light;\n            light.color = scene_PointLightColor[index];\n            light.position = scene_PointLightPosition[index];\n            light.distance = scene_PointLightDistance[index];\n\n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Spot light\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n        vec3 color;\n        vec3 position;\n        vec3 direction;\n        float distance;\n        float angleCos;\n        float penumbraCos;\n    };\n\n    ivec2 scene_SpotLightCullingMask[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightColor[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightPosition[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightDirection[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightDistance[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightAngleCos[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightPenumbraCos[ SCENE_SPOT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        SpotLight getSpotLight(int index){\n            SpotLight light;\n            light.color = scene_SpotLightColor[index];\n            light.position = scene_SpotLightPosition[index];\n            light.direction = scene_SpotLightDirection[index];\n            light.distance = scene_SpotLightDistance[index];\n            light.angleCos = scene_SpotLightAngleCos[index];\n            light.penumbraCos = scene_SpotLightPenumbraCos[index];\n\n            return light;\n        }\n    #endif\n\n\n#endif\n\n// Ambient light\nstruct EnvMapLight {\n    vec3 diffuse;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n};\n\n\nEnvMapLight scene_EnvMapLight;\n\n#ifdef SCENE_USE_SH\n    vec3 scene_EnvSH[9];\n#endif\n\n#ifdef SCENE_USE_SPECULAR_ENV\n    samplerCube scene_EnvSpecularSampler;\n#endif\n\n\n\n\n#endif\n";

var Normal = "#ifndef NORMAL_INCLUDED\n#define NORMAL_INCLUDED\n\n\nvec3 getNormalByNormalTexture(mat3 tbn, sampler2D normalTexture, float normalIntensity, vec2 uv, bool isFrontFacing){\n    vec3 normal = (texture2D(normalTexture, uv)).rgb;\n    normal = normalize(tbn * ((2.0 * normal - 1.0) * vec3(normalIntensity, normalIntensity, 1.0)));\n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n\n    return normal;\n}\n\nmat3 getTBNByDerivatives(vec2 uv, vec3 normal, vec3 position, bool isFrontFacing){\n    #ifdef HAS_DERIVATIVES\n        uv = isFrontFacing? uv: -uv;\n        // ref: http://www.thetenthplanet.de/archives/1180\n        // get edge vectors of the pixel triangle\n\t    vec3 dp1 = dFdx(position);\n\t    vec3 dp2 = dFdy(position);\n\t    vec2 duv1 = dFdx(uv);\n\t    vec2 duv2 = dFdy(uv);\n\t    // solve the linear system\n\t    vec3 dp2perp = cross(dp2, normal);\n\t    vec3 dp1perp = cross(normal, dp1);\n\t    vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n\t    vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n\t    // construct a scale-invariant frame \n        float denom = max( dot(tangent, tangent), dot(bitangent, bitangent) );\n        float invmax = (denom == 0.0) ? 0.0 : camera_ProjectionParams.x / sqrt( denom );\n\t    return mat3(tangent * invmax, bitangent * invmax, normal);\n    #else\n        return mat3(vec3(0.0), vec3(0.0), normal);\n    #endif\n}\n\n\n#endif";

var PBRSource = "Shader \"PBR.gs\" {\n    EditorProperties {\n      Header(\"Base\"){\n        material_IOR(\"IOR\", Range(0, 5, 0.01)) = 1.5;\n        material_BaseColor(\"BaseColor\", Color) = (1, 1, 1, 1);\n        material_BaseTexture(\"BaseTexture\", Texture2D);\n      }\n\n      Header(\"Metal Roughness\") {\n        material_Metal( \"Metal\", Range(0,1,0.01) ) = 1;\n        material_Roughness( \"Roughness\", Range( 0, 1, 0.01 ) ) = 1;\n        material_RoughnessMetallicTexture(\"RoughnessMetallicTexture\", Texture2D);\n      }\n\n      Header(\"Anisotropy\") {\n        material_AnisotropyInfo(\"AnisotropyInfo\", Vector3) = (1, 0, 0);\n        material_AnisotropyTexture(\"AnisotropyTexture\", Texture2D);\n      }\n\n      Header(\"Normal\") {\n        material_NormalTexture(\"NormalTexture\", Texture2D);\n        material_NormalIntensity(\"NormalIntensity\", Range(0, 5, 0.01)) = 1;\n      }\n\n      Header(\"Emissive\") {\n        material_EmissiveColor(\"EmissiveColor\", Color ) = (0, 0, 0, 1);\n        material_EmissiveTexture(\"EmissiveTexture\", Texture2D);\n      }\n\n      Header(\"Occlusion\") {\n        material_OcclusionTexture(\"OcclusionTexture\", Texture2D);\n        material_OcclusionIntensity(\"OcclusionIntensity\", Range(0, 5, 0.01)) = 1;\n        material_OcclusionTextureCoord(\"OcclusionTextureCoord\", Float) = 0;\n      }\n      \n      Header(\"Clear Coat\") {\n        material_ClearCoat(\"ClearCoat\", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatTexture(\"ClearCoatTexture\", Texture2D);\n        material_ClearCoatRoughness(\"ClearCoatRoughness\", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatRoughnessTexture(\"ClearCoatRoughnessTexture\", Texture2D);\n        material_ClearCoatNormalTexture(\"ClearCoatNormalTexture\", Texture2D);\n      }\n\n      Header(\"Common\") {\n        material_AlphaCutoff( \"AlphaCutoff\", Range(0, 1, 0.01) ) = 0;\n        material_TilingOffset(\"TilingOffset\", Vector4) = (1, 1, 0, 0);\n      }\n    }\n\n    EditorMacros {\n      Header(\"Conditional Macors\") {\n        MATERIAL_HAS_BASETEXTURE(\"HAS_BASETEXTURE\");\n        MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE(\"HAS_ROUGHNESS_METALLIC_TEXTURE\");\n        MATERIAL_ENABLE_ANISOTROPY(\"ENABLE_ANISOTROPY\");\n        MATERIAL_HAS_ANISOTROPY_TEXTURE(\"HAS_ANISOTROPY_TEXTURE\")\n        MATERIAL_HAS_NORMALTEXTURE(\"HAS_NORMALTEXTURE\");\n        MATERIAL_HAS_EMISSIVETEXTURE(\"HAS_EMISSIVETEXTURE\");\n        MATERIAL_HAS_OCCLUSION_TEXTURE(\"HAS_OCCLUSION_TEXTURE\");\n        MATERIAL_ENABLE_CLEAR_COAT(\"ENABLE_CLEAR_COAT\");\n        MATERIAL_HAS_CLEAR_COAT_TEXTURE(\"HAS_CLEAR_COAT_TEXTURE\");\n        MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE(\"HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\");\n        MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE(\"HAS_CLEAR_COAT_NORMAL_TEXTURE\");\n        MATERIAL_IS_TRANSPARENT(\"IS_TRANSPARENT\");\n        MATERIAL_IS_ALPHA_CUTOFF(\"IS_ALPHA_CUTOFF\");\n      }\n    }\n    \n    SubShader \"Default\" {\n      UsePass \"pbr/Default/ShadowCaster\"\n\n      Pass \"Forward Pass\" {\n        Tags { pipelineStage = \"Forward\"} \n\n        #define IS_METALLIC_WORKFLOW\n        \n        VertexShader = PBRVertex;\n        FragmentShader = PBRFragment;\n\n        #include \"ForwardPassPBR.glsl\"\n      }\n    }\n  }";

var Shadow = "#ifndef SHADOW_INCLUDED\n#define SHADOW_INCLUDED\n\n#include \"Transform.glsl\"\n#include \"Common.glsl\"\n\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n    #define NEED_CALCULATE_SHADOWS\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n\n        mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT + 1];\n        vec4 scene_ShadowSplitSpheres[4];\n\n        mediump int computeCascadeIndex(vec3 positionWS) {\n            vec3 fromCenter0 = positionWS - scene_ShadowSplitSpheres[0].xyz;\n            vec3 fromCenter1 = positionWS - scene_ShadowSplitSpheres[1].xyz;\n            vec3 fromCenter2 = positionWS - scene_ShadowSplitSpheres[2].xyz;\n            vec3 fromCenter3 = positionWS - scene_ShadowSplitSpheres[3].xyz;\n\n            mediump vec4 comparison = vec4(\n                (dot(fromCenter0, fromCenter0) < scene_ShadowSplitSpheres[0].w),\n                (dot(fromCenter1, fromCenter1) < scene_ShadowSplitSpheres[1].w),\n                (dot(fromCenter2, fromCenter2) < scene_ShadowSplitSpheres[2].w),\n                (dot(fromCenter3, fromCenter3) < scene_ShadowSplitSpheres[3].w));\n            comparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\n            mediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\n            mediump int index = 4 - int(dot(comparison, indexCoefficient));\n            return index;\n        }\n\n        vec3 getShadowCoord(vec3 positionWS) {\n            #if SCENE_SHADOW_CASCADED_COUNT == 1\n                mediump int cascadeIndex = 0;\n            #else\n                mediump int cascadeIndex = computeCascadeIndex(positionWS);\n            #endif\n        \n            #ifdef GRAPHICS_API_WEBGL2\n                mat4 shadowMatrix = scene_ShadowMatrices[cascadeIndex];\n            #else\n                mat4 shadowMatrix;\n                #if SCENE_SHADOW_CASCADED_COUNT == 4\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else if (cascadeIndex == 2) {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } else if (cascadeIndex == 3) {\n                        shadowMatrix = scene_ShadowMatrices[3];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[4];\n                    }\n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 2\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } \n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 1\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else  {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } \n                #endif\n            #endif\n        \n            vec4 shadowCoord = shadowMatrix * vec4(positionWS, 1.0);\n            return shadowCoord.xyz;\n        }\n\n    #endif\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    // intensity, null, fadeScale, fadeBias\n    vec4 scene_ShadowInfo;\n    vec4 scene_ShadowMapSize;\n\n    #ifdef GRAPHICS_API_WEBGL2\n        mediump sampler2DShadow scene_ShadowMap;\n        #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n    #else\n        sampler2D scene_ShadowMap;\n        #ifdef ENGINE_NO_DEPTH_TEXTURE\n            const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n            /**\n            * Unpack depth value.\n            */\n            float unpack(in vec4 rgbaDepth) {\n                return dot(rgbaDepth, bitShift);\n            }\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n        #else\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) ((texture2D(textureName, coord3.xy)).r < coord3.z ? 0.0 : 1.0)\n        #endif\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 2\n        float sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowMapSize) {\n            float attenuation;\n            vec4 attenuation4;\n            vec2 offset=shadowMapSize.xy/2.0;\n            vec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\n            vec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\n            vec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\n            vec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\n            attenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\n            attenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\n            attenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\n            attenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\n            attenuation = dot(attenuation4, vec4(0.25));\n            return attenuation;\n        }\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 3\n        #include \"ShadowSampleTent.glsl\"\n\n        float sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowmapSize) {\n            float attenuation;\n            float fetchesWeights[9];\n            vec2 fetchesUV[9];\n            sampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\n            attenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\n            attenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\n            attenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\n            attenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\n            attenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\n            attenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\n            attenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\n            attenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\n            attenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\n            return attenuation;\n        }\n    #endif\n\n\n    float getShadowFade(vec3 positionWS){\n        vec3 camToPixel = positionWS - camera_Position;\n        float distanceCamToPixel2 = dot(camToPixel, camToPixel);\n        return saturate( distanceCamToPixel2 * scene_ShadowInfo.z + scene_ShadowInfo.w );\n    }\n\n\n    float sampleShadowMap(vec3 positionWS, vec3 shadowCoord) {\n        float attenuation = 1.0;\n        if(shadowCoord.z > 0.0 && shadowCoord.z < 1.0) {\n        #if SCENE_SHADOW_TYPE == 1\n            attenuation = SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap, shadowCoord);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 2\n            attenuation = sampleShadowMapFiltered4(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 3\n            attenuation = sampleShadowMapFiltered9(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n            attenuation = mix(1.0, attenuation, scene_ShadowInfo.x);\n        }\n\n        float shadowFade = getShadowFade(positionWS);\n        attenuation = mix(1.0, mix(attenuation, 1.0, shadowFade), scene_ShadowInfo.x);\n\n        return attenuation;\n    }\n#endif\n\n\n#endif";

var ShadowSampleTent = "#ifndef SHADOW_SAMPLE_TENT_INCLUDED\n#define SHADOW_SAMPLE_TENT_INCLUDED\n\n// ------------------------------------------------------------------\n//  PCF Filtering Tent Functions\n// ------------------------------------------------------------------\n\n// Assuming a isoceles right angled triangle of height \"triangleHeight\" (as drawn below).\n// This function return the area of the triangle above the first texel(in Y the first texel).\n//\n// |\\      <-- 45 degree slop isosceles right angled triangle\n// | \\\n// ----    <-- length of this side is \"triangleHeight\"\n// _ _ _ _ <-- texels\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight) {\n    return triangleHeight - 0.5;\n}\n\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\n// This function return the area of the triangle above each of those texels.\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\n//  /   \\\n// _ _ _ _ <-- texels\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut) {\n    // Compute the exterior areas,a and h is same.\n    float a = offset + 0.5;\n    float offsetSquaredHalved = a * a * 0.5;\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\n\n    // Compute the middle areas\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\n    // intersect the axis between Y and Z (ie where offset = 0).\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\n    float clampedOffsetLeft = min(offset,0.0);\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\n\n    // We do the same for the Z but with the right part of the isoceles triangle\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\n    float clampedOffsetRight = max(offset,0.0);\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\n}\n\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\n// This function return the weight of each texels area relative to the full triangle area.\n//  /       \\\n// _ _ _ _ _ _ <-- texels\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB) {\n    vec4 areaFrom3texelTriangle;\n    vec4 areaUncutFrom3texelTriangle;\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\n\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\n    // 0.16 is 1/(the triangle area)\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\n}\n\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\n{\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    vec3 texelsWeightsUA, texelsWeightsUB;\n    vec3 texelsWeightsVA, texelsWeightsVB;\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\n\n    // move the PCF bilinear fetches to respect texels weights\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\n\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\n\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\n}\n\n\n#endif";

var Skin = "#ifndef SKIN_INCLUDED\n#define SKIN_INCLUDED\n\n\n#ifdef RENDERER_HAS_SKIN\n    #ifdef RENDERER_USE_JOINT_TEXTURE\n        sampler2D renderer_JointSampler;\n        float renderer_JointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index){\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n    #else\n        mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n    #endif\n\n    mat4 getSkinMatrix(Attributes attributes){\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.x ) +\n                attributes.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.y ) +\n                attributes.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.z ) +\n                attributes.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.w );\n        #else\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * renderer_JointMatrix[ int( attributes.JOINTS_0.x ) ] +\n                attributes.WEIGHTS_0.y * renderer_JointMatrix[ int( attributes.JOINTS_0.y ) ] +\n                attributes.WEIGHTS_0.z * renderer_JointMatrix[ int( attributes.JOINTS_0.z ) ] +\n                attributes.WEIGHTS_0.w * renderer_JointMatrix[ int( attributes.JOINTS_0.w ) ];\n        #endif\n\n        return skinMatrix;\n    }\n\n#endif\n\n\n#endif";

var Transform = "#ifndef TRANSFORM_INCLUDED\n#define TRANSFORM_INCLUDED\n\nmat4 renderer_LocalMat;\nmat4 renderer_ModelMat;\nmat4 camera_ViewMat;\nmat4 camera_ProjMat;\nmat4 renderer_MVMat;\nmat4 renderer_MVPMat;\nmat4 renderer_NormalMat;\n\nvec3 camera_Position;\nvec3 camera_Forward; \nvec4 camera_ProjectionParams;\n\n#endif";

var AttributesPBR = "#ifndef ATTRIBUTES_PBR_INCLUDED\n#define ATTRIBUTES_PBR_INCLUDED\n\n\nstruct Attributes{\n  \tvec3 POSITION;\n\n\t#ifdef RENDERER_HAS_BLENDSHAPE\n    \t#ifndef RENDERER_BLENDSHAPE_USE_TEXTURE\n    \t\tvec3 POSITION_BS0;\n    \t  \tvec3 POSITION_BS1;\n    \t  \t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t    \tvec3 NORMAL_BS0;\n    \t    \tvec3 NORMAL_BS1;\n    \t    \tvec3 TANGENT_BS0;\n    \t    \tvec3 TANGENT_BS1;\n    \t  \t#else\n    \t    \t#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    \t    \t  vec3 POSITION_BS2;\n    \t    \t  vec3 POSITION_BS3;\n\n    \t    \t  #ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\n    \t    \t    vec3 NORMAL_BS0;\n    \t    \t    vec3 NORMAL_BS1;\n    \t    \t    vec3 NORMAL_BS2;\n    \t    \t    vec3 NORMAL_BS3;\n    \t    \t  #endif\n\n    \t    \t  #ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\n    \t    \t    vec3 TANGENT_BS0;\n    \t    \t    vec3 TANGENT_BS1;\n    \t    \t    vec3 TANGENT_BS2;\n    \t    \t    vec3 TANGENT_BS3;\n    \t    \t  #endif\n\n    \t    \t#else\n    \t    \t  vec3 POSITION_BS2;\n    \t    \t  vec3 POSITION_BS3;\n    \t    \t  vec3 POSITION_BS4;\n    \t    \t  vec3 POSITION_BS5;\n    \t    \t  vec3 POSITION_BS6;\n    \t    \t  vec3 POSITION_BS7;\n    \t    #endif\n    \t#endif\n    #endif\n  #endif\n\n\n  \t#ifdef RENDERER_HAS_UV\n  \t    vec2 TEXCOORD_0;\n  \t#endif\n\n  \t#ifdef RENDERER_HAS_UV1\n  \t    vec2 TEXCOORD_1;\n  \t#endif\n\n  \t#ifdef RENDERER_HAS_SKIN\n  \t    vec4 JOINTS_0;\n  \t    vec4 WEIGHTS_0;\n  \t#endif\n\n  \t#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  \t    vec4 COLOR_0;\n  \t#endif\n\n\t#ifdef RENDERER_HAS_NORMAL\n\t    vec3 NORMAL;\n\t#endif\n\n    #ifdef RENDERER_HAS_TANGENT\n        vec4 TANGENT;\n    #endif\n};\n\n\n#endif";

var BRDF = "\n#ifndef BRDF_INCLUDED\n#define BRDF_INCLUDED\n\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS            0.002025\n\n#if defined(RENDERER_HAS_TANGENT) || defined(MATERIAL_ENABLE_ANISOTROPY) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_HAS_NORMALTEXTURE)\n    #define NEED_TANGENT\n#endif\n\n\nstruct SurfaceData{\n    // common\n\tvec3  albedoColor;\n    vec3  specularColor;\n\tvec3  emissiveColor;\n    float metallic;\n    float roughness;\n    float diffuseAO;\n    float specularAO;\n    float f0;\n    float opacity;\n\n    // geometry\n    vec3 position;\n    vec3 normal;\n\n    #ifdef NEED_TANGENT\n        vec3  tangent;\n        vec3  bitangent;\n    #endif\n\n    vec3  viewDir;\n    float dotNV;\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy;\n        vec3  anisotropicT;\n        vec3  anisotropicB;\n        vec3  anisotropicN;\n    #endif\n\n    // Clear coat\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoat;\n        float clearCoatRoughness;\n        vec3  clearCoatNormal;\n        float clearCoatDotNV;\n    #endif\n};\n\n\nstruct BRDFData{\n    vec3  diffuseColor;\n    vec3  specularColor;\n    float roughness;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3  clearCoatSpecularColor;\n        float clearCoatRoughness;\n    #endif\n};\n\n\nfloat getAARoughnessFactor(vec3 normal) {\n    // Kaplanyan 2016, \"Stable specular highlights\"\n    // Tokuyoshi 2017, \"Error Reduction and Simplification for Shading Anti-Aliasing\"\n    // Tokuyoshi and Kaplanyan 2019, \"Improved Geometric Specular Antialiasing\"\n    #ifdef HAS_DERIVATIVES\n        vec3 dxy = max( abs(dFdx(normal)), abs(dFdy(normal)) );\n        return max( max(dxy.x, dxy.y), dxy.z );\n    #else\n        return 0.0;\n    #endif\n}\n\n\nfloat F_Schlick(float f0, float dotLH) {\n\treturn f0 + 0.96 * (pow(1.0 - dotLH, 5.0));\n}\n\nvec3 F_Schlick(vec3 specularColor, float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(float alpha, float dotNL, float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n    float G_GGX_SmithCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL) {\n        float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n        float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n        return 0.5 / max(lambdaV + lambdaL, EPSILON);\n    }\n#endif\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX(float alpha, float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // GGX Distribution Anisotropic\n    // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\n    float D_GGX_Anisotropic(float at, float ab, float ToH, float BoH, float NoH) {\n        float a2 = at * ab;\n        highp vec3 d = vec3(ab * ToH, at * BoH, a2 * NoH);\n        highp float d2 = dot(d, d);\n        float b2 = a2 / d2;\n        return a2 * b2 * b2 * RECIPROCAL_PI;\n    }\n#endif\n\nvec3 isotropicLobe(vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat D = D_GGX( alpha, dotNH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\treturn F * ( G * D );\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 anisotropicLobe(vec3 h, vec3 l, SurfaceData surfaceData, vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n        vec3 t = surfaceData.anisotropicT;\n        vec3 b = surfaceData.anisotropicB;\n        vec3 v = surfaceData.viewDir;\n\n        float dotTV = dot(t, v);\n        float dotBV = dot(b, v);\n        float dotTL = dot(t, l);\n        float dotBL = dot(b, l);\n        float dotTH = dot(t, h);\n        float dotBH = dot(b, h);\n\n        // Aniso parameter remapping\n        // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf page 24\n        float at = max(alpha * (1.0 + surfaceData.anisotropy), MIN_ROUGHNESS);\n        float ab = max(alpha * (1.0 - surfaceData.anisotropy), MIN_ROUGHNESS);\n\n        // specular anisotropic BRDF\n    \tvec3 F = F_Schlick( specularColor, dotLH );\n        float D = D_GGX_Anisotropic(at, ab, dotTH, dotBH, dotNH);\n        float G = G_GGX_SmithCorrelated_Anisotropic(at, ab, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL);\n\n        return F * ( G * D );\n    }\n#endif\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX(vec3 incidentDirection, SurfaceData surfaceData, vec3 normal, vec3 specularColor, float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentDirection + surfaceData.viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentDirection ) );\n    float dotNV = saturate( dot( normal, surfaceData.viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentDirection, halfDir ) );\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        return anisotropicLobe(halfDir, incidentDirection, surfaceData, specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #else\n        return isotropicLobe(specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\n\n\nvoid initBRDFData(SurfaceData surfaceData, out BRDFData brdfData){\n    vec3 albedoColor = surfaceData.albedoColor;\n    vec3 specularColor = surfaceData.specularColor;\n    float metallic = surfaceData.metallic;\n    float roughness = surfaceData.roughness;\n    float f0 = surfaceData.f0;\n\n    #ifdef IS_METALLIC_WORKFLOW\n        brdfData.diffuseColor = albedoColor * ( 1.0 - metallic );\n        brdfData.specularColor = mix( vec3(f0), albedoColor, metallic );\n    #else\n        float specularStrength = max( max( specularColor.r, specularColor.g ), specularColor.b );\n        brdfData.diffuseColor = albedoColor * ( 1.0 - specularStrength );\n        brdfData.specularColor = specularColor;\n    #endif\n\n    brdfData.roughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(roughness + getAARoughnessFactor(surfaceData.normal), 1.0));\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        brdfData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n        brdfData.clearCoatSpecularColor = vec3(0.04);\n    #endif\n}\n\n#endif";

var LightProbe = "#ifndef LIGHT_PROBE\n#define LIGHT_PROBE\n\n// ------------------------Specular------------------------\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float dotNV ) {\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n}\n\n\nvec3 getReflectedVector(SurfaceData surfaceData, vec3 n) {\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        vec3 r = reflect(-surfaceData.viewDir, surfaceData.anisotropicN);\n    #else\n        vec3 r = reflect(-surfaceData.viewDir, n);\n    #endif\n\n    return r;\n}\n\nfloat getSpecularMIPLevel(float roughness, int maxMIPLevel ) {\n    return roughness * float(maxMIPLevel);\n}\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeRadiance(SurfaceData surfaceData, vec3 normal, float roughness) {\n\n    #ifndef SCENE_USE_SPECULAR_ENV\n        return vec3(0);\n    #else\n        vec3 reflectVec = getReflectedVector(surfaceData, normal);\n        reflectVec.x = -reflectVec.x; // TextureCube is left-hand,so x need inverse\n        \n        float specularMIPLevel = getSpecularMIPLevel(roughness, int(scene_EnvMapLight.mipMapLevel) );\n\n        #ifdef HAS_TEX_LOD\n            vec4 envMapColor = textureCubeLodEXT( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #else\n            vec4 envMapColor = textureCube( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #endif\n\n        #ifdef SCENE_IS_DECODE_ENV_RGBM\n            envMapColor.rgb = (RGBMToLinear(envMapColor, 5.0)).rgb;\n            #ifdef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = linearToGamma(envMapColor);\n            #endif\n        #else\n             #ifndef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = gammaToLinear(envMapColor);\n            #endif\n        #endif\n        \n        return envMapColor.rgb * scene_EnvMapLight.specularIntensity;\n\n    #endif\n}\n\n#endif";

var ForwardPassPBR = "#ifndef FORWARD_PASS_PBR_INCLUDED\n#define FORWARD_PASS_PBR_INCLUDED\n\n#include \"Common.glsl\"\n#include \"Fog.glsl\"\n\n#include \"AttributesPBR.glsl\"\n#include \"VaryingsPBR.glsl\"\n#include \"LightDirectPBR.glsl\"\n#include \"LightIndirectPBR.glsl\"\n\n#include \"VertexPBR.glsl\"\n#include \"FragmentPBR.glsl\"\n\n\nVaryings PBRVertex(Attributes attributes) {\n  Varyings varyings;\n\n  varyings.uv = getUV0(attributes);\n  #ifdef RENDERER_HAS_UV1\n      varyings.uv1 = attributes.TEXCOORD_1;\n  #endif\n\n  #ifdef RENDERER_ENABLE_VERTEXCOLOR\n    varyings.vertexColor = attributes.COLOR_0;\n  #endif\n\n\n  VertexInputs vertexInputs = getVertexInputs(attributes);\n\n  // positionWS\n  varyings.positionWS = vertexInputs.positionWS;\n\n  // positionVS\n  #if SCENE_FOG_MODE != 0\n\t  varyings.positionVS = vertexInputs.positionVS;\n\t#endif\n\n  // normalWS、tangentWS、bitangentWS\n  #ifdef RENDERER_HAS_NORMAL\n    varyings.normalWS = vertexInputs.normalWS;\n    #ifdef RENDERER_HAS_TANGENT\n      varyings.tangentWS = vertexInputs.tangentWS;\n      varyings.bitangentWS = vertexInputs.bitangentWS;\n    #endif\n  #endif\n\n  // ShadowCoord\n  #if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n      varyings.shadowCoord = getShadowCoord(vertexInputs.positionWS);\n  #endif\n\n  gl_Position = renderer_MVPMat * vertexInputs.positionOS;\n\n  return varyings;\n}\n\n\nvoid PBRFragment(Varyings varyings) {\n  BRDFData brdfData;\n\n  // Get aoUV\n  vec2 aoUV = varyings.uv;\n  #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(RENDERER_HAS_UV1)\n    if(material_OcclusionTextureCoord == 1.0){\n        aoUV = varyings.uv1;\n    }\n  #endif\n\n  SurfaceData surfaceData = getSurfaceData(varyings, aoUV, gl_FrontFacing);\n\n  // Can modify surfaceData here\n  initBRDFData(surfaceData, brdfData);\n\n  vec4 color = vec4(0, 0, 0, surfaceData.opacity);\n\n  // Get shadow attenuation\n  float shadowAttenuation = 1.0;\n  #if defined(SCENE_DIRECT_LIGHT_COUNT) && defined(NEED_CALCULATE_SHADOWS)\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n      vec3 shadowCoord = varyings.shadowCoord;\n    #else\n      vec3 shadowCoord = getShadowCoord(varyings.positionWS);\n    #endif\n    shadowAttenuation *= sampleShadowMap(varyings.positionWS, shadowCoord);\n  #endif\n\n  // Evaluate direct lighting\n  evaluateDirectRadiance(varyings, surfaceData, brdfData, shadowAttenuation, color.rgb);\n\n  // IBL\n  evaluateIBL(varyings, surfaceData, brdfData, color.rgb);\n\n  // Emissive\n  color.rgb += surfaceData.emissiveColor;\n\n\n  #if SCENE_FOG_MODE != 0\n      color = fog(color, varyings.positionVS);\n  #endif\n\n  #ifndef ENGINE_IS_COLORSPACE_GAMMA\n      color = linearToGamma(color);\n  #endif\n\n  gl_FragColor = color;\n}\n\n\n#endif";

var FragmentPBR = "#ifndef MATERIAL_INPUT_PBR_INCLUDED\n#define MATERIAL_INPUT_PBR_INCLUDED\n\n#include \"Normal.glsl\"\n\nfloat material_AlphaCutoff;\nvec4 material_BaseColor;\nfloat material_Metal;\nfloat material_Roughness;\nfloat material_IOR;\nvec3 material_PBRSpecularColor;\nfloat material_Glossiness;\nvec3 material_EmissiveColor;\nfloat material_NormalIntensity;\nfloat material_OcclusionIntensity;\nfloat material_OcclusionTextureCoord;\n\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n    float material_ClearCoat;\n    float material_ClearCoatRoughness;\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n        sampler2D material_ClearCoatTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n        sampler2D material_ClearCoatRoughnessTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n        sampler2D material_ClearCoatNormalTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 material_AnisotropyInfo;\n    #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n        sampler2D material_AnisotropyTexture;\n    #endif\n#endif\n\n// Texture\n#ifdef MATERIAL_HAS_BASETEXTURE\n    sampler2D material_BaseTexture;\n#endif\n\n#ifdef MATERIAL_HAS_NORMALTEXTURE\n    sampler2D material_NormalTexture;\n#endif\n\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n    sampler2D material_RoughnessMetallicTexture;\n#endif\n\n\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n    sampler2D material_SpecularGlossinessTexture;\n#endif\n\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n    sampler2D material_OcclusionTexture;\n#endif\n\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Aniso Bent Normals\n    // Mc Alley https://www.gdcvault.com/play/1022235/Rendering-the-World-of-Far \n    vec3 getAnisotropicBentNormal(SurfaceData surfaceData) {\n        vec3  anisotropyDirection = (surfaceData.anisotropy >= 0.0) ? surfaceData.anisotropicB : surfaceData.anisotropicT;\n        vec3  anisotropicTangent  = cross(anisotropyDirection, surfaceData.viewDir);\n        vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n        // reduce stretching for (roughness < 0.2), refer to https://advances.realtimerendering.com/s2018/Siggraph%202018%20HDRP%20talk_with%20notes.pdf 80\n        vec3  bentNormal          = normalize( mix(surfaceData.normal, anisotropicNormal, abs(surfaceData.anisotropy) * saturate( 5.0 * surfaceData.roughness)) );\n\n        return bentNormal;\n    }\n#endif\n\n\nSurfaceData getSurfaceData(Varyings v, vec2 aoUV, bool isFrontFacing){\n    SurfaceData surfaceData;\n\n    vec2 uv = v.uv;\n\n    // common\n    vec4 baseColor = material_BaseColor;\n    float metallic = material_Metal;\n    float roughness = material_Roughness;\n    vec3 specularColor = material_PBRSpecularColor;\n    float glossiness = material_Glossiness;\n    float f0 = pow2( (material_IOR - 1.0) / (material_IOR + 1.0) );\n    vec3 emissiveRadiance = material_EmissiveColor;\n\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        vec4 baseTextureColor = texture2D(material_BaseTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            baseTextureColor = gammaToLinear(baseTextureColor);\n        #endif\n        baseColor *= baseTextureColor;\n    #endif\n\n    #ifdef RENDERER_ENABLE_VERTEXCOLOR\n        baseColor *= v.vertexColor;\n    #endif\n\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    #ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n        vec4 metalRoughMapColor = texture2D( material_RoughnessMetallicTexture, uv );\n        roughness *= metalRoughMapColor.g;\n        metallic *= metalRoughMapColor.b;\n    #endif\n\n    #ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n        vec4 specularGlossinessColor = texture2D(material_SpecularGlossinessTexture, uv );\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            specularGlossinessColor = gammaToLinear(specularGlossinessColor);\n        #endif\n        specularColor *= specularGlossinessColor.rgb;\n        glossiness *= specularGlossinessColor.a;\n        roughness =  1.0 - glossiness;\n    #endif\n\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n\n    surfaceData.albedoColor = baseColor.rgb;\n    surfaceData.specularColor = specularColor;\n    surfaceData.emissiveColor = emissiveRadiance;\n    surfaceData.metallic = metallic;\n    surfaceData.roughness = roughness;\n    surfaceData.f0 = f0;\n\n    #ifdef MATERIAL_IS_TRANSPARENT\n        surfaceData.opacity = baseColor.a;\n    #else\n        surfaceData.opacity = 1.0;\n    #endif\n\n\n    // Geometry\n    surfaceData.position = v.positionWS;\n    \n    #ifdef CAMERA_ORTHOGRAPHIC\n        surfaceData.viewDir = -camera_Forward;\n    #else\n        surfaceData.viewDir = normalize(camera_Position - v.positionWS);\n    #endif\n\n    // Normal\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = normalize(v.normalWS);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v.positionWS);\n        vec3 pos_dy = dFdy(v.positionWS);\n        vec3 normal = normalize( cross(pos_dx, pos_dy) );\n        normal *= camera_ProjectionParams.x;\n    #else\n        vec3 normal = vec3(0, 0, 1);\n    #endif\n    \n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n    surfaceData.normal = normal;\n\n    // Tangent\n    #ifdef NEED_TANGENT\n        #if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT)\n            surfaceData.tangent = v.tangentWS;\n            surfaceData.bitangent = v.bitangentWS;\n            mat3 tbn = mat3(v.tangentWS, v.bitangentWS, v.normalWS);\n        #else\n            mat3 tbn = getTBNByDerivatives(uv, normal, v.positionWS, isFrontFacing);\n            surfaceData.tangent = tbn[0];\n            surfaceData.bitangent = tbn[1];\n        #endif\n\n        #ifdef MATERIAL_HAS_NORMALTEXTURE\n            surfaceData.normal = getNormalByNormalTexture(tbn, material_NormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #endif\n    #endif\n\n    surfaceData.dotNV = saturate( dot(surfaceData.normal, surfaceData.viewDir) );\n\n    // Clear Coat\n     #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n            surfaceData.clearCoatNormal = getNormalByNormalTexture(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal), material_ClearCoatNormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #else\n            surfaceData.clearCoatNormal = normal;\n        #endif\n        surfaceData.clearCoatDotNV = saturate( dot(surfaceData.clearCoatNormal, surfaceData.viewDir) );\n\n        surfaceData.clearCoat = material_ClearCoat;\n        surfaceData.clearCoatRoughness = material_ClearCoatRoughness;\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n            surfaceData.clearCoat *= (texture2D( material_ClearCoatTexture, uv )).r;\n        #endif\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n            surfaceData.clearCoatRoughness *= (texture2D( material_ClearCoatRoughnessTexture, uv )).g;\n        #endif\n\n        surfaceData.clearCoat = saturate( surfaceData.clearCoat );\n        surfaceData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n    #endif\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy = material_AnisotropyInfo.z;\n        vec3 anisotropicDirection = vec3(material_AnisotropyInfo.xy, 0.0);\n        #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n            vec3 anisotropyTextureInfo = (texture2D( material_AnisotropyTexture, uv )).rgb;\n            anisotropy *= anisotropyTextureInfo.b;\n            anisotropicDirection.xy *= anisotropyTextureInfo.rg * 2.0 - 1.0;\n        #endif\n\n        surfaceData.anisotropy = anisotropy;\n        surfaceData.anisotropicT = normalize(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal) * anisotropicDirection);\n        surfaceData.anisotropicB = normalize(cross(surfaceData.normal, surfaceData.anisotropicT));\n        surfaceData.anisotropicN = getAnisotropicBentNormal(surfaceData);\n    #endif\n\n    // AO\n    float diffuseAO = 1.0;\n    float specularAO = 1.0;\n\n    #ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n        diffuseAO = ((texture2D(material_OcclusionTexture, aoUV)).r - 1.0) * material_OcclusionIntensity + 1.0;\n    #endif\n\n    #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(SCENE_USE_SPECULAR_ENV) \n        specularAO = saturate( pow( surfaceData.dotNV + diffuseAO, exp2( - 16.0 * surfaceData.roughness - 1.0 ) ) - 1.0 + diffuseAO );\n    #endif\n\n    surfaceData.diffuseAO = diffuseAO;\n    surfaceData.specularAO = specularAO;\n\n    return surfaceData;\n}\n\n\n\n#endif";

var LightDirectPBR = "\n#ifndef LIGHT_DIRECT_PBR_INCLUDED\n#define LIGHT_DIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_SURFACE_SHADING\n    #define FUNCTION_SURFACE_SHADING surfaceShading\n#endif\n#ifndef FUNCTION_DIFFUSE_LOBE\n    #define FUNCTION_DIFFUSE_LOBE diffuseLobe\n#endif\n#ifndef FUNCTION_SPECULAR_LOBE\n    #define FUNCTION_SPECULAR_LOBE specularLobe\n#endif\n#ifndef FUNCTION_CLEAR_COAT_LOBE\n    #define FUNCTION_CLEAR_COAT_LOBE clearCoatLobe\n#endif\n\n#include \"BRDF.glsl\"\n#include \"Light.glsl\"\n#include \"ReflectionLobe.glsl\"\n\nvoid surfaceShading(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 lightColor, inout vec3 color) {\n\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n    float dotNL = saturate( dot( surfaceData.normal, incidentDirection ) );\n    vec3 irradiance = dotNL * lightColor * PI;\n\n    // ClearCoat Lobe\n    float attenuation = FUNCTION_CLEAR_COAT_LOBE(varyings, surfaceData, brdfData, incidentDirection, lightColor, specularColor);\n\n    vec3 attenuationIrradiance = attenuation * irradiance;\n    // Diffuse Lobe\n    FUNCTION_DIFFUSE_LOBE(varyings, surfaceData, brdfData, attenuationIrradiance, diffuseColor);\n    // Specular Lobe\n    FUNCTION_SPECULAR_LOBE(varyings, surfaceData, brdfData, incidentDirection, attenuationIrradiance, specularColor);\n\n    color += diffuseColor + specularColor;\n\n}\n\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    void addDirectionalDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, DirectLight directionalLight, inout vec3 color) {\n        vec3 lightColor = directionalLight.color;\n        vec3 direction = -directionalLight.direction;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n    }\n\n#endif\n\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n\tvoid addPointDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, PointLight pointLight, inout vec3 color) {\n\t\tvec3 lVector = pointLight.position - surfaceData.position;\n\t\tvec3 direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\n\t\tvec3 lightColor = pointLight.color;\n\t\tlightColor *= clamp(1.0 - pow(lightDistance/pointLight.distance, 4.0), 0.0, 1.0);\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\t}\n\n#endif\n\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n\tvoid addSpotDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, SpotLight spotLight, inout vec3 color) {\n\n\t\tvec3 lVector = spotLight.position - surfaceData.position;\n\t\tvec3 direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( direction, -spotLight.direction );\n\n\t\tfloat spotEffect = smoothstep( spotLight.penumbraCos, spotLight.angleCos, angleCos );\n\t\tfloat decayEffect = clamp(1.0 - pow(lightDistance/spotLight.distance, 4.0), 0.0, 1.0);\n\n\t\tvec3 lightColor = spotLight.color;\n\t\tlightColor *= spotEffect * decayEffect;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n\t}\n\n\n#endif\n\nvoid evaluateDirectRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float shadowAttenuation, inout vec3 color){\n    #ifdef SCENE_DIRECT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_DIRECT_LIGHT_COUNT; i ++ ) {\n            // warning: use `continue` syntax may trigger flickering bug in safri 16.1.\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_DirectLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    DirectLight directionalLight = getDirectLight(i);\n                #else\n                    DirectLight directionalLight;\n                    directionalLight.color = scene_DirectLightColor[i];\n                    directionalLight.direction = scene_DirectLightDirection[i];\n                #endif\n                \n                #ifdef NEED_CALCULATE_SHADOWS\n                    if (i == 0) { // Sun light index is always 0\n                        directionalLight.color *= shadowAttenuation;\n                    }\n                #endif\n                addDirectionalDirectLightRadiance(varyings, surfaceData, brdfData, directionalLight, color );\n            }\n        }\n\n    #endif\n\n    #ifdef SCENE_POINT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_POINT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_PointLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    PointLight pointLight = getPointLight(i);\n                #else\n                    PointLight pointLight;\n                    pointLight.color = scene_PointLightColor[i];\n                    pointLight.position = scene_PointLightPosition[i];\n                    pointLight.distance = scene_PointLightDistance[i];\n                #endif\n                addPointDirectLightRadiance(varyings, surfaceData, brdfData, pointLight, color );\n            } \n        }\n\n    #endif\n\n    #ifdef SCENE_SPOT_LIGHT_COUNT\n      \n        for ( int i = 0; i < SCENE_SPOT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_SpotLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    SpotLight spotLight = getSpotLight(i);\n                #else\n                    SpotLight spotLight;\n                    spotLight.color = scene_SpotLightColor[i];\n                    spotLight.position = scene_SpotLightPosition[i];\n                    spotLight.direction = scene_SpotLightDirection[i];\n                    spotLight.distance = scene_SpotLightDistance[i];\n                    spotLight.angleCos = scene_SpotLightAngleCos[i];\n                    spotLight.penumbraCos = scene_SpotLightPenumbraCos[i];\n                #endif\n                addSpotDirectLightRadiance( varyings, surfaceData, brdfData, spotLight, color );\n            } \n        }\n\n    #endif\n}\n\n\n#endif";

var LightIndirectPBR = "\n#ifndef LIGHT_INDIRECT_PBR_INCLUDED\n#define LIGHT_INDIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_DIFFUSE_IBL\n    #define FUNCTION_DIFFUSE_IBL evaluateDiffuseIBL\n#endif\n#ifndef FUNCTION_SPECULAR_IBL\n    #define FUNCTION_SPECULAR_IBL evaluateSpecularIBL\n#endif\n#ifndef FUNCTION_CLEAR_COAT_IBL\n    #define FUNCTION_CLEAR_COAT_IBL evaluateClearCoatIBL\n#endif\n\n\n#include \"BRDF.glsl\"\n#include \"Light.glsl\"\n#include \"LightProbe.glsl\"\n\n// ------------------------Diffuse------------------------\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeIrradiance(vec3 sh[9], vec3 normal){\n      normal.x = -normal.x;\n      vec3 result = sh[0] +\n\n            sh[1] * (normal.y) +\n            sh[2] * (normal.z) +\n            sh[3] * (normal.x) +\n\n            sh[4] * (normal.y * normal.x) +\n            sh[5] * (normal.y * normal.z) +\n            sh[6] * (3.0 * normal.z * normal.z - 1.0) +\n            sh[7] * (normal.z * normal.x) +\n            sh[8] * (normal.x * normal.x - normal.y * normal.y);\n    \n    return max(result, vec3(0.0));\n\n}\n\n\nvoid evaluateDiffuseIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 diffuseColor){\n    #ifdef SCENE_USE_SH\n        vec3 irradiance = getLightProbeIrradiance(scene_EnvSH, surfaceData.normal);\n        #ifdef ENGINE_IS_COLORSPACE_GAMMA\n            irradiance = (linearToGamma(vec4(irradiance, 1.0))).rgb;\n        #endif\n        irradiance *= scene_EnvMapLight.diffuseIntensity;\n    #else\n       vec3 irradiance = scene_EnvMapLight.diffuse * scene_EnvMapLight.diffuseIntensity;\n       irradiance *= PI;\n    #endif\n\n    diffuseColor += surfaceData.diffuseAO * irradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nfloat evaluateClearCoatIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 specularColor){\n    float radianceAttenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3 clearCoatRadiance = getLightProbeRadiance(surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatRoughness);\n        specularColor += surfaceData.specularAO * clearCoatRadiance * surfaceData.clearCoat * envBRDFApprox(brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness, surfaceData.clearCoatDotNV);\n        radianceAttenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return radianceAttenuation;\n}\n\nvoid evaluateSpecularIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float radianceAttenuation, inout vec3 specularColor){\n    vec3 radiance = getLightProbeRadiance(surfaceData, surfaceData.normal, brdfData.roughness);\n    specularColor += surfaceData.specularAO * radianceAttenuation * radiance * envBRDFApprox(brdfData.specularColor, brdfData.roughness, surfaceData.dotNV );\n}\n\n\nvoid evaluateIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 color){\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n\n    // IBL diffuse\n    FUNCTION_DIFFUSE_IBL(varyings, surfaceData, brdfData, diffuseColor);\n\n    // IBL ClearCoat\n    float radianceAttenuation = FUNCTION_CLEAR_COAT_IBL(varyings, surfaceData, brdfData, specularColor);\n\n    // IBL specular\n    FUNCTION_SPECULAR_IBL(varyings, surfaceData, brdfData, radianceAttenuation, specularColor);\n\n    color += diffuseColor + specularColor;\n}\n\n\n#endif";

var ReflectionLobe = "#ifndef REFLECTION_LOBE_INCLUDED\n#define REFLECTION_LOBE_INCLUDED\n\nvoid diffuseLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 attenuationIrradiance, inout vec3 diffuseColor){\n    diffuseColor += attenuationIrradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nvoid specularLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 attenuationIrradiance, inout vec3 specularColor){\n    specularColor += attenuationIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.normal, brdfData.specularColor, brdfData.roughness);\n}\n\nfloat clearCoatLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 color, inout vec3 specularColor){\n    float attenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoatDotNL = saturate( dot( surfaceData.clearCoatNormal, incidentDirection ) );\n        vec3 clearCoatIrradiance = clearCoatDotNL * color;\n\n        specularColor += surfaceData.clearCoat * clearCoatIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness );\n        attenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return attenuation;\n}\n\n\n\n#endif";

var VaryingsPBR = "#ifndef VARYINGS_PBR_INCLUDED\n#define VARYINGS_PBR_INCLUDED\n\n#include \"Shadow.glsl\"\n\nstruct Varyings{\n\tvec2 uv;\n\t#ifdef RENDERER_HAS_UV1\n\t    vec2 uv1;\n\t#endif\n\n\t#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  \t\tvec4 vertexColor;\n\t#endif\n\n\tvec3 positionWS;\n\n\t#if SCENE_FOG_MODE != 0\n\t    vec3 positionVS;\n\t#endif\n\n\t#ifdef RENDERER_HAS_NORMAL\n\t    vec3 normalWS;\n\t    #ifdef RENDERER_HAS_TANGENT\n\t\t\tvec3 tangentWS;\n\t\t\tvec3 bitangentWS;\n\t    #endif\n\t#endif\n\n\n\t#if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n\t    vec3 shadowCoord;\n\t#endif\n};\n\n\n#endif";

var VertexPBR = "#ifndef VERTEX_INCLUDE\n#define VERTEX_INCLUDE\n\n#include \"Transform.glsl\"\n#include \"Skin.glsl\"\n#include \"BlendShape.glsl\"\n#include \"Shadow.glsl\"\n\n\nstruct VertexInputs{\n    vec4 positionOS;\n    vec3 positionWS;\n\n    #if SCENE_FOG_MODE != 0\n        vec3 positionVS;\n    #endif\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normalWS;\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS;\n            vec3 bitangentWS;\n        #endif\n    #endif\n};\n\nvec4 material_TilingOffset;\nvec2 getUV0(Attributes attributes){\n    vec2 uv0 = vec2(0);\n\n    #ifdef RENDERER_HAS_UV\n        uv0 = attributes.TEXCOORD_0;\n    #endif\n\n    return uv0 * material_TilingOffset.xy + material_TilingOffset.zw;\n}\n\nVertexInputs getVertexInputs(Attributes attributes){\n    VertexInputs inputs;\n    vec4 position = vec4(attributes.POSITION, 1.0);\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = vec3( attributes.NORMAL );\n        #ifdef RENDERER_HAS_TANGENT\n            vec4 tangent = vec4( attributes.TANGENT );\n        #endif\n    #endif\n\n   \n    // BlendShape\n    #ifdef RENDERER_HAS_BLENDSHAPE\n        calculateBlendShape(attributes, position\n        #ifdef RENDERER_HAS_NORMAL\n            ,normal\n             #ifdef RENDERER_HAS_TANGENT\n                ,tangent\n            #endif\n        #endif\n        );\n    #endif\n\n    // Skin\n    #ifdef RENDERER_HAS_SKIN\n        mat4 skinMatrix = getSkinMatrix(attributes);\n        position = skinMatrix * position;\n\n        #if defined(RENDERER_HAS_NORMAL)\n            mat3 skinNormalMatrix = INVERSE_MAT(mat3(skinMatrix));\n            normal = normal * skinNormalMatrix;\n            #ifdef RENDERER_HAS_TANGENT\n                tangent.xyz = tangent.xyz * skinNormalMatrix;\n            #endif\n        #endif\n    #endif\n\n    // TBN world space\n    #ifdef RENDERER_HAS_NORMAL\n        inputs.normalWS = normalize( mat3(renderer_NormalMat) * normal );\n\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS = normalize( mat3(renderer_NormalMat) * tangent.xyz );\n            vec3 bitangentWS = cross( inputs.normalWS, tangentWS ) * tangent.w;\n\n            inputs.tangentWS = tangentWS;\n            inputs.bitangentWS = bitangentWS;\n        #endif\n    #endif\n\n\n    inputs.positionOS = position;\n    vec4 positionWS = renderer_ModelMat * position;\n    inputs.positionWS = positionWS.xyz / positionWS.w;\n\n     #if SCENE_FOG_MODE != 0\n        vec4 positionVS = renderer_MVMat * position;\n        inputs.positionVS = positionVS.xyz / positionVS.w;\n    #endif\n\n    return inputs;\n}\n\n#endif";

var shadingPBR = [
    {
        source: ForwardPassPBR,
        includeKey: "ForwardPassPBR.glsl"
    },
    {
        source: AttributesPBR,
        includeKey: "AttributesPBR.glsl"
    },
    {
        source: VaryingsPBR,
        includeKey: "VaryingsPBR.glsl"
    },
    {
        source: FragmentPBR,
        includeKey: "FragmentPBR.glsl"
    },
    {
        source: LightDirectPBR,
        includeKey: "LightDirectPBR.glsl"
    },
    {
        source: LightIndirectPBR,
        includeKey: "LightIndirectPBR.glsl"
    },
    {
        source: VertexPBR,
        includeKey: "VertexPBR.glsl"
    },
    {
        source: BRDF,
        includeKey: "BRDF.glsl"
    },
    {
        source: LightProbe,
        includeKey: "LightProbe.glsl"
    },
    {
        source: ReflectionLobe,
        includeKey: "ReflectionLobe.glsl"
    }
];

var fragmentList = [].concat([
    {
        source: BlendShape,
        includeKey: "BlendShape.glsl"
    },
    {
        source: Common,
        includeKey: "Common.glsl"
    },
    {
        source: Fog,
        includeKey: "Fog.glsl"
    },
    {
        source: Light,
        includeKey: "Light.glsl"
    },
    {
        source: Normal,
        includeKey: "Normal.glsl"
    },
    {
        source: ShadowSampleTent,
        includeKey: "ShadowSampleTent.glsl"
    },
    {
        source: Shadow,
        includeKey: "Shadow.glsl"
    },
    {
        source: Transform,
        includeKey: "Transform.glsl"
    },
    {
        source: Skin,
        includeKey: "Skin.glsl"
    }
], shadingPBR);

var includeRegistered = false;
var shaderRegistered = false;
function registerIncludes() {
    if (includeRegistered) return;
    for(var _iterator = _create_for_of_iterator_helper_loose(fragmentList), _step; !(_step = _iterator()).done;){
        var sourceFragment = _step.value;
        engine.ShaderFactory.registerInclude(sourceFragment.includeKey, sourceFragment.source);
    }
    includeRegistered = true;
}
function registerShader() {
    if (shaderRegistered) return;
    engine.Shader.create(PBRSource);
    shaderRegistered = true;
}

exports.fragmentList = fragmentList;
exports.registerIncludes = registerIncludes;
exports.registerShader = registerShader;
//# sourceMappingURL=browser.js.map
