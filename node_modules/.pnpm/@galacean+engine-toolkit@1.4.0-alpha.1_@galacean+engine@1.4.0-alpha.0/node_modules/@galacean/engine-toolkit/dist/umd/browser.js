!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@galacean/engine")):"function"==typeof define&&define.amd?define(["exports","@galacean/engine"],t):t(((e="undefined"!=typeof globalThis?globalThis:e||self).Galacean=e.Galacean||{},e.Galacean.Toolkit={}),e.Galacean)}(this,function(e,t){"use strict";function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function a(e,t){return(a=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function i(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&a(e,t)}var o,s,l,c,h,d,u,_,f,p,m,g,A,v,C,y,x,E,S=function(e){function t(){var t;return t=e.apply(this,arguments)||this,t._isSelected=!1,t.onSelect=function(){},t.onUnselect=function(){},t}return i(t,e),r(t,[{key:"isSelect",get:function(){return this._isSelected},set:function(e){this._isSelected!==e&&(this._isSelected=e,e?this.onSelect():this.onUnselect())}}]),t}(t.Component),M=function(){function e(){}return e.createPlane=function(n){var r=new t.ModelMesh(n);return e._initGeometryData(r),r},e._initGeometryData=function(e){var n=[,,,,];n[0]=new t.Vector3(-1,-1,0),n[1]=new t.Vector3(1,-1,0),n[2]=new t.Vector3(1,1,0),n[3]=new t.Vector3(-1,1,0);var r=new Uint8Array(6);return r[0]=0,r[1]=1,r[2]=2,r[3]=0,r[4]=2,r[5]=3,e.setPositions(n),e.setIndices(r),e.uploadData(!0),e.addSubMesh(0,6),e},e}(),T=function(e){function n(n){var r;return(r=e.call(this,n,t.Shader.find("box"))||this).isTransparent=!0,r.boxColor=new t.Vector4(.29,.63,1,.3),r.borderColor=new t.Vector4(.22,.48,1,.9),r.borderWidth=devicePixelRatio,r}return i(n,e),r(n,[{key:"minPoint",get:function(){return this.shaderData.getVector2(n._minPoint)},set:function(e){this.shaderData.setVector2(n._minPoint,e)}},{key:"maxPoint",get:function(){return this.shaderData.getVector2(n._maxPoint)},set:function(e){this.shaderData.setVector2(n._maxPoint,e)}},{key:"boxColor",get:function(){return this.shaderData.getVector4(n._boxColor)},set:function(e){this.shaderData.setVector4(n._boxColor,e)}},{key:"borderColor",get:function(){return this.shaderData.getVector4(n._borderColor)},set:function(e){this.shaderData.setVector4(n._borderColor,e)}},{key:"borderWidth",get:function(){return this.shaderData.getFloat(n._borderWidth)},set:function(e){this.shaderData.setFloat(n._borderWidth,e)}}]),n}(t.BaseMaterial);T._borderWidth=t.ShaderProperty.getByName("u_width"),T._minPoint=t.ShaderProperty.getByName("u_min"),T._maxPoint=t.ShaderProperty.getByName("u_max"),T._boxColor=t.ShaderProperty.getByName("u_boxColor"),T._borderColor=t.ShaderProperty.getByName("u_borderColor"),t.Shader.create("box","\n#include <common>\n#include <common_vert>\n\nvoid main() {\n  gl_Position = vec4(POSITION, 1.0);\n}","\nuniform vec2 u_min;\nuniform vec2 u_max;\nuniform vec4 u_boxColor;\nuniform vec4 u_borderColor;\nuniform float u_width;\n\nvoid main() {\n  float vColor = step(u_min.x + u_width, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x - u_width) * step(u_min.y + u_width, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y - u_width);\n  float vBorder = step(u_min.x, gl_FragCoord.x) * step(gl_FragCoord.x, u_max.x) * step(u_min.y, gl_FragCoord.y) * step(gl_FragCoord.y, u_max.y);\n  gl_FragColor = u_boxColor * vColor + (1. - vColor) * vBorder * u_borderColor;\n}\n");var I=function(){function e(e,n){this.engine=e,this.element=new t.Entity(e),this.sceneRoot=n,this.startPoint=new t.Vector2,this.pointBottomLeft=new t.Vector2,this.pointTopRight=new t.Vector2,this.input=e.inputManager,this.init()}var n=e.prototype;return n.init=function(){var e=this.element.addComponent(t.MeshRenderer);e.receiveShadows=!1,e.castShadows=!1,e.mesh=M.createPlane(this.engine),this.material=new T(this.engine),e.setMaterial(this.material),this.element.transform.rotation.x=.5*Math.PI},n.onSelectStart=function(e){this.startPoint.x=e.x,this.startPoint.y=this.engine.canvas.height-e.y,this.sceneRoot.addChild(this.element)},n.onSelecting=function(e){this.pointTopRight.x=Math.max(this.startPoint.x,e.x),this.pointTopRight.y=Math.max(this.startPoint.y,this.engine.canvas.height-e.y),this.pointBottomLeft.x=Math.min(this.startPoint.x,e.x),this.pointBottomLeft.y=Math.min(this.startPoint.y,this.engine.canvas.height-e.y),this.material.maxPoint=this.pointTopRight,this.material.minPoint=this.pointBottomLeft},n.onSelectEnd=function(){this.sceneRoot.removeChild(this.element)},e}(),w=new t.BoundingFrustum,D=new t.Vector3,P=new t.Vector2,b=new t.Vector3,R=new t.Vector3,N=new t.Vector3,O=new t.Vector3,L=new t.Vector3,B=new t.Vector3,V=new t.Vector3,F=new t.Vector3,H=new t.Vector3,U=new t.Vector3,z=new t.Vector3,k=new t.Vector3,G=new t.Matrix;function W(e,n){return t.Vector3.transformCoordinate(e,G,e),t.Vector3.transformCoordinate(e,n.transform.worldMatrix,e)}var Q=function(e){function n(){var n;return n=e.apply(this,arguments)||this,n.startPoint=new t.Vector2,n.endPoint=new t.Vector2,n.collection=[],n.instances={},n.deep=Number.MAX_VALUE,n.isDeep=!0,n}i(n,e);var r=n.prototype;return r.onAwake=function(){var e=this.engine,n=this.entity;this.camera=n.getComponent(t.Camera),this.input=e.inputManager,this.helper=new I(this.engine,this.scene.getRootEntity())},r.onUpdate=function(){var e=this.input.pointers[0];if(e){var n=this.engine.canvas;if(this.input.isPointerDown(t.PointerButton.Primary)){var r,a=e.position.x/n.width*2-1,i=1-e.position.y/n.height*2;this.startPoint.set(a,i),null==(r=this.helper)||r.onSelectStart(e.position)}if(this.input.isPointerUp(t.PointerButton.Primary)){var o,s=e.position.x/n.width*2-1,l=1-e.position.y/n.height*2;this.endPoint.set(s,l),null==(o=this.helper)||o.onSelectEnd(e.position)}if(this.input.isPointerHeldDown(t.PointerButton.Primary)){var c,h=e.position.x/n.width*2-1,d=1-e.position.y/n.height*2;this.endPoint.set(h,d),this.select(),null==(c=this.helper)||c.onSelecting(e.position)}}},r.select=function(e,t){return this.startPoint=e||this.startPoint,this.endPoint=t||this.endPoint,this.collection.length=0,G.copyFrom(this.camera.projectionMatrix),G.invert(),this.updateBoundingFrustum(this.startPoint,this.endPoint),this.searchChildInBoundingFrustum(w,this.scene.getRootEntity(),this.isDeep)},r.updateBoundingFrustum=function(e,n){if(e=e||this.startPoint,n=n||this.endPoint,e.x===n.x&&(n.x+=Number.EPSILON),e.y===n.y&&(n.y+=Number.EPSILON),this.camera.isOrthographic){var r=Math.min(e.x,n.x),a=Math.max(e.y,n.y),i=Math.max(e.x,n.x),o=Math.min(e.y,n.y);R.set(r,a,-1),N.set(i,a,-1),O.set(i,o,-1),L.set(r,o,-1),B.set(r,a,1),V.set(i,a,1),F.set(i,o,1),H.set(r,o,1),W(R,this.entity),W(N,this.entity),W(O,this.entity),W(L,this.entity),W(B,this.entity),W(V,this.entity),W(F,this.entity),W(H,this.entity),t.Plane.fromPoints(R,B,V,w.top),t.Plane.fromPoints(N,V,F,w.right),t.Plane.fromPoints(F,H,L,w.bottom),t.Plane.fromPoints(H,B,R,w.left),t.Plane.fromPoints(N,O,L,w.near),t.Plane.fromPoints(F,V,B,w.far),w.far.normal.scale(-1)}else P.set(Math.min(e.x,n.x),Math.max(e.y,n.y)),n.set(Math.max(e.x,n.x),Math.min(e.y,n.y)),this.entity.transform.worldMatrix.getTranslation(b),R.set(P.x,P.y,.5),N.set(n.x,P.y,0),O.set(n.x,n.y,.5),L.set(P.x,n.y,0),W(R,this.entity),W(N,this.entity),W(O,this.entity),W(L,this.entity),U.copyFrom(R).subtract(b),z.copyFrom(N).subtract(b),k.copyFrom(O).subtract(b),U.normalize(),z.normalize(),k.normalize(),U.scale(this.deep),z.scale(this.deep),k.scale(this.deep),U.add(b),z.add(b),k.add(b),t.Plane.fromPoints(b,R,N,w.top),t.Plane.fromPoints(b,N,O,w.right),t.Plane.fromPoints(O,L,b,w.bottom),t.Plane.fromPoints(L,R,b,w.left),t.Plane.fromPoints(N,O,L,w.near),t.Plane.fromPoints(k,z,U,w.far),w.far.normal.scale(-1)},r.searchChildInBoundingFrustum=function(e,n,r){void 0===r&&(r=!1);var a=n.getComponent(S);a&&a.enabled&&(D.copyFrom(n.transform.worldPosition),a.isSelect=t.CollisionUtil.frustumContainsPoint(e,D)!==t.ContainmentType.Disjoint,a.isSelect&&this.collection.push(n));var i=n.children.length;if(r&&i)for(var o=0;o<i;o++)this.searchChildInBoundingFrustum(e,n.children[o],r);return this.collection},n}(t.Script);e.ControlHandlerType=void 0,(o=e.ControlHandlerType||(e.ControlHandlerType={}))[o.None=0]="None",o[o.ROTATE=1]="ROTATE",o[o.ZOOM=2]="ZOOM",o[o.PAN=4]="PAN",o[o.All=7]="All";var X=function(){function n(){}var r=n.prototype;return r.onUpdateHandler=function(n){return n.isKeyHeldDown(t.Keys.ArrowLeft)||n.isKeyHeldDown(t.Keys.KeyA)||n.isKeyHeldDown(t.Keys.ArrowUp)||n.isKeyHeldDown(t.Keys.KeyW)||n.isKeyHeldDown(t.Keys.ArrowDown)||n.isKeyHeldDown(t.Keys.KeyS)||n.isKeyHeldDown(t.Keys.ArrowRight)||n.isKeyHeldDown(t.Keys.KeyD)?e.ControlHandlerType.PAN:e.ControlHandlerType.None},r.onUpdateDelta=function(e,n){var r=e.movementSpeed,a=e.input;n.x=n.y=n.z=0,(a.isKeyHeldDown(t.Keys.ArrowLeft)||a.isKeyHeldDown(t.Keys.KeyA))&&(n.x-=r),(a.isKeyHeldDown(t.Keys.ArrowRight)||a.isKeyHeldDown(t.Keys.KeyD))&&(n.x+=r),(a.isKeyHeldDown(t.Keys.ArrowUp)||a.isKeyHeldDown(t.Keys.KeyW))&&(n.z-=r),(a.isKeyHeldDown(t.Keys.ArrowDown)||a.isKeyHeldDown(t.Keys.KeyS))&&(n.z+=r)},n}();(s=v||(v={}))[s.Moving=0]="Moving",s[s.Distance=1]="Distance",s[s.None=2]="None";var J=function(){function n(){this._deltaType=0,this._handlerType=e.ControlHandlerType.None,this._frameIndex=0,this._lastUsefulFrameIndex=-1}var r=n.prototype;return r.onUpdateHandler=function(n){if(++this._frameIndex,1===n.pointers.length){if(n.isPointerHeldDown(t.PointerButton.Primary))this._updateType(e.ControlHandlerType.ROTATE,0);else{var r=n.pointers[0].deltaPosition;(0!==r.x||0!==r.y)&&n.isPointerUp(t.PointerButton.Primary)?this._updateType(e.ControlHandlerType.ROTATE,0):this._updateType(e.ControlHandlerType.None,2)}}else this._updateType(e.ControlHandlerType.None,2);return this._handlerType},r.onUpdateDelta=function(e,t){var n=this._frameIndex;if(0===this._deltaType){if(this._lastUsefulFrameIndex===n-1){var r=e.input.pointers[0].deltaPosition;t.x=r.x,t.y=r.y}else t.x=0,t.y=0}this._lastUsefulFrameIndex=n},r._updateType=function(e,t){(this._handlerType!==e||this._deltaType!==t)&&(this._handlerType=e,this._deltaType=t,this._lastUsefulFrameIndex=-1)},n}(),K=t.MathUtil.zeroTolerance,j=function(){function e(e,n,r){this.radius=e,this.phi=n,this.theta=r,this._matrix=new t.Matrix,this._matrixInv=new t.Matrix,this.radius=void 0!==e?e:1,this.phi=void 0!==n?n:0,this.theta=void 0!==r?r:0}var n=e.prototype;return n.makeSafe=function(){var e=Math.floor(this.phi/Math.PI);return this.phi=t.MathUtil.clamp(this.phi,e*Math.PI+K,(e+1)*Math.PI-K),this},n.set=function(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this},n.setYAxis=function(n){var r=e._xAxis,a=e._yAxis,i=e._zAxis;t.Vector3.equals(r.set(1,0,0),a.copyFrom(n).normalize())&&r.set(0,1,0),t.Vector3.cross(r,a,i),i.normalize(),t.Vector3.cross(a,i,r);var o=this._matrix.elements;o[0]=r.x,o[1]=r.y,o[2]=r.z,o[4]=a.x,o[5]=a.y,o[6]=a.z,o[8]=i.x,o[9]=i.y,o[10]=i.z;var s=this._matrixInv.elements;s[0]=r.x,s[4]=r.y,s[8]=r.z,s[1]=a.x,s[5]=a.y,s[9]=a.z,s[2]=i.x,s[6]=i.y,s[10]=i.z},n.setFromVec3=function(e,n){return void 0===n&&(n=!1),e.transformNormal(this._matrixInv),this.radius=e.length(),0===this.radius?(this.theta=0,this.phi=0):n?(this.phi=2*Math.PI-Math.acos(t.MathUtil.clamp(e.y/this.radius,-1,1)),this.theta=Math.atan2(-e.x,-e.z)):(this.phi=Math.acos(t.MathUtil.clamp(e.y/this.radius,-1,1)),this.theta=Math.atan2(e.x,e.z)),this},n.setToVec3=function(e){var t=this.radius,n=this.phi,r=this.theta,a=Math.sin(n)*t;return this.phi-=Math.floor(this.phi/Math.PI/2)*Math.PI*2,e.set(a*Math.sin(r),t*Math.cos(n),a*Math.cos(r)),e.transformNormal(this._matrix),this.phi>Math.PI},e}();j._xAxis=new t.Vector3,j._yAxis=new t.Vector3,j._zAxis=new t.Vector3;var Y=function(n){function r(e){(r=n.call(this,e)||this).inputDevices=[new X,new J],r.movementSpeed=1,r.rotateSpeed=1,r.floorMock=!0,r.floorY=0,r._spherical=new j,r._tempVec=new t.Vector3,r._atTheBack=!1,r._topVec=new t.Vector3(0,1,0),r._bottomVec=new t.Vector3(0,-1,0),r.input=r.engine.inputManager;var r,a=r._cameraTransform=e.transform,i=function(e){if(void 0===e)throw ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(r),o=i._tempVec,s=i._spherical;return t.Vector3.transformByQuat(o.set(0,0,-1),a.rotationQuaternion,o),s.setFromVec3(o,r._atTheBack),r}i(r,n);var a=r.prototype;return a.onLateUpdate=function(t){if(!1!==this.enabled){e.ControlHandlerType.None;for(var n=this._tempVec,r=this.inputDevices,a=this.input,i=r.length-1;i>=0;i--){var o=r[i],s=o.onUpdateHandler(a);if(s)switch(o.onUpdateDelta(this,n),s){case e.ControlHandlerType.ROTATE:this._rotate(n);break;case e.ControlHandlerType.PAN:this._pan(n,t)}}if(this.floorMock){var l=this._cameraTransform.position;l.y!==this.floorY&&this._cameraTransform.setPosition(l.x,this.floorY,l.z)}}},a._pan=function(e,t){var n=t*this.movementSpeed;e.normalize().scale(n),this._cameraTransform.translate(e,!0)},a._rotate=function(e){if(0!==e.x||0!==e.y){var n=this.engine.canvas,r=-(180*e.x)/n.width,a=180*e.y/n.height;this._spherical.theta+=t.MathUtil.degreeToRadian(r),this._spherical.phi+=t.MathUtil.degreeToRadian(a),this._spherical.makeSafe(),this._atTheBack=this._spherical.setToVec3(this._tempVec),t.Vector3.add(this._cameraTransform.position,this._tempVec,this._tempVec),this._atTheBack?this._cameraTransform.lookAt(this._tempVec,this._bottomVec):this._cameraTransform.lookAt(this._tempVec,this._topVec)}},r}(t.Script);function q(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):e instanceof t}var Z=function(){function n(){}var r=n.prototype;return r.onUpdateHandler=function(n){return n.isKeyHeldDown(t.Keys.ArrowLeft)||n.isKeyHeldDown(t.Keys.ArrowRight)||n.isKeyHeldDown(t.Keys.ArrowUp)||n.isKeyHeldDown(t.Keys.ArrowDown)?e.ControlHandlerType.PAN:e.ControlHandlerType.None},r.onUpdateDelta=function(e,n){var r=e.keyPanSpeed,a=e.input;n.x=n.y=0,a.isKeyHeldDown(t.Keys.ArrowLeft)&&(n.x+=r),a.isKeyHeldDown(t.Keys.ArrowRight)&&(n.x-=r),a.isKeyHeldDown(t.Keys.ArrowUp)&&(n.y+=r),a.isKeyHeldDown(t.Keys.ArrowDown)&&(n.y-=r)},n}();(l=C||(C={}))[l.Moving=0]="Moving",l[l.Distance=1]="Distance",l[l.None=2]="None";var $=function(){function n(){this._deltaType=2,this._handlerType=e.ControlHandlerType.None,this._frameIndex=0,this._lastUsefulFrameIndex=-1,this._distanceOfPointers=0}var r=n.prototype;return r.onUpdateHandler=function(n){switch(++this._frameIndex,n.pointers.length){case 1:if(n.isPointerHeldDown(t.PointerButton.Secondary))this._updateType(e.ControlHandlerType.PAN,0);else if(n.isPointerHeldDown(t.PointerButton.Auxiliary))this._updateType(e.ControlHandlerType.ZOOM,0);else if(n.isPointerHeldDown(t.PointerButton.Primary))this._updateType(e.ControlHandlerType.ROTATE,0);else{var r=n.pointers[0].deltaPosition;0!==r.x&&0!==r.y?n.isPointerUp(t.PointerButton.Secondary)?this._updateType(e.ControlHandlerType.PAN,0):n.isPointerUp(t.PointerButton.Auxiliary)?this._updateType(e.ControlHandlerType.ZOOM,0):n.isPointerUp(t.PointerButton.Primary)?this._updateType(e.ControlHandlerType.ROTATE,0):this._updateType(e.ControlHandlerType.None,2):this._updateType(e.ControlHandlerType.None,2)}break;case 2:this._updateType(e.ControlHandlerType.ZOOM,1);break;case 3:this._updateType(e.ControlHandlerType.PAN,0);break;default:this._updateType(e.ControlHandlerType.None,2)}return this._handlerType},r.onUpdateDelta=function(e,n){var r=this._frameIndex;switch(this._deltaType){case 0:if(n.x=0,n.y=0,this._lastUsefulFrameIndex===r-1){for(var a=e.input.pointers,i=a.length,o=i-1;o>=0;o--){var s=a[o].deltaPosition;n.x+=s.x,n.y+=s.y}n.x/=i,n.y/=i}break;case 1:var l=e.input.pointers,c=l[0],h=l[1],d=t.Vector2.distance(c.position,h.position);this._lastUsefulFrameIndex===r-1?n.set(0,this._distanceOfPointers-d,0):n.set(0,0,0),this._distanceOfPointers=d}this._lastUsefulFrameIndex=r},r._updateType=function(e,t){(this._handlerType!==e||this._deltaType!==t)&&(this._handlerType=e,this._deltaType=t,this._lastUsefulFrameIndex=-1)},n}(),ee=function(){function t(){}var n=t.prototype;return n.onUpdateHandler=function(t){var n=t.wheelDelta;return 0===n.x&&0===n.y&&0===n.z?e.ControlHandlerType.None:e.ControlHandlerType.ZOOM},n.onUpdateDelta=function(e,t){t.copyFrom(e.input.wheelDelta)},t}(),et=function(n){function a(){var r;return r=n.apply(this,arguments)||this,r.inputDevices=[new Z,new $,new ee],r.autoRotate=!1,r.autoRotateSpeed=Math.PI,r.enableDamping=!0,r.rotateSpeed=1,r.zoomSpeed=1,r.keyPanSpeed=7,r.dampingFactor=.1,r.zoomFactor=.2,r.minDistance=.1,r.maxDistance=1/0,r.minZoom=0,r.maxZoom=1/0,r.minPolarAngle=1/180*Math.PI,r.maxPolarAngle=179/180*Math.PI,r.minAzimuthAngle=-1/0,r.maxAzimuthAngle=1/0,r._enableKeys=!0,r._up=new t.Vector3(0,1,0),r._target=new t.Vector3,r._atTheBack=!1,r._spherical=new j,r._sphericalDelta=new j,r._sphericalDump=new j,r._zoomFrag=0,r._scale=1,r._panOffset=new t.Vector3,r._tempVec3=new t.Vector3,r._enableHandler=e.ControlHandlerType.All,r}i(a,n);var o=a.prototype;return o.onAwake=function(){var e=this.engine,n=this.entity;this.canvas=e.canvas,this.input=e.inputManager,this.camera=n.getComponent(t.Camera),this.cameraTransform=n.transform,this._spherical.setYAxis(this._up),this._atTheBack=!1},o.onLateUpdate=function(e){this._updateInputDelta(e),this._updateTransform()},o._updateInputDelta=function(t){for(var n=e.ControlHandlerType.None,r=this._tempVec3,a=this._enableHandler,i=this.inputDevices,o=this.input,s=i.length-1;s>=0;s--){var l=i[s],c=l.onUpdateHandler(o);if(c&a)switch(n|=c,l.onUpdateDelta(this,r),c){case e.ControlHandlerType.ROTATE:this._rotate(r);break;case e.ControlHandlerType.ZOOM:this._zoom(r);break;case e.ControlHandlerType.PAN:this._pan(r)}}var h=this._sphericalDump,d=this._sphericalDelta;if(this.enableDamping&&(a&e.ControlHandlerType.ZOOM&&n^e.ControlHandlerType.ZOOM&&(this._zoomFrag*=1-this.zoomFactor),a&e.ControlHandlerType.ROTATE&&n^e.ControlHandlerType.ROTATE&&(d.theta=h.theta*=1-this.dampingFactor,d.phi=h.phi*=1-this.dampingFactor)),n===e.ControlHandlerType.None&&this.autoRotate){var u=this.autoRotateSpeed*t;d.theta-=u}},o._rotate=function(e){var t=2*Math.PI*e.x/this.canvas.width*this.rotateSpeed;this._sphericalDelta.theta-=t;var n=2*Math.PI*e.y/this.canvas.height*this.rotateSpeed;this._sphericalDelta.phi-=n,this.enableDamping&&(this._sphericalDump.theta=-t,this._sphericalDump.phi=-n)},o._zoom=function(e){e.y>0?this._scale/=Math.pow(.95,this.zoomSpeed):e.y<0&&(this._scale*=Math.pow(.95,this.zoomSpeed))},o._pan=function(e){var n=this.cameraTransform,r=n.worldMatrix.elements,a=this.canvas.height,i=t.Vector3.distance(n.position,this.target)*(this.camera.fieldOfView/2)*(Math.PI/180),o=-2*e.x*(i/a),s=2*e.y*(i/a);this._panOffset.x+=r[0]*o+r[4]*s,this._panOffset.y+=r[1]*o+r[5]*s,this._panOffset.z+=r[2]*o+r[6]*s},o._updateTransform=function(){var e=this.cameraTransform,n=this.target,r=this._tempVec3,a=this._spherical,i=this._sphericalDelta,o=this._panOffset;r.copyFrom(e.worldUp),this._atTheBack=r.y<=0,t.Vector3.subtract(e.position,n,r),a.setFromVec3(r,this._atTheBack),a.theta+=i.theta,a.phi+=i.phi,a.theta=Math.max(this.minAzimuthAngle,Math.min(this.maxAzimuthAngle,a.theta)),a.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,a.phi)),a.makeSafe(),1!==this._scale&&(this._zoomFrag=a.radius*(this._scale-1)),a.radius+=this._zoomFrag,a.radius=Math.max(this.minDistance,Math.min(this.maxDistance,a.radius)),this._atTheBack=a.setToVec3(r),t.Vector3.add(n.add(o),r,e.worldPosition),e.lookAt(n,r.copyFrom(this.up).scale(this._atTheBack?-1:1)),this._zoomFrag=0,this._scale=1,i.set(0,0,0),o.set(0,0,0)},r(a,[{key:"enableKeys",get:function(){return this._enableKeys},set:function(e){if(this._enableKeys!==e){this._enableKeys=e;var t,n=this.inputDevices;if(e)n.push(new Z);else for(var r=n.length-1;r>=0;r--)if(t=n[r],null!=Z&&"undefined"!=typeof Symbol&&Z[Symbol.hasInstance]?!!Z[Symbol.hasInstance](t):q(t,Z)){n.splice(r,1);break}}}},{key:"up",get:function(){return this._up},set:function(e){this._up.copyFrom(e),this._spherical.setYAxis(e),this._atTheBack=!1}},{key:"target",get:function(){return this._target},set:function(e){this._target.copyFrom(e),this._atTheBack=!1}},{key:"enableRotate",get:function(){return(this._enableHandler&e.ControlHandlerType.ROTATE)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.ROTATE:this._enableHandler&=~e.ControlHandlerType.ROTATE}},{key:"enableZoom",get:function(){return(this._enableHandler&e.ControlHandlerType.ZOOM)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.ZOOM:this._enableHandler&=~e.ControlHandlerType.ZOOM}},{key:"enablePan",get:function(){return(this._enableHandler&e.ControlHandlerType.PAN)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.PAN:this._enableHandler&=~e.ControlHandlerType.PAN}}]),a}(t.Script),en=function(n){function a(r){var a;return(a=n.call(this,r)||this).inputDevices=[new Z,new $,new ee],a.target=new t.Vector3,a.up=new t.Vector3(0,1,0),a.autoRotate=!1,a.autoRotateSpeed=Math.PI,a.enableKeys=!1,a.enableDamping=!0,a.rotateSpeed=1,a.zoomSpeed=1,a.keyPanSpeed=7,a.dampingFactor=.1,a.zoomFactor=.2,a.minDistance=.1,a.maxDistance=1/0,a.minZoom=0,a.maxZoom=1/0,a.minPolarAngle=0,a.maxPolarAngle=Math.PI,a.minAzimuthAngle=-1/0,a.maxAzimuthAngle=1/0,a._zoomScaleUnit=2,a._scale=1,a._panOffset=new t.Vector3,a._tempVec3=new t.Vector3,a._enableHandler=e.ControlHandlerType.All,a.enableRotate=!1,a}i(a,n);var o=a.prototype;return o.onAwake=function(){var e=this.engine,n=this.entity;this.canvas=e.canvas,this.input=e.inputManager,this.camera=n.getComponent(t.Camera),this.cameraTransform=n.transform},o.onLateUpdate=function(e){this._updateInputDelta(e),this._updateCamera()},o._updateInputDelta=function(t){e.ControlHandlerType.None;for(var n=this._tempVec3,r=this._enableHandler,a=this.inputDevices,i=this.input,o=a.length-1;o>=0;o--){var s=a[o],l=s.onUpdateHandler(i);if(l&r)switch(s.onUpdateDelta(this,n),l){case e.ControlHandlerType.ZOOM:this._zoom(n);break;case e.ControlHandlerType.PAN:this._pan(n)}}},o._zoom=function(e){e.y>0?this._scale/=Math.pow(.95,this.zoomSpeed):e.y<0&&(this._scale*=Math.pow(.95,this.zoomSpeed))},o._pan=function(e){this._panOffset.copyFrom(e)},o._updateCamera=function(){var e=this.cameraTransform,t=this.camera,n=this._panOffset,r=this._zoomScaleUnit*Math.log1p(t.orthographicSize)*(this._scale-1),a=t.orthographicSize+r;t.orthographicSize=Math.max(this.minZoom,Math.min(this.maxZoom,a));var i=this.canvas,o=i.width,s=i.height,l=n.x,c=n.y,h=2*t.orthographicSize,d=h*t.aspectRatio,u=e.position,_=this._tempVec3;_.x=u.x-l*d/o,_.y=u.y+c*h/s,_.z=u.z,e.position=_,this._scale=1,n.set(0,0,0)},r(a,[{key:"enableRotate",get:function(){return(this._enableHandler&e.ControlHandlerType.ROTATE)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.ROTATE:this._enableHandler&=~e.ControlHandlerType.ROTATE}},{key:"enableZoom",get:function(){return(this._enableHandler&e.ControlHandlerType.ZOOM)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.ZOOM:this._enableHandler&=~e.ControlHandlerType.ZOOM}},{key:"enablePan",get:function(){return(this._enableHandler&e.ControlHandlerType.PAN)!=0},set:function(t){t?this._enableHandler|=e.ControlHandlerType.PAN:this._enableHandler&=~e.ControlHandlerType.PAN}}]),a}(t.Script);function er(e,t){return(er=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}"function"==typeof SuppressedError&&SuppressedError;var ea=t.Shader.create("framebuffer-picker-color","#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <position_vert>\n}","#define GLSLIFY 1\n#include <common>\nuniform vec3 u_pickColor;void main(){gl_FragColor=vec4(u_pickColor,1.0);}");function ei(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function eo(e,t,n){return t&&ei(e.prototype,t),n&&ei(e,n),e}ea.subShaders.forEach(function(e){e.passes.forEach(function(e){e.setTag("spriteDisableBatching",!0)})}),e.FramebufferPicker=function(e){function n(){var n;return n=e.apply(this,arguments)||this,n._renderersMap=[],n._frameBufferSize=new t.Vector2(1024,1024),n}!function(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&er(e,t)}(n,e);var r,a=n.prototype;return a.onAwake=function(){this._camera=this.entity.getComponent(t.Camera)},a.pick=function(e,t){var n=this;return new Promise(function(r,a){n._setupRenderTarget();var i=n._readPixelFromRenderTarget(e,t);r(n._getRendererByPixel(i))})},a.regionPick=function(e,t,n,r){var a=this;return new Promise(function(i,o){a._setupRenderTarget();var s=a._readPixelFromRenderTarget(e,t,n,r);i(a._getRenderersByPixel(s))})},a._checkFrameBufferSize=function(){var e=this._pickRenderTarget,n=this.engine,r=this._frameBufferSize;e&&r.x==e.width&&r.y==e.height||(e&&e.destroy(),this._pickRenderTarget=new t.RenderTarget(n,r.x,r.y,new t.Texture2D(n,r.x,r.y,t.TextureFormat.R8G8B8A8,!1)))},a._updateRenderersPickColor=function(e){for(var r=0,a=this._renderersMap,i=n._rootEntityRenderers,o=e.rootEntities,s=n._pickColorProperty,l=0,c=o.length;l<c;l++){o[l].getComponentsIncludeChildren(t.Renderer,i);for(var h=0,d=i.length;h<d;h++){var u=i[h],_=u.shaderData,f=_.getVector3(s);f||(f=new t.Vector3,_.setVector3(s,f)),this._uniqueId2Color(++r,f),a[r]=u}}},a._setupRenderTarget=function(){this._checkFrameBufferSize();var e=this._camera,n=e.enablePostProcess,r=e.enableHDR,a=e.depthTextureMode,i=e.opaqueTextureEnabled;this._updateRenderersPickColor(e.scene);var o=e.renderTarget,s=e.aspectRatio;e.renderTarget=this._pickRenderTarget,e.setReplacementShader(ea),e.aspectRatio=s,e.enablePostProcess=!1,e.enableHDR=!1,e.depthTextureMode=t.DepthTextureMode.None,e.opaqueTextureEnabled=!1,e.render(),e.resetReplacementShader(),e.renderTarget=o,e.resetAspectRatio(),e.enablePostProcess=n,e.enableHDR=r,e.depthTextureMode=a,e.opaqueTextureEnabled=i},a._readPixelFromRenderTarget=function(e,t,r,a){var i,o,s,l=this._getCoordOnRenderTarget(e,t),c=arguments.length;if(2===c)i=n._pickPixel,o=s=1;else if(4===c){var h=this._getCoordOnRenderTarget(r,a);o=Math.abs(l.x-h.x),s=Math.abs(l.y-h.y),l.x=l.x<h.x?l.x:h.x,l.y=l.y<h.y?l.y:h.y,i=new Uint8Array(o*s*4)}return this._pickRenderTarget.getColorTexture().getPixelBuffer(l.x,l.y,o,s,0,i),i},a._getCoordOnRenderTarget=function(e,t){var n=this._pickRenderTarget,r=this.engine.canvas,a=this._camera.viewport,i=(a.z-a.x)*r.width,o=(a.w-a.y)*r.height;return{x:Math.floor((e-a.x)/i*(n.width-1)),y:Math.floor((t-a.y)/o*(n.height-1))}},a._getRendererByPixel=function(e){return this._renderersMap[this._color2UniqueId(e)]},a._getRenderersByPixel=function(e){var t=this,n=[];return this._color2UniqueIds(e).forEach(function(e){t._renderersMap[e]&&n.push(t._renderersMap[e])}),n},a._uniqueId2Color=function(e,n){e>=16777215&&(t.Logger.warn("Framebuffer Picker encounter primitive's id greater than 16777215"),n.set(0,0,0)),n.set((255&e)/255,((65280&e)>>8)/255,((16711680&e)>>16)/255)},a._color2UniqueId=function(e){return e[0]|e[1]<<8|e[2]<<16},a._color2UniqueIds=function(e){n._pickIds.clear();for(var t=0;t<e.length;t+=4){var r=e[t]|e[t+1]<<8|e[t+2]<<16;n._pickIds.add(r)}return n._pickIds},r=[{key:"frameBufferSize",get:function(){return this._frameBufferSize},set:function(e){this._frameBufferSize=e}}],function(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}(n.prototype,r),n}(t.Script),e.FramebufferPicker._rootEntityRenderers=[],e.FramebufferPicker._pickPixel=new Uint8Array(4),e.FramebufferPicker._pickIds=new Set,e.FramebufferPicker._pickColorProperty=t.ShaderProperty.getByName("u_pickColor"),e.FramebufferPicker=function(e,t,n,r){var a,i=arguments.length,o=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var s=e.length-1;s>=0;s--)(a=e[s])&&(o=(i<3?a(o):i>3?a(t,n,o):a(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o}([t.dependentComponents(t.Camera,t.DependentMode.CheckOnly)],e.FramebufferPicker);var es=function(){function e(){}return e.createCuboidWireframe=function(e,t,n,r,a,i,o){var s=e/2,l=t/2,c=n/2,h=a;r[h++].set(-s,l,-c),r[h++].set(s,l,-c),r[h++].set(s,l,c),r[h++].set(-s,l,c),r[h++].set(-s,-l,-c),r[h++].set(s,-l,-c),r[h++].set(s,-l,c),r[h++].set(-s,-l,c),r[h++].set(-s,l,-c),r[h++].set(-s,l,c),r[h++].set(-s,-l,c),r[h++].set(-s,-l,-c),r[h++].set(s,l,-c),r[h++].set(s,l,c),r[h++].set(s,-l,c),r[h++].set(s,-l,-c),r[h++].set(-s,l,c),r[h++].set(s,l,c),r[h++].set(s,-l,c),r[h++].set(-s,-l,c),r[h++].set(-s,l,-c),r[h++].set(s,l,-c),r[h++].set(s,-l,-c),r[h++].set(-s,-l,-c),i[o++]=a,i[o++]=a+1,i[o++]=a+1,i[o++]=a+2,i[o++]=a+2,i[o++]=a+3,i[o++]=a+3,i[o++]=a,i[o++]=a+4,i[o++]=a+5,i[o++]=a+5,i[o++]=a+6,i[o++]=a+6,i[o++]=a+7,i[o++]=a+7,i[o++]=a+4,i[o++]=a+8,i[o++]=a+9,i[o++]=a+9,i[o++]=a+10,i[o++]=a+10,i[o++]=a+11,i[o++]=a+11,i[o++]=a+8,i[o++]=a+12,i[o++]=a+13,i[o++]=a+13,i[o++]=a+14,i[o++]=a+14,i[o++]=a+15,i[o++]=a+15,i[o++]=a+12,i[o++]=a+16,i[o++]=a+17,i[o++]=a+17,i[o++]=a+18,i[o++]=a+18,i[o++]=a+19,i[o++]=a+19,i[o++]=a+16,i[o++]=a+20,i[o++]=a+21,i[o++]=a+21,i[o++]=a+22,i[o++]=a+22,i[o++]=a+23,i[o++]=a+23,i[o++]=a+20},e.createSphereWireframe=function(t,n,r,a,i){e._shift.set(0,0,0),e.createCircleWireframe(t,0,e._shift,n,r,a,i),e.createCircleWireframe(t,1,e._shift,n,r+e.circleVertexCount,a,i+e.circleIndexCount),e.createCircleWireframe(t,2,e._shift,n,r+2*e.circleVertexCount,a,i+2*e.circleIndexCount)},e.createConeWireframe=function(t,n,r,a,i,o){e._shift.set(0,-n,0),e.createCircleWireframe(t,1,e._shift,r,a,i,o);var s=a+e.circleVertexCount,l=s;r[l++].set(0,0,0),r[l++].set(-t,-n,0),r[l++].set(t,-n,0),r[l++].set(0,-n,t),r[l++].set(0,-n,-t),o+=e.circleIndexCount,i[o++]=s,i[o++]=s+1,i[o++]=s,i[o++]=s+2,i[o++]=s,i[o++]=s+3,i[o++]=s,i[o++]=s+4},e.createUnboundCylinderWireframe=function(n,r,a,i,o){e._shift.set(0,0,0),e.createCircleWireframe(n,1,e._shift,r,a,i,o);var s=a+e.circleVertexCount,l=s;o+=e.circleIndexCount;for(var c=0;c<8;c++){var h=t.MathUtil.degreeToRadian(45*c);r[l++].set(n*Math.cos(h),0,n*Math.sin(h)),r[l++].set(n*Math.cos(h),-5,n*Math.sin(h)),i[o+2*c]=s+2*c,i[o+2*c+1]=s+2*c+1}},e.createCapsuleWireframe=function(t,n,r,a,i,o){var s=e.circleIndexCount,l=e.circleVertexCount,c=n/2;e._shift.set(0,c,0),e.createCircleWireframe(t,1,e._shift,r,a,i,o),e._shift.set(0,-c,0),e.createCircleWireframe(t,1,e._shift,r,a+l,i,o+s),e.createEllipticWireframe(t,c,2,r,a+2*l,i,o+2*s),e.createEllipticWireframe(t,c,0,r,a+3*l,i,o+2*s+e.ellipticIndexCount)},e.createCircleWireframe=function(t,n,r,a,i,o,s){for(var l=e.circleVertexCount,c=2*Math.PI,h=1/l,d=i,u=0;u<l;++u){var _=u*h*c;switch(n){case 0:a[d++].set(r.x,t*Math.cos(_)+r.y,t*Math.sin(_)+r.z);break;case 1:a[d++].set(t*Math.cos(_)+r.x,r.y,t*Math.sin(_)+r.z);break;case 2:a[d++].set(t*Math.cos(_)+r.x,t*Math.sin(_)+r.y,r.z)}var f=u+i;u<l-1?(o[s+2*u]=f,o[s+2*u+1]=f+1):(o[s+2*u]=f,o[s+2*u+1]=i)}},e.createEllipticWireframe=function(t,n,r,a,i,o,s){for(var l=e.circleVertexCount,c=2*Math.PI,h=1/l,d=i,u=0;u<l;++u){var _=u*h*c;switch(r){case 0:a[d++].set(0,t*Math.sin(_)+n,t*Math.cos(_));break;case 1:a[d++].set(t*Math.cos(_),n,t*Math.sin(_));break;case 2:a[d++].set(t*Math.cos(_),t*Math.sin(_)+n,0)}u==l/2&&(n=-n);var f=u+i;u<l-1?(o[s+2*u]=f,o[s+2*u+1]=f+1):(o[s+2*u]=f,o[s+2*u+1]=i)}},e.createFrustumWireframe=function(n,r,a,i,o,s,l){e._shift.set(0,0,0),e.createCircleWireframe(n,2,e._shift,i,o,s,l),e._shift.set(0,0,-r);var c=n+Math.tan(t.MathUtil.degreeToRadian(a))*r;e.createCircleWireframe(c,2,e._shift,i,o+e.circleVertexCount,s,l+e.circleIndexCount);var h=o+2*e.circleVertexCount,d=h;i[d++].set(0,0,0),i[d++].set(0,0,-r),i[d++].set(n,0,0),i[d++].set(c,0,-r),i[d++].set(-n,0,0),i[d++].set(-c,0,-r),i[d++].set(0,n,0),i[d++].set(0,c,-r),i[d++].set(0,-n,0),i[d++].set(0,-c,-r),l+=2*e.circleIndexCount,s[l++]=h,s[l++]=h+1,s[l++]=h+2,s[l++]=h+3,s[l++]=h+4,s[l++]=h+5,s[l++]=h+6,s[l++]=h+7,s[l++]=h+8,s[l++]=h+9},e.createHemisphereWireframe=function(t,n,r,a,i,o){for(var s=e.circleVertexCount/2,l=Math.PI,c=1/s,h=a,d=0;d<s+1;d++){var u=d*c*l;switch(n){case 0:r[h++].set(t*Math.sin(u),0,t*Math.cos(u));break;case 1:r[h++].set(0,t*Math.sin(u),t*Math.cos(u));break;case 2:r[h++].set(-t*Math.cos(u),0,-t*Math.sin(u))}var _=d+a;d<s&&(i[o+2*d]=_,i[o+2*d+1]=_+1)}o+=e.circleVertexCount;for(var f=0;f<s+1;f++){var p=f*c*l;switch(n){case 0:r[h++].set(t*Math.sin(p),t*Math.cos(p),0);break;case 1:r[h++].set(t*Math.cos(p),t*Math.sin(p),0);break;case 2:r[h++].set(0,-t*Math.cos(p),-t*Math.sin(p))}var m=f+a+s+1;f<s&&(i[o+2*f]=m,i[o+2*f+1]=m+1)}e._shift.set(0,0,0),e.createCircleWireframe(t,n,e._shift,r,a+e.circleVertexCount+2,i,o+e.circleVertexCount)},eo(e,null,[{key:"cuboidIndexCount",get:function(){return 48}},{key:"cuboidPositionCount",get:function(){return 24}},{key:"sphereIndexCount",get:function(){return 3*e.circleIndexCount}},{key:"spherePositionCount",get:function(){return 3*e.circlePositionCount}},{key:"coneIndexCount",get:function(){return e.circleIndexCount+8}},{key:"conePositionCount",get:function(){return e.circlePositionCount+5}},{key:"unboundCylinderIndexCount",get:function(){return e.circleIndexCount+16}},{key:"unboundCylinderPositionCount",get:function(){return e.circlePositionCount+16}},{key:"capsuleIndexCount",get:function(){return(e.circleIndexCount+e.ellipticIndexCount)*2}},{key:"capsulePositionCount",get:function(){return(e.circlePositionCount+e.ellipticPositionCount)*2}},{key:"circleIndexCount",get:function(){return 2*e.circleVertexCount}},{key:"circlePositionCount",get:function(){return e.circleVertexCount}},{key:"ellipticIndexCount",get:function(){return 2*e.circleVertexCount}},{key:"ellipticPositionCount",get:function(){return e.circleVertexCount}},{key:"frustumIndexCount",get:function(){return 2*e.circleIndexCount+10}},{key:"frustumPositionCount",get:function(){return 2*e.circleVertexCount+10}},{key:"hemisphereIndexCount",get:function(){return 2*e.circleVertexCount+e.circleIndexCount}},{key:"hemispherePositionCount",get:function(){return e.circleVertexCount+2+e.circlePositionCount}}]),e}();function el(e,t){return(el=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ec(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&el(e,t)}function eh(e,t,n,r){var a,i=arguments.length,o=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var s=e.length-1;s>=0;s--)(a=e[s])&&(o=(i<3?a(o):i>3?a(t,n,o):a(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o}es._shift=new t.Vector3,es.circleVertexCount=40,"function"==typeof SuppressedError&&SuppressedError;var ed=function(){function e(){}return e.replaceShader=function(n){n.shader=t.Shader.find("planarShadowShader");var r=n.renderStates[1];r.renderQueueType=t.RenderQueueType.Transparent,r.depthState.writeEnabled=!1;var a=r.blendState.targetBlendState;a.enabled=!0,a.sourceColorBlendFactor=t.BlendFactor.SourceAlpha,a.destinationColorBlendFactor=t.BlendFactor.OneMinusSourceAlpha,a.sourceAlphaBlendFactor=t.BlendFactor.One,a.destinationAlphaBlendFactor=t.BlendFactor.OneMinusSourceAlpha;var i=r.stencilState;i.enabled=!0,i.referenceValue=0,i.compareFunctionFront=t.CompareFunction.Equal,i.compareFunctionBack=t.CompareFunction.Equal,i.failOperationFront=t.StencilOperation.Keep,i.failOperationBack=t.StencilOperation.Keep,i.zFailOperationFront=t.StencilOperation.Keep,i.zFailOperationBack=t.StencilOperation.Keep,i.passOperationFront=t.StencilOperation.IncrementWrap,i.passOperationBack=t.StencilOperation.IncrementWrap;var o=n.shaderData;o.setFloat(e._shadowFalloffProp,0),o.setColor(e._shadowColorProp,new t.Color(1,1,1,1)),o.setVector3(e._lightDirProp,new t.Vector3(0,0,0)),o.setFloat(e._planarHeightProp,0)},e.setPlanarHeight=function(t,n){t.shaderData.setFloat(e._planarHeightProp,n)},e.setLightDirection=function(t,n){var r=t.shaderData.getVector3(e._lightDirProp);n!==r?r.copyFrom(n.normalize()):n.normalize()},e.setShadowColor=function(t,n){var r=t.shaderData.getColor(e._shadowColorProp);n!==r&&r.copyFrom(n)},e.setShadowFalloff=function(t,n){t.shaderData.setFloat(e._shadowFalloffProp,n)},e}();ed._lightDirProp=t.ShaderProperty.getByName("u_lightDir"),ed._planarHeightProp=t.ShaderProperty.getByName("u_planarHeight"),ed._shadowColorProp=t.ShaderProperty.getByName("u_planarShadowColor"),ed._shadowFalloffProp=t.ShaderProperty.getByName("u_planarShadowFalloff");var eu=new t.ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ","\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");function e_(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ef(e,t,n){return t&&e_(e.prototype,t),n&&e_(e,n),e}function ep(e,t){return(ep=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function em(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&ep(e,t)}t.Shader.create("planarShadowShader",[t.Shader.find("pbr").subShaders[0].passes[0],eu]);var eg=function(e){function n(r){(a=e.call(this,r,t.Shader.find("grid"))||this).isTransparent=!0;var a,i=a.shaderData;return i.setFloat(n._nearClipProperty,.1),i.setFloat(n._farClipProperty,100),i.setFloat(n._primaryScaleProperty,10),i.setFloat(n._secondaryScaleProperty,1),i.setFloat(n._gridIntensityProperty,.2),i.setFloat(n._axisIntensityProperty,.1),i.setFloat(n._flipProgressProperty,0),i.setFloat(n._fadeProperty,0),a}return em(n,e),ef(n,[{key:"nearClipPlane",get:function(){return this.shaderData.getFloat(n._nearClipProperty)},set:function(e){this.shaderData.setFloat(n._nearClipProperty,e)}},{key:"farClipPlane",get:function(){return this.shaderData.getFloat(n._farClipProperty)},set:function(e){this.shaderData.setFloat(n._farClipProperty,e)}},{key:"primaryScale",get:function(){return this.shaderData.getFloat(n._primaryScaleProperty)},set:function(e){this.shaderData.setFloat(n._primaryScaleProperty,e)}},{key:"secondaryScale",get:function(){return this.shaderData.getFloat(n._secondaryScaleProperty)},set:function(e){this.shaderData.setFloat(n._secondaryScaleProperty,e)}},{key:"gridIntensity",get:function(){return this.shaderData.getFloat(n._gridIntensityProperty)},set:function(e){this.shaderData.setFloat(n._gridIntensityProperty,e)}},{key:"axisIntensity",get:function(){return this.shaderData.getFloat(n._axisIntensityProperty)},set:function(e){this.shaderData.setFloat(n._axisIntensityProperty,e)}},{key:"flipProgress",get:function(){return this.shaderData.getFloat(n._flipProgressProperty)},set:function(e){this.shaderData.setFloat(n._flipProgressProperty,t.MathUtil.clamp(e,0,1))}},{key:"fade",get:function(){return this.shaderData.getFloat(n._fadeProperty)},set:function(e){this.shaderData.setFloat(n._fadeProperty,t.MathUtil.clamp(e,0,1))}}]),n}(t.BaseMaterial);eg._farClipProperty=t.ShaderProperty.getByName("u_far"),eg._nearClipProperty=t.ShaderProperty.getByName("u_near"),eg._primaryScaleProperty=t.ShaderProperty.getByName("u_primaryScale"),eg._secondaryScaleProperty=t.ShaderProperty.getByName("u_secondaryScale"),eg._gridIntensityProperty=t.ShaderProperty.getByName("u_gridIntensity"),eg._axisIntensityProperty=t.ShaderProperty.getByName("u_axisIntensity"),eg._flipProgressProperty=t.ShaderProperty.getByName("u_flipProgress"),eg._fadeProperty=t.ShaderProperty.getByName("u_fade"),t.Shader.create("grid","\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}","\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");var eA=function(){function e(){}return e.createGridPlane=function(n){var r=new t.ModelMesh(n);return e._updateGridData(r),n.resourceManager.addContentRestorer(new ev(r)),r},e._updateGridData=function(e){var n=new Float32Array([-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,1,-1,1]);e.setVertexElements([new t.VertexElement("POSITION_FLIP",0,t.VertexElementFormat.Vector4,0)]),e.setVertexBufferBinding(new t.Buffer(e.engine,t.BufferBindFlag.VertexBuffer,n,t.BufferUsage.Static),16),e.addSubMesh(0,4,t.MeshTopology.TriangleStrip);var r=e.bounds;return r.min.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),r.max.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e},e}(),ev=function(e){function t(t){return e.call(this,t)}return em(t,e),t.prototype.restoreContent=function(){eA._updateGridData(this.resource)},t}(t.ContentRestorer),eC=function(e){function n(){var t;return t=e.apply(this,arguments)||this,t._progress=0,t._is2DGrid=!1,t._flipGrid=!1,t.speed=10,t.camera=null,t.distance=8,t}em(n,e);var r=n.prototype;return r.onAwake=function(){var e=this.engine,n=this.entity.addComponent(t.MeshRenderer);n.receiveShadows=!1,n.castShadows=!1,n.mesh=eA.createGridPlane(e),this._material=new eg(e),n.setMaterial(this._material)},r.onUpdate=function(e){var n=this._material,r=this.camera;if(null!==r){n.nearClipPlane=r.nearClipPlane,n.farClipPlane=r.farClipPlane;var a=Math.log2(this.distance),i=Math.pow(2,Math.floor(a));n.fade=(this.distance-i)/(Math.pow(2,Math.floor(a)+1)-i);var o=-Math.floor(a);if(n.primaryScale=Math.pow(2,o),n.secondaryScale=Math.pow(2,o+1),n.axisIntensity=.3/n.primaryScale,this._flipGrid){this._progress+=e;var s=t.MathUtil.clamp(this._progress*this.speed,0,1);s>=1&&(this._flipGrid=!1),this._is2DGrid||(s=1-s),n.flipProgress=s}}},ef(n,[{key:"material",get:function(){return this._material}},{key:"is2DGrid",get:function(){return this._is2DGrid},set:function(e){this._is2DGrid=e,this._progress=0,this._flipGrid=!0}}]),n}(t.Script);t.Shader.create("water-ripple","\n  attribute vec3 POSITION;\n  attribute vec2 TEXCOORD_0;\n  attribute vec4 COLOR_0;\n  uniform mat4 renderer_MVPMat;\n  \n  uniform float u_time;\n  uniform vec2 u_foam_speed; \n  uniform vec2 u_distorsion_speed; \n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  varying vec4 v_color;\n      \n  void main() {\n    gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    waterTexCoords = TEXCOORD_0 + vec2(u_foam_speed.x * u_time, u_foam_speed.y * u_time);\n    normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));\n    v_color = COLOR_0; \n  }\n  ","\n  #include <common>\n  varying vec4 v_color;\n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  uniform sampler2D material_NormalTexture;\n  uniform sampler2D u_foamTex;\n  uniform vec3 u_foamColor;\n  uniform vec2 u_foam_param;\n  uniform float u_distorsion_amount;\n  void main() {  \n    vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n    vec4 waterTex = texture2D(u_foamTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n    float alphaComp = v_color.r * waterTex.r * u_foam_param.x;\n    float alpha = pow(alphaComp,2.0);\n    alpha = smoothstep(0.5 - u_foam_param.y, 0.5+ u_foam_param.y, alpha);\n    alpha = saturate(alpha);\n    \n    gl_FragColor = vec4(u_foamColor.rgb, alpha);\n  }\n  ");var ey=function(e){function n(r){(a=e.call(this,r,t.Shader.find("water-ripple"))||this).isTransparent=!0;var a,i=a.shaderData;return i.setVector3(n._foamColor,new t.Vector3(.81,1.0275,1.255)),i.setVector2(n._foamSpeed,new t.Vector2(-1,.3)),i.setVector2(n._foamParam,new t.Vector2(2,.05)),i.setVector2(n._distorsionSpeed,new t.Vector2(1,0)),i.setFloat(n._distorsionAmount,.03),a}return em(n,e),ef(n,[{key:"foamTexture",get:function(){return this.shaderData.getTexture(n._foamTextureProp)},set:function(e){this.shaderData.setTexture(n._foamTextureProp,e)}},{key:"normalTexture",get:function(){return this.shaderData.getTexture(n._normalTextureProp)},set:function(e){this.shaderData.setTexture(n._normalTextureProp,e)}},{key:"foamColor",get:function(){return this.shaderData.getVector3(n._foamColor)},set:function(e){this.shaderData.setVector3(n._foamColor,e)}},{key:"foamSpeed",get:function(){return this.shaderData.getVector2(n._foamSpeed)},set:function(e){this.shaderData.setVector2(n._foamSpeed,e)}},{key:"foamParam",get:function(){return this.shaderData.getVector2(n._foamParam)},set:function(e){this.shaderData.setVector2(n._foamParam,e)}},{key:"distorsionSpeed",get:function(){return this.shaderData.getVector2(n._distorsionSpeed)},set:function(e){this.shaderData.setVector2(n._distorsionSpeed,e)}},{key:"distorsionAmount",get:function(){return this.shaderData.getFloat(n._distorsionAmount)},set:function(e){this.shaderData.setFloat(n._distorsionAmount,e)}}]),n}(t.BaseMaterial);ey._foamColor=t.ShaderProperty.getByName("u_foamColor"),ey._foamSpeed=t.ShaderProperty.getByName("u_foam_speed"),ey._foamParam=t.ShaderProperty.getByName("u_foam_param"),ey._distorsionSpeed=t.ShaderProperty.getByName("u_distorsion_speed"),ey._distorsionAmount=t.ShaderProperty.getByName("u_distorsion_amount"),ey._foamTextureProp=t.ShaderProperty.getByName("u_foamTex"),t.Shader.create("water","\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n\n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_distorsion_speed; \n    \n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * sin(u_time), u_water_speed.y * cos(u_time));\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));     \n      \n      v_color = COLOR_0;\n    }\n    ","\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_edgeTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {\n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 edgeTex = texture2D(u_edgeTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      float edge = pow((v_color.r + edgeTex.r) * v_color.r, 2.0);\n      edge = saturate(1.0 - smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edge));\n      vec4 finalCol = mix(waterTex, u_edgeColor, edge);\n  \n      gl_FragColor = finalCol;\n    }\n    ");var ex=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("water"))||this).shaderData.setVector2(n._waterSpeed,new t.Vector2(-.02,.02)),a.shaderData.setVector4(n._edgeColor,new t.Vector4(324/510,411/510,502/510,1)),a.shaderData.setVector2(n._edgeParam,new t.Vector2(.008,.002)),a.shaderData.setFloat(n._distorsionAmount,.02),a.shaderData.setVector2(n._distorsionSpeed,new t.Vector2(.2,.2)),a}return em(n,e),ef(n,[{key:"normalTexture",get:function(){return this.shaderData.getTexture(n._normalTextureProp)},set:function(e){this.shaderData.setTexture(n._normalTextureProp,e)}},{key:"waterTexture",get:function(){return this.shaderData.getTexture(n._waterTextureProp)},set:function(e){this.shaderData.setTexture(n._waterTextureProp,e)}},{key:"edgeTexture",get:function(){return this.shaderData.getTexture(n._edgeTextureProp)},set:function(e){this.shaderData.setTexture(n._edgeTextureProp,e)}},{key:"waterSpeed",get:function(){return this.shaderData.getVector2(n._waterSpeed)},set:function(e){this.shaderData.setVector2(n._waterSpeed,e)}},{key:"edgeColor",get:function(){return this.shaderData.getVector4(n._edgeColor)},set:function(e){this.shaderData.setVector4(n._edgeColor,e)}},{key:"edgeParam",get:function(){return this.shaderData.getVector2(n._edgeParam)},set:function(e){this.shaderData.setVector2(n._edgeParam,e)}},{key:"distorsionAmount",get:function(){return this.shaderData.getFloat(n._distorsionAmount)},set:function(e){this.shaderData.setFloat(n._distorsionAmount,e)}},{key:"distorsionSpeed",get:function(){return this.shaderData.getVector2(n._distorsionSpeed)},set:function(e){this.shaderData.setVector2(n._distorsionSpeed,e)}}]),n}(t.BaseMaterial);ex._waterSpeed=t.ShaderProperty.getByName("u_water_speed"),ex._edgeColor=t.ShaderProperty.getByName("u_edgeColor"),ex._edgeParam=t.ShaderProperty.getByName("u_edgeParam"),ex._distorsionAmount=t.ShaderProperty.getByName("u_distorsion_amount"),ex._distorsionSpeed=t.ShaderProperty.getByName("u_distorsion_speed"),ex._waterTextureProp=t.ShaderProperty.getByName("u_waterTex"),ex._edgeTextureProp=t.ShaderProperty.getByName("u_edgeTex"),t.Shader.create("water-fall","\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ","\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ");var eE=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("water-fall"))||this).shaderData.setVector2(n._waterSpeed,new t.Vector2(.2,0)),a.shaderData.setVector2(n._waterfallSpeed,new t.Vector2(.9,0)),a.shaderData.setVector4(n._edgeColor,new t.Vector4(160/255,250/255,250/255,1)),a.shaderData.setVector2(n._edgeParam,new t.Vector2(.7,.05)),a.shaderData.setFloat(n._distorsionAmount,.03),a.shaderData.setVector2(n._distorsionSpeed,new t.Vector2(1,1)),a}return em(n,e),ef(n,[{key:"normalTexture",get:function(){return this.shaderData.getTexture(n._normalTextureProp)},set:function(e){this.shaderData.setTexture(n._normalTextureProp,e)}},{key:"waterTexture",get:function(){return this.shaderData.getTexture(n._waterTextureProp)},set:function(e){this.shaderData.setTexture(n._waterTextureProp,e)}},{key:"waterfallTexture",get:function(){return this.shaderData.getTexture(n._waterfallTextureProp)},set:function(e){this.shaderData.setTexture(n._waterfallTextureProp,e)}},{key:"edgeNoiseTexture",get:function(){return this.shaderData.getTexture(n._edgeTextureProp)},set:function(e){this.shaderData.setTexture(n._edgeTextureProp,e)}},{key:"waterSpeed",get:function(){return this.shaderData.getVector2(n._waterSpeed)},set:function(e){this.shaderData.setVector2(n._waterSpeed,e)}},{key:"waterfallSpeed",get:function(){return this.shaderData.getVector2(n._waterfallSpeed)},set:function(e){this.shaderData.setVector2(n._waterfallSpeed,e)}},{key:"edgeColor",get:function(){return this.shaderData.getVector4(n._edgeColor)},set:function(e){this.shaderData.setVector4(n._edgeColor,e)}},{key:"edgeParam",get:function(){return this.shaderData.getVector2(n._edgeParam)},set:function(e){this.shaderData.setVector2(n._edgeParam,e)}},{key:"distorsionAmount",get:function(){return this.shaderData.getFloat(n._distorsionAmount)},set:function(e){this.shaderData.setFloat(n._distorsionAmount,e)}},{key:"distorsionSpeed",get:function(){return this.shaderData.getVector2(n._distorsionSpeed)},set:function(e){this.shaderData.setVector2(n._distorsionSpeed,e)}}]),n}(t.BaseMaterial);eE._waterSpeed=t.ShaderProperty.getByName("u_water_speed"),eE._waterfallSpeed=t.ShaderProperty.getByName("u_waterfall_speed"),eE._distorsionSpeed=t.ShaderProperty.getByName("u_distorsion_speed"),eE._edgeColor=t.ShaderProperty.getByName("u_edgeColor"),eE._edgeParam=t.ShaderProperty.getByName("u_edgeParam"),eE._distorsionAmount=t.ShaderProperty.getByName("u_distorsion_amount"),eE._waterTextureProp=t.ShaderProperty.getByName("u_waterTex"),eE._waterfallTextureProp=t.ShaderProperty.getByName("u_waterfallTex"),eE._edgeTextureProp=t.ShaderProperty.getByName("u_edgeNoiseTex"),t.Shader.create("bake-pbr","\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n","\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n");var eS=function(e){function n(r){var a;return(a=e.call(this,r)||this).shader=t.Shader.find("bake-pbr"),a.shaderData.setFloat(n._lightMapIntensityProp,1),a}return em(n,e),n.prototype.clone=function(){var e=new n(this._engine);return this.cloneTo(e),e},ef(n,[{key:"lightmapTexture",get:function(){return this.shaderData.getTexture(n._lightMapTextureProp)},set:function(e){this.shaderData.setTexture(n._lightMapTextureProp,e),e?this.shaderData.enableMacro("LIGHTMAP_TEXTURE"):this.shaderData.disableMacro("LIGHTMAP_TEXTURE")}},{key:"lightmapIntensity",get:function(){return this.shaderData.getFloat(n._lightMapIntensityProp)},set:function(e){this.shaderData.setFloat(n._lightMapIntensityProp,e)}}]),n}(t.PBRMaterial);eS._lightMapTextureProp=t.ShaderProperty.getByName("u_lightMapTexture"),eS._lightMapIntensityProp=t.ShaderProperty.getByName("u_lightMapIntensity");var eM=function(e){function n(r){var a,i=(a=e.call(this,r,t.Shader.find("plain-color"))||this).shaderData;return i.enableMacro("MATERIAL_OMIT_NORMAL"),i.setColor(n._baseColorProp,new t.Color(1,1,1,1)),a.renderState.rasterState.cullMode=t.CullMode.Off,a}return em(n,e),n.prototype.clone=function(){var e=new n(this._engine);return this.cloneTo(e),e},ef(n,[{key:"baseColor",get:function(){return this.shaderData.getColor(n._baseColorProp)},set:function(e){var t=this.shaderData.getColor(n._baseColorProp);e!==t&&t.copyFrom(e)}}]),n}(t.BaseMaterial);function eT(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):q(e,t)}t.Shader.create("plain-color","\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n\nvoid main() {\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n}\n","\n#include <common>\n\nuniform vec4 material_BaseColor;\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n     #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n}\n"),e.WireframeManager=function(e){function n(){var n;return n=e.apply(this,arguments)||this,n._cameraPositions=[new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3,new t.Vector3],n._localPositions=[],n._globalPositions=[],n._indices=null,n._indicesCount=0,n._boundsIndicesCount=0,n._wireframeRenderers=[],n._wireframeElements=[],n}ec(n,e);var r=n.prototype;return r.clear=function(){this._wireframeRenderers.length=0,this._wireframeElements.length=0,this._localPositions.length=0,this._globalPositions.length=0,this._indicesCount=0,this._mesh.subMesh.count=0},r.addEntityWireframe=function(e,n){if(void 0===n&&(n=!0),n){var r=[];e.getComponentsIncludeChildren(t.Camera,r);for(var a=0,i=r.length;a<i;a++)this.addCameraWireframe(r[a]);var o=r.length;e.getComponentsIncludeChildren(t.SpotLight,r);for(var s=o,l=r.length;s<l;s++)this.addSpotLightWireframe(r[s]);o=r.length,e.getComponentsIncludeChildren(t.DirectLight,r);for(var c=o,h=r.length;c<h;c++)this.addDirectLightWireframe(r[c]);o=r.length,e.getComponentsIncludeChildren(t.PointLight,r);for(var d=o,u=r.length;d<u;d++)this.addPointLightWireframe(r[d]);o=r.length,e.getComponentsIncludeChildren(t.Collider,r);for(var _=o,f=r.length;_<f;_++)this.addCollideWireframe(r[_]);o=r.length,e.getComponentsIncludeChildren(t.ParticleRenderer,r);for(var p=o,m=r.length;p<m;p++)this.addParticleRendererEmissionShapeWireframe(r[p])}else{var g=e.getComponent(t.Camera);g&&this.addCameraWireframe(g);var A=e.getComponent(t.SpotLight);A&&this.addSpotLightWireframe(A);var v=e.getComponent(t.DirectLight);v&&this.addDirectLightWireframe(v);var C=e.getComponent(t.PointLight);C&&this.addPointLightWireframe(C);var y=e.getComponent(t.Collider);y&&this.addCollideWireframe(y);var x=e.getComponent(t.ParticleRenderer);x&&this.addParticleRendererEmissionShapeWireframe(x)}},r.addCameraWireframe=function(e){var t=e.entity.transform,r=e.projectionMatrix.clone();r.invert();var a=this._localPositions,i=a.length;this._wireframeElements.push(new eI(t,i));for(var o=n._ndcPosition,s=0;s<4;s++){var l=this._cameraPositions[s];l.copyFrom(o[s]),l.transformCoordinate(r),a.push(l)}for(var c=0;c<4;c++){var h=this._cameraPositions[c+4];h.copyFrom(o[c]),h.z=1,h.transformCoordinate(r),a.push(h)}this._growthIndexMemory(24);var d=this._indices;d[this._indicesCount++]=i,d[this._indicesCount++]=i+1,d[this._indicesCount++]=i+1,d[this._indicesCount++]=i+2,d[this._indicesCount++]=i+2,d[this._indicesCount++]=i+3,d[this._indicesCount++]=i+3,d[this._indicesCount++]=i,d[this._indicesCount++]=i,d[this._indicesCount++]=i+4,d[this._indicesCount++]=i+1,d[this._indicesCount++]=i+5,d[this._indicesCount++]=i+2,d[this._indicesCount++]=i+6,d[this._indicesCount++]=i+3,d[this._indicesCount++]=i+7,d[this._indicesCount++]=i+4,d[this._indicesCount++]=i+5,d[this._indicesCount++]=i+5,d[this._indicesCount++]=i+6,d[this._indicesCount++]=i+6,d[this._indicesCount++]=i+7,d[this._indicesCount++]=i+7,d[this._indicesCount++]=i+4},r.addSpotLightWireframe=function(e){var t=e.distance,n=Math.tan(e.angle/2)*t,r=this._localPositions.length,a=es.coneIndexCount;this._growthIndexMemory(a),this._growthPosition(es.conePositionCount);var i=this._indices,o=this._localPositions;es.createConeWireframe(n,t,o,r,i,this._indicesCount),this._indicesCount+=a,this._rotateAroundX(r),this._wireframeElements.push(new eI(e.entity.transform,r))},r.addPointLightWireframe=function(e){var t=this._localPositions.length,n=es.sphereIndexCount;this._growthIndexMemory(n),this._growthPosition(es.spherePositionCount);var r=this._indices,a=this._localPositions;es.createSphereWireframe(e.distance,a,t,r,this._indicesCount),this._indicesCount+=n,this._wireframeElements.push(new eI(e.entity.transform,t))},r.addDirectLightWireframe=function(e){var t=this._localPositions.length,n=es.unboundCylinderIndexCount;this._growthIndexMemory(n),this._growthPosition(es.unboundCylinderPositionCount);var r=this._indices,a=this._localPositions;es.createUnboundCylinderWireframe(1,a,t,r,this._indicesCount),this._indicesCount+=n,this._rotateAroundX(t),this._wireframeElements.push(new eI(e.entity.transform,t))},r.addRendererWireframe=function(e){this._boundsIndicesCount+=es.cuboidIndexCount,this._wireframeRenderers.push(e)},r.addCollideWireframe=function(e){for(var n=e.shapes,r=0,a=n.length;r<a;r++){var i=n[r];eT(i,t.BoxColliderShape)?this.addBoxColliderShapeWireframe(i):eT(i,t.SphereColliderShape)?this.addSphereColliderShapeWireframe(i):eT(i,t.CapsuleColliderShape)&&this.addCapsuleColliderShapeWireframe(i)}},r.addBoxColliderShapeWireframe=function(e){var r=e.collider.entity.transform,a=r.lossyWorldScale,i=e.position,o=e.rotation,s=e.size,l=n._tempVector,c=n._tempRotation,h=this._localPositions.length,d=es.cuboidIndexCount;this._growthIndexMemory(d),this._growthPosition(es.cuboidPositionCount);var u=this._indices,_=this._localPositions;es.createCuboidWireframe(a.x*s.x,a.y*s.y,a.z*s.z,_,h,u,this._indicesCount),t.Quaternion.rotationYawPitchRoll(o.x,o.y,o.z,c),this._localRotation(h,c),t.Vector3.multiply(i,a,l),this._localTranslate(h,l),this._indicesCount+=d,this._wireframeElements.push(new eI(r,h))},r.addSphereColliderShapeWireframe=function(e){var r=e.collider.entity.transform,a=r.lossyWorldScale,i=e.position,o=e.rotation,s=e.radius,l=n._tempVector,c=n._tempRotation,h=this._localPositions.length,d=es.sphereIndexCount;this._growthIndexMemory(d),this._growthPosition(es.spherePositionCount);var u=this._indices,_=this._localPositions;es.createSphereWireframe(Math.max(a.x,a.y,a.z)*s,_,h,u,this._indicesCount),t.Quaternion.rotationYawPitchRoll(o.x,o.y,o.z,c),this._localRotation(h,c),t.Vector3.multiply(i,a,l),this._localTranslate(h,l),this._indicesCount+=d,this._wireframeElements.push(new eI(r,h))},r.addCapsuleColliderShapeWireframe=function(e){var r=e.collider.entity.transform,a=r.lossyWorldScale,i=Math.max(a.x,a.y,a.z),o=e.radius,s=e.height,l=e.upAxis,c=e.position,h=e.rotation,d=n._tempVector,u=n._tempRotation,_=n._tempAxis,f=n._halfSqrt,p=this._localPositions.length,m=es.capsuleIndexCount;this._growthIndexMemory(m),this._growthPosition(es.capsulePositionCount);var g=this._indices,A=this._localPositions;switch(es.createCapsuleWireframe(i*o,i*s,A,p,g,this._indicesCount),l){case t.ColliderShapeUpAxis.X:_.set(0,0,f,f);break;case t.ColliderShapeUpAxis.Y:_.set(0,0,0,1);break;case t.ColliderShapeUpAxis.Z:_.set(f,0,0,f)}t.Quaternion.rotationYawPitchRoll(h.x,h.y,h.z,u),t.Quaternion.multiply(u,_,u),this._localRotation(p,u),t.Vector3.multiply(c,a,d),this._localTranslate(p,d),this._indicesCount+=m,this._wireframeElements.push(new eI(r,p))},r.addParticleRendererEmissionShapeWireframe=function(e){if(e.generator.emission.enabled){var t=e.generator.emission.shape,n=e.entity.transform;switch(null==t?void 0:t.shapeType){case 0:this.addBoxParticleShapeWireframe(t,n);break;case 1:this.addCircleParticleShapeWireframe(t,n);break;case 2:this.addConeParticleShapeWireframe(t,n);break;case 3:this.addHemisphereParticleShapeWireframe(t,n);break;case 4:this.addSphereParticleShapeWireframe(t,n)}}},r.addBoxParticleShapeWireframe=function(e,t){var n=e.size,r=this._localPositions.length,a=es.cuboidIndexCount;this._growthIndexMemory(a),this._growthPosition(es.cuboidPositionCount);var i=this._indices,o=this._localPositions;es.createCuboidWireframe(n.x,n.y,n.z,o,r,i,this._indicesCount),this._indicesCount+=a,this._wireframeElements.push(new eI(t,r,!1))},r.addCircleParticleShapeWireframe=function(e,n){var r=e.radius,a=this._localPositions.length,i=es.circleIndexCount;this._growthIndexMemory(i),this._growthPosition(es.circlePositionCount);var o=this._indices,s=this._localPositions;es.createCircleWireframe(r,0,new t.Vector3,s,a,o,this._indicesCount),this._indicesCount+=i,this._wireframeElements.push(new eI(n,a,!1))},r.addConeParticleShapeWireframe=function(e,t){var n=e.radius,r=e.length,a=e.angle,i=this._localPositions.length,o=es.frustumIndexCount;this._growthIndexMemory(o),this._growthPosition(es.frustumPositionCount);var s=this._indices,l=this._localPositions;es.createFrustumWireframe(n,r,a,l,i,s,this._indicesCount),this._indicesCount+=o,this._wireframeElements.push(new eI(t,i,!1))},r.addHemisphereParticleShapeWireframe=function(e,t){var n=e.radius,r=this._localPositions.length,a=es.hemisphereIndexCount;this._growthIndexMemory(a),this._growthPosition(es.hemispherePositionCount);var i=this._indices,o=this._localPositions;es.createHemisphereWireframe(n,2,o,r,i,this._indicesCount),this._indicesCount+=a,this._wireframeElements.push(new eI(t,r,!1))},r.addSphereParticleShapeWireframe=function(e,t){var n=e.radius,r=this._localPositions.length,a=es.sphereIndexCount;this._growthIndexMemory(a),this._growthPosition(es.spherePositionCount);var i=this._indices,o=this._localPositions;es.createSphereWireframe(n,o,r,i,this._indicesCount),this._indicesCount+=a,this._wireframeElements.push(new eI(t,r,!1))},r.onAwake=function(){var e=this.engine,n=new t.ModelMesh(e),r=new eM(e),a=this.entity.getComponent(t.MeshRenderer);a.castShadows=!1,a.receiveShadows=!1;var i=e._hardwareRenderer.canIUse(t.GLCapabilityType.elementIndexUint);n.addSubMesh(0,this._indicesCount,t.MeshTopology.Lines),a.mesh=n,a.setMaterial(r);var o=n.bounds;o.min.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),o.max.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._mesh=n,this._material=r,this._renderer=a,this._indices=i?new Uint32Array(128):new Uint16Array(128),this._supportUint32Array=i},r.onEnable=function(){this._renderer.enabled=!0},r.onDisable=function(){this._renderer.enabled=!1},r.onLateUpdate=function(e){var r=this._mesh,a=this._localPositions,i=this._globalPositions,o=this._wireframeElements,s=this._wireframeRenderers,l=this._indices,c=a.length;i.length=c;for(var h=0,d=!1,u=0,_=o.length;u<_;u++){var f=o[u],p=f.transformRanges,m=u<_-1?o[u+1].transformRanges:c;if(f.updateFlag.flag){var g=f.transform,A=n._tempMatrix;f.isScaleIgnored?t.Matrix.rotationTranslation(g.worldRotationQuaternion,g.worldPosition,A):A.copyFrom(g.worldMatrix);for(var v=p;v<m;v++){var C=a[h],y=n._getPositionFromPool(h);t.Vector3.transformCoordinate(C,A,y),i[h]=y,h++}f.updateFlag.flag=!1,d=!0}else h+=m-p}this._growthIndexMemory(this._boundsIndicesCount);for(var x=this._indicesCount,E=0;E<s.length;E++){var S=s[E].bounds,M=n._tempVector;S.getExtent(M);var T=i.length;es.createCuboidWireframe(2*M.x,2*M.y,2*M.z,i,T,l,x),S.getCenter(M);for(var I=T;I<i.length;I++)i[I].add(M);x+=es.cuboidIndexCount}(s.length>0||d)&&(r.setPositions(i),r.setIndices(this._indices),r.uploadData(!1),r.subMesh.count=x),0===x?this._renderer.setMaterial(null):this._renderer.setMaterial(this._material)},r._growthIndexMemory=function(e){var t=this._indices,n=this._indicesCount+e;if(n>t.length){if(n>(this._supportUint32Array?4294967295:65535))throw Error("The vertex count is over limit.");var r=this._supportUint32Array?new Uint32Array(n):new Uint16Array(n);r.set(t),this._indices=r}},r._growthPosition=function(e){for(var n=this._localPositions,r=0;r<e;r++)n.push(new t.Vector3)},r._localTranslate=function(e,t){for(var n=this._localPositions,r=e;r<n.length;r++)n[r].add(t)},r._localRotation=function(e,n){for(var r=this._localPositions,a=e;a<r.length;a++){var i=r[a];t.Vector3.transformByQuat(i,n,i)}},r._rotateAroundX=function(e){for(var t=this._localPositions,n=e;n<t.length;n++){var r=t[n],a=r.y,i=r.z;r.z=a,r.y=-i}},n._getPositionFromPool=function(e){var r,a=n._positionPool;return e<a.length?r=a[e]:(r=new t.Vector3,n._positionPool.push(r)),r},eo(n,[{key:"baseColor",get:function(){return this._material.baseColor},set:function(e){this._material.baseColor=e}}]),n}(t.Script),e.WireframeManager._positionPool=[],e.WireframeManager._ndcPosition=[new t.Vector3(-1,1,-1),new t.Vector3(1,1,-1),new t.Vector3(1,-1,-1),new t.Vector3(-1,-1,-1)],e.WireframeManager._tempMatrix=new t.Matrix,e.WireframeManager._tempVector=new t.Vector3,e.WireframeManager._tempRotation=new t.Quaternion,e.WireframeManager._tempAxis=new t.Quaternion,e.WireframeManager._halfSqrt=.70710678118655,e.WireframeManager=eh([t.dependentComponents(t.MeshRenderer,t.DependentMode.CheckOnly)],e.WireframeManager);var eI=function(e,t,n){void 0===n&&(n=!0),this.transform=e,this.transformRanges=t,this.isScaleIgnored=n,this.updateFlag=e.registerWorldChangeFlag()};function ew(e,t){return(ew=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}e.LineDrawer=function(e){function n(){return e.apply(this,arguments)}ec(n,e);var r=n.prototype;return r.onAwake=function(){var e=this.engine,r=new t.ModelMesh(e),a=new eM(e),i=this.entity.getComponent(t.MeshRenderer);i.castShadows=!1,i.receiveShadows=!1;var o=e._hardwareRenderer.canIUse(t.GLCapabilityType.elementIndexUint);r._enableVAO=!1,r.addSubMesh(0,n._indicesCount,t.MeshTopology.Lines),i.mesh=r,i.setMaterial(a);var s=r.bounds;s.min.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),s.max.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._mesh=r,this._material=a,this._renderer=i,n._indices=o?new Uint32Array(128):new Uint16Array(128),n._supportUint32Array=o},r.onLateUpdate=function(e){var t=this._mesh;n._positionCount>0?(t.setPositions(n._positions),t.setIndices(n._indices),t.uploadData(!1),t.subMesh.count=n._indicesCount,this._renderer.setMaterial(this._material)):this._renderer.setMaterial(null),n.flush()},n.drawLine=function(e,r){n._growthPosition(2),n._growthIndexMemory(2),n._indices[n._indicesCount++]=n._positionCount,n._indices[n._indicesCount++]=n._positionCount+1,null==n.matrix?(n._positions[n._positionCount++].copyFrom(e),n._positions[n._positionCount++].copyFrom(r)):(t.Vector3.transformCoordinate(e,n.matrix,n._positions[n._positionCount++]),t.Vector3.transformCoordinate(r,n.matrix,n._positions[n._positionCount++]))},n.drawRect=function(e,r,a,i){n._growthPosition(4),n._growthIndexMemory(8),n._indices[n._indicesCount++]=n._positionCount,n._indices[n._indicesCount++]=n._positionCount+1,n._indices[n._indicesCount++]=n._positionCount+2,n._indices[n._indicesCount++]=n._positionCount+1,n._indices[n._indicesCount++]=n._positionCount+2,n._indices[n._indicesCount++]=n._positionCount+3,n._indices[n._indicesCount++]=n._positionCount,n._indices[n._indicesCount++]=n._positionCount+3,null==n.matrix?(n._positions[n._positionCount++].copyFrom(e),n._positions[n._positionCount++].copyFrom(r),n._positions[n._positionCount++].copyFrom(a),n._positions[n._positionCount++].copyFrom(i)):(t.Vector3.transformCoordinate(e,n.matrix,n._positions[n._positionCount++]),t.Vector3.transformCoordinate(r,n.matrix,n._positions[n._positionCount++]),t.Vector3.transformCoordinate(a,n.matrix,n._positions[n._positionCount++]),t.Vector3.transformCoordinate(i,n.matrix,n._positions[n._positionCount++]))},n.drawSphere=function(e,r){var a=es.spherePositionCount,i=es.sphereIndexCount,o=n._positions;n._growthPosition(a),n._growthIndexMemory(i),es.createSphereWireframe(e,o,n._positionCount,n._indices,n._indicesCount);for(var s=0;s<a;s++){var l=o[n._positionCount+s];l.add(r),null!=n.matrix&&t.Vector3.transformCoordinate(l,n.matrix,l)}n._positionCount+=a,n._indicesCount+=i},n.drawCuboid=function(e,r,a,i){var o=es.cuboidPositionCount,s=es.cuboidIndexCount,l=n._positions;n._growthPosition(o),n._growthIndexMemory(s),es.createCuboidWireframe(e,r,a,l,n._positionCount,n._indices,n._indicesCount);for(var c=0;c<o;c++){var h=l[n._positionCount+c];h.add(i),null!=n.matrix&&t.Vector3.transformCoordinate(h,n.matrix,h)}n._positionCount+=o,n._indicesCount+=s},n.drawCapsule=function(e,r,a){var i=es.capsulePositionCount,o=es.capsuleIndexCount,s=n._positions;n._growthPosition(i),n._growthIndexMemory(o),es.createCapsuleWireframe(e,r,s,n._positionCount,n._indices,n._indicesCount);for(var l=0;l<i;l++){var c=s[n._positionCount+l];c.add(a),null!=n.matrix&&t.Vector3.transformCoordinate(c,n.matrix,c)}n._positionCount+=i,n._indicesCount+=o},n.drawCircle=function(e,r,a){es._shift.set(0,0,0);var i=es.circlePositionCount,o=es.circleIndexCount,s=n._positions;n._growthPosition(i),n._growthIndexMemory(o),es.createCircleWireframe(e,r,es._shift,s,n._positionCount,n._indices,n._indicesCount);for(var l=0;l<i;l++){var c=s[n._positionCount+l];c.add(a),null!=n.matrix&&t.Vector3.transformCoordinate(c,n.matrix,c)}n._positionCount+=i,n._indicesCount+=o},n.flush=function(){n._positionCount=0,n._indicesCount=0},n._growthIndexMemory=function(e){var t=n._indices,r=n._indicesCount+e;if(r>t.length){if(r>(n._supportUint32Array?4294967295:65535))throw Error("The vertex count is over limit.");var a=n._supportUint32Array?new Uint32Array(r):new Uint16Array(r);a.set(t),n._indices=a}},n._growthPosition=function(e){var r=n._positions,a=n._positionCount+e;if(a>r.length)for(var i=0,o=a-r.length;i<o;i++)r.push(new t.Vector3)},eo(n,[{key:"color",set:function(e){this._material.baseColor.copyFrom(e)}}]),n}(t.Script),e.LineDrawer._positions=[],e.LineDrawer._positionCount=0,e.LineDrawer._indicesCount=0,e.LineDrawer.matrix=null,e.LineDrawer=eh([t.dependentComponents(t.MeshRenderer,t.DependentMode.CheckOnly)],e.LineDrawer),e.AxisType=void 0,(c=e.AxisType||(e.AxisType={}))[c.X=0]="X",c[c.Y=1]="Y",c[c.Z=2]="Z";var eD=function(e){function n(n){(r=e.call(this,n)||this).midStep=.2,r.midWidthScale=.1,r.ballSize=.25,r.scaleFactor=.85,r.colorMin=new t.Color(.35,.35,.35,1),r.colorMax=new t.Color(.7,.7,.7,1),r._debugMesh=[];var r,a=n.engine;if(!eP.get(a)){var i=new t.Material(n.engine,t.Shader.find("skeleton-viewer"));i.renderState.rasterState.depthBias=-1e8,i.renderState.renderQueueType=t.RenderQueueType.Transparent,eP.set(a,i)}r._material=eP.get(a),r._material.shaderData.setColor("u_colorMin",r.colorMin),r._material.shaderData.setColor("u_colorMax",r.colorMax);var o=[];r.entity.getComponentsIncludeChildren(t.SkinnedMeshRenderer,o);for(var s=0;s<o.length;s++){var l=o[s];l.skin&&r._showSkeleton(l)}return r}!function(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&ew(e,t)}(n,e);var r=n.prototype;return r.onDestroy=function(){for(var e=0,t=this._debugMesh.length;e<t;e++)this._debugMesh[e].destroy();this._debugMesh.length=0},r.onEnable=function(){for(var e=0,t=this._debugMesh.length;e<t;e++)this._debugMesh[e].enabled=!0},r.onDisable=function(){for(var e=0,t=this._debugMesh.length;e<t;e++)this._debugMesh[e].enabled=!1},r._createSpur=function(e){var n=new t.ModelMesh(this.engine),r=e.length(),a=this.midStep*r,i=r*this.midWidthScale,o=Array(24),s=Array(24),l=new t.Matrix,c=new t.Quaternion;t.Matrix.lookAt(new t.Vector3(0,0,0),e,new t.Vector3(0,1,0),l),l.getRotation(c).invert();var h=[new t.Vector3(i,-i,-a).transformByQuat(c),new t.Vector3(i,i,-a).transformByQuat(c),new t.Vector3(-i,i,-a).transformByQuat(c),new t.Vector3(-i,-i,-a).transformByQuat(c),new t.Vector3(0,0,-r).transformByQuat(c),new t.Vector3(0,0,0)];o[0]=new t.Vector3(0,0,0),o[1]=h[0].clone(),o[2]=h[1].clone(),o[3]=new t.Vector3(0,0,0),o[4]=h[1].clone(),o[5]=h[2].clone(),o[6]=new t.Vector3(0,0,0),o[7]=h[2].clone(),o[8]=h[3].clone(),o[9]=new t.Vector3(0,0,0),o[10]=h[3].clone(),o[11]=h[0].clone(),o[12]=h[0].clone(),o[13]=h[4].clone(),o[14]=h[1].clone(),o[15]=h[1].clone(),o[16]=h[4].clone(),o[17]=h[2].clone(),o[18]=h[2].clone(),o[19]=h[4].clone(),o[20]=h[3].clone(),o[21]=h[3].clone(),o[22]=h[4].clone(),o[23]=h[0].clone(),s[0]=s[1]=s[2]=new t.Vector3(1,0,1).transformByQuat(c),s[3]=s[4]=s[5]=new t.Vector3(0,1,1).transformByQuat(c),s[6]=s[7]=s[8]=new t.Vector3(-1,0,1).transformByQuat(c),s[9]=s[10]=s[11]=new t.Vector3(0,-1,1).transformByQuat(c),s[12]=s[13]=s[14]=new t.Vector3(1,0,-1).transformByQuat(c),s[15]=s[16]=s[17]=new t.Vector3(0,1,-1).transformByQuat(c),s[18]=s[19]=s[20]=new t.Vector3(-1,0,-1).transformByQuat(c),s[21]=s[22]=s[23]=new t.Vector3(0,-1,-1).transformByQuat(c);var d=n.bounds,u=d.min,_=d.max;u.set(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY),_.set(-Number.NEGATIVE_INFINITY,-Number.NEGATIVE_INFINITY,-Number.NEGATIVE_INFINITY);for(var f=0;f<6;f++){var p=h[f];t.Vector3.min(u,p,u),t.Vector3.max(_,p,_)}return n.setPositions(o),n.setNormals(s),n.uploadData(!0),n.addSubMesh(0,24),n},r._showSkeleton=function(e){for(var n=e.bones,r=[],a=0,i=0;i<n.length;i++){var o=n[i],s=o.transform.worldPosition,l=o.createChild(),c=l.addComponent(t.MeshRenderer);c.receiveShadows=!1,c.castShadows=!1,c.mesh=t.PrimitiveMesh.createSphere(this.engine,this.ballSize,16),c.setMaterial(this._material),c.priority=1,r.push([l,o]),this._debugMesh.push(c);for(var h=0;h<o.children.length;h++){var d=o.children[h],u=d.transform.worldPosition.clone().subtract(s),_=d.transform.position,f=u.length();f>a&&(a=f);var p=o.addComponent(t.MeshRenderer);p.receiveShadows=!1,p.castShadows=!1,p.setMaterial(this._material),p.mesh=this._createSpur(_),p.priority=1,this._debugMesh.push(p)}}for(var m=0;m<r.length;m++){for(var g=r[m][0],A=r[m][1],v=0;A.parent;)v++,A=A.parent;var C=.5*a*Math.pow(this.scaleFactor,v),y=g.transform.lossyWorldScale;g.transform.setScale(C/y.x,C/y.y,C/y.z)}},n}(t.Script);t.Shader.create("skeleton-viewer","\n  attribute vec3 POSITION;\n  attribute vec3 NORMAL;\n\n  uniform mat4 renderer_MVPMat;\n  uniform mat4 renderer_NormalMat;\n\n  varying vec3 v_normal;\n\n  void main(){\n      gl_Position = renderer_MVPMat * vec4( POSITION , 1.0 );;\n      v_normal = normalize( mat3(renderer_NormalMat) * NORMAL );\n  }","\n      uniform vec3 u_colorMin;\n      uniform vec3 u_colorMax;\n      varying vec3 v_normal;\n\n      void main(){\n        float ndl = dot(v_normal, vec3(0, 1, 0)) * 0.5 + 0.5;\n        vec3 diffuse = mix(u_colorMin, u_colorMax, ndl);\n        gl_FragColor = vec4(diffuse, 1.0);\n      }\n      ");var eP=new Map;function eb(e){this.message=e}function eR(e,t,n,r,a,i,o){try{var s=e[i](o),l=s.value}catch(e){n(e);return}s.done?t(l):Promise.resolve(l).then(r,a)}function eN(e){return function(){var t=this,n=arguments;return new Promise(function(r,a){var i=e.apply(t,n);function o(e){eR(i,r,a,o,s,"next",e)}function s(e){eR(i,r,a,o,s,"throw",e)}o(void 0)})}}function eO(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function eL(e,t,n){return t&&eO(e.prototype,t),n&&eO(e,n),e}function eB(e,t){var n,r,a,i,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return i={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(s){return function(l){return function(s){if(n)throw TypeError("Generator is already executing.");for(;i&&(i=0,s[0]&&(o=0)),o;)try{if(n=1,r&&(a=2&s[0]?r.return:s[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,s[1])).done)return a;switch(r=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{n=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,l])}}}e.LineCap=void 0,(h=e.LineCap||(e.LineCap={}))[h.Round=0]="Round",h[h.Butt=1]="Butt",h[h.Square=2]="Square",e.LineJoin=void 0,(d=e.LineJoin||(e.LineJoin={}))[d.Miter=0]="Miter",d[d.Round=1]="Round",d[d.Bevel=2]="Bevel",eb.prototype=Error(),eb.prototype.name="InvalidCharacterError","function"==typeof SuppressedError&&SuppressedError;var eV="AGFzbQEAAAABbg1gAAF/YAAAYAF/AGAEfX19fQF9YAR9fX9/AGAFfX1/f38AYAp9fX9/f39/f39/AGAJfX19fX9/fX9/AGAHf39/f39/fwBgBX9/f39/AGANfX19fX9/f319fX9/fwBgCH9/f399f39/AGABfwF/AxQTAQMCBAUGBwgJCgsBAAAAAAIMAAQFAXABAgIFBgEBgAKAAgYTA38BQZCIwAILfwFBAAt/AUEACwf/AQ0GbWVtb3J5AgAQYnVpbGRfc29saWRfbGluZQAHD2J1aWxkX2Rhc2hfbGluZQAKC19pbml0aWFsaXplAAAZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAEF9fZXJybm9fbG9jYXRpb24AEhVlbXNjcmlwdGVuX3N0YWNrX2luaXQACxllbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlAAwZZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZQANGGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZAAOCXN0YWNrU2F2ZQAPDHN0YWNrUmVzdG9yZQAQCnN0YWNrQWxsb2MAEQkHAQBBAQsBAArdIBMEABALCw0AIAAgApQgASADlJILVwEEfQJAIAAqAgAiAiAClCAAKgIEIgMgA5SSIgRDAAAAAF4EQCAAIAJEAAAAAAAA8D8gBLufo7YiAZQ4AgAgAyABlCEBDAELIABBADYCAAsgACABOAIECysAAkAgAkEBcUUEQCADIAGMOAIADAELIAMgATgCACAAjCEACyADIAA4AgQLfQIBfwJ9IwBBEGsiBSQAIAVCADcDCCAAIAEgAiAFQQhqEAMgBCAFKgIIIgY4AgAgBCAFKgIMIgc4AgQgA0EBRwRAIAQCfSACQX5xQQRGBEAgBCAGIACTOAIAIAcgAZMMAQsgBCAGIACSOAIAIAcgAZILOAIECyAFQRBqJAAL1AUCBn0DfyMAQRBrIhAkACAQQQA2AgggEEIANwMAQX9BASAFQQFxIhIbIRECQCAFQXxxQQRGBEAgAioCACACKgIEIAUgAyAQEAQMAQsgBUEDTQRAIAIqAgAhCyACKgIEIQogBioCACEMIAYqAgQhDSMAQRBrIgIkACACQgA3AwggCyAKIAUgAkEIahADAkAgBUEBSwRAIA0hDiAMIQ8gCiENIAshDAwBCyAKIQ4gCyEPCwJAIAdFBEAgECACKgIIOAIAIBAgAioCDDgCBAwBCyACIA4gDZI4AgQgAiAPIAySOAIAIAIQAiACKgIAIgwgAioCBCIOIAIqAggiDSACKgIMIgoQASELAkACQCAEQQFrQQFLDQBBASEDIAVBAU0gC0MAAAAAXnENASAFQX5xQQJHDQAgC0MAAAAAXQ0BCyAFQQFNBEBBASEDIAtDAAAAAF0NAQsgBUF+cUECRiALQwAAAABecSEDCwJAIAMEQCAQIA04AgAMAQsgEEMAAIA/QwAAgD8gDSAKIA6MIgsgDBABIgqVIAqLu0SamZmZmZm5P2MbIgogC5Q4AgAgDCAKlCEKCyAQIAo4AgQLIAJBEGokAAwBCyAFQQhHDQAgAioCACELIAIqAgQhCiAGKgIAIQwgBioCBCENIwBBEGsiAiQAIAJCADcDCCALIApBCCACQQhqEAMgAiAKIA2SOAIEIAIgCyAMkjgCACACEAIgECALIApDAACAP0MAAIA/IAIqAgggAioCDCACKgIEjCILIAIqAgAiChABIgyVIAyLu0SamZmZmZm5P2MbIgwgC5QiCyAKIAyUIgoQASIMOAIIIBAgCowgCiAMQwAAAABdIgMbOAIEIBAgC4wgCyADGzgCACACQRBqJABBAUF/IBIbIBEgECoCCEMAAAAAXRshEQsgACABIBAqAgAgECoCBCARIAdDAAAAACAIIAkQBiAQQRBqJAALOwAgByAIQRhsaiIHIAY4AhQgByAFOwESIAcgBDsBECAHIAM4AgwgByACOAIIIAcgATgCBCAHIAA4AgAL6gYCDH8FfSMAQSBrIgckACAHIAAqAgggACoCACITkzgCGCAHIAAqAgwgACoCBCIUkzgCHCAHQgA3AxAgB0EYaiIJEAIgEyAUIAkgAyACQQQgB0EQaiIOQQAgBUEAEAUgACoCACAAKgIEIAkgAyACQQUgDkEAIAVBARAFIARBAmohDwJAIAFBAkgEQEECIQtBASEMQQEhDQwBCyABQQJrIRBBASENQQEhDEECIQtBACEEA0AgACAEQQN0aiIIKgIAIRYgCCoCCCEVIAcgCCoCDCIXIAgqAgQiE5M4AhwgByAVIBaTOAIYIAdBGGoQAiAHQgA3AwggBEEBdCEJIAQEQCAJQQJ0IABqIghBCGsqAgAhFCAHIBMgCEEEayoCAJM4AgwgByAWIBSTOAIIIAdBCGoQAgsgB0IANwMAIAQgEEYiEUUEQCAJQQJ0IABqIggqAhAhFCAHIAgqAhQgF5M4AgQgByAUIBWTOAIAIAcQAgsgFiATIAdBGGoiCSADIAJBACAHQQhqIg4gBEEARyIIIAUgCxAFIA9BAWogDUEBaiAMIAYgChAIIBYgEyAJIAMgAkEBIA4gCCAFIAtBAWoQBSAPQQJqIA1BAmogDCAGIApBA2oQCCAVIBcgCSADIAJBAiAHIAQgEEciCCAFIAtBAmoQBSAPQQNqIA1BA2ogDCAGIApBBmoQCCAVIBcgCSADIAJBAyAHIAggBSALQQNqEAUgD0EEaiIJIA1BBGoiCCAMIAYgCkEJahAIIApBDGohDiALQQRqIRICfyACQQFHIBFyRQRAIBUgFyAHQRhqIANBAUEIIAdBAiAFIBIQBSAPQQVqIg8gDUEFaiINIAwgBiAOEAggCkEPaiEKIAxFIQwgC0EFagwBCyAOIQogCCENIAkhDyASCyELIARBAWohBCARRQ0ACwsgByABQQN0IABqIgRBCGsiASoCACITIARBEGsqAgCTOAIYIAcgBEEEayIAKgIAIhQgBEEMayoCAJM4AhwgB0EYaiIOEAIgB0IANwMQIBMgFCAOIAMgAkEGIAdBEGoiBEEAIAUgCxAFIA9BAWogDUEBaiAMIAYgChAIIAEqAgAgACoCACAOIAMgAkEHIARBACAFIAtBAWoQBSAPQQJqIA1BAmogDCAGIApBA2oQCCAHQSBqJAALQgAgAyAEQQF0aiIDIAA7AQQgA0F+QX8gAhsiBEF/QX4gAhsiAiABQQFxIgEbIABqOwECIAMgAiAEIAEbIABqOwEAC6kHAgN/BH0jAEEQayINJABBf0EBIAZBAXEiDhshDwJAIAZBfHFBBEYEQCANQgA3AwAgAiADIAYgBCANEAQMAQsgBkEDTQRAIA1CADcDACMAQRBrIgQkACAEQgA3AwggAiADIAYgBEEIahADIAQqAgghEiANIAQqAgwiEzgCBCANIBI4AgACQCAGQQFLBEAgCSEQIAghESADIQkgAiEIDAELIAMhECACIRELAkAgCkUNACAEIBAgCZI4AgQgBCARIAiSOAIAIAQQAiANIAQqAgAiCEMAAIA/QwAAgD8gEiATIAQqAgSMIgkgCBABIgiVIAiLu0SamZmZmZm5P2MbIhCUIgg4AgQgDSAQIAmUIgk4AgAgAiADIAkgCBABIQICQCAGQX5xQQJGBEAgAkMAAAAAXg0BDAILIAJDAAAAAF1FIAZBAUtyDQELIA0gEyAJjCICIAiMIgMgEiATEAFDAAAAwJQiCJQgA5I4AgQgDSASIAiUIAKSOAIACyAEQRBqJAAMAQtBAUF/IA4bIQQgBkEIRgRAIA1BADYCCCANQgA3AwAjAEEQayIGJAAgBkIANwMIIAIgA0EIIAZBCGoQAyAGKgIMIRAgBioCCCERIAZCADcDACAGIAkgAyAJkiIJIAIgCJIiEkMAAAAAWyAJQwAAAABbcSIOGzgCBCAGIAggEiAOGzgCACAGEAIgDSACIANDAACAP0MAAIA/IBEgECAGKgIEjCICIAYqAgAiAxABIgiVIAiLu0SamZmZmZm5P2MbIgggApQiAiADIAiUIgMQASIIOAIIIA0gA4wgAyAIQwAAAABdIg4bIgOMIAMgBUECRiIFGzgCBCANIAKMIAIgDhsiAowgAiAFGzgCACAGQRBqJAAgDSoCCCECAkAgBQRAIAJDAAAAAF4NAQwDCyACQwAAAABdRQ0CCyAEIQ8MAQsgDUEANgIIIA1CADcDACMAQRBrIgUkACAFQgA3AwggAiADAn8gBrIiEItDAAAAT10EQCAQqAwBC0GAgICAeAsgBUEIahADIAUqAgghECAFKgIMIREgDSACIAMgAyADIAmSIgMgAiAIkiIIQwAAAABbIANDAAAAAFtxIgYbjCACIAggBhsQASICOAIIIA0gEYwgESACQwAAAABeIgYbOAIEIA0gEIwgECAGGzgCACAFQRBqJAAgBCAPIA0qAghDAAAAAF4bIQ8LIAAgASANKgIAIA0qAgQgDyAKIAcgCyAMEAYgDUEQaiQAC5UJAg1/DH0jAEEgayIIJAAgACoCACEVIAAqAgghFiAIIAAqAgwgACoCBCIXkzgCHCAIIBYgFZM4AhggCEEYahACIBUgFyAIKgIYIhUgCCoCHCIWIAMgAkEEIARDAAAAAEMAAAAAQQAgBkEAEAkgACoCACAAKgIEIBUgFiADIAJBBSAEQwAAAABDAAAAAEEAIAZBARAJIAVBAmohDgJAIAFBAkgEQEEBIQpBASENQQIhCwwBCyABQQJrIRJBAiELQQEhDUEBIQpBACEFA0AgACAFQQN0aiIJKgIAIRogCSoCCCEXIAggCSoCDCIbIAkqAgQiHZMiHzgCFCAIIBcgGpMiIDgCECAFQQF0IQkgCEEQahACQwAAAAAhGCAIKgIUIRUgCCoCECEWQwAAAAAhHEMAAAAAIR4gBQRAIAlBAnQgAGoiD0EIayoCACEZIAggHSAPQQRrKgIAkzgCDCAIIBogGZM4AgggCEEIahACIAgqAgwhHiAIKgIIIRwLQwAAAAAhGSAFIBJGIhNFBEAgCUECdCAAaiIJKgIQIRggCCAJKgIUIBuTOAIMIAggGCAXkzgCCCAIQQhqEAIgCCoCDCEZIAgqAgghGAsgAkECRyIUIAVFckUEQCAaIB0gFiAVIANBAkEKIAQgHCAeQQIgBiALEAkgDkEBaiIOIA1BAWoiDSAKIAcgDBAIIAtBAWohCyAKRSEKIAxBA2ohDAsgGiAdIBYgFSADIAJBACAEIBwgHiAFQQBHIgkgBiALEAkgDkEBaiANQQFqIAogByAMEAggGiAdIBYgFSADIAJBASAEIBwgHiAJIAYgC0EBahAJIA5BAmogDUECaiAKIAcgDEEDahAIIBcgGyAWIBUgAyACQQIgBCAgICCUIB8gH5SSkZIiBCAYIBkgBSASRyIJIAYgC0ECahAJIA5BA2ogDUEDaiAKIAcgDEEGahAIIBcgGyAWIBUgAyACQQMgBCAYIBkgCSAGIAtBA2oQCSAOQQRqIg8gDUEEaiIRIAogByAMQQlqEAggDEEMaiEJIAtBBGohEAJ/IBMEQCARIQ0gCSEMIA8hDiAQDAELIBRFBEAgFyAbIBYgFSADQQJBCSAEIBggGUECIAYgEBAJIA5BBWoiDyANQQVqIhEgCiAHIAkQCCALQQVqIRAgCkUhCiAMQQ9qIQkLIBcgGyAWIBUgAyACQQggBCAYIBlBAiAGIBAQCSAPQQFqIg4gEUEBaiINIAogByAJEAggCUEDaiEMIApFIQogEEEBagshCyAFQQFqIQUgE0UNAAsLIAFBA3QgAGoiAEEQayoCACEWIABBCGsiASoCACEVIAggAEEEayIFKgIAIhcgAEEMayoCAJM4AhQgCCAVIBaTOAIQIAhBEGoQAiAVIBcgCCoCECIVIAgqAhQiFiADIAJBBiAEQwAAAABDAAAAAEEAIAYgCxAJIA5BAWogDUEBaiAKIAcgDBAIIAEqAgAgBSoCACAVIBYgAyACQQcgBEMAAAAAQwAAAABBACAGIAtBAWoQCSAOQQJqIA1BAmogCiAHIAxBA2oQCCAIQSBqJAALDgBBkIjAAiQCQZAIJAELBwAjACMBawsEACMCCwQAIwELBAAjAAsGACAAJAALEAAjACAAa0FwcSIAJAAgAAsFAEGACAs=",eF=function(){function t(){var e=this,t=Uint8Array.from("undefined"==typeof atob?function(e){var t=String(e).replace(/=+$/,"");if(t.length%4==1)throw new eb("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,r,a="",i=0,o=0;r=t.charAt(o++);~r&&(n=i%4?64*n+r:r,i++%4)&&(a+=String.fromCharCode(255&n>>(-2*i&6))))r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r);return a}(eV):atob(eV),function(e){return e.charCodeAt(0)});this._wasmInitPromise=new Promise(function(n){WebAssembly.instantiate(t,{env:{consoleLog:function(e){},segfault:function(e,t,n){console.log(e,t,n)},alignfault:function(e,t,n){console.log(e,t,n)}}}).then(function(t){e._memory=t.instance.exports.memory.buffer,e._heap32=new Float32Array(e._memory),e._heap16=new Int16Array(e._memory),e._wasmModule=t.instance.exports,n()})})}var n=t.prototype;return n.solidLine=function(e,t,n,r){var a=this;return eN(function(){var i,o,s,l,c;return eB(this,function(h){switch(h.label){case 0:return[4,a._wasmInitPromise];case 1:return h.sent(),a._heap32.set(e,0),o=3*(i=a._getSolidVertexCount(e.length/2,t))-6,c=(l=(s=e.length*Float32Array.BYTES_PER_ELEMENT)+24*i)+o*Uint16Array.BYTES_PER_ELEMENT,a._wasmModule.build_solid_line(0,e.length/2,t,n,r,s,l),[2,{vertices:new Float32Array(a._memory.slice(s,l)),indices:new Uint16Array(a._memory.slice(l,c))}]}})})()},n.dashLine=function(e,t,n,r,a){var i=this;return eN(function(){var o,s,l,c,h;return eB(this,function(d){switch(d.label){case 0:return[4,i._wasmInitPromise];case 1:return d.sent(),i._heap32.set(e,0),s=3*(o=i._getDashVertexCount(e.length/2,t))-6,h=(c=(l=e.length*Float32Array.BYTES_PER_ELEMENT)+24*o)+s*Uint16Array.BYTES_PER_ELEMENT,i._wasmModule.build_dash_line(0,e.length/2,t,n,r,a,l,c),[2,{vertices:new Float32Array(i._memory.slice(l,c)),indices:new Uint16Array(i._memory.slice(c,h))}]}})})()},n._getSolidVertexCount=function(t,n){return n===e.LineJoin.Round?5*t-2:4*t},n._getDashVertexCount=function(t,n){return n===e.LineJoin.Bevel?7*t-6:5*t-2},eL(t,null,[{key:"instance",get:function(){return this._instance||(this._instance=new t),this._instance}}]),t}();function eH(e,t){return(eH=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function eU(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&eH(e,t)}t.Shader.create("line","\nattribute vec2 a_pos;\nattribute vec2 a_normal;\nattribute vec2 a_data;\n\nuniform mat4 renderer_MVPMat;\nuniform float u_width;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\n\nvoid main() {\n    v_direction = a_data.x;\n    v_part = a_data.y;\n    float layer_index = 1.0;\n\n    v_origin = a_pos;\n    vec2 position = a_pos + a_normal * u_width;\n    v_position = position;\n    gl_Position = renderer_MVPMat * vec4(position, 0.0, 1);\n}\n  ","\nprecision highp float;\n\nuniform vec4 u_color;\nuniform int u_join;\nuniform int u_cap;\nuniform float u_width;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\n\nfloat IS_CAP = 0.0;\n\nvoid main() {\n    vec4 finalColor;\n    if (u_cap == 0 && v_part == IS_CAP) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    if (u_join == 1 && v_part > 1.0) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n\n    gl_FragColor = u_color;\n}\n\n  ");var ez=function(e){function n(n){var r,a=(r=e.call(this,n,t.Shader.find("line"))||this).renderState,i=a.depthState,o=a.blendState.targetBlendState;return a.rasterState.cullMode=t.CullMode.Off,i.writeEnabled=!1,r.renderState.renderQueueType=t.RenderQueueType.Transparent,o.enabled=!0,o.sourceColorBlendFactor=t.BlendFactor.SourceAlpha,o.destinationColorBlendFactor=t.BlendFactor.OneMinusSourceAlpha,o.sourceAlphaBlendFactor=t.BlendFactor.SourceAlpha,o.destinationAlphaBlendFactor=t.BlendFactor.OneMinusSourceAlpha,o.colorBlendOperation=t.BlendOperation.Add,o.alphaBlendOperation=t.BlendOperation.Add,r}return eU(n,e),n}(t.Material);t.Shader.create("dash","\nattribute vec2 a_pos;\nattribute vec2 a_normal;\nattribute vec2 a_data;\nattribute float a_lengthsofar;\n\nuniform mat4 renderer_MVPMat;\nuniform float u_width;\nuniform vec2 u_dash;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\nvarying vec2 v_tex;\n\nvoid main() {\n    v_direction = a_data.x;\n    v_part = a_data.y;\n    float layer_index = 1.0;\n\n\n    v_origin = a_pos;\n\n    float texcoord_y = 0.0;\n\n    texcoord_y = a_lengthsofar / (u_dash.x + u_dash.y);\n    if (v_direction == 1.0) {\n        v_tex = vec2(1.0, texcoord_y);\n    } else {\n        v_tex = vec2(0.0, texcoord_y);\n    }\n    vec2 position = a_pos + a_normal * u_width;\n    v_position = position;\n    gl_Position = renderer_MVPMat * vec4(position, 0.0, 1);\n}\n  ","\nprecision highp float;\n\nuniform vec4 u_color;\nuniform int u_join;\nuniform int u_cap;\nuniform float u_width;\nuniform sampler2D u_texture;\n\nvarying vec2 v_origin;\nvarying vec2 v_position;\nvarying float v_direction;\nvarying float v_part;\nvarying vec2 v_tex;\n\nfloat IS_CAP = 0.0;\n\nvoid main() {\n    vec4 finalColor;\n    if (u_cap == 0 && v_part == IS_CAP) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    if (u_join == 1 && v_part > 1.5) {\n      if (distance(v_position, v_origin) > u_width) {\n        discard;\n      }\n    }\n    vec4 textureColor = texture2D(u_texture, v_tex);\n    if (textureColor.a <= 0.5) {\n      gl_FragColor = vec4(u_color.rgb, 0.0);\n    } else {\n      gl_FragColor = u_color;\n    }\n}\n");var ek=function(e){function n(n){var r;return(r=e.call(this,n)||this).shader=t.Shader.find("dash"),r}return eU(n,e),n}(ez),eG=function(n){function r(r){var a;return(a=n.call(this,r)||this)._points=[],a._cap=e.LineCap.Butt,a._join=e.LineJoin.Miter,a._flattenPoints=[],a._width=.1,a._color=new t.Color(0,0,0,1),a._needUpdate=!1,a}eU(r,n);var a=r.prototype;return a.onAwake=function(){this._renderer=this.entity.addComponent(t.MeshRenderer),this.color=this._color,this.join=this._join,this.cap=this._cap,this.width=this._width,this._initMaterial(),this._mesh=new t.BufferMesh(this.engine,"LineGeometry"),this._mesh.setVertexElements([new t.VertexElement("a_pos",0,t.VertexElementFormat.Vector2,0),new t.VertexElement("a_normal",8,t.VertexElementFormat.Vector2,0),new t.VertexElement("a_data",16,t.VertexElementFormat.Short2,0),new t.VertexElement("a_lengthsofar",20,t.VertexElementFormat.Float,0)]),this._renderer.mesh=this._mesh},a.onUpdate=function(){this._needUpdate&&(this._render(),this._needUpdate=!1)},a.onEnable=function(){this._renderer.enabled=!0},a.onDisable=function(){this._renderer.enabled=!1},a.onDestroy=function(){this._renderer.destroy()},a._generateData=function(){var e=this;return eN(function(){return eB(this,function(t){switch(t.label){case 0:return[4,eF.instance.solidLine(e._flattenPoints,e._join,e._cap,-1)];case 1:return[2,t.sent()]}})})()},a._render=function(){var e=this;return eN(function(){var n,r,a,i,o,s,l;return eB(this,function(c){switch(c.label){case 0:return[4,e._generateData()];case 1:return r=(n=c.sent()).vertices,a=n.indices,i=new t.Buffer(e.engine,t.BufferBindFlag.VertexBuffer,r,t.BufferUsage.Static),o=new t.Buffer(e.engine,t.BufferBindFlag.IndexBuffer,a,t.BufferUsage.Static),i.setData(r),o.setData(a),e._mesh&&(e._mesh.vertexBufferBindings.forEach(function(e){var t;null==e||null==(t=e.buffer)||t.destroy()}),null==(l=e._mesh.indexBufferBinding)||null==(s=l.buffer)||s.destroy()),e._mesh.setVertexBufferBinding(i,24,0),e._mesh.setIndexBufferBinding(o,t.IndexFormat.UInt16),e._mesh.clearSubMesh(),e._mesh.addSubMesh(0,a.length),e._mesh._enableVAO=!1,[2]}})})()},a._initMaterial=function(){this._material=new ez(this.engine),this._renderer.setMaterial(this._material)},eL(r,[{key:"points",get:function(){return this._points},set:function(e){this._points=e,this._flattenPoints=this._points.map(function(e){return[e.x,e.y]}).flat(),this._needUpdate=!0}},{key:"cap",get:function(){return this._cap},set:function(e){if(e!==this._cap){var t;this._cap=e,null==(t=this._renderer)||t.shaderData.setInt("u_cap",e),this._needUpdate=!0}}},{key:"join",get:function(){return this._join},set:function(e){if(e!==this._join){var t;this._join=e,null==(t=this._renderer)||t.shaderData.setInt("u_join",e),this._needUpdate=!0}}},{key:"width",get:function(){return this._width},set:function(e){this._width=e,this._renderer.shaderData.setFloat("u_width",e)}},{key:"color",get:function(){return this._color},set:function(e){this._color=e,this._renderer.shaderData.setColor("u_color",e)}}]),r}(t.Script),eW=function(e){function n(t){var n;return(n=e.call(this,t)||this)._material=null,n}eU(n,e);var r=n.prototype;return r._generateData=function(){var e=this;return eN(function(){return eB(this,function(t){switch(t.label){case 0:return[4,eF.instance.dashLine(e._flattenPoints,e._join,e._cap,0,-1)];case 1:return[2,t.sent()]}})})()},r._initMaterial=function(){var e=new ek(this.engine);this._renderer.setMaterial(e),this._material=e},r._generateDashTexture=function(e){for(var t=[],n=Math.ceil((e.x+e.y)*10),r=0;r<n;r++)r<10*e.x?t.push(255,255,255,255):t.push(255,255,255,0);return new Uint8Array(t)},eL(n,[{key:"dash",get:function(){return this._dash},set:function(e){this._dash=e,null==(n=this._renderer)||n.shaderData.setVector2("u_dash",e);var n,r,a=new t.Texture2D(this.engine,1,Math.ceil((e.x+e.y)*10));a.setPixelBuffer(this._generateDashTexture(e)),null==(r=this._renderer)||r.shaderData.setTexture("u_texture",a)}}]),n}(eG);function eQ(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function eX(e,t,n){return t&&eQ(e.prototype,t),n&&eQ(e,n),e}e.AnchorType=void 0,(u=e.AnchorType||(e.AnchorType={}))[u.Pivot=0]="Pivot",u[u.Center=1]="Center",e.CoordinateType=void 0,(_=e.CoordinateType||(e.CoordinateType={}))[_.Local=0]="Local",_[_.Global=1]="Global",(f=y||(y={}))[f.None=0]="None",f[f.AnchorDirty=1]="AnchorDirty",f[f.CoordinateDirty=2]="CoordinateDirty",f[f.All=3]="All";var eJ=function(){function n(){this._gizmoTransformDirty=!0,this._entities=[],this._listeners=[],this._worldMatrix=new t.Matrix,this._anchorType=e.AnchorType.Pivot,this._coordinateType=e.CoordinateType.Local,this._dirtyFlag=3}var r=n.prototype;return r.addEntity=function(e){for(var t=this._entities,n=!0,r=t.length-1;r>=0;r--){var a=t[r];if(a===e||this._hasRelationship(a,e)){n=!1;break}this._hasRelationship(e,a)&&this._applyDel(r)}return n&&this._applyAdd(e),n},r.addEntities=function(e){for(var t=e.length-1;t>=0;t--)this.addEntity(e[t])},r.deleteEntity=function(e){this._applyDel(e)},r.deleteEntities=function(e){for(var t=e.length-1;t>=0;t--)this.deleteEntity(e[t])},r.getIndexOf=function(e){return this._entities.findIndex(function(t){return e===t})},r.reset=function(){this._entities.length=0;for(var e=this._listeners,t=e.length-1;t>=0;t--){var n=e[t];n.flagManager.removeListener(n.fun)}e.length=0,this._dirtyFlag=3},r.getWorldMatrix=function(e){return!(this._entities.length<=0)&&(this._updateAnchor(),this._updateCoordinate(),e&&e.copyFrom(this._worldMatrix),!0)},r.getWorldPosition=function(e){if(this.getWorldMatrix()){var t=this._worldMatrix.elements;e.set(t[12],t[13],t[14])}},r.applyTransform=function(e,r){var a=this._entities;if(!(this._entities.length<=0||t.Matrix.equals(e,r))){var i=n._tempMat0,o=n._tempMat1;t.Matrix.invert(e,i);for(var s=a.length-1;s>=0;s--){var l=a[s].transform;t.Matrix.multiply(i,l.worldMatrix,o),t.Matrix.multiply(r,o,o),l.worldMatrix=o}}},r.setDirtyFlagTrue=function(e){this._dirtyFlag|=e,this._gizmoTransformDirty=!0},r._applyAdd=function(e){this._entities.push(e);var t=this._onEntityWorldTransformChange(e),n=e.transform._updateFlagManager;n.addListener(t),this._listeners.push({flagManager:n,fun:t}),t()},r._applyDel=function(t){var n="number"==typeof t?t:this._entities.indexOf(t);if(0===n){this._coordinateType===e.CoordinateType.Local?this.setDirtyFlagTrue(3):this.setDirtyFlagTrue(1),this._entities.splice(n,1);var r=this._listeners[n];r.flagManager.removeListener(r.fun),this._listeners.splice(n,1)}else if(n>0){this._anchorType===e.AnchorType.Center&&this.setDirtyFlagTrue(1),this._entities.splice(n,1);var a=this._listeners[n];a.flagManager.removeListener(a.fun),this._listeners.splice(n,1)}},r._onEntityWorldTransformChange=function(t){var n=this;return function(){0===n._entities.indexOf(t)?n._coordinateType===e.CoordinateType.Local?n.setDirtyFlagTrue(3):n.setDirtyFlagTrue(1):n._anchorType===e.AnchorType.Center&&n.setDirtyFlagTrue(1)}},r._hasRelationship=function(e,t){for(;t.parent;){if(e===t.parent)return!0;t=t.parent}return!1},r._updateAnchor=function(){if(1&this._dirtyFlag){var t=this._worldMatrix,r=n._tempVec30,a=t.elements;switch(this._anchorType){case e.AnchorType.Center:this._getCenter(r),a[12]=r.x,a[13]=r.y,a[14]=r.z;break;case e.AnchorType.Pivot:var i=this._entities[0].transform.worldMatrix.elements;a[12]=i[12],a[13]=i[13],a[14]=i[14]}this._dirtyFlag&=-2}},r._updateCoordinate=function(){if(2&this._dirtyFlag){var t=this._worldMatrix.elements;switch(this._coordinateType){case e.CoordinateType.Local:var n=this._entities[0].transform.worldMatrix.elements,r=1/Math.sqrt(Math.pow(n[0],2)+Math.pow(n[1],2)+Math.pow(n[2],2)),a=1/Math.sqrt(Math.pow(n[4],2)+Math.pow(n[5],2)+Math.pow(n[6],2)),i=1/Math.sqrt(Math.pow(n[8],2)+Math.pow(n[9],2)+Math.pow(n[10],2));t[0]=n[0]*r,t[4]=n[4]*a,t[8]=n[8]*i,t[1]=n[1]*r,t[5]=n[5]*a,t[9]=n[9]*i,t[2]=n[2]*r,t[6]=n[6]*a,t[10]=n[10]*i;break;case e.CoordinateType.Global:t[0]=1,t[4]=0,t[8]=0,t[1]=0,t[5]=1,t[9]=0,t[2]=0,t[6]=0,t[10]=1}this._dirtyFlag&=-3}},r._getCenter=function(e){var r=n._tempBoundBox;r.min.set(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),r.max.set(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);for(var a=this._entities,i=!1,o=a.length-1;o>=0;o--){var s=a[o].getComponentsIncludeChildren(t.Renderer,[]);i||(i=s.length>0);for(var l=s.length-1;l>=0;l--)s[l].entity.isActiveInHierarchy&&t.BoundingBox.merge(r,s[l].bounds,r)}var c=r.getExtent(e).length();if((c<=0||c>=Number.MAX_VALUE)&&(i=!1),i)r.getCenter(e);else{e.set(0,0,0);for(var h=a.length-1;h>=0;h--)e.add(a[h].transform.worldPosition);e.scale(1/a.length)}},eX(n,[{key:"anchorType",get:function(){return this._anchorType},set:function(e){this._anchorType!==e&&(this._anchorType=e,this.setDirtyFlagTrue(1))}},{key:"coordinateType",get:function(){return this._coordinateType},set:function(e){this._coordinateType!==e&&(this._coordinateType=e,this.setDirtyFlagTrue(2))}}]),n}();function eK(e,t){return(eK=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ej(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&eK(e,t)}function eY(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}function eq(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return eY(e,void 0);var n=Object.prototype.toString.call(e).slice(8,-1);if("Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return eY(e,void 0)}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}eJ._tempVec30=new t.Vector3,eJ._tempMat0=new t.Matrix,eJ._tempMat1=new t.Matrix,eJ._tempBoundBox=new t.BoundingBox;var eZ=function(e){function n(n){var r;return(r=e.call(this,n)||this)._color=new t.Color,r._highLightColor=new t.Color,r._yellowColor=new t.Color(1,.95,0,1),r._grayColor=new t.Color(.75,.75,.75,.6),r}ej(n,e);var r=n.prototype;return r.initAxis=function(e){this._material=e.axisMaterial,this._color.copyFrom(e.axisMaterial.baseColor),this._highLightColor.copyFrom(this._color),this._highLightColor.r=this._highLightColor.r+.3,this._highLightColor.g=this._highLightColor.g+.3,this._highLightColor.b=this._highLightColor.b+.3,this._highLightColor.a=this._highLightColor.a+.1;for(var n=0;n<e.axisMesh.length;n++){var r=this.entity.createChild(e.name);r.transform.rotate(e.axisRotation[n]),r.transform.translate(e.axisTranslation[n],!1);var a=r.addComponent(t.MeshRenderer);a.receiveShadows=!1,a.castShadows=!1,a.priority=e.priority?e.priority:100,a.mesh=e.axisMesh[n],a.setMaterial(this._material)}for(var i=this.entity.parent.parent.findByName("invisible"),o=0;o<e.axisHelperMesh.length;o++){var s=i.createChild(e.name).createChild(e.name);s.transform.rotate(e.axisRotation[o]),s.transform.translate(e.axisTranslation[o],!1);var l=s.addComponent(t.MeshRenderer);l.receiveShadows=!1,l.castShadows=!1,l.priority=e.priority?e.priority:100,l.mesh=e.axisHelperMesh[o],l.setMaterial(e.axisHelperMaterial)}},r.highLight=function(){this._material.baseColor.copyFrom(this._highLightColor)},r.unLight=function(){this._material.baseColor.copyFrom(this._color)},r.yellow=function(){this._material.baseColor.copyFrom(this._yellowColor)},r.gray=function(){this._material.baseColor.copyFrom(this._grayColor)},r.recover=function(){this._material.baseColor.copyFrom(this._color)},r.alpha=function(e){this._material.baseColor.a=e},n}(t.Component);e.State=void 0,(p=e.State||(e.State={}))[p.translate=1]="translate",p[p.rotate=2]="rotate",p[p.scale=4]="scale",p[p.all=15]="all";var e$=function(e){function t(t,n){var r;return(r=e.call(this,t)||this).primitiveInfo=n,r}return ej(t,e),t.prototype.restoreContent=function(){var e=this.primitiveInfo;switch(e.type){case 0:e4.updateCircle(this.resource,e.startPoint,e.normal,e.thetaLength,e.center);break;case 2:e4.updateCircleTube(this.resource,e.arc,e.radius,e.tubeRadius,e.tubularSegments,e.radialSegments);break;case 1:e4.updateLine(this.resource,e.points)}},t}(t.ContentRestorer);(m=x||(x={}))[m.Circle=0]="Circle",m[m.Line=1]="Line",m[m.CircleTube=2]="CircleTube";var e0=function(e){this.type=e},e1=function(e){function t(t,n,r,a){var i;return(i=e.call(this,0)||this).startPoint=t,i.normal=n,i.thetaLength=r,i.center=a,i}return ej(t,e),t}(e0),e2=function(e){function t(t,n,r,a,i){var o;return(o=e.call(this,2)||this).arc=t,o.radius=n,o.tubeRadius=r,o.tubularSegments=a,o.radialSegments=i,o}return ej(t,e),t}(e0),e3=function(e){function t(t){var n;return(n=e.call(this,1)||this).points=t,n}return ej(t,e),t}(e0),e4=function(){function e(){}return e.createCircle=function(n,r,a,i,o){void 0===r&&(r=new t.Vector3),void 0===a&&(a=new t.Vector3(0,0,1)),void 0===i&&(i=new t.Vector3(1.6,0,0)),void 0===o&&(o=Math.PI/2);var s=new t.ModelMesh(n);return e.updateCircle(s,i,a,o,r),n.resourceManager.addContentRestorer(new e$(s,new e1(i,a,o,r))),s},e.updateCircle=function(n,r,a,i,o,s){void 0===r&&(r=new t.Vector3(1.6,0,0)),void 0===a&&(a=new t.Vector3(0,0,1)),void 0===i&&(i=Math.PI/2),void 0===o&&(o=new t.Vector3),void 0===s&&(s=16);for(var l=Math.max(6,Math.abs(Math.ceil(s*i/Math.PI))),c=new Uint16Array(3*l),h=[],d=1;d<=l;d++){var u=(d-1)*3;c[u]=d,c[u+1]=d+1,c[u+2]=0}h.push(o);for(var _=0;_<=l;_++){var f=_/l*i;t.Quaternion.rotationAxisAngle(a,f,e._tempQuat),t.Vector3.transformByQuat(r,e._tempQuat,e._tempVect),h[_+1]=e._tempVect.clone()}e._initialize(n,h,c,t.MeshTopology.Triangles)},e.createCircleTube=function(n,r,a,i,o,s){void 0===r&&(r=Math.PI),void 0===a&&(a=1.6),void 0===i&&(i=.02),void 0===o&&(o=48),void 0===s&&(s=6);var l=new t.ModelMesh(n);return e.updateCircleTube(l,r,a,i,o,s),n.resourceManager.addContentRestorer(new e$(l,new e2(r,a,i,o,s))),l},e.updateCircleTube=function(n,r,a,i,o,s){void 0===r&&(r=Math.PI),void 0===a&&(a=1.6),void 0===i&&(i=.02),void 0===o&&(o=48),void 0===s&&(s=6);for(var l=(s+1)*(o+1),c=new Uint16Array(s*o*6),h=Array(l),d=Array(l),u=Array(l),_=0,f=0;f<=s;f++)for(var p=0;p<=o;p++){var m=p/o*r,g=f/s*Math.PI*2,A=Math.cos(g),v=Math.sin(g),C=Math.cos(m),y=Math.sin(m),x=new t.Vector3((a+i*A)*C,(a+i*A)*y,i*v);h[_]=x;var E=a*C,S=a*y;d[_]=new t.Vector3(x.x-E,x.y-S,x.z).normalize(),u[_++]=new t.Vector2(p/o,f/s)}_=0;for(var M=1;M<=s;M++)for(var T=1;T<=o;T++){var I=(o+1)*M+T-1,w=(o+1)*(M-1)+T-1,D=(o+1)*(M-1)+T,P=(o+1)*M+T;c[_++]=I,c[_++]=w,c[_++]=P,c[_++]=w,c[_++]=D,c[_++]=P}var b=n.bounds,R=a+i;b.min.set(-R,-R,-i),b.max.set(R,R,i),e._initialize(n,h,c,t.MeshTopology.Triangles,d,u)},e.createLine=function(n,r){var a=new t.ModelMesh(n);return e.updateLine(a,r),n.resourceManager.addContentRestorer(new e$(a,new e3(r))),a},e.updateLine=function(n,r){for(var a=new Uint8Array(r.length),i=0;i<r.length;i++)a[i]=i;e._initialize(n,r,a,t.MeshTopology.Lines)},e._initialize=function(e,t,n,r,a,i){e.setPositions(t),e.setIndices(n),a&&e.setNormals(a),i&&e.setUVs(i),e.clearSubMesh(),e.uploadData(!1),e.addSubMesh(0,n.length,r)},e}();e4._tempQuat=new t.Quaternion,e4._tempVect=new t.Vector3;var e5=function(){function n(){}return n.init=function(r){n.redMaterialTrans=this._createPlainColorMaterial(r,e.State.translate,1,.25,.25,1),n.lightRedMaterial=this._createPlainColorMaterial(r,e.State.translate,1,.25,.25,.9),n.greenMaterialTrans=this._createPlainColorMaterial(r,e.State.translate,.5,.8,.2,1),n.lightGreenMaterial=this._createPlainColorMaterial(r,e.State.translate,.5,.8,.2,.9),n.blueMaterialTrans=this._createPlainColorMaterial(r,e.State.translate,.3,.5,1,1),n.lightBlueMaterial=this._createPlainColorMaterial(r,e.State.translate,.3,.5,1,.9),n.invisibleMaterialTrans=this._createPlainColorMaterial(r,e.State.translate,0,0,0,0),n.redArcMaterial=this._createPlainColorMaterial(r,e.State.rotate,1,.25,.25),n.greenArcMaterial=this._createPlainColorMaterial(r,e.State.rotate,.5,.8,.2),n.blueArcMaterial=this._createPlainColorMaterial(r,e.State.rotate,.3,.5,1),n.yellowMaterial=this._createPlainColorMaterial(r,e.State.rotate,1,.95,0,1),n.rotatePlaneMaterial=this._createPlainColorMaterial(r,e.State.rotate,1,.95,0,.2),n.rotatePlaneMaterial.renderState.rasterState.cullMode=t.CullMode.Off,n.invisibleMaterialRotate=this._createPlainColorMaterial(r,e.State.rotate,0,0,0,0),n.invisibleMaterialRotate.renderState.rasterState.cullMode=t.CullMode.Off,n.invisibleMaterialCircle=this._createPlainColorMaterial(r,e.State.rotate,0,0,0,0),n.redMaterialScale=this._createPlainColorMaterial(r,e.State.scale,1,.25,.25,1),n.greenMaterialScale=this._createPlainColorMaterial(r,e.State.scale,.5,.8,.2,1),n.blueMaterialScale=this._createPlainColorMaterial(r,e.State.scale,.3,.5,1,1),n.greyMaterial=this._createPlainColorMaterial(r,e.State.scale,.75,.75,.75,1),n.lightMaterial=this._createPlainColorMaterial(r,e.State.scale,.7,.7,.7,1),n.invisibleMaterialScale=this._createPlainColorMaterial(r,e.State.scale,0,0,0,0),n.lineMesh=t.PrimitiveMesh.createCylinder(r,.02,.02,1.5),n.lineMeshShort=t.PrimitiveMesh.createCylinder(r,.02,.02,1.3),n.axisArrowMesh=t.PrimitiveMesh.createCone(r,.08,.3),n.axisPlaneMesh=t.PrimitiveMesh.createPlane(r,.35,.35),n.axisCubeMesh=t.PrimitiveMesh.createCuboid(r,.32,.32,.32),n.axisSphereMesh=t.PrimitiveMesh.createSphere(r,1.8,48),n.axisEndCubeMesh=t.PrimitiveMesh.createCuboid(r,.25,.25,.25),n.axisXTorusMesh=e4.createCircleTube(r,Math.PI,1.6,.02),n.axisYTorusMesh=e4.createCircleTube(r,Math.PI,1.6,.02),n.axisZTorusMesh=e4.createCircleTube(r,Math.PI,1.6,.02),n.axisXYZTorusMesh=e4.createCircleTube(r,2*Math.PI,1.8,.02),n.axisHelperLineMesh=t.PrimitiveMesh.createCylinder(r,.15,.15,1.75),n.axisHelperPlaneMesh=t.PrimitiveMesh.createPlane(r,.75,.75),n.axisHelpertorusMesh=e4.createCircleTube(r,Math.PI,1.6,.24),n.xAxisPositive=new t.Vector3(-1,0,0),n.yAxisPositive=new t.Vector3(0,-1,0),n.zAxisPositive=new t.Vector3(0,0,-1)},n._createPlainColorMaterial=function(e,t,n,r,a,i){void 0===n&&(n=1),void 0===r&&(r=1),void 0===a&&(a=1),void 0===i&&(i=1);var o=new eM(e);return o.isTransparent=!0,o.renderState.depthState.enabled=!1,o.baseColor.set(n,r,a,i),o.name=t.toString(),o},n}();e5.rotateCircleRadius=1.6,e5.scaleFactor=.05773502691896257;var e6=function(e){function t(){return e.apply(this,arguments)}return ej(t,e),t}(t.Component);(g=E||(E={}))[g.x=0]="x",g[g.y=1]="y",g[g.z=2]="z",g[g.xyz=3]="xyz",g[g.xy=4]="xy",g[g.yz=5]="yz",g[g.xz=6]="xz";var e9=[new t.Vector3(1,0,0),new t.Vector3(0,1,0),new t.Vector3(0,0,1),new t.Vector3(1,1,1),new t.Vector3(1,1,0),new t.Vector3(0,1,1),new t.Vector3(1,0,1)],e8=[new t.Plane(new t.Vector3(1,0,0),0),new t.Plane(new t.Vector3(0,1,0),0),new t.Plane(new t.Vector3(0,0,1),0),new t.Plane(new t.Vector3(0,0,0),0),new t.Plane(new t.Vector3(0,0,1),0),new t.Plane(new t.Vector3(1,0,0),0),new t.Plane(new t.Vector3(0,1,0),0)],e7=function(n){function r(r){var a;return(a=n.call(this,r)||this)._scaleFactor=1,a._scaleAxisComponent=[],a._scaleControlMap=[],a._preMatrix=new t.Matrix,a._startGroupMatrix=new t.Matrix,a._startInvMatrix=new t.Matrix,a._startPoint=new t.Vector3,a._factorVec=new t.Vector3,a._currPoint=new t.Vector3,a._plane=new t.Plane,a._tempVec0=new t.Vector3,a._tempVec1=new t.Vector3,a._tempVec2=new t.Vector3,a._tempMat=new t.Matrix,a.type=e.State.scale,a._initAxis(),a._createAxis(r),a}ej(r,n);var a=r.prototype;return a.init=function(e,t){this._camera=e,this._group=t},a.onHoverStart=function(e){if(this._selectedAxis!==E[e]){this.onHoverEnd(),this._selectedAxis=E[e];var t=this.gizmoEntity.findByName(e).getComponent(eZ);t.highLight&&t.highLight()}},a.onHoverEnd=function(){for(var e,t=this.gizmoEntity.children,n=eq(t);!(e=n()).done;){var r=e.value.getComponent(eZ);r.unLight&&r.unLight()}this._selectedAxis=null},a.onMoveStart=function(e,n){this._selectedAxis=E[n],this._group.getWorldMatrix(this._startGroupMatrix),this._preMatrix.copyFrom(this._startGroupMatrix),t.Matrix.invert(this._startGroupMatrix,this._startInvMatrix);var r=this._startPoint,a=this._scaleFactor;this._getHitPlane(),this._calRayIntersection(e,this._startPoint);var i=e9[this._selectedAxis];this._factorVec.set(0===r.x?0:a*i.x/r.x,0===r.y?0:a*i.y/r.y,0===r.z?0:a*i.z/r.z);for(var o=this.gizmoEntity.children,s=0;s<o.length;s++){var l=o[s],c=l.getComponent(eZ);E[l.name]===this._selectedAxis?c.yellow&&c.yellow():c.gray&&c.gray()}},a.onMove=function(e){this._calRayIntersection(e,this._currPoint);var n=this._factorVec,r=this._tempVec0,a=this._tempMat;switch(t.Vector3.subtract(this._currPoint,this._startPoint,r),this._selectedAxis){case E.x:case E.y:case E.z:r.x=r.x*n.x+1,r.y=r.y*n.y+1,r.z=r.z*n.z+1;break;case E.xyz:var i=this._startPoint.length(),o=this._currPoint.length();r.x=o/i,r.y=o/i,r.z=o/i}t.Matrix.scale(this._startGroupMatrix,r,a),this._group.applyTransform(this._preMatrix,a),this._preMatrix.copyFrom(a),this.engine.dispatch("gizmo-move","scale")},a.onMoveEnd=function(){for(var e=this.gizmoEntity.children,t=0;t<e.length;t++){var n=e[t].getComponent(eZ);n.recover&&n.recover()}},a.onUpdate=function(e){void 0===e&&(e=!1),this._resizeControl(e)},a.onSwitch=function(e){void 0===e&&(e=!1),this._resizeControl(e)},a.onAlphaChange=function(e,t){var n=this.gizmoEntity.findByName(e);n&&n.getComponent(eZ).alpha(t)},a._initAxis=function(){this._scaleControlMap=[{name:"x",axisMesh:[e5.lineMeshShort,e5.axisEndCubeMesh],axisMaterial:e5.redMaterialScale,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialScale,axisRotation:[new t.Vector3(0,0,-90),new t.Vector3(0,0,-90)],axisTranslation:[new t.Vector3(.75,0,0),new t.Vector3(1.5,0,0)],priority:102},{name:"y",axisMesh:[e5.lineMeshShort,e5.axisEndCubeMesh],axisMaterial:e5.greenMaterialScale,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialScale,axisRotation:[new t.Vector3(0,90,0),new t.Vector3(0,0,0)],axisTranslation:[new t.Vector3(0,.75,0),new t.Vector3(0,1.5,0)],priority:102},{name:"z",axisMesh:[e5.lineMeshShort,e5.axisEndCubeMesh],axisMaterial:e5.blueMaterialScale,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialScale,axisRotation:[new t.Vector3(0,90,90),new t.Vector3(0,90,90)],axisTranslation:[new t.Vector3(0,0,.75),new t.Vector3(0,0,1.5)],priority:102},{name:"xyz",axisMesh:[e5.axisCubeMesh],axisMaterial:e5.greyMaterial,axisHelperMesh:[e5.axisCubeMesh],axisHelperMaterial:e5.invisibleMaterialScale,axisRotation:[new t.Vector3(0,0,0)],axisTranslation:[new t.Vector3(0,0,0)],priority:105}]},a._createAxis=function(e){this.gizmoEntity=e.createChild("visible"),this.gizmoHelperEntity=e.createChild("invisible");var t=this.gizmoEntity.createChild("x"),n=this.gizmoEntity.createChild("y"),r=this.gizmoEntity.createChild("z"),a=this.gizmoEntity.createChild("xyz");this._scaleAxisComponent=[t.addComponent(eZ),n.addComponent(eZ),r.addComponent(eZ),a.addComponent(eZ)];for(var i=0;i<this._scaleControlMap.length;i++){var o=this._scaleAxisComponent[i],s=this._scaleControlMap[i];o.initAxis(s)}},a._getHitPlane=function(){switch(this._selectedAxis){case E.x:case E.y:case E.z:case E.xyz:var e=this._tempVec0,n=this._tempVec1,r=this._tempVec2;r.copyFrom(this._camera.entity.transform.worldPosition),r.transformToVec3(this._startInvMatrix);var a=e9[this._selectedAxis];t.Vector3.cross(r,a,n),t.Plane.fromPoints(a,e.set(0,0,0),n,this._plane)}},a._calRayIntersection=function(e,n){var r=this._startInvMatrix;t.Vector3.transformCoordinate(e.origin,r,e.origin),t.Vector3.transformNormal(e.direction,r,e.direction),e.getPoint(e.intersectPlane(this._plane),n)},a._resizeControl=function(e){void 0===e&&(e=!1);var n=this._tempVec0,r=this._tempMat,a=this._camera.entity.transform.worldPosition;if(this._group.getWorldMatrix(r),this._camera.isOrthographic){var i=e?this._camera.orthographicSize*e5.scaleFactor*2.25:this._camera.orthographicSize*e5.scaleFactor*3;this.entity.transform.worldMatrix=this._tempMat.scale(this._tempVec0.set(i,i,i))}else{var o=r.elements;n.set(o[12],o[13],o[14]);var s=e?t.Vector3.distance(a,n)*e5.scaleFactor*.75:t.Vector3.distance(a,n)*e5.scaleFactor,l=s/Math.sqrt(Math.pow(o[0],2)+Math.pow(o[1],2)+Math.pow(o[2],2)),c=s/Math.sqrt(Math.pow(o[4],2)+Math.pow(o[5],2)+Math.pow(o[6],2)),h=s/Math.sqrt(Math.pow(o[8],2)+Math.pow(o[9],2)+Math.pow(o[10],2));this.entity.transform.worldMatrix=this._tempMat.scale(this._tempVec0.set(l,c,h))}},r}(e6),te=function(n){function r(r){var a;return(a=n.call(this,r)||this)._scale=1,a._preMatrix=new t.Matrix,a._startGroupMatrix=new t.Matrix,a._startInvMatrix=new t.Matrix,a._startScale=1,a._startPoint=new t.Vector3,a._currPoint=new t.Vector3,a._plane=new t.Plane,a._tempVec0=new t.Vector3,a._tempVec1=new t.Vector3,a._tempVec2=new t.Vector3,a._tempMat=new t.Matrix,a._tempScale=1,a.type=e.State.translate,a._initAxis(),a._createAxis(r),a}ej(r,n);var a=r.prototype;return a.init=function(e,t){this._camera=e,this._group=t},a.onHoverStart=function(e){if(this._selectedAxis!==E[e]){this.onHoverEnd(),this._selectedAxis=E[e];var t=this.gizmoEntity.findByName(e).getComponent(eZ);t.highLight&&t.highLight()}},a.onHoverEnd=function(){for(var e,t=this.gizmoEntity.children,n=eq(t);!(e=n()).done;){var r=e.value.getComponent(eZ);r.unLight&&r.unLight()}this._selectedAxis=null},a.onMoveStart=function(e,n){this._selectedAxis=E[n],this._group.getWorldMatrix(this._startGroupMatrix),this._preMatrix.copyFrom(this._startGroupMatrix),t.Matrix.invert(this._startGroupMatrix,this._startInvMatrix),this._startScale=this._scale,this._getHitPlane(),this._calRayIntersection(e,this._startPoint);for(var r=this.gizmoEntity.children,a=0;a<r.length;a++){var i=r[a],o=i.getComponent(eZ);E[i.name]===this._selectedAxis?o.yellow&&o.yellow():o.gray&&o.gray()}},a.onMove=function(e){this._calRayIntersection(e,this._currPoint);var n=this._scale,r=this._tempMat,a=this._tempVec0,i=this._startScale;a.x=this._currPoint.x-this._startPoint.x/i*n,a.y=this._currPoint.y-this._startPoint.y/i*n,a.z=this._currPoint.z-this._startPoint.z/i*n;var o=e9[this._selectedAxis];r.identity(),r.elements[12]=a.x*o.x,r.elements[13]=a.y*o.y,r.elements[14]=a.z*o.z,t.Matrix.multiply(this._startGroupMatrix,r,r),this._group.applyTransform(this._preMatrix,r),this._preMatrix.copyFrom(r),this.engine.dispatch("gizmo-move","translate")},a.onMoveEnd=function(){for(var e=this.gizmoEntity.children,t=0;t<e.length;t++){var n=e[t].getComponent(eZ);n.recover&&n.recover()}},a.onUpdate=function(e){void 0===e&&(e=!1),this._resizeControl(e)},a.onSwitch=function(){this._resizeControl()},a.onAlphaChange=function(e,t){switch(e){case"x":this._changeAxisAlpha("x",t),this._changeAxisAlpha("xy",t),this._changeAxisAlpha("xz",t);break;case"y":this._changeAxisAlpha("y",t),this._changeAxisAlpha("xy",t),this._changeAxisAlpha("xz",t);break;case"z":this._changeAxisAlpha("z",t),this._changeAxisAlpha("xz",t),this._changeAxisAlpha("yz",t)}},a._initAxis=function(){this._translateControlMap=[{name:"x",axisMesh:[e5.lineMesh,e5.axisArrowMesh],axisMaterial:e5.redMaterialTrans,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(0,0,-90),new t.Vector3(0,0,-90)],axisTranslation:[new t.Vector3(.75,0,0),new t.Vector3(1.5,0,0)]},{name:"y",axisMesh:[e5.lineMesh,e5.axisArrowMesh],axisMaterial:e5.greenMaterialTrans,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(0,90,0),new t.Vector3(0,0,0)],axisTranslation:[new t.Vector3(0,.75,0),new t.Vector3(0,1.5,0)]},{name:"z",axisMesh:[e5.lineMesh,e5.axisArrowMesh],axisMaterial:e5.blueMaterialTrans,axisHelperMesh:[e5.axisHelperLineMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(0,90,90),new t.Vector3(0,90,90)],axisTranslation:[new t.Vector3(0,0,.75),new t.Vector3(0,0,1.5)]},{name:"xy",axisMesh:[e5.axisPlaneMesh],axisMaterial:e5.lightBlueMaterial,axisHelperMesh:[e5.axisHelperPlaneMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(0,90,90)],axisTranslation:[new t.Vector3(.5,.5,0)]},{name:"yz",axisMesh:[e5.axisPlaneMesh],axisMaterial:e5.lightRedMaterial,axisHelperMesh:[e5.axisHelperPlaneMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(90,90,0)],axisTranslation:[new t.Vector3(0,.5,.5)]},{name:"xz",axisMesh:[e5.axisPlaneMesh],axisMaterial:e5.lightGreenMaterial,axisHelperMesh:[e5.axisHelperPlaneMesh],axisHelperMaterial:e5.invisibleMaterialTrans,axisRotation:[new t.Vector3(0,0,0)],axisTranslation:[new t.Vector3(.5,0,.5)]}]},a._createAxis=function(e){this.gizmoEntity=e.createChild("visible"),this.gizmoHelperEntity=e.createChild("invisible");var t=this.gizmoEntity.createChild("x"),n=this.gizmoEntity.createChild("y"),r=this.gizmoEntity.createChild("z"),a=this.gizmoEntity.createChild("xy"),i=this.gizmoEntity.createChild("yz"),o=this.gizmoEntity.createChild("xz");this._translateAxisComponent=[t.addComponent(eZ),n.addComponent(eZ),r.addComponent(eZ),a.addComponent(eZ),i.addComponent(eZ),o.addComponent(eZ)];for(var s=0;s<this._translateControlMap.length;s++){var l=this._translateAxisComponent[s],c=this._translateControlMap[s];l.initAxis(c)}},a._getHitPlane=function(){switch(this._selectedAxis){case E.x:case E.y:case E.z:var e=this._tempVec0,n=this._tempVec1,r=this._tempVec2;r.copyFrom(this._camera.entity.transform.worldPosition),r.transformToVec3(this._startInvMatrix);var a=e9[this._selectedAxis];t.Vector3.cross(r,a,n),t.Plane.fromPoints(a,e.set(0,0,0),n,this._plane);break;case E.xy:case E.yz:case E.xz:this._plane.copyFrom(e8[this._selectedAxis])}},a._calRayIntersection=function(e,n){var r=this._startInvMatrix;t.Vector3.transformCoordinate(e.origin,r,e.origin),t.Vector3.transformNormal(e.direction,r,e.direction),e.getPoint(e.intersectPlane(this._plane),n)},a._resizeControl=function(e){var n=this._tempMat,r=this._tempVec0,a=this._camera.entity.transform.worldPosition;this._group.getWorldMatrix(n),this._camera.isOrthographic?this._tempScale=this._camera.orthographicSize*e5.scaleFactor*3:(r.set(n.elements[12],n.elements[13],n.elements[14]),this._tempScale=this._scale=t.Vector3.distance(a,r)*e5.scaleFactor),this.gizmoEntity.transform.worldMatrix=this.gizmoHelperEntity.transform.worldMatrix=n.scale(r.set(this._tempScale,this._tempScale,this._tempScale))},a._changeAxisAlpha=function(e,t){var n=this.gizmoEntity.findByName(e);n&&n.getComponent(eZ).alpha(t)},r}(e6),tt=function(n){function r(r){var a;return(a=n.call(this,r)||this)._rotateAxisComponent=[],a._rotateControlMap=[],a._isModified=!1,a._startLineMesh=e4.createLine(a.engine,[new t.Vector3(0,0,0),new t.Vector3(0,0,0)]),a._endLineMesh=e4.createLine(a.engine,[new t.Vector3(0,0,0),new t.Vector3(0,0,0)]),a._rotateHelperPlaneMesh=e4.createCircle(a.engine),a._preMatrix=new t.Matrix,a._startMatrix=new t.Matrix,a._startInvMatrix=new t.Matrix,a._startPointUnit=new t.Vector3,a._currPointUnit=new t.Vector3,a._cameraPos=new t.Vector3,a._previousRad=0,a._finalRad=0,a._verticalAxis=new t.Vector3(0,1,0),a._horizontalAxis=new t.Vector3,a._speedFactor=.01,a._tempMat=new t.Matrix,a._tempMat2=new t.Matrix,a._tempVec=new t.Vector3,a._tempVec2=new t.Vector3,a._tempVec30=new t.Vector3,a._tempVec31=new t.Vector3,a._tempVec32=new t.Vector3,a._tempMat41=new t.Matrix,a._isAtBack=!1,a.type=e.State.rotate,a._initAxis(),a._createAxis(r),a}ej(r,n);var a=r.prototype;return a._initAxis=function(){this._rotateControlMap=[{name:"x",axisMesh:[e5.axisXTorusMesh],axisMaterial:e5.redArcMaterial,axisHelperMesh:[e5.axisHelpertorusMesh],axisHelperMaterial:e5.invisibleMaterialRotate,axisRotation:[new t.Vector3(0,90,90)],axisTranslation:[new t.Vector3(0,0,0)]},{name:"y",axisMesh:[e5.axisYTorusMesh],axisMaterial:e5.greenArcMaterial,axisHelperMesh:[e5.axisHelpertorusMesh],axisHelperMaterial:e5.invisibleMaterialRotate,axisRotation:[new t.Vector3(90,0,0)],axisTranslation:[new t.Vector3(0,0,0)]},{name:"z",axisMesh:[e5.axisZTorusMesh],axisMaterial:e5.blueArcMaterial,axisHelperMesh:[e5.axisHelpertorusMesh],axisHelperMaterial:e5.invisibleMaterialRotate,axisRotation:[new t.Vector3(0,0,-90)],axisTranslation:[new t.Vector3(0,0,0)]},{name:"xyz",axisMesh:[e5.axisXYZTorusMesh],axisMaterial:e5.lightMaterial,axisHelperMesh:[e5.axisSphereMesh],axisHelperMaterial:e5.invisibleMaterialCircle,axisRotation:[new t.Vector3(0,0,0)],axisTranslation:[new t.Vector3(0,0,0)],priority:99}]},a._createAxis=function(e){this.gizmoEntity=e.createChild("visible"),this.gizmoHelperEntity=e.createChild("invisible"),this._axisX=this.gizmoEntity.createChild("x"),this._axisY=this.gizmoEntity.createChild("y"),this._axisZ=this.gizmoEntity.createChild("z"),this._axisXYZ=this.gizmoEntity.createChild("xyz"),this._rotateAxisComponent=[this._axisX.addComponent(eZ),this._axisY.addComponent(eZ),this._axisZ.addComponent(eZ),this._axisXYZ.addComponent(eZ)];for(var n=0;n<this._rotateControlMap.length;n++){var r=this._rotateAxisComponent[n],a=this._rotateControlMap[n];r.initAxis(a)}var i=this.gizmoHelperEntity.children;this._axisXHelper=i[0],this._axisYHelper=i[1],this._axisZHelper=i[2],this._axisXYZHelper=i[3],this._gizmoRotateHelperEntity=e.createChild("helper"),this._startLineHelperEntity=this._gizmoRotateHelperEntity.createChild("lineHelperS");var o=this._startLineHelperEntity.addComponent(t.MeshRenderer);o.receiveShadows=!1,o.castShadows=!1,o.mesh=this._startLineMesh,o.setMaterial(e5.yellowMaterial),o.priority=90,this._endLineHelperEntity=this._gizmoRotateHelperEntity.createChild("lineHelperE");var s=this._endLineHelperEntity.addComponent(t.MeshRenderer);s.receiveShadows=!1,s.castShadows=!1,s.mesh=this._endLineMesh,s.setMaterial(e5.yellowMaterial),s.priority=90,this._rotateHelperPlaneEntity=this._gizmoRotateHelperEntity.createChild("rotateHelperPlane");var l=this._rotateHelperPlaneEntity.addComponent(t.MeshRenderer);l.receiveShadows=!1,l.castShadows=!1,l.mesh=this._rotateHelperPlaneMesh,this._rotateHelperPlaneMesh._enableVAO=!1,l.setMaterial(e5.rotatePlaneMaterial),l.priority=90,this._rotateHelperPlaneEntity.isActive=!1},a.init=function(e,t){this._camera=e,this._group=t},a.onHoverStart=function(e){if(this._selectedAxis!==E[e]){this.onHoverEnd(),this._selectedAxis=E[e];var t=this.gizmoEntity.findByName(e).getComponent(eZ);t.highLight&&t.highLight()}},a.onHoverEnd=function(){for(var e,t=this.gizmoEntity.children,n=eq(t);!(e=n()).done;){var r=e.value.getComponent(eZ);r.unLight&&r.unLight()}this._selectedAxis=null},a.onMoveStart=function(e,n){this._selectedAxis=E[n];var r=this._group,a=this._startPointUnit,i=this._startMatrix,o=this._tempVec,s=this._tempMat;r.getWorldMatrix(i),this._preMatrix.copyFrom(i),t.Matrix.invert(i,this._startInvMatrix);var l=this._getGizmoScale();switch(this._tempMat.copyFrom(i).scale(o.set(l,l,l)),this.gizmoEntity.transform.worldMatrix=s,this._selectedAxis){case E.x:case E.y:case E.z:this.gizmoHelperEntity.transform.worldMatrix=s,this._gizmoRotateHelperEntity.transform.worldMatrix=s,this._calRayIntersection(e,a),this._setAxisSelected(this._selectedAxis,!0),e4.updateLine(this._startLineMesh,[new t.Vector3(0,0,0),a]),e4.updateLine(this._endLineMesh,[new t.Vector3(0,0,0),a]),e4.updateCircle(this._rotateHelperPlaneMesh,a,e9[n],0),this._startLineHelperEntity.isActive=!0,this._endLineHelperEntity.isActive=!0,this._rotateHelperPlaneEntity.isActive=!0,this._startLineHelperEntity.transform.setRotation(0,0,0),this._endLineHelperEntity.transform.setRotation(0,0,0),this._rotateHelperPlaneEntity.transform.setRotation(0,0,0);break;case E.xyz:this.gizmoHelperEntity.transform.worldMatrix=s,this._setAxisSelected(this._selectedAxis,!0),this._isAtBack=this.gizmoEntity.transform.worldUp.y<0,this._isAtBack?this._verticalAxis.set(0,-1,0):this._verticalAxis.set(0,1,0)}},a.onMove=function(e,n){var r=this._startPointUnit,a=this._currPointUnit,i=this._startMatrix,o=this._tempMat2,s=this._group,l=this._tempVec;switch(this._selectedAxis){case E.x:case E.y:case E.z:var c=e9[this._selectedAxis];this._calRayIntersection(e,a);var h=this._getFinalRad(r,a,c);e4.updateCircle(this._rotateHelperPlaneMesh,r,c,h),t.Matrix.rotateAxisAngle(i,c,h,o),s.applyTransform(this._preMatrix,o),this._preMatrix.copyFrom(o);var d=h/Math.PI*180;this._endLineHelperEntity.transform.setRotation(d*c.x,d*c.y,d*c.z);break;case E.xyz:var u=n.deltaPosition,_=u.x,f=u.y,p=this._horizontalAxis,m=this._verticalAxis;p.copyFrom(this._camera.entity.transform.worldUp),t.Vector3.cross(p,m,p),this._isAtBack?p.scale(-f):p.scale(f),l.copyFrom(m),this._isAtBack?l.scale(-_):l.scale(_),t.Vector3.add(p,l,l),t.Vector3.transformNormal(l,this._startInvMatrix,l);var g=n.deltaPosition.length()*this._speedFactor;t.Matrix.rotateAxisAngle(i,l,g,i),s.applyTransform(this._preMatrix,i),this._preMatrix.copyFrom(i),t.Matrix.invert(i,this._startInvMatrix)}this.engine.dispatch("gizmo-move","rotate")},a.onMoveEnd=function(){this._finalRad=0,this._previousRad=0,this._setAxisSelected(this._selectedAxis,!1);var e=this._rotateControlMap[this._selectedAxis].axisMesh[0];switch(this._selectedAxis){case E.x:case E.y:case E.z:e4.updateCircleTube(e,Math.PI),this._endLineHelperEntity.isActive=!1,this._startLineHelperEntity.isActive=!1,this._rotateHelperPlaneEntity.isActive=!1;break;case E.xyz:e4.updateCircleTube(e,2*Math.PI,1.8)}},a.onUpdate=function(e){void 0===e&&(e=!1),this._resizeControl(e),this._updateAxisTransform()},a.onSwitch=function(e){void 0===e&&(e=!1),this._resizeControl(e)},a.onAlphaChange=function(e,t){},a._setAxisSelected=function(e,t){var n=this._rotateControlMap[e].axisMesh[0];e4.updateCircleTube(n,2*Math.PI);for(var r=this.gizmoEntity.children,a=0;a<r.length;a++){var i=r[a],o=i.getComponent(eZ);E[i.name]===e&&(t?o.yellow&&o.yellow():o.recover&&o.recover())}},a._calRayIntersection=function(e,n){var r=this._startInvMatrix;t.Vector3.transformCoordinate(e.origin,r,e.origin),t.Vector3.transformNormal(e.direction,r,e.direction),e.getPoint(e.intersectPlane(e8[this._selectedAxis]),n),n.normalize().scale(e5.rotateCircleRadius)},a._getFinalRad=function(e,n,r){var a=t.Vector3.dot(e,n);t.Vector3.cross(e,n,this._tempVec);var i=Math.sign(t.Vector3.dot(this._tempVec,r))*Math.acos(a/Math.pow(e5.rotateCircleRadius,2)),o=i-this._previousRad;return this._previousRad*i<0?Math.abs(i)<Math.PI/2?this._finalRad+=o:this._finalRad+=-Math.sign(o)*(2*Math.PI-Math.abs(o)):this._finalRad+=o,this._previousRad=i,this._finalRad},a._getGizmoScale=function(){var e=this._camera.entity.transform.worldPosition;return(this._group.getWorldPosition(this._tempVec),this._camera.isOrthographic)?this._isModified?this._camera.orthographicSize*e5.scaleFactor*3*.8:this._camera.orthographicSize*e5.scaleFactor*3:this._isModified?t.Vector3.distance(e,this._tempVec)*e5.scaleFactor*.8:t.Vector3.distance(e,this._tempVec)*e5.scaleFactor},a._updateAxisTransform=function(){var e=this._tempMat,n=this._tempVec,r=this._tempVec2,a=this._cameraPos;a.copyFrom(this._camera.entity.transform.worldPosition);var i=this.gizmoEntity.transform;t.Vector3.subtract(a,i.worldPosition,n),t.Matrix.invert(i.worldMatrix,e),t.Vector3.transformNormal(n,e,r);var o=t.MathUtil.radToDegreeFactor,s=r.x,l=r.y,c=r.z;this._axisX.transform.rotation.x=this._axisXHelper.transform.rotation.x=-Math.atan2(l,c)*o,this._axisY.transform.rotation.y=this._axisYHelper.transform.rotation.y=Math.atan2(s,c)*o,this._axisZ.transform.rotation.z=this._axisZHelper.transform.rotation.z=Math.atan2(l,s)*o,this._localLookAt(this._axisXYZ.transform,r),this._axisXYZHelper.transform.rotationQuaternion=this._axisXYZ.transform.rotationQuaternion},a._resizeControl=function(e){void 0===e&&(e=!1),this._group.getWorldMatrix(this._tempMat),this._isModified=e;var t=this._getGizmoScale();this.gizmoEntity.transform.worldMatrix=this.gizmoHelperEntity.transform.worldMatrix=this._tempMat.scale(this._tempVec.set(t,t,t))},a._localLookAt=function(e,n){var r=this._tempVec30;t.Vector3.subtract(e.position,n,r),r.normalize();var a=this._tempVec31.set(r.z,0,-r.x).normalize(),i=this._tempVec32;t.Vector3.cross(r,a,i),i.normalize();var o=this._tempMat41,s=o.elements;s[0]=a.x,s[1]=a.y,s[2]=a.z,s[4]=i.x,s[5]=i.y,s[6]=i.z,s[8]=r.x,s[9]=r.y,s[10]=r.z,o.getRotation(e.rotationQuaternion)},r}(e6),tn=function(n){function r(r){var a;if((a=n.call(this,r)||this).epsilon=.05,a._initialized=!1,a._isStarted=!1,a._lastDistance=-1,a._lastOrthoSize=-1,a._lastIsOrtho=!1,a._controlMap=[],a._group=new eJ,a._tempVec30=new t.Vector3,a._tempVec31=new t.Vector3,a._worldMat=new t.Matrix,a._tempRay=new t.Ray,a._tempRay2=new t.Ray,a._type=null,a._scalar=1,!a.entity.engine.physicsManager)throw Error("PhysicsManager is not initialized");return e5.init(a.engine),a._createGizmoControl(e.State.translate,te),a._createGizmoControl(e.State.rotate,tt),a._createGizmoControl(e.State.scale,e7),a.layer=t.Layer.Layer31,a.state=a._type,a}ej(r,n);var a=r.prototype;return a.init=function(n,r){var a=this;n!==this._sceneCamera&&(n?(this._group=r,this._sceneCamera=n,this._framebufferPicker=n.entity.addComponent(e.FramebufferPicker),this._framebufferPicker.frameBufferSize=new t.Vector2(256,256),this._controlMap.forEach(function(e){e.init(n,a._group)}),this._initialized=!0):this._initialized=!1)},a.onUpdate=function(){var n=this;if(this._initialized){var r=this.engine.inputManager,a=r.pointers.find(function(e){return e.phase!==t.PointerPhase.Up&&e.phase!==t.PointerPhase.Leave});if(this._lastIsOrtho!==this._sceneCamera.isOrthographic&&(this._lastIsOrtho=this._sceneCamera.isOrthographic,this._traverseControl(this._type,function(t){n._type===e.State.all?t.onSwitch(!0):t.onSwitch(!1)})),this._group.getWorldPosition(this._tempVec30),this._isStarted)a&&(a.pressedButtons&t.PointerButton.Primary)!=0?(0!==a.deltaPosition.x||0!==a.deltaPosition.y)&&this._triggerGizmoMove():this._triggerGizmoEnd(),this._group._gizmoTransformDirty&&(this._traverseControl(this._type,function(t){n._type===e.State.all?t.onUpdate(!0):t.onUpdate(!1)}),this._group._gizmoTransformDirty=!1);else{this._group.getWorldPosition(this._tempVec30);var i=this._sceneCamera.entity.transform.worldPosition,o=t.Vector3.distance(i,this._tempVec30),s=!1;Math.abs(this._lastDistance-o)>t.MathUtil.zeroTolerance&&(s=!0,this._lastDistance=o);var l=!1;if(this._sceneCamera.isOrthographic&&Math.abs(this._lastOrthoSize-this._sceneCamera.orthographicSize)>t.MathUtil.zeroTolerance&&(l=!0,this._lastOrthoSize=this._sceneCamera.orthographicSize),(this._group._gizmoTransformDirty||s||l)&&(this._traverseControl(this._type,function(t){n._type===e.State.all?t.onUpdate(!0):t.onUpdate(!1)}),this._group._gizmoTransformDirty=!1),a){var c=a.position,h=c.x,d=c.y,u=this.engine.canvas;if(h<=0||d<=0||h>u.width||d>u.height)return;if(r.isPointerDown(t.PointerButton.Primary))this._framebufferPicker.pick(a.position.x,a.position.y).then(function(e){e&&n._selectHandler(e,a.position)});else{var _=this._sceneCamera.cullingMask;this._sceneCamera.cullingMask=this._layer;var f=this._framebufferPicker.pick(a.position.x,a.position.y);this._sceneCamera.cullingMask=_,f.then(function(e){n._overHandler(e)})}}}}},a.onLateUpdate=function(e){this._adjustAxisAlpha()},a._createGizmoControl=function(e,t){var n=this.entity.createChild(e.toString()).addComponent(t);this._controlMap.push(n)},a._onGizmoHoverStart=function(e,t){var n=this;this._traverseControl(e,function(e){n._currentControl=e}),this._currentControl.onHoverStart(t)},a._onGizmoHoverEnd=function(){this._currentControl&&this._currentControl.onHoverEnd()},a._triggerGizmoStart=function(e,n){var r=this;this._isStarted=!0,this._onGizmoHoverEnd();var a=this.engine.inputManager.pointers.find(function(e){return e.phase!==t.PointerPhase.Up&&e.phase!==t.PointerPhase.Leave});a&&(this._sceneCamera.screenPointToRay(a.position,this._tempRay),this._traverseControl(e,function(e){r._currentControl=e},function(e){e.entity.isActive=!1}),this._currentControl.onMoveStart(this._tempRay,n),this.engine.dispatch("gizmo-move-start",n))},a._triggerGizmoMove=function(){var e=this.engine.inputManager.pointers.find(function(e){return e.phase!==t.PointerPhase.Up&&e.phase!==t.PointerPhase.Leave});this._sceneCamera.screenPointToRay(e.position,this._tempRay2),this._currentControl.onMove(this._tempRay2,e)},a._triggerGizmoEnd=function(){this._currentControl&&this._currentControl.onMoveEnd(),this._group.setDirtyFlagTrue(y.CoordinateDirty),this._traverseControl(this._type,function(e){e.entity.isActive=!0}),this._isStarted=!1,this.engine.dispatch("gizmo-move-end")},a._selectHandler=function(e,t){var n=parseInt(e.getMaterial().name),r=e.entity;r.layer===this._layer&&this._triggerGizmoStart(n,r.name)},a._overHandler=function(e){if(e){var t=parseInt(e.getMaterial().name),n=e.entity;this._onGizmoHoverStart(t,n.name)}else this._onGizmoHoverEnd()},a._traverseEntity=function(e,t){t(e);for(var n,r=eq(e.children);!(n=r()).done;){var a=n.value;this._traverseEntity(a,t)}},a._traverseControl=function(e,t,n){void 0===e&&(e=this._type),this._controlMap.forEach(function(r){(e&r.type)!=0?t(r):n&&n(r)})},a._adjustAxisAlpha=function(){var e=this,t=e5.xAxisPositive,n=e5.yAxisPositive,r=e5.zAxisPositive;this._traverseControl(this._type,function(a){a.onAlphaChange("x",e._getAlphaFactor(t)),a.onAlphaChange("y",e._getAlphaFactor(n)),a.onAlphaChange("z",e._getAlphaFactor(r))})},a._getAlphaFactor=function(e){var n=this._worldMat,r=this._tempVec30,a=this._tempVec31,i=this.epsilon;r.copyFrom(this._sceneCamera.entity.transform.worldForward).normalize(),this._group.getWorldMatrix(n),t.Vector3.transformNormal(e,n,a);var o=Math.abs(t.Vector3.dot(a,r));if(this._sceneCamera.isOrthographic)return 1-o<i?t.MathUtil.clamp((1-o)/i,0,1):1;this._group.getWorldPosition(a),t.Vector3.subtract(this._sceneCamera.entity.transform.worldPosition,a,a);var s=Math.abs(t.Vector3.dot(a.normalize(),r));return 1-Math.max(o,s)<i?t.MathUtil.clamp((1-Math.min(o,s))/i,0,1):1},eX(r,[{key:"layer",get:function(){return this._layer},set:function(e){this._layer!==e&&(this._layer=e,this._traverseEntity(this.entity,function(t){t.layer=e}))}},{key:"state",get:function(){return this._type},set:function(t){this._type=t,this._traverseControl(t,function(n){n.entity.isActive=!0,t===e.State.all?n.onUpdate(!0):n.onUpdate(!1)},function(e){e.entity.isActive=!1})}},{key:"size",get:function(){return this._scalar},set:function(e){this._scalar=t.MathUtil.clamp(e,.01,1/0),e5.scaleFactor=.05773502691896257*this._scalar}}]),r}(t.Script);function tr(e,t){return(tr=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ta(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ti(e,t,n){return t&&ta(e.prototype,t),n&&ta(e,n),e}function to(e,t){return(to=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function ts(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&to(e,t)}"function"==typeof SuppressedError&&SuppressedError,e.OutlineManager=function(e){function n(n){(r=e.call(this,n)||this).isChildrenIncluded=!1,r._size=1,r._clearColor=new t.Color(1,1,1,1),r._replaceColor=new t.Color(1,0,0,1),r._outlineMainColor=new t.Color(.95,.35,.14,1),r._outlineSubColor=new t.Color(.16,.67,.89,1),r._layer=t.Layer.Layer29,r._outlineEntities=[],r._subLineEntities=[],r._renderers=[],r._layerMap=[],r._cameraViewport=new t.Vector4,r._outLineViewport=new t.Vector4(0,0,1,1);var r,a=r.engine,i=new t.BaseMaterial(a,t.Shader.find("outline-postprocess-shader")),o=t.Shader.find("outline-replace-shader"),s=r.entity.createChild("screen"),l=s.addComponent(t.MeshRenderer);return l.receiveShadows=!1,l.castShadows=!1,s.layer=r._layer,s.isActive=!1,l.mesh=t.PrimitiveMesh.createPlane(a,2,2),l.setMaterial(i),i.isTransparent=!0,r._outlineMaterial=i,r._replaceShader=o,r._screenEntity=s,r.size=r._size,r}!function(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&tr(e,t)}(n,e);var r,a=n.prototype;return a.clear=function(){this._outlineEntities.length=0},a.addEntity=function(e){-1===this._outlineEntities.indexOf(e)&&(this._outlineEntities.push(e),this.isChildrenIncluded&&this._calSublineEntites())},a.removeEntity=function(e){var t=this._outlineEntities.indexOf(e),n=this._outlineEntities.length;t>-1&&(t<n-1&&(this._outlineEntities[t]=this._outlineEntities[n-1]),this._outlineEntities.length--,this.isChildrenIncluded&&this._calSublineEntites())},a.onEndRender=function(e){var t=this._outlineEntities;t.length&&(this._checkFrameBufferSize(this._size),this._renderEntity(e,this.subColor,this._subLineEntities),this._renderEntity(e,this.mainColor,t))},a.onDestroy=function(){this._renderTarget.getColorTexture().destroy(!0),this._renderTarget.destroy(),this._screenEntity.destroy(),this._outlineEntities=null,this._renderers=null,this._layerMap=null},a._renderEntity=function(e,r,a){var i=e.scene,o=e.clearFlags,s=e.cullingMask,l=e.enableFrustumCulling,c=i.background.solidColor,h=i.background.mode,d=e.renderTarget,u=e.enablePostProcess,_=e.enableHDR,f=e.depthTextureMode,p=e.opaqueTextureEnabled,m=this._renderers,g=this._layerMap;g.length=0;for(var A=a.length-1;A>=0;A--){var v=a[A];m.length=0,v.getComponents(t.MeshRenderer,m),m.length&&(g.push({entity:v,layer:v.layer}),v.layer=this._layer)}this._screenEntity.isActive=!1,e.renderTarget=this._renderTarget,i.background.solidColor=this._clearColor,i.background.mode=t.BackgroundMode.SolidColor,e.cullingMask=this._layer,e.setReplacementShader(this._replaceShader),e.shaderData.setColor(n._replaceColorProp,this._replaceColor),e.enablePostProcess=!1,e.enableHDR=!1,e.depthTextureMode=t.DepthTextureMode.None,e.opaqueTextureEnabled=!1,e.render(),this._screenEntity.isActive=!0,this._cameraViewport.copyFrom(e.viewport),e.renderTarget=null,e.viewport=this._outLineViewport,e.clearFlags=t.CameraClearFlags.None,e.enableFrustumCulling=!1,e.resetReplacementShader();for(var C=g.length-1;C>=0;C--){var y=g[C],x=y.entity,E=y.layer;x.layer=E}this._outlineMaterial.shaderData.setColor(n._outlineColorProp,r),e.render(),this._screenEntity.isActive=!1,e.clearFlags=o,e.enableFrustumCulling=l,e.cullingMask=s,e.viewport=this._cameraViewport,i.background.solidColor=c,i.background.mode=h,e.renderTarget=d,e.enablePostProcess=u,e.enableHDR=_,e.depthTextureMode=f,e.opaqueTextureEnabled=p},a._calSublineEntites=function(){var e=this;this._subLineEntities.length=0;for(var t=0;t<this._outlineEntities.length;t++)n._traverseEntity(this._outlineEntities[t],function(t){e._subLineEntities.push(t)})},a._checkFrameBufferSize=function(e){var r=this._size,a=this.engine.canvas,i=a.width,o=a.height,s=i/e,l=o/e;if(!this._renderTarget||e!==r||this._renderTarget.width!==s||this._renderTarget.height!==l){this._renderTarget&&(this._renderTarget.getColorTexture().destroy(!0),this._renderTarget.destroy());var c=new t.Texture2D(this.engine,s,l),h=new t.RenderTarget(this.engine,s,l,c);this._outlineMaterial.shaderData.setTexture(n._outlineTextureProp,c),this._outlineMaterial.shaderData.setVector2(n._texSizeProp,new t.Vector2(1/s,1/l)),c.wrapModeU=c.wrapModeV=t.TextureWrapMode.Clamp,this._renderTarget=h}},n._traverseEntity=function(e,t){t(e);for(var n=e.children.length-1;n>=0;n--)this._traverseEntity(e.children[n],t)},r=[{key:"layer",get:function(){return this.layer},set:function(e){this._layer=e}},{key:"mainColor",get:function(){return this._outlineMainColor},set:function(e){var t=this._outlineMainColor;e!==t&&t.copyFrom(e)}},{key:"subColor",get:function(){return this._outlineSubColor},set:function(e){var t=this._outlineSubColor;e!==t&&t.copyFrom(e)}},{key:"size",get:function(){return this._size},set:function(e){e=Math.max(1,Math.min(e,6)),this._checkFrameBufferSize(e),this._size=e}}],function(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}(n.prototype,r),n}(t.Script),e.OutlineManager._outlineColorProp=t.ShaderProperty.getByName("material_OutlineColor"),e.OutlineManager._outlineTextureProp=t.ShaderProperty.getByName("material_OutlineTexture"),e.OutlineManager._texSizeProp=t.ShaderProperty.getByName("material_TexSize"),e.OutlineManager._replaceColorProp=t.ShaderProperty.getByName("camera_OutlineReplaceColor"),e.OutlineManager=function(e,t,n,r){var a,i=arguments.length,o=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,n,r);else for(var s=e.length-1;s>=0;s--)(a=e[s])&&(o=(i<3?a(o):i>3?a(t,n,o):a(t,n))||o);return i>3&&o&&Object.defineProperty(t,n,o),o}([t.dependentComponents(t.Camera,t.DependentMode.CheckOnly)],e.OutlineManager),t.Shader.create("outline-postprocess-shader","#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION.xzy,1.0);gl_Position.y*=-1.0;v_uv=TEXCOORD_0;}","#define GLSLIFY 1\nuniform vec3 material_OutlineColor;uniform sampler2D material_OutlineTexture;uniform vec2 material_TexSize;varying vec2 v_uv;float luminance(vec4 color){return 0.2125*color.r+0.7154*color.g+0.0721*color.b;}float sobel(){float Gx[9];Gx[0]=-1.0;Gx[1]=0.0;Gx[2]=1.0;Gx[3]=-2.0;Gx[4]=0.0;Gx[5]=2.0;Gx[6]=-1.0;Gx[7]=0.0;Gx[8]=1.0;float Gy[9];Gy[0]=-1.0;Gy[1]=-2.0;Gy[2]=-1.0;Gy[3]=0.0;Gy[4]=0.0;Gy[5]=0.0;Gy[6]=1.0;Gy[7]=2.0;Gy[8]=1.0;float texColor;float edgeX=0.0;float edgeY=0.0;vec2 uv[9];uv[0]=v_uv+material_TexSize.xy*vec2(-1,-1);uv[1]=v_uv+material_TexSize.xy*vec2(0,-1);uv[2]=v_uv+material_TexSize.xy*vec2(1,-1);uv[3]=v_uv+material_TexSize.xy*vec2(-1,0);uv[4]=v_uv+material_TexSize.xy*vec2(0,0);uv[5]=v_uv+material_TexSize.xy*vec2(1,0);uv[6]=v_uv+material_TexSize.xy*vec2(-1,1);uv[7]=v_uv+material_TexSize.xy*vec2(0,1);uv[8]=v_uv+material_TexSize.xy*vec2(1,1);for(int i=0;i<9;i++){texColor=luminance(texture2D(material_OutlineTexture,uv[i]));edgeX+=texColor*Gx[i];edgeY+=texColor*Gy[i];}return abs(edgeX)+abs(edgeY);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}void main(){float sobelFactor=step(1.0,sobel());gl_FragColor=mix(vec4(0),vec4(material_OutlineColor,1.0),sobelFactor);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"),t.Shader.create("outline-replace-shader","#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <position_vert>\n}","#define GLSLIFY 1\nuniform vec4 camera_OutlineReplaceColor;void main(){gl_FragColor=camera_OutlineReplaceColor;}");var tl=function(e){function n(){var r;return r=e.apply(this,arguments)||this,r._flipView=!1,r._flipSpeed=3,r._progress=0,r._textColor=new t.Color,r._target=n._vector,r._normalQuat=new t.Quaternion,r._tempMat=new t.Matrix,r._targetMat=new t.Matrix,r._currentMat=new t.Matrix,r._startMat=new t.Matrix,r._tempVect=new t.Vector3,r._tempEyeVect=new t.Vector3,r._upVector=new t.Vector3(0,1,0),r._disabledCompArray=[],r.AxisFactor={x:{upVector:r._upVector,axis:"x",factor:1,unit:new t.Vector3(0,.001,0)},y:{upVector:r._upVector,axis:"y",factor:1,unit:new t.Vector3(0,0,.001)},z:{upVector:r._upVector,axis:"z",factor:1,unit:new t.Vector3(0,.001,0)},"-x":{upVector:r._upVector,axis:"x",factor:-1,unit:new t.Vector3(0,.001,0)},"-y":{upVector:new t.Vector3(0,-1,0),axis:"y",factor:-1,unit:new t.Vector3(0,0,-.001)},"-z":{upVector:r._upVector,axis:"z",factor:-1,unit:new t.Vector3(0,.001,0)}},r}ts(n,e);var r=n.prototype;return r.onAwake=function(){var e=this.entity.findByName("text");this._textRenderer=e.getComponent(t.TextRenderer),this._textColor.copyFrom(this._textRenderer.color),this._backEntity=this.entity.findByName("back")},r.onPointerEnter=function(){this._textRenderer.color.set(1,1,1,1),this._backEntity.isActive=!0},r.onPointerExit=function(){this._textRenderer.color.copyFrom(this._textColor),this._backEntity.isActive=!1},r.onPointerClick=function(){this._disableComponent();var e=this.entity.name;this._startMat=this._sceneCameraEntity.transform.worldMatrix.clone(),this._currentMat=this._sceneCameraEntity.transform.worldMatrix,this._targetMat=this._getTargetMatrix(this._sceneCameraEntity,e),this._flipView=!0},r.onUpdate=function(e){if(this.entity.transform.worldRotationQuaternion=this._normalQuat,this._flipView){this._progress+=e;var n=t.MathUtil.clamp(this._progress*this._flipSpeed,0,1);n>=1&&(this._flipView=!1,this._progress=0,this._enableComponent()),t.Matrix.lerp(this._startMat,this._targetMat,n,this._currentMat),this._sceneCameraEntity.transform.worldMatrix=this._currentMat}},r._getTargetMatrix=function(e,n){var r=this._target,a=this._tempEyeVect,i=this._tempVect,o=this._tempMat,s=this.AxisFactor[n],l=s.upVector,c=s.factor,h=s.axis,d=s.unit;t.Vector3.subtract(e.transform.worldPosition,r,i);var u=i.length();return d[h]=c*u,t.Vector3.add(d,r,a),t.Matrix.lookAt(a,r,l,o),o.invert(),o},r._disableComponent=function(){var e=[];this._sceneCameraEntity.getComponents(t.Script,e);for(var n=0;n<e.length;n++){var r=e[n],a=Object.getPrototypeOf(r);(a.onUpdate||a.onLateUpdate||a.onPhysicsUpdate)&&r.enabled&&(r.enabled=!1,this._disabledCompArray.push(r))}},r._enableComponent=function(){for(var e=0;e<this._disabledCompArray.length;e++)this._disabledCompArray[e].enabled=!0},ti(n,[{key:"camera",get:function(){return this._sceneCamera},set:function(e){this._sceneCamera=e,this._sceneCameraEntity=this._sceneCamera.entity}},{key:"target",get:function(){return this._target},set:function(e){this._target.copyFrom(e)}}]),n}(t.Script);tl._vector=new t.Vector3;var tc=function(e){function n(){var r;return r=e.apply(this,arguments)||this,r._isTriggered=!1,r._speedXFactor=.02,r._speedYFactor=.004,r._textColor=[],r._tempQuat=new t.Quaternion,r._tempQuat2=new t.Quaternion,r._deltaPointer=new t.Vector2,r._tempMat=new t.Matrix,r._upVec=new t.Vector3(0,1,0),r._topVec=new t.Vector3(0,1,0),r._bottomVec=new t.Vector3(0,-1,0),r._target=n._vector,r._currentPos=new t.Vector3,r._rotateVec=new t.Vector3,r._tempUpVec=new t.Vector3,r._startRadian=0,r._ray=new t.Ray,r._isBack=!1,r._disabledCompArray=[],r}ts(n,e);var r=n.prototype;return r.onAwake=function(){var e=this.entity.parent;this._directionEntity=e.findByName("direction"),this._roundEntity=this.entity.findByName("round"),this._endEntity=this._directionEntity.findByName("end"),this._gizmoCameraEntity=e.findByName("gizmo-camera"),this._gizmoCamera=this._gizmoCameraEntity.getComponent(t.Camera),this._xEntity=this._endEntity.findByName("-x").findByName("back"),this._yEntity=this._endEntity.findByName("-y").findByName("back"),this._zEntity=this._endEntity.findByName("-z").findByName("back"),this._getTextColor()},r.onPointerEnter=function(){this._roundEntity.isActive=!0,this._xEntity.isActive=!0,this._yEntity.isActive=!0,this._zEntity.isActive=!0},r.onPointerExit=function(){this._isTriggered||(this._roundEntity.isActive=!1,this._xEntity.isActive=!1,this._yEntity.isActive=!1,this._zEntity.isActive=!1)},r.onPointerDown=function(e){this._disableComponent(),this._recoverTextColor(),n._startPos.copyFrom(this._sceneCameraEntity.transform.worldPosition),n._startQuat.copyFrom(this._directionEntity.transform.worldRotationQuaternion),n._startPointer.copyFrom(e.position),this._tempUpVec.copyFrom(this._sceneCameraEntity.transform.worldUp),this._isBack=this._tempUpVec.y<=0,this._upVec.copyFrom(this._isBack?this._bottomVec:this._topVec),n._startAxis.copyFrom(this._sceneCameraEntity.transform.worldForward),t.Vector3.cross(n._startAxis,this._upVec,n._startAxis),t.Vector3.subtract(n._startPos,this._target,this._tempUpVec);var r=this._tempUpVec.length(),a=t.Vector3.dot(this._tempUpVec,this._upVec);this._isBack?this._startRadian=Math.PI+Math.acos(t.MathUtil.clamp(a/r,-1,1)):this._startRadian=Math.acos(t.MathUtil.clamp(a/r,-1,1)),this._isTriggered=!0,this._navigateCamera(e)},r.onPointerDrag=function(e){this._navigateCamera(e)},r.onPointerUp=function(e){this._isTriggered&&(this._gizmoCamera.screenPointToRay(e.position,this._ray),this.engine.physicsManager.raycast(this._ray,Number.MAX_VALUE,t.Layer.Everything)||(this._roundEntity.isActive=!1,this._xEntity.isActive=!1,this._yEntity.isActive=!1,this._zEntity.isActive=!1),this._isTriggered=!1,this._enableComponent())},r.onUpdate=function(){this._isTriggered&&(this._upVec.copyFrom(this._isBack?this._bottomVec:this._topVec),t.Matrix.lookAt(this._currentPos,this._target,this._upVec,this._tempMat),this._tempMat.invert(),this._sceneCameraEntity.transform.worldMatrix=this._tempMat),n._tempMat.copyFrom(this._sceneCamera.viewMatrix);var e=n._tempMat.elements;e[12]=e[13]=e[14]=0,this._directionEntity.transform.worldMatrix=n._tempMat},r._navigateCamera=function(e){var r=e.position;t.Vector2.subtract(n._startPointer,r,this._deltaPointer);var a=-this._deltaPointer.x*this._speedXFactor,i=-this._deltaPointer.y*this._speedYFactor,o=this._startRadian-i>Math.PI&&this._startRadian-i<2*Math.PI;this._isBack=this._startRadian-i<=0||o;var s=this._tempQuat,l=this._tempQuat2;t.Quaternion.rotationAxisAngle(n._startAxis,i,s),t.Quaternion.rotationYawPitchRoll(a,0,0,l),t.Quaternion.multiply(s,l,s),t.Vector3.subtract(n._startPos,this._target,this._rotateVec),t.Vector3.transformByQuat(this._rotateVec,s.invert(),this._currentPos),t.Vector3.add(this._target,this._currentPos,this._currentPos)},r._getTextColor=function(){for(var e=this._endEntity.children,n=0;n<e.length;n++){var r=e[n].findByName("text").getComponent(t.TextRenderer).color.clone();this._textColor.push(r)}},r._recoverTextColor=function(){for(var e=this._endEntity.children,n=0;n<e.length;n++)e[n].findByName("text").getComponent(t.TextRenderer).color.copyFrom(this._textColor[n])},r._disableComponent=function(){var e=[];this._sceneCameraEntity.getComponents(t.Script,e);for(var n=0;n<e.length;n++){var r=e[n],a=Object.getPrototypeOf(r);(a.onUpdate||a.onLateUpdate||a.onPhysicsUpdate)&&r.enabled&&(r.enabled=!1,this._disabledCompArray.push(r))}},r._enableComponent=function(){for(var e=0;e<this._disabledCompArray.length;e++)this._disabledCompArray[e].enabled=!0},ti(n,[{key:"camera",get:function(){return this._sceneCamera},set:function(e){this._sceneCamera=e,this._sceneCameraEntity=this._sceneCamera.entity}},{key:"target",get:function(){return this._target},set:function(e){this._target.copyFrom(e)}}]),n}(t.Script);function th(e,n,r,a,i){void 0===n&&(n=1),void 0===r&&(r=48),void 0===a&&(a=new t.Vector3(0,0,0)),void 0===i&&(i=new t.Vector3(0,0,1));for(var o=new t.ModelMesh(e),s=new Uint16Array(3*r),l=[],c=new t.Vector3(1,0,0).scale(n),h=new t.Quaternion,d=new t.Vector3,u=1;u<=r;u++){var _=(u-1)*3;s[_]=u,s[_+1]=u+1,s[_+2]=0}l.push(a);for(var f=0;f<=r;f++){var p=f/r*Math.PI*2;t.Quaternion.rotationAxisAngle(i,p,h),t.Vector3.transformByQuat(c,h,d),l[f+1]=d.clone()}return o.setPositions(l),o.setIndices(s),o.addSubMesh(0,s.length,t.MeshTopology.Triangles),o.uploadData(!1),o}tc._startQuat=new t.Quaternion,tc._startPointer=new t.Vector2,tc._startPos=new t.Vector3,tc._startAxis=new t.Vector3,tc._tempMat=new t.Matrix,tc._vector=new t.Vector3;var td=function(e){this.radius=9.2,this.endRadius=1.6,this.axisLength=this.radius-2*this.endRadius,this.endDist=this.radius-this.endRadius,this.xRotateVector=new t.Vector3,this.yRotateVector=new t.Vector3,this.zRotateVector=new t.Vector3,this.xTranslateVector=new t.Vector3,this.yTranslateVector=new t.Vector3,this.zTranslateVector=new t.Vector3,this.xEndTranslateVector=new t.Vector3,this.yEndTranslateVector=new t.Vector3,this.zEndTranslateVector=new t.Vector3;var n=new eM(e);n.isTransparent=!0,n.baseColor.set(1,.25,.25,1),this.redMaterial=n;var r=new eM(e);r.isTransparent=!0,r.baseColor.set(.5,.8,.2,1),this.greenMaterial=r;var a=new eM(e);a.isTransparent=!0,a.baseColor.set(.3,.5,1,1),this.blueMaterial=a;var i=new eM(e);i.isTransparent=!0,i.baseColor.set(1,1,1,.1),this.bgMaterial=i;var o=new eM(e);o.isTransparent=!0,o.baseColor.set(.5,.5,.5,1),this.greyMaterial=o,this.axisMesh=t.PrimitiveMesh.createCylinder(e,.12,.12,this.axisLength),this.bgMesh=th(e,this.radius,144),this.endMesh=th(e,this.endRadius-.2),this.xRotateVector=new t.Vector3(0,0,90),this.yRotateVector=new t.Vector3(0,90,0),this.zRotateVector=new t.Vector3(90,0,0),this.xTranslateVector=new t.Vector3(.5*this.axisLength,0,0),this.yTranslateVector=new t.Vector3(0,.5*this.axisLength,0),this.zTranslateVector=new t.Vector3(0,0,.5*this.axisLength),this.xEndTranslateVector=new t.Vector3(this.endDist,0,0),this.yEndTranslateVector=new t.Vector3(0,this.endDist,0),this.zEndTranslateVector=new t.Vector3(0,0,this.endDist)};function tu(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}var t_=function(e){function n(n){if((r=e.call(this,n)||this)._gizmoLayer=t.Layer.Layer30,r._target=new t.Vector3,r._endScript={X:tl,Y:tl,Z:tl,"-X":tl,"-Y":tl,"-Z":tl},r.position=new t.Vector2(0,0),r.size=new t.Vector2(.12,.12),!n.engine.physicsManager)throw Error("PhysicsManager is not initialized");r._utils=new td(r.engine),r._gizmoEntity=n.createChild("navigation-gizmo"),r._gizmoEntity.layer=r._gizmoLayer;var r,a=r._gizmoEntity.createChild("gizmo-camera");a.transform.setPosition(0,0,10);var i=a.addComponent(t.Camera);return i.isOrthographic=!0,i.cullingMask=r._gizmoLayer,i.clearFlags=t.CameraClearFlags.Depth,i.priority=100,r._gizmoCamera=i,r._createGizmo(),r._setTarget=r._setTarget.bind(function(e){if(void 0===e)throw ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(r)),r._target._onValueChanged=r._setTarget,r}ts(n,e);var r=n.prototype;return r.onUpdate=function(){this._gizmoCamera.viewport.set(this.position.x,this.position.y,this.size.x,this.size.y)},r._createGizmo=function(){var e=this._utils,n=this._gizmoEntity.createChild("direction"),r=n.createChild("axis"),a=r.createChild("x"),i=r.createChild("y"),o=r.createChild("z");this._createAxis(a,e.xRotateVector,e.xTranslateVector,e.redMaterial),this._createAxis(i,e.yRotateVector,e.yTranslateVector,e.greenMaterial),this._createAxis(o,e.zRotateVector,e.zTranslateVector,e.blueMaterial);var s=n.createChild("end"),l=s.createChild("x"),c=s.createChild("y"),h=s.createChild("z");this._createEnd(l,e.xEndTranslateVector,e.redMaterial,"X",new t.Color(1,.25,.25,1)),this._createEnd(c,e.yEndTranslateVector,e.greenMaterial,"Y",new t.Color(.5,.8,.2,1)),this._createEnd(h,e.zEndTranslateVector,e.blueMaterial,"Z",new t.Color(.3,.5,1,1));var d=s.createChild("-x"),u=s.createChild("-y"),_=s.createChild("-z");this._createEnd(d,e.xEndTranslateVector.negate(),e.greyMaterial,"-X",new t.Color(1,1,1,0)),this._createEnd(u,e.yEndTranslateVector.negate(),e.greyMaterial,"-Y",new t.Color(1,1,1,0)),this._createEnd(_,e.zEndTranslateVector.negate(),e.greyMaterial,"-Z",new t.Color(1,1,1,0));var f=this._gizmoEntity.createChild("sphere");f.transform.setPosition(0,0,-(e.radius+.5));var p=f.addComponent(t.StaticCollider),m=new t.SphereColliderShape;m.radius=e.radius,p.addShape(m);var g=f.createChild("round"),A=g.addComponent(t.MeshRenderer);A.receiveShadows=!1,A.castShadows=!1,A.mesh=e.bgMesh,A.setMaterial(e.bgMaterial),g.isActive=!1,this._sphereScript=f.addComponent(tc)},r._createAxis=function(e,n,r,a){e.transform.setRotation(n.x,n.y,n.z),e.transform.setPosition(r.x,r.y,r.z);var i=e.addComponent(t.MeshRenderer);i.receiveShadows=!1,i.castShadows=!1,i.mesh=this._utils.axisMesh,i.setMaterial(a)},r._createEnd=function(e,n,r,a,i){var o=this._utils;e.transform.setPosition(n.x,n.y,n.z);var s=e.addComponent(t.StaticCollider),l=new t.SphereColliderShape;l.radius=o.endRadius,s.addShape(l);var c=e.createChild("back"),h=c.addComponent(t.MeshRenderer);h.receiveShadows=!1,h.castShadows=!1,h.mesh=o.endMesh,h.setMaterial(r),c.isActive=!1;var d=e.createChild("text");d.transform.setPosition(0,0,.05);var u=d.addComponent(t.TextRenderer);u.receiveShadows=!1,u.castShadows=!1,u.font=t.Font.createFromOS(this.engine,"Arial"),u.text=a,u.fontStyle=t.FontStyle.Bold,u.fontSize=200,u.color.copyFrom(i),u.horizontalAlignment=t.TextHorizontalAlignment.Center,this._endScript[a]=e.addComponent(tl)},r._setTarget=function(){var e=this;this._sphereScript.target.copyFrom(this._target),Object.keys(this._endScript).forEach(function(t){e._endScript[t].target.copyFrom(e._target)})},ti(n,[{key:"camera",get:function(){return this._sceneCamera},set:function(e){var t=this,n=this._sceneCamera;if(n!==e){if(e)n=this._sceneCamera=e,this._sphereScript.camera=e,Object.keys(this._endScript).forEach(function(n){t._endScript[n].camera=e});else throw Error("navigation gizmo needs scene camera")}}},{key:"target",get:function(){return this._target},set:function(e){e!==this._target&&this._target.copyFrom(e)}},{key:"layer",get:function(){return this._gizmoLayer},set:function(e){this._gizmoLayer!==e&&(this._gizmoLayer=e,this._gizmoCamera.cullingMask=e,function e(t,n){n(t);for(var r,a=function(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return tu(e,void 0);var n=Object.prototype.toString.call(e).slice(8,-1);if("Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return tu(e,void 0)}}(e))){n&&(e=n);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(t.children);!(r=a()).done;)e(r.value,n)}(this._gizmoEntity,function(t){t.layer=e}))}},{key:"priority",get:function(){return this._gizmoCamera.priority},set:function(e){this._gizmoCamera.priority=e}}]),n}(t.Script);function tf(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function tp(e,t,n){return t&&tf(e.prototype,t),n&&tf(e,n),e}function tm(e,t){return(tm=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function tg(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&tm(e,t)}e.SketchMode=void 0,(A=e.SketchMode||(e.SketchMode={}))[A.Wireframe=0]="Wireframe",A[A.Normal=1]="Normal",A[A.Tangent=2]="Tangent",A[A.BiTangent=3]="BiTangent";var tA="\n   uniform sampler2D u_verticesSampler;\n   uniform float u_verticesTextureWidth;\n   uniform float u_verticesTextureHeight;\n   \n   uniform sampler2D u_indicesSampler;\n   uniform float u_indicesTextureWidth;\n   uniform float u_indicesTextureHeight;\n   \n   vec4 getVertexElement(float row, float col) {\n        return texture2D(u_verticesSampler, vec2((col + 0.5) / u_verticesTextureWidth, (row + 0.5) / u_verticesTextureHeight));\n   }\n   \n   vec3 getIndicesElement(float row, float col) {\n        return texture2D(u_indicesSampler, vec2((col + 0.5) / u_indicesTextureWidth, (row + 0.5) / u_indicesTextureHeight )).xyz;\n   }\n   \n   vec2 getVec2(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        return vec2(x, y);\n   }\n   \n   vec3 getVec3(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float z = rows[row_index][value_index];\n        return vec3(x, y, z);\n   }\n   \n   vec4 getVec4(inout vec4[ELEMENT_COUNT] rows, inout int row_index, inout int value_index) {\n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float x = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float y = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float z = rows[row_index][value_index];\n        \n        row_index += (value_index+1)/4;\n        value_index = (value_index+1)%4;\n        float w = rows[row_index][value_index];\n        return vec4(x, y, z, w);\n   }\n",tv="\n        int row = pointIndex * ELEMENT_COUNT / int(u_verticesTextureWidth);\n        int col = pointIndex * ELEMENT_COUNT % int(u_verticesTextureWidth);\n        \n        vec4 rows[ELEMENT_COUNT];\n        for( int i = 0; i < ELEMENT_COUNT; i++ ) {\n            rows[i] = getVertexElement(float(row), float(col + i));\n        }\n        \n        vec3 POSITION = vec3(rows[0].x, rows[0].y, rows[0].z);        \n        int row_index = 0;\n        int value_index = 2;\n#ifdef RENDERER_HAS_NORMAL \n        vec3 NORMAL = getVec3(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_VERTEXCOLOR\n        vec4 COLOR_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_WEIGHT\n        vec4 WEIGHTS_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_JOINT\n        vec4 JOINTS_0 = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_TANGENT\n        vec4 TANGENT = getVec4(rows, row_index, value_index);\n#endif\n\n#ifdef RENDERER_HAS_UV\n        vec2 TEXCOORD_0 = getVec2(rows, row_index, value_index);\n#endif\n";t.Shader.create("tbnShader","\n#include <common>\n   uniform float u_lineScale;\n   uniform mat4 camera_VPMat;\n   uniform mat4 u_worldMatrix;\n   uniform mat4 u_worldNormal;\n\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\n    uniform sampler2D renderer_JointSampler;\n    uniform float renderer_JointCount;\n\n    mat4 getJointMatrix(sampler2D smp, float index) {\n        float base = index / renderer_JointCount;\n        float hf = 0.5 / renderer_JointCount;\n        float v = base + hf;\n\n        vec4 m0 = texture2D(smp, vec2(0.125, v ));\n        vec4 m1 = texture2D(smp, vec2(0.375, v ));\n        vec4 m2 = texture2D(smp, vec2(0.625, v ));\n        vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n        return mat4(m0, m1, m2, m3);\n    }\n#else\n    uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n#endif\n#endif\n\n"+tA+"\n\nvoid main() {\n    int pointIndex = gl_VertexID / 2;\n    "+tv+"\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n\n    gl_Position = u_worldMatrix * position; \n    \n#if defined(SHOW_NORMAL) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        gl_Position.xyz += normalize(normalW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_TANGENT) && defined(RENDERER_HAS_TANGENT)\n    if (gl_VertexID % 2 == 1) {\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        gl_Position.xyz += normalize(tangentW) * u_lineScale;\n    }\n#endif\n\n#if defined(SHOW_BITANGENT) && defined(RENDERER_HAS_TANGENT) && defined(RENDERER_HAS_NORMAL)\n    if (gl_VertexID % 2 == 1) {\n        vec3 normalW = normalize( mat3(u_worldNormal) * normal.xyz );\n        vec3 tangentW = normalize( mat3(u_worldNormal) * tangent.xyz );\n        vec3 bitangentW = cross( normalW, tangentW ) * tangent.w;\n        gl_Position.xyz += normalize(bitangentW) * u_lineScale;\n    }\n#endif\n    \n    gl_Position = camera_VPMat * gl_Position; \n}\n","\nuniform vec4 material_BaseColor;\nvoid main() {\n    gl_FragColor = material_BaseColor;\n}\n");var tC=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("tbnShader"))||this).shaderData.setColor(n._baseColorProp,new t.Color(1,0,0,1)),a.shaderData.enableMacro("SHOW_NORMAL"),a}return tg(n,e),tp(n,[{key:"baseColor",get:function(){return this.shaderData.getColor(n._baseColorProp)},set:function(e){var t=this.shaderData.getColor(n._baseColorProp);e!==t&&t.copyFrom(e)}}]),n}(t.BaseMaterial),ty=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("tbnShader"))||this).shaderData.setColor(n._baseColorProp,new t.Color(0,1,0,1)),a.shaderData.enableMacro("SHOW_TANGENT"),a}return tg(n,e),tp(n,[{key:"baseColor",get:function(){return this.shaderData.getColor(n._baseColorProp)},set:function(e){var t=this.shaderData.getColor(n._baseColorProp);e!==t&&t.copyFrom(e)}}]),n}(t.BaseMaterial),tx=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("tbnShader"))||this).shaderData.setColor(n._baseColorProp,new t.Color(0,0,1,1)),a.shaderData.enableMacro("SHOW_BITANGENT"),a}return tg(n,e),tp(n,[{key:"baseColor",get:function(){return this.shaderData.getColor(n._baseColorProp)},set:function(e){var t=this.shaderData.getColor(n._baseColorProp);e!==t&&t.copyFrom(e)}}]),n}(t.BaseMaterial);t.Shader.create("wireframeShader","\n#include <common>\n   uniform float u_lineScale;\n   uniform mat4 camera_VPMat;\n   uniform mat4 u_worldMatrix;\n   uniform mat4 u_worldNormal;\n\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\n    uniform sampler2D renderer_JointSampler;\n    uniform float renderer_JointCount;\n\n    mat4 getJointMatrix(sampler2D smp, float index) {\n        float base = index / renderer_JointCount;\n        float hf = 0.5 / renderer_JointCount;\n        float v = base + hf;\n\n        vec4 m0 = texture2D(smp, vec2(0.125, v ));\n        vec4 m1 = texture2D(smp, vec2(0.375, v ));\n        vec4 m2 = texture2D(smp, vec2(0.625, v ));\n        vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n        return mat4(m0, m1, m2, m3);\n    }\n#else\n    uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n#endif\n#endif\n\n"+tA+"\n\nvarying vec3 v_baryCenter;\n\nvoid main() {\n    int indicesIndex = gl_VertexID / 3;\n    int indicesRow = indicesIndex / int(u_indicesTextureWidth);\n    int indicesCol = indicesIndex % int(u_indicesTextureWidth);\n    vec3 triangleIndices = getIndicesElement(float(indicesRow), float(indicesCol));\n    int subIndex = gl_VertexID % 3;\n    v_baryCenter = vec3(0.0);\n    v_baryCenter[subIndex] = 1.0;\n    \n    int pointIndex = int(triangleIndices[subIndex]);\n    "+tv+"\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <skinning_vert>\n    \n    gl_Position = u_worldMatrix * position; \n    gl_Position = camera_VPMat * gl_Position; \n}\n","\nvarying vec3 v_baryCenter;\n\nfloat edgeFactor(){\n    vec3 d = fwidth(v_baryCenter);\n    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_baryCenter);\n    return min(min(a3.x, a3.y), a3.z);\n}\n\nuniform vec4 material_BaseColor;\nvoid main() {\n    if (gl_FrontFacing) {\n        gl_FragColor = vec4(material_BaseColor.xyz, 1.0 - edgeFactor());\n    } else {\n        // fade back face\n        gl_FragColor = vec4(material_BaseColor.xyz, (1.0 - edgeFactor()) * 0.3);\n    }\n}\n");var tE=function(e){function n(r){var a;return(a=e.call(this,r,t.Shader.find("wireframeShader"))||this).shaderData.setColor(n._baseColorProp,new t.Color(0,0,0,1)),a.isTransparent=!0,a.renderFace=t.RenderFace.Double,a}return tg(n,e),tp(n,[{key:"baseColor",get:function(){return this.shaderData.getColor(n._baseColorProp)},set:function(e){var t=this.shaderData.getColor(n._baseColorProp);e!==t&&t.copyFrom(e)}}]),n}(t.BaseMaterial),tS=function(n){function r(e){(r=n.call(this,e)||this)._worldNormalMatrix=new t.Matrix,r._worldMatrix=null,r._targetMesh=null,r._verticesTexture=null,r._indicesTexture=null,r._showState=[!1,!1,!1,!1],r._triangleSubMesh=new t.SubMesh,r._lineSubMesh=new t.SubMesh(0,0,t.MeshTopology.Lines);var r,a=r.engine;return r.mesh=new t.ModelMesh(a),r._wireframeMaterial=new tE(a),r._normalMaterial=new tC(a),r._tangentMaterial=new ty(a),r._biTangentMaterial=new tx(a),r.mesh.addSubMesh(r._triangleSubMesh),r.mesh.addSubMesh(r._lineSubMesh),r.mesh.addSubMesh(r._lineSubMesh),r.mesh.addSubMesh(r._lineSubMesh),r.scale=.1,r}tg(r,n);var a=r.prototype;return a.setSketchMode=function(t,n){switch(t){case e.SketchMode.Wireframe:n?(this._targetMesh&&this.setMaterial(0,this._wireframeMaterial),this._showState[0]=!0):(this.setMaterial(0,null),this._showState[0]=!1);break;case e.SketchMode.Normal:n?(this._targetMesh&&this.setMaterial(1,this._normalMaterial),this._showState[1]=!0):(this.setMaterial(1,null),this._showState[1]=!1);break;case e.SketchMode.Tangent:n?(this._targetMesh&&this.setMaterial(2,this._tangentMaterial),this._showState[2]=!0):(this.setMaterial(2,null),this._showState[2]=!1);break;case e.SketchMode.BiTangent:n?(this._targetMesh&&this.setMaterial(3,this._biTangentMaterial),this._showState[3]=!0):(this.setMaterial(3,null),this._showState[3]=!1)}},a.clear=function(){this.setMaterial(0,null),this.setMaterial(1,null),this.setMaterial(2,null),this.setMaterial(3,null)},a.update=function(e){n.prototype.update.call(this,e);var a=this._worldMatrix;if(a){var i=this._worldNormalMatrix;t.Matrix.invert(a,i),i.transpose(),this.shaderData.setMatrix(r._worldNormalProp,i)}},a._uploadIndicesBuffer=function(e){var n=e._indexBufferBinding.buffer,a=n.byteLength,i=new Uint8Array(a);n.getData(i);var o=e._indicesFormat,s=0;switch(o){case t.IndexFormat.UInt8:var l=Math.min(s=a/3,r._MAX_TEXTURE_ROWS),c=Math.ceil(s/r._MAX_TEXTURE_ROWS);this._indicesTexture=new t.Texture2D(this.engine,l,c,t.TextureFormat.R32G32B32A32,!1);for(var h=new Float32Array(l*c*4),d=0;d<s;d++){for(var u=0;u<3;u++)h[4*d+u]=i[3*d+u];h[4*d+3]=0}this._indicesTexture.setPixelBuffer(h),this.shaderData.setTexture(r._indicesSamplerProp,this._indicesTexture),this.shaderData.setFloat(r._indicesTextureWidthProp,l),this.shaderData.setFloat(r._indicesTextureHeightProp,c);break;case t.IndexFormat.UInt16:var _=new Uint16Array(i.buffer),f=Math.min(s=a/6,r._MAX_TEXTURE_ROWS),p=Math.ceil(s/r._MAX_TEXTURE_ROWS);this._indicesTexture=new t.Texture2D(this.engine,f,p,t.TextureFormat.R32G32B32A32,!1);for(var m=new Float32Array(f*p*4),g=0;g<s;g++){for(var A=0;A<3;A++)m[4*g+A]=_[3*g+A];m[4*g+3]=0}this._indicesTexture.setPixelBuffer(m),this.shaderData.setTexture(r._indicesSamplerProp,this._indicesTexture),this.shaderData.setFloat(r._indicesTextureWidthProp,f),this.shaderData.setFloat(r._indicesTextureHeightProp,p);break;case t.IndexFormat.UInt32:var v=new Uint32Array(i.buffer),C=Math.min(s=a/12,r._MAX_TEXTURE_ROWS),y=Math.ceil(s/r._MAX_TEXTURE_ROWS);this._indicesTexture=new t.Texture2D(this.engine,C,y,t.TextureFormat.R32G32B32A32,!1);for(var x=new Float32Array(C*y*4),E=0;E<s;E++){for(var S=0;S<3;S++)x[4*E+S]=v[3*E+S];x[4*E+3]=0}this._indicesTexture.setPixelBuffer(x),this.shaderData.setTexture(r._indicesSamplerProp,this._indicesTexture),this.shaderData.setFloat(r._indicesTextureWidthProp,C),this.shaderData.setFloat(r._indicesTextureHeightProp,y)}this._indicesTexture.filterMode=t.TextureFilterMode.Point},a._uploadVerticesBuffer=function(e){var t=e._vertexBufferBindings[0],n=e.vertexCount,a=this._updateMeshElement(e),i=r._jointIndexBegin,o=a;-1!==i&&(o+=3);var s=new Float32Array(a*n);t.buffer.getData(s);var l=new Uint8Array(s.buffer),c=4*Math.ceil(o/4);this.shaderData.enableMacro("ELEMENT_COUNT",(c/4).toString());for(var h=Math.min(n,r._MAX_TEXTURE_ROWS)*c,d=Math.ceil(n/r._MAX_TEXTURE_ROWS),u=new Float32Array(h*d),_=0;_<n;_++)for(var f=0;f<o;f++)-1!==i&&f===i?u[_*c+f]=l[_*a*4+4*i]:-1!==i&&f===i+1?u[_*c+f]=l[_*a*4+4*i+1]:-1!==i&&f===i+2?u[_*c+f]=l[_*a*4+4*i+2]:-1!==i&&f===i+3?u[_*c+f]=l[_*a*4+4*i+3]:-1!==i&&f>i+3?u[_*c+f]=s[_*a+f-3]:u[_*c+f]=s[_*a+f];this._createVerticesTexture(u,h/4,d),r._jointIndexBegin=-1},a._createVerticesTexture=function(e,n,a){this._verticesTexture=new t.Texture2D(this.engine,n,a,t.TextureFormat.R32G32B32A32,!1),this._verticesTexture.filterMode=t.TextureFilterMode.Point,this._verticesTexture.setPixelBuffer(e),this.shaderData.setTexture(r._verticesSamplerProp,this._verticesTexture),this.shaderData.setFloat(r._verticesTextureWidthProp,n),this.shaderData.setFloat(r._verticesTextureHeightProp,a)},a._updateMeshElement=function(e){var t=this.shaderData;t.disableMacro(r._normalMacro),t.disableMacro(r._vertexColorMacro),t.disableMacro(r._tangentMacro),t.disableMacro(r._uvMacro),t.disableMacro(r._uv1Macro),t.disableMacro(r._weightMacro),t.disableMacro(r._jointMacro);for(var n=0,a=e._vertexElements,i=0,o=a.length;i<o;i++)switch(a[i].semantic){case"POSITION":n+=3;break;case"NORMAL":n+=3,t.enableMacro(r._normalMacro);break;case"COLOR_0":n+=4,t.enableMacro(r._vertexColorMacro);break;case"WEIGHTS_0":n+=4,t.enableMacro(r._weightMacro);break;case"JOINTS_0":r._jointIndexBegin=n,n+=1,t.enableMacro(r._jointMacro);break;case"TANGENT":t.enableMacro(r._tangentMacro),n+=4;break;case"TEXCOORD_0":t.enableMacro(r._uvMacro),n+=2;break;case"TEXCOORD_1":t.enableMacro(r._uv1Macro),n+=2;break;case"TEXCOORD_2":case"TEXCOORD_3":case"TEXCOORD_4":case"TEXCOORD_5":case"TEXCOORD_6":case"TEXCOORD_7":n+=2}return n},a._updateLineSubMesh=function(e){this._lineSubMesh.count=2*e.vertexCount},a._updateTriangleSubMesh=function(e){for(var t=0,n=e.subMeshes,r=0;r<n.length;r++)t+=n[r].count;this._triangleSubMesh.count=t},a._destroy=function(){this._indicesTexture&&this._indicesTexture.destroy(),this._verticesTexture&&this._verticesTexture.destroy()},tp(r,[{key:"scale",get:function(){return this.shaderData.getFloat(r._lineScaleProp)},set:function(e){this.shaderData.setFloat(r._lineScaleProp,e)}},{key:"worldMatrix",set:function(e){e!==this._worldMatrix&&(this._worldMatrix=e,this.shaderData.setMatrix(r._worldMatrixProp,e))}},{key:"targetMesh",set:function(e){if(e!==this._targetMesh){this._destroy(),this._targetMesh=e,this._uploadVerticesBuffer(e),this._uploadIndicesBuffer(e),this._updateTriangleSubMesh(e),this._updateLineSubMesh(e);for(var t=0;t<4;t++)this.setSketchMode(t,this._showState[t])}}},{key:"wireframeMaterial",get:function(){return this._wireframeMaterial}},{key:"normalMaterial",get:function(){return this._normalMaterial}},{key:"tangentMaterial",get:function(){return this._normalMaterial}},{key:"biTangentMaterial",get:function(){return this._normalMaterial}}]),r}(t.SkinnedMeshRenderer);function tM(e,t){return null!=t&&"undefined"!=typeof Symbol&&t[Symbol.hasInstance]?!!t[Symbol.hasInstance](e):q(e,t)}function tT(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function tI(e,t,n){return t&&tT(e.prototype,t),n&&tT(e,n),e}tS._weightMacro=t.ShaderMacro.getByName("RENDERER_HAS_WEIGHT"),tS._jointMacro=t.ShaderMacro.getByName("RENDERER_HAS_JOINT"),tS._MAX_TEXTURE_ROWS=512,tS._jointIndexBegin=-1,tS._verticesSamplerProp=t.ShaderProperty.getByName("u_verticesSampler"),tS._verticesTextureHeightProp=t.ShaderProperty.getByName("u_verticesTextureHeight"),tS._verticesTextureWidthProp=t.ShaderProperty.getByName("u_verticesTextureWidth"),tS._indicesSamplerProp=t.ShaderProperty.getByName("u_indicesSampler"),tS._indicesTextureHeightProp=t.ShaderProperty.getByName("u_indicesTextureHeight"),tS._indicesTextureWidthProp=t.ShaderProperty.getByName("u_indicesTextureWidth"),tS._lineScaleProp=t.ShaderProperty.getByName("u_lineScale"),tS._worldMatrixProp=t.ShaderProperty.getByName("u_worldMatrix"),tS._worldNormalProp=t.ShaderProperty.getByName("u_worldNormal");var tw=0,tD=function(){function e(){this._hooked=!1,this._hooked=!0}var t=e.prototype;return t.reset=function(){tw=0},t.release=function(){this._hooked&&(XMLHttpRequest.prototype.send=this._originalSend,Object.defineProperty(Image.prototype,"src",{set:function(e){this.src.call(this,e)}})),this._hooked=!1},tI(e,[{key:"size",get:function(){var e;return Number(e=tw/1024/1024).toFixed(Math.max(6-e.toString().split(".")[0].length,0))}}]),e}();function tP(){for(var e,n=arguments.length,r=Array(n),a=0;a<n;a++)r[a]=arguments[a];(e=t.Logger).info.apply(e,[].concat(["\uD83D\uDE80 [galacean engine--stats]"],r))}function tb(){for(var e,n=arguments.length,r=Array(n),a=0;a<n;a++)r[a]=arguments[a];(e=t.Logger).error.apply(e,[].concat(["\uD83D\uDE80 [galacean engine-stats]"],r))}var tR=function(){function e(e){if(this.drawCall=0,this.triangles=0,this.lines=0,this.points=0,this.realDrawElements=e.drawElements,this.realDrawArrays=e.drawArrays,e.drawElements=this.hookedDrawElements.bind(this),e.drawArrays=this.hookedDrawArrays.bind(this),this.hasInstancedFunction(e))this.realDrawElementsInstanced=e.drawElementsInstanced,this.realDrawArraysInstanced=e.drawArraysInstanced,e.drawElementsInstanced=this.hookedDrawElementsInstanced.bind(this),e.drawArraysInstanced=this.hookedDrawArraysInstanced.bind(this);else{var t=e.getExtension("ANGLE_instanced_arrays");t?(this.realDrawElementsInstanced=t.drawElementsInstancedANGLE,this.realDrawArraysInstanced=t.drawArraysInstancedANGLE,t.drawElementsInstancedANGLE=this.hookedDrawElementsInstanced.bind(this),t.drawArraysInstancedANGLE=this.hookedDrawArraysInstanced.bind(this)):tb("GPU Instancing is not supported.")}this.hooked=!0,this.gl=e,tP("DrawCall is hooked.")}var t=e.prototype;return t.hasInstancedFunction=function(e){return tM(e,WebGL2RenderingContext)||e.hasOwnProperty("drawElementsInstanced")&&e.hasOwnProperty("drawArraysInstanced")},t.hookedDrawElements=function(e,t,n,r){this.realDrawElements.call(this.gl,e,t,n,r),this.update(t,e)},t.hookedDrawArrays=function(e,t,n){this.realDrawArrays.call(this.gl,e,t,n),this.update(n,e)},t.hookedDrawElementsInstanced=function(e,t,n,r,a){this.realDrawElementsInstanced.call(this.gl,e,t,n,r,a),this.update(t,e)},t.hookedDrawArraysInstanced=function(e,t,n,r){this.realDrawArraysInstanced.call(this.gl,e,t,n,r),this.update(n,e)},t.update=function(e,t){var n=this.gl;switch(this.drawCall++,t){case n.TRIANGLES:this.triangles+=e/3;break;case n.TRIANGLE_STRIP:case n.TRIANGLE_FAN:this.triangles+=e-2;break;case n.LINES:this.lines+=e/2;break;case n.LINE_STRIP:this.lines+=e-1;break;case n.LINE_LOOP:this.lines+=e;break;case n.POINTS:this.points+=e;break;default:tb("Unknown draw mode: "+t)}},t.reset=function(){this.drawCall=0,this.triangles=0,this.lines=0,this.points=0},t.release=function(){if(this.hooked){var e=this.gl;if(e.drawElements=this.realDrawElements,e.drawArrays=this.realDrawArrays,this.hasInstancedFunction(e))e.drawElementsInstanced=this.realDrawElementsInstanced,e.drawArraysInstanced=this.realDrawArraysInstanced;else{var t=e.getExtension("ANGLE_instanced_arrays");t&&(t.drawElementsInstancedANGLE=this.realDrawElementsInstanced,t.drawArraysInstancedANGLE=this.realDrawArraysInstanced)}}this.hooked=!1},e}(),tN=function(){function e(e){this.shaders=0,this.realAttachShader=e.attachShader,this.realDetachShader=e.detachShader,e.attachShader=this.hookedAttachShader.bind(this),e.detachShader=this.hookedDetachShader.bind(this),this.hooked=!0,this.gl=e,tP("Shader is hooked.")}var t=e.prototype;return t.hookedAttachShader=function(e,t){this.realAttachShader.call(this.gl,e,t),this.shaders++,tP("AttachShader:",t,"shaders: "+this.shaders)},t.hookedDetachShader=function(e,t){this.realDetachShader.call(this.gl,e,t),this.shaders--,tP("DetachShader. shaders: "+this.shaders)},t.reset=function(){this.shaders=0},t.release=function(){this.hooked&&(this.gl.attachShader=this.realAttachShader,this.gl.detachShader=this.realDetachShader),this.hooked=!1},e}(),tO=function(){function e(e){this.textures=0,this.realCreateTexture=e.createTexture,this.realDeleteTexture=e.deleteTexture,e.createTexture=this.hookedCreateTexture.bind(this),e.deleteTexture=this.hookedDeleteTexture.bind(this),this.hooked=!0,this.gl=e,tP("Texture is hooked.")}var t=e.prototype;return t.hookedCreateTexture=function(){var e=this.realCreateTexture.call(this.gl);return this.textures++,tP("CreateTexture:",e,"textures: "+this.textures),e},t.hookedDeleteTexture=function(e){this.realDeleteTexture.call(this.gl,e),this.textures--,tP("DeleteTexture. textures: "+this.textures)},t.reset=function(){this.textures=0},t.release=function(){this.hooked&&(this.gl.createTexture=this.realCreateTexture,this.gl.deleteTexture=this.realDeleteTexture),this.hooked=!1},e}(),tL=function(){function e(e){this.samplingFrames=60,this.samplingIndex=0,this.updateCounter=0,this.updateTime=0,this.gl=e,this.hook(e)}var t=e.prototype;return t.hook=function(e){this.drawCallHook=new tR(e),this.textureHook=new tO(e),this.shaderHook=new tN(e),this.requestHook=new tD},t.reset=function(){this.drawCallHook&&this.drawCallHook.reset()},t.release=function(){this.drawCallHook&&this.drawCallHook.release(),this.textureHook&&this.textureHook.release(),this.shaderHook&&this.shaderHook.release()},t.update=function(){this.updateCounter++;var e=performance.now();if(!(e-this.updateTime<1e3)){if(this.samplingIndex!==this.samplingFrames){this.reset(),this.samplingIndex++;return}this.samplingIndex=0;var t={fps:Math.round(1e3*this.updateCounter/(e-this.updateTime)),memory:performance.memory&&performance.memory.usedJSHeapSize/1048576>>0,drawCall:this.drawCallHook.drawCall,triangles:this.drawCallHook.triangles,lines:this.drawCallHook.lines,points:this.drawCallHook.points,textures:this.textureHook.textures,size:this.requestHook.size,shaders:this.shaderHook.shaders,webglContext:window.hasOwnProperty("WebGL2RenderingContext")&&tM(this.gl,WebGL2RenderingContext)?"2.0":"1.0"};return this.reset(),this.updateCounter=0,this.updateTime=e,t}},e}(),tB="\n  .gl-perf {\n    pointer-events: none;\n    user-select: none;\n    position: fixed;\n    top: 0;\n    left: 0;\n    padding: "+10/7.5+"vh "+10/7.5+"vh 0 "+10/7.5+"vh;\n    background: rgba(0, 0, 0, 0.3);\n    color: #fff;\n    font: "+10/7.5+"vh arial;\n  }\n\n  .gl-perf dl,\n  .gl-perf dt,\n  .gl-perf dd {\n    padding: 0;\n    margin: 0;\n  }\n\n  .gl-perf dt {\n    color: #fff;\n    text-shadow: #000 0 0 1px;\n  }\n\n  .gl-perf dt .unit{\n    font-size: "+10/7.5+"vh;\n  }\n\n  .gl-perf dd {\n    font-size: "+20/7.5+"vh;\n    padding: "+10/7.5+"vh 0 "+10/7.5+"vh;\n  }\n",tV=function(){function e(e){this.core=new tL(e),this.items=[],this.items=["fps","memory","drawCall","triangles","textures","shaders","size","webglContext"],this.createContainer(),this.update=this.update.bind(this)}var t=e.prototype;return t.createContainer=function(){var e=document.createElement("div");e.classList.add("gl-perf"),e.innerHTML='\n  <dl>\n    <dt>FPS</dt>\n    <dd>0</dd>\n    <dt>Memory <span class="unit">(MB)</span></dt>\n    <dd>0</dd>\n    <dt>DrawCall</dt>\n    <dd>0</dd>\n    <dt>Triangles</dt>\n    <dd>0</dd>\n    <dt>Textures</dt>\n    <dd>0</dd>\n    <dt>Shaders</dt>\n    <dd>0</dd>\n    <dt>Network Size <span class="unit">(MB)</span></dt>\n    <dd>0</dd>\n    <dt>WebGL</dt>\n    <dd></dd>\n  </dl>\n',e.appendChild(this.createStyle()),document.body.appendChild(e),this.doms=Array.prototype.slice.apply(e.querySelectorAll("dd")),this.container=e},t.createStyle=function(){var e=document.createElement("style");return e.type="text/css",e.appendChild(document.createTextNode(tB)),e},t.update=function(){var e=this.core.update();if(e)for(var t,n=0,r=this.items.length;n<r;n++)t=this,function(n,r){var a=t.doms[n],i=e[t.items[n]]||0;requestAnimationFrame(function(){a.innerText=i})}(n,0)},t.reset=function(){this.core.reset()},t.release=function(){this.core.release()},t.destroy=function(){this.release(),document.body.removeChild(this.container)},e}();function tF(e,t){return(tF=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var tH=function(e){function t(){return e.apply(this,arguments)}!function(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&tF(e,t)}(t,e);var n=t.prototype;return n.onBeginRender=function(e){this.camera=e,this.monitor||this._setupMonitor()},n.onEndRender=function(e){this.monitor&&this.monitor.update()},n._setupMonitor=function(){var e=this.camera.engine._hardwareRenderer.gl;e&&(this.monitor=new tV(e))},t.hookRequest=function(){!function(){var e=XMLHttpRequest.prototype.send,t=new Map;function n(e,n){void 0==t.get(e)&&(t.set(e,n),tw+=n)}XMLHttpRequest.prototype.send=function(t){this.addEventListener("load",function(){var e=0;""===this.responseType||"text"===this.responseType?e=new Blob([JSON.stringify(this.responseText)]).size:tM(this.response,Blob)?e=this.response.size:tM(this.response,ArrayBuffer)?e=this.response.byteLength:"json"===this.responseType&&(e=new Blob([JSON.stringify(this.response)]).size),n(this.responseURL,e)},!1),e.call(this,t);var r=Object.getOwnPropertyDescriptor(Image.prototype,"src").set;this.originalImageSrc=r,Object.defineProperty(Image.prototype,"src",{set:function(e){var t=this;fetch(e).then(function(e){e.ok&&e.blob().then(function(e){n(t.responseURL,e.size)})}),r.call(this,e)}})}}()},tI(t,[{key:"enabled",set:function(e){e?this._setupMonitor():this.monitor.destroy()}}]),t}(t.Script),tU=[].concat([{source:"#ifndef BLENDSHAPE_INCLUDED\n#define BLENDSHAPE_INCLUDED\n\n#ifdef RENDERER_HAS_BLENDSHAPE\n	#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\n		mediump sampler2DArray renderer_BlendShapeTexture;\n		ivec3 renderer_BlendShapeTextureInfo;\n		float renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n\n		vec3 getBlendShapeVertexElement(int blendShapeIndex, int vertexElementIndex){			\n			int y = vertexElementIndex / renderer_BlendShapeTextureInfo.y;\n			int x = vertexElementIndex - y * renderer_BlendShapeTextureInfo.y;\n			ivec3 uv = ivec3(x, y , blendShapeIndex);\n			return (texelFetch(renderer_BlendShapeTexture, uv, 0)).xyz;\n		}\n	#else\n		#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n			float renderer_BlendShapeWeights[2];\n		#else\n			#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n				float renderer_BlendShapeWeights[4];\n			#else\n				float renderer_BlendShapeWeights[8];\n			#endif\n		#endif\n	#endif\n\n	void calculateBlendShape(Attributes attributes, inout vec4 position\n        #ifdef RENDERER_HAS_NORMAL\n            ,inout vec3 normal\n			 #ifdef RENDERER_HAS_TANGENT\n            	,inout vec4 tangent\n        	#endif\n        #endif\n       \n	){\n		#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE	\n    		int vertexOffset = gl_VertexID * renderer_BlendShapeTextureInfo.x;\n    		for(int i = 0; i < RENDERER_BLENDSHAPE_COUNT; i++){\n    			int vertexElementOffset = vertexOffset;\n    			float weight = renderer_BlendShapeWeights[i];\n    			// Warnning: Multiplying by 0 creates weird precision issues, causing rendering anomalies in Ace2 Android13\n    			if(weight != 0.0){\n    				position.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    \n    				#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\n    					vertexElementOffset += 1;\n    					normal += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    				#endif\n    \n    				#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT)\n    					vertexElementOffset += 1;\n    					tangent.xyz += getBlendShapeVertexElement(i, vertexElementOffset) * weight;\n    				#endif\n    			}\n    \n    		}\n    	#else\n    		position.xyz += attributes.POSITION_BS0 * renderer_BlendShapeWeights[0];\n    		position.xyz += attributes.POSITION_BS1 * renderer_BlendShapeWeights[1];\n\n    		#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    			#ifdef RENDERER_HAS_NORMAL\n    				normal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    				normal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    			#endif\n                    \n    			#ifdef RENDERER_HAS_TANGENT\n    				tangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    				tangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    			#endif				\n    		#else\n    			#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    				position.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    				position.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n\n    				#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\n    					normal += attributes.NORMAL_BS0 * renderer_BlendShapeWeights[0];\n    					normal += attributes.NORMAL_BS1 * renderer_BlendShapeWeights[1];\n    					normal += attributes.NORMAL_BS2 * renderer_BlendShapeWeights[2];\n    					normal += attributes.NORMAL_BS3 * renderer_BlendShapeWeights[3];\n    				#endif\n\n    				#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT )\n    					tangent.xyz += attributes.TANGENT_BS0 * renderer_BlendShapeWeights[0];\n    					tangent.xyz += attributes.TANGENT_BS1 * renderer_BlendShapeWeights[1];\n    					tangent.xyz += attributes.TANGENT_BS2 * renderer_BlendShapeWeights[2];\n    					tangent.xyz += attributes.TANGENT_BS3 * renderer_BlendShapeWeights[3];\n    				#endif\n    			#else\n    				position.xyz += attributes.POSITION_BS2 * renderer_BlendShapeWeights[2];\n    				position.xyz += attributes.POSITION_BS3 * renderer_BlendShapeWeights[3];\n    				position.xyz += attributes.POSITION_BS4 * renderer_BlendShapeWeights[4];\n    				position.xyz += attributes.POSITION_BS5 * renderer_BlendShapeWeights[5];\n    				position.xyz += attributes.POSITION_BS6 * renderer_BlendShapeWeights[6];\n    				position.xyz += attributes.POSITION_BS7 * renderer_BlendShapeWeights[7];\n    			#endif\n    		#endif\n    	#endif\n	}\n\n#endif\n\n\n#endif",includeKey:"BlendShape.glsl"},{source:"#ifndef COMMON_INCLUDED\n#define COMMON_INCLUDED\n\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n\nfloat pow2(float x ) {\n    return x * x;\n}\n\nvec4 RGBMToLinear(vec4 value, float maxRange ) {\n    return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 gammaToLinear(vec4 srgbIn){\n    return vec4( pow(srgbIn.rgb, vec3(2.2)), srgbIn.a);\n}\n\nvec4 linearToGamma(vec4 linearIn){\n	linearIn = max(linearIn, 0.0);\n    return vec4( pow(linearIn.rgb, vec3(1.0 / 2.2)), linearIn.a);\n}\n\nvec4 camera_DepthBufferParams;\n\nfloat remapDepthBufferLinear01(float z){\n	return 1.0/ (camera_DepthBufferParams.x * z + camera_DepthBufferParams.y);\n}\n\n\n#ifdef GRAPHICS_API_WEBGL2\n	#define INVERSE_MAT(mat) inverse(mat)\n#else\n	mat2 inverseMat(mat2 m) {\n		return mat2(m[1][1],-m[0][1],\n				-m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n	}\n	mat3 inverseMat(mat3 m) {\n		float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n		float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n		float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n		float b01 = a22 * a11 - a12 * a21;\n		float b11 = -a22 * a10 + a12 * a20;\n		float b21 = a21 * a10 - a11 * a20;\n\n		float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n		return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n					b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n					b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n	}\n	mat4 inverseMat(mat4 m) {\n		float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n			a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n			a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n			a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n			b00 = a00 * a11 - a01 * a10,\n			b01 = a00 * a12 - a02 * a10,\n			b02 = a00 * a13 - a03 * a10,\n			b03 = a01 * a12 - a02 * a11,\n			b04 = a01 * a13 - a03 * a11,\n			b05 = a02 * a13 - a03 * a12,\n			b06 = a20 * a31 - a21 * a30,\n			b07 = a20 * a32 - a22 * a30,\n			b08 = a20 * a33 - a23 * a30,\n			b09 = a21 * a32 - a22 * a31,\n			b10 = a21 * a33 - a23 * a31,\n			b11 = a22 * a33 - a23 * a32,\n\n			det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n		return mat4(\n			a11 * b11 - a12 * b10 + a13 * b09,\n			a02 * b10 - a01 * b11 - a03 * b09,\n			a31 * b05 - a32 * b04 + a33 * b03,\n			a22 * b04 - a21 * b05 - a23 * b03,\n			a12 * b08 - a10 * b11 - a13 * b07,\n			a00 * b11 - a02 * b08 + a03 * b07,\n			a32 * b02 - a30 * b05 - a33 * b01,\n			a20 * b05 - a22 * b02 + a23 * b01,\n			a10 * b10 - a11 * b08 + a13 * b06,\n			a01 * b08 - a00 * b10 - a03 * b06,\n			a30 * b04 - a31 * b02 + a33 * b00,\n			a21 * b02 - a20 * b04 - a23 * b00,\n			a11 * b07 - a10 * b09 - a12 * b06,\n			a00 * b09 - a01 * b07 + a02 * b06,\n			a31 * b01 - a30 * b03 - a32 * b00,\n			a20 * b03 - a21 * b01 + a22 * b00) / det;\n	}\n\n	#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n\n\n#endif",includeKey:"Common.glsl"},{source:"#ifndef FOG_INCLUDED\n#define FOG_INCLUDED\n\n#if SCENE_FOG_MODE != 0\n    vec4 scene_FogColor;\n    vec4 scene_FogParams; // (-1/(end-start), end/(end-start), density/ln(2),density/sprt(ln(2)));\n\n    vec4 fog(vec4 color, vec3 positionVS){\n        float fogDepth = length(positionVS);\n\n        #if SCENE_FOG_MODE == 1\n            // (end-z) / (end-start) = z * (-1/(end-start)) + (end/(end-start))\n            float fogIntensity = clamp(fogDepth * scene_FogParams.x + scene_FogParams.y, 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 2\n            // exp(-z * density) = exp2((-z * density)/ln(2)) = exp2(-z * density/ln(2))\n            float fogIntensity = clamp(exp2(-fogDepth * scene_FogParams.z), 0.0, 1.0);\n        #elif SCENE_FOG_MODE == 3\n            // exp(-(z * density)^2) = exp2(-(z * density)^2/ln(2)) = exp2(-(z * density/sprt(ln(2)))^2)\n            float factor = fogDepth * scene_FogParams.w;\n            float fogIntensity = clamp(exp2(-factor * factor), 0.0, 1.0);\n        #endif\n\n        color.rgb = mix(scene_FogColor.rgb, color.rgb, fogIntensity);\n\n        return color;\n    }\n#endif\n\n\n#endif",includeKey:"Fog.glsl"},{source:"#ifndef LIGHT_INCLUDED\n#define LIGHT_INCLUDED\n\n\nivec4 renderer_Layer;\n#ifndef GRAPHICS_API_WEBGL2\n    bool isBitSet(float value, float mask, float bitIndex){\n        return mod(floor(value / pow(2.0, bitIndex)), 2.0) == 1.0 && mod(floor(mask / pow(2.0, bitIndex)), 2.0) == 1.0;\n    }\n#endif\n\nbool isRendererCulledByLight(ivec2 rendererLayer, ivec2 lightCullingMask){\n    #ifdef GRAPHICS_API_WEBGL2\n    return !((rendererLayer.x & lightCullingMask.x) != 0 || (rendererLayer.y & lightCullingMask.y) != 0);\n    #else\n    for (int i = 0; i < 16; i++) {\n        if (isBitSet( float(rendererLayer.x), float(lightCullingMask.x), float(i)) || isBitSet( float(rendererLayer.y), float(lightCullingMask.y), float(i))) {\n            return false;\n        }\n    }\n    return true;\n    #endif\n}\n\n// Directional light\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    struct DirectLight {\n        vec3 color;\n        vec3 direction;\n    };\n\n    ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];\n    vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        DirectLight getDirectLight(int index){\n            DirectLight light;\n            light.color = scene_DirectLightColor[index];\n            light.direction = scene_DirectLightDirection[index];\n    \n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Point light\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n    struct PointLight {\n        vec3 color;\n        vec3 position;\n        float distance;\n    };\n\n    ivec2 scene_PointLightCullingMask[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightColor[ SCENE_POINT_LIGHT_COUNT ];\n    vec3 scene_PointLightPosition[ SCENE_POINT_LIGHT_COUNT ];\n    float scene_PointLightDistance[ SCENE_POINT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        PointLight getPointLight(int index){\n            PointLight light;\n            light.color = scene_PointLightColor[index];\n            light.position = scene_PointLightPosition[index];\n            light.distance = scene_PointLightDistance[index];\n\n            return light;\n        }\n    #endif\n\n#endif\n\n\n// Spot light\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n    struct SpotLight {\n        vec3 color;\n        vec3 position;\n        vec3 direction;\n        float distance;\n        float angleCos;\n        float penumbraCos;\n    };\n\n    ivec2 scene_SpotLightCullingMask[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightColor[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightPosition[ SCENE_SPOT_LIGHT_COUNT ];\n    vec3 scene_SpotLightDirection[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightDistance[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightAngleCos[ SCENE_SPOT_LIGHT_COUNT ];\n    float scene_SpotLightPenumbraCos[ SCENE_SPOT_LIGHT_COUNT ];\n\n    #ifdef GRAPHICS_API_WEBGL2\n        SpotLight getSpotLight(int index){\n            SpotLight light;\n            light.color = scene_SpotLightColor[index];\n            light.position = scene_SpotLightPosition[index];\n            light.direction = scene_SpotLightDirection[index];\n            light.distance = scene_SpotLightDistance[index];\n            light.angleCos = scene_SpotLightAngleCos[index];\n            light.penumbraCos = scene_SpotLightPenumbraCos[index];\n\n            return light;\n        }\n    #endif\n\n\n#endif\n\n// Ambient light\nstruct EnvMapLight {\n    vec3 diffuse;\n    float mipMapLevel;\n    float diffuseIntensity;\n    float specularIntensity;\n};\n\n\nEnvMapLight scene_EnvMapLight;\n\n#ifdef SCENE_USE_SH\n    vec3 scene_EnvSH[9];\n#endif\n\n#ifdef SCENE_USE_SPECULAR_ENV\n    samplerCube scene_EnvSpecularSampler;\n#endif\n\n\n\n\n#endif\n",includeKey:"Light.glsl"},{source:"#ifndef NORMAL_INCLUDED\n#define NORMAL_INCLUDED\n\n\nvec3 getNormalByNormalTexture(mat3 tbn, sampler2D normalTexture, float normalIntensity, vec2 uv, bool isFrontFacing){\n    vec3 normal = (texture2D(normalTexture, uv)).rgb;\n    normal = normalize(tbn * ((2.0 * normal - 1.0) * vec3(normalIntensity, normalIntensity, 1.0)));\n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n\n    return normal;\n}\n\nmat3 getTBNByDerivatives(vec2 uv, vec3 normal, vec3 position, bool isFrontFacing){\n    #ifdef HAS_DERIVATIVES\n        uv = isFrontFacing? uv: -uv;\n        // ref: http://www.thetenthplanet.de/archives/1180\n        // get edge vectors of the pixel triangle\n	    vec3 dp1 = dFdx(position);\n	    vec3 dp2 = dFdy(position);\n	    vec2 duv1 = dFdx(uv);\n	    vec2 duv2 = dFdy(uv);\n	    // solve the linear system\n	    vec3 dp2perp = cross(dp2, normal);\n	    vec3 dp1perp = cross(normal, dp1);\n	    vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n	    vec3 bitangent = dp2perp * duv1.y + dp1perp * duv2.y;\n	    // construct a scale-invariant frame \n        float denom = max( dot(tangent, tangent), dot(bitangent, bitangent) );\n        float invmax = (denom == 0.0) ? 0.0 : camera_ProjectionParams.x / sqrt( denom );\n	    return mat3(tangent * invmax, bitangent * invmax, normal);\n    #else\n        return mat3(vec3(0.0), vec3(0.0), normal);\n    #endif\n}\n\n\n#endif",includeKey:"Normal.glsl"},{source:'#ifndef SHADOW_SAMPLE_TENT_INCLUDED\n#define SHADOW_SAMPLE_TENT_INCLUDED\n\n// ------------------------------------------------------------------\n//  PCF Filtering Tent Functions\n// ------------------------------------------------------------------\n\n// Assuming a isoceles right angled triangle of height "triangleHeight" (as drawn below).\n// This function return the area of the triangle above the first texel(in Y the first texel).\n//\n// |\\      <-- 45 degree slop isosceles right angled triangle\n// | \\\n// ----    <-- length of this side is "triangleHeight"\n// _ _ _ _ <-- texels\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight) {\n    return triangleHeight - 0.5;\n}\n\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\n// This function return the area of the triangle above each of those texels.\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\n//  /   \\\n// _ _ _ _ <-- texels\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut) {\n    // Compute the exterior areas,a and h is same.\n    float a = offset + 0.5;\n    float offsetSquaredHalved = a * a * 0.5;\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\n\n    // Compute the middle areas\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\n    // intersect the axis between Y and Z (ie where offset = 0).\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\n    float clampedOffsetLeft = min(offset,0.0);\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\n\n    // We do the same for the Z but with the right part of the isoceles triangle\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\n    float clampedOffsetRight = max(offset,0.0);\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\n}\n\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\n// This function return the weight of each texels area relative to the full triangle area.\n//  /       \\\n// _ _ _ _ _ _ <-- texels\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB) {\n    vec4 areaFrom3texelTriangle;\n    vec4 areaUncutFrom3texelTriangle;\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\n\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\n    // 0.16 is 1/(the triangle area)\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\n}\n\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\n{\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\n\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\n    vec3 texelsWeightsUA, texelsWeightsUB;\n    vec3 texelsWeightsVA, texelsWeightsVB;\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\n\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\n\n    // move the PCF bilinear fetches to respect texels weights\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\n\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\n\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\n}\n\n\n#endif',includeKey:"ShadowSampleTent.glsl"},{source:'#ifndef SHADOW_INCLUDED\n#define SHADOW_INCLUDED\n\n#include "Transform.glsl"\n#include "Common.glsl"\n\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n    #define NEED_CALCULATE_SHADOWS\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n\n        mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT + 1];\n        vec4 scene_ShadowSplitSpheres[4];\n\n        mediump int computeCascadeIndex(vec3 positionWS) {\n            vec3 fromCenter0 = positionWS - scene_ShadowSplitSpheres[0].xyz;\n            vec3 fromCenter1 = positionWS - scene_ShadowSplitSpheres[1].xyz;\n            vec3 fromCenter2 = positionWS - scene_ShadowSplitSpheres[2].xyz;\n            vec3 fromCenter3 = positionWS - scene_ShadowSplitSpheres[3].xyz;\n\n            mediump vec4 comparison = vec4(\n                (dot(fromCenter0, fromCenter0) < scene_ShadowSplitSpheres[0].w),\n                (dot(fromCenter1, fromCenter1) < scene_ShadowSplitSpheres[1].w),\n                (dot(fromCenter2, fromCenter2) < scene_ShadowSplitSpheres[2].w),\n                (dot(fromCenter3, fromCenter3) < scene_ShadowSplitSpheres[3].w));\n            comparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\n            mediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\n            mediump int index = 4 - int(dot(comparison, indexCoefficient));\n            return index;\n        }\n\n        vec3 getShadowCoord(vec3 positionWS) {\n            #if SCENE_SHADOW_CASCADED_COUNT == 1\n                mediump int cascadeIndex = 0;\n            #else\n                mediump int cascadeIndex = computeCascadeIndex(positionWS);\n            #endif\n        \n            #ifdef GRAPHICS_API_WEBGL2\n                mat4 shadowMatrix = scene_ShadowMatrices[cascadeIndex];\n            #else\n                mat4 shadowMatrix;\n                #if SCENE_SHADOW_CASCADED_COUNT == 4\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else if (cascadeIndex == 2) {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } else if (cascadeIndex == 3) {\n                        shadowMatrix = scene_ShadowMatrices[3];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[4];\n                    }\n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 2\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else if (cascadeIndex == 1) {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } else {\n                        shadowMatrix = scene_ShadowMatrices[2];\n                    } \n                #endif\n                #if SCENE_SHADOW_CASCADED_COUNT == 1\n                    if (cascadeIndex == 0) {\n                        shadowMatrix = scene_ShadowMatrices[0];\n                    } else  {\n                        shadowMatrix = scene_ShadowMatrices[1];\n                    } \n                #endif\n            #endif\n        \n            vec4 shadowCoord = shadowMatrix * vec4(positionWS, 1.0);\n            return shadowCoord.xyz;\n        }\n\n    #endif\n#endif\n\n\n#ifdef NEED_CALCULATE_SHADOWS\n    // intensity, null, fadeScale, fadeBias\n    vec4 scene_ShadowInfo;\n    vec4 scene_ShadowMapSize;\n\n    #ifdef GRAPHICS_API_WEBGL2\n        mediump sampler2DShadow scene_ShadowMap;\n        #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n    #else\n        sampler2D scene_ShadowMap;\n        #ifdef ENGINE_NO_DEPTH_TEXTURE\n            const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));\n            /**\n            * Unpack depth value.\n            */\n            float unpack(in vec4 rgbaDepth) {\n                return dot(rgbaDepth, bitShift);\n            }\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n        #else\n            #define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) ((texture2D(textureName, coord3.xy)).r < coord3.z ? 0.0 : 1.0)\n        #endif\n        #define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 2\n        float sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowMapSize) {\n            float attenuation;\n            vec4 attenuation4;\n            vec2 offset=shadowMapSize.xy/2.0;\n            vec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\n            vec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\n            vec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\n            vec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\n            attenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\n            attenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\n            attenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\n            attenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\n            attenuation = dot(attenuation4, vec4(0.25));\n            return attenuation;\n        }\n    #endif\n\n    #if SCENE_SHADOW_TYPE == 3\n        #include "ShadowSampleTent.glsl"\n\n        float sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap), vec3 shadowCoord, vec4 shadowmapSize) {\n            float attenuation;\n            float fetchesWeights[9];\n            vec2 fetchesUV[9];\n            sampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\n            attenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\n            attenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\n            attenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\n            attenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\n            attenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\n            attenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\n            attenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\n            attenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\n            attenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\n            return attenuation;\n        }\n    #endif\n\n\n    float getShadowFade(vec3 positionWS){\n        vec3 camToPixel = positionWS - camera_Position;\n        float distanceCamToPixel2 = dot(camToPixel, camToPixel);\n        return saturate( distanceCamToPixel2 * scene_ShadowInfo.z + scene_ShadowInfo.w );\n    }\n\n\n    float sampleShadowMap(vec3 positionWS, vec3 shadowCoord) {\n        float attenuation = 1.0;\n        if(shadowCoord.z > 0.0 && shadowCoord.z < 1.0) {\n        #if SCENE_SHADOW_TYPE == 1\n            attenuation = SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap, shadowCoord);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 2\n            attenuation = sampleShadowMapFiltered4(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n\n        #if SCENE_SHADOW_TYPE == 3\n            attenuation = sampleShadowMapFiltered9(scene_ShadowMap, shadowCoord, scene_ShadowMapSize);\n        #endif\n            attenuation = mix(1.0, attenuation, scene_ShadowInfo.x);\n        }\n\n        float shadowFade = getShadowFade(positionWS);\n        attenuation = mix(1.0, mix(attenuation, 1.0, shadowFade), scene_ShadowInfo.x);\n\n        return attenuation;\n    }\n#endif\n\n\n#endif',includeKey:"Shadow.glsl"},{source:"#ifndef TRANSFORM_INCLUDED\n#define TRANSFORM_INCLUDED\n\nmat4 renderer_LocalMat;\nmat4 renderer_ModelMat;\nmat4 camera_ViewMat;\nmat4 camera_ProjMat;\nmat4 renderer_MVMat;\nmat4 renderer_MVPMat;\nmat4 renderer_NormalMat;\n\nvec3 camera_Position;\nvec3 camera_Forward; \nvec4 camera_ProjectionParams;\n\n#endif",includeKey:"Transform.glsl"},{source:"#ifndef SKIN_INCLUDED\n#define SKIN_INCLUDED\n\n\n#ifdef RENDERER_HAS_SKIN\n    #ifdef RENDERER_USE_JOINT_TEXTURE\n        sampler2D renderer_JointSampler;\n        float renderer_JointCount;\n\n        mat4 getJointMatrix(sampler2D smp, float index){\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n    #else\n        mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n    #endif\n\n    mat4 getSkinMatrix(Attributes attributes){\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.x ) +\n                attributes.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.y ) +\n                attributes.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.z ) +\n                attributes.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, attributes.JOINTS_0.w );\n        #else\n            mat4 skinMatrix =\n                attributes.WEIGHTS_0.x * renderer_JointMatrix[ int( attributes.JOINTS_0.x ) ] +\n                attributes.WEIGHTS_0.y * renderer_JointMatrix[ int( attributes.JOINTS_0.y ) ] +\n                attributes.WEIGHTS_0.z * renderer_JointMatrix[ int( attributes.JOINTS_0.z ) ] +\n                attributes.WEIGHTS_0.w * renderer_JointMatrix[ int( attributes.JOINTS_0.w ) ];\n        #endif\n\n        return skinMatrix;\n    }\n\n#endif\n\n\n#endif",includeKey:"Skin.glsl"}],[{source:'#ifndef FORWARD_PASS_PBR_INCLUDED\n#define FORWARD_PASS_PBR_INCLUDED\n\n#include "Common.glsl"\n#include "Fog.glsl"\n\n#include "AttributesPBR.glsl"\n#include "VaryingsPBR.glsl"\n#include "LightDirectPBR.glsl"\n#include "LightIndirectPBR.glsl"\n\n#include "VertexPBR.glsl"\n#include "FragmentPBR.glsl"\n\n\nVaryings PBRVertex(Attributes attributes) {\n  Varyings varyings;\n\n  varyings.uv = getUV0(attributes);\n  #ifdef RENDERER_HAS_UV1\n      varyings.uv1 = attributes.TEXCOORD_1;\n  #endif\n\n  #ifdef RENDERER_ENABLE_VERTEXCOLOR\n    varyings.vertexColor = attributes.COLOR_0;\n  #endif\n\n\n  VertexInputs vertexInputs = getVertexInputs(attributes);\n\n  // positionWS\n  varyings.positionWS = vertexInputs.positionWS;\n\n  // positionVS\n  #if SCENE_FOG_MODE != 0\n	  varyings.positionVS = vertexInputs.positionVS;\n	#endif\n\n  // normalWS、tangentWS、bitangentWS\n  #ifdef RENDERER_HAS_NORMAL\n    varyings.normalWS = vertexInputs.normalWS;\n    #ifdef RENDERER_HAS_TANGENT\n      varyings.tangentWS = vertexInputs.tangentWS;\n      varyings.bitangentWS = vertexInputs.bitangentWS;\n    #endif\n  #endif\n\n  // ShadowCoord\n  #if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n      varyings.shadowCoord = getShadowCoord(vertexInputs.positionWS);\n  #endif\n\n  gl_Position = renderer_MVPMat * vertexInputs.positionOS;\n\n  return varyings;\n}\n\n\nvoid PBRFragment(Varyings varyings) {\n  BRDFData brdfData;\n\n  // Get aoUV\n  vec2 aoUV = varyings.uv;\n  #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(RENDERER_HAS_UV1)\n    if(material_OcclusionTextureCoord == 1.0){\n        aoUV = varyings.uv1;\n    }\n  #endif\n\n  SurfaceData surfaceData = getSurfaceData(varyings, aoUV, gl_FrontFacing);\n\n  // Can modify surfaceData here\n  initBRDFData(surfaceData, brdfData);\n\n  vec4 color = vec4(0, 0, 0, surfaceData.opacity);\n\n  // Get shadow attenuation\n  float shadowAttenuation = 1.0;\n  #if defined(SCENE_DIRECT_LIGHT_COUNT) && defined(NEED_CALCULATE_SHADOWS)\n    #if SCENE_SHADOW_CASCADED_COUNT == 1\n      vec3 shadowCoord = varyings.shadowCoord;\n    #else\n      vec3 shadowCoord = getShadowCoord(varyings.positionWS);\n    #endif\n    shadowAttenuation *= sampleShadowMap(varyings.positionWS, shadowCoord);\n  #endif\n\n  // Evaluate direct lighting\n  evaluateDirectRadiance(varyings, surfaceData, brdfData, shadowAttenuation, color.rgb);\n\n  // IBL\n  evaluateIBL(varyings, surfaceData, brdfData, color.rgb);\n\n  // Emissive\n  color.rgb += surfaceData.emissiveColor;\n\n\n  #if SCENE_FOG_MODE != 0\n      color = fog(color, varyings.positionVS);\n  #endif\n\n  #ifndef ENGINE_IS_COLORSPACE_GAMMA\n      color = linearToGamma(color);\n  #endif\n\n  gl_FragColor = color;\n}\n\n\n#endif',includeKey:"ForwardPassPBR.glsl"},{source:"#ifndef ATTRIBUTES_PBR_INCLUDED\n#define ATTRIBUTES_PBR_INCLUDED\n\n\nstruct Attributes{\n  	vec3 POSITION;\n\n	#ifdef RENDERER_HAS_BLENDSHAPE\n    	#ifndef RENDERER_BLENDSHAPE_USE_TEXTURE\n    		vec3 POSITION_BS0;\n    	  	vec3 POSITION_BS1;\n    	  	#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    	    	vec3 NORMAL_BS0;\n    	    	vec3 NORMAL_BS1;\n    	    	vec3 TANGENT_BS0;\n    	    	vec3 TANGENT_BS1;\n    	  	#else\n    	    	#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n    	    	  vec3 POSITION_BS2;\n    	    	  vec3 POSITION_BS3;\n\n    	    	  #ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\n    	    	    vec3 NORMAL_BS0;\n    	    	    vec3 NORMAL_BS1;\n    	    	    vec3 NORMAL_BS2;\n    	    	    vec3 NORMAL_BS3;\n    	    	  #endif\n\n    	    	  #ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\n    	    	    vec3 TANGENT_BS0;\n    	    	    vec3 TANGENT_BS1;\n    	    	    vec3 TANGENT_BS2;\n    	    	    vec3 TANGENT_BS3;\n    	    	  #endif\n\n    	    	#else\n    	    	  vec3 POSITION_BS2;\n    	    	  vec3 POSITION_BS3;\n    	    	  vec3 POSITION_BS4;\n    	    	  vec3 POSITION_BS5;\n    	    	  vec3 POSITION_BS6;\n    	    	  vec3 POSITION_BS7;\n    	    #endif\n    	#endif\n    #endif\n  #endif\n\n\n  	#ifdef RENDERER_HAS_UV\n  	    vec2 TEXCOORD_0;\n  	#endif\n\n  	#ifdef RENDERER_HAS_UV1\n  	    vec2 TEXCOORD_1;\n  	#endif\n\n  	#ifdef RENDERER_HAS_SKIN\n  	    vec4 JOINTS_0;\n  	    vec4 WEIGHTS_0;\n  	#endif\n\n  	#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  	    vec4 COLOR_0;\n  	#endif\n\n	#ifdef RENDERER_HAS_NORMAL\n	    vec3 NORMAL;\n	#endif\n\n    #ifdef RENDERER_HAS_TANGENT\n        vec4 TANGENT;\n    #endif\n};\n\n\n#endif",includeKey:"AttributesPBR.glsl"},{source:'#ifndef VARYINGS_PBR_INCLUDED\n#define VARYINGS_PBR_INCLUDED\n\n#include "Shadow.glsl"\n\nstruct Varyings{\n	vec2 uv;\n	#ifdef RENDERER_HAS_UV1\n	    vec2 uv1;\n	#endif\n\n	#ifdef RENDERER_ENABLE_VERTEXCOLOR\n  		vec4 vertexColor;\n	#endif\n\n	vec3 positionWS;\n\n	#if SCENE_FOG_MODE != 0\n	    vec3 positionVS;\n	#endif\n\n	#ifdef RENDERER_HAS_NORMAL\n	    vec3 normalWS;\n	    #ifdef RENDERER_HAS_TANGENT\n			vec3 tangentWS;\n			vec3 bitangentWS;\n	    #endif\n	#endif\n\n\n	#if defined(NEED_CALCULATE_SHADOWS) && (SCENE_SHADOW_CASCADED_COUNT == 1)\n	    vec3 shadowCoord;\n	#endif\n};\n\n\n#endif',includeKey:"VaryingsPBR.glsl"},{source:'#ifndef MATERIAL_INPUT_PBR_INCLUDED\n#define MATERIAL_INPUT_PBR_INCLUDED\n\n#include "Normal.glsl"\n\nfloat material_AlphaCutoff;\nvec4 material_BaseColor;\nfloat material_Metal;\nfloat material_Roughness;\nfloat material_IOR;\nvec3 material_PBRSpecularColor;\nfloat material_Glossiness;\nvec3 material_EmissiveColor;\nfloat material_NormalIntensity;\nfloat material_OcclusionIntensity;\nfloat material_OcclusionTextureCoord;\n\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n    float material_ClearCoat;\n    float material_ClearCoatRoughness;\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n        sampler2D material_ClearCoatTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n        sampler2D material_ClearCoatRoughnessTexture;\n    #endif\n\n    #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n        sampler2D material_ClearCoatNormalTexture;\n    #endif\n#endif\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 material_AnisotropyInfo;\n    #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n        sampler2D material_AnisotropyTexture;\n    #endif\n#endif\n\n// Texture\n#ifdef MATERIAL_HAS_BASETEXTURE\n    sampler2D material_BaseTexture;\n#endif\n\n#ifdef MATERIAL_HAS_NORMALTEXTURE\n    sampler2D material_NormalTexture;\n#endif\n\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\n    sampler2D material_EmissiveTexture;\n#endif\n\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n    sampler2D material_RoughnessMetallicTexture;\n#endif\n\n\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n    sampler2D material_SpecularGlossinessTexture;\n#endif\n\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n    sampler2D material_OcclusionTexture;\n#endif\n\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Aniso Bent Normals\n    // Mc Alley https://www.gdcvault.com/play/1022235/Rendering-the-World-of-Far \n    vec3 getAnisotropicBentNormal(SurfaceData surfaceData) {\n        vec3  anisotropyDirection = (surfaceData.anisotropy >= 0.0) ? surfaceData.anisotropicB : surfaceData.anisotropicT;\n        vec3  anisotropicTangent  = cross(anisotropyDirection, surfaceData.viewDir);\n        vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n        // reduce stretching for (roughness < 0.2), refer to https://advances.realtimerendering.com/s2018/Siggraph%202018%20HDRP%20talk_with%20notes.pdf 80\n        vec3  bentNormal          = normalize( mix(surfaceData.normal, anisotropicNormal, abs(surfaceData.anisotropy) * saturate( 5.0 * surfaceData.roughness)) );\n\n        return bentNormal;\n    }\n#endif\n\n\nSurfaceData getSurfaceData(Varyings v, vec2 aoUV, bool isFrontFacing){\n    SurfaceData surfaceData;\n\n    vec2 uv = v.uv;\n\n    // common\n    vec4 baseColor = material_BaseColor;\n    float metallic = material_Metal;\n    float roughness = material_Roughness;\n    vec3 specularColor = material_PBRSpecularColor;\n    float glossiness = material_Glossiness;\n    float f0 = pow2( (material_IOR - 1.0) / (material_IOR + 1.0) );\n    vec3 emissiveRadiance = material_EmissiveColor;\n\n    #ifdef MATERIAL_HAS_BASETEXTURE\n        vec4 baseTextureColor = texture2D(material_BaseTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            baseTextureColor = gammaToLinear(baseTextureColor);\n        #endif\n        baseColor *= baseTextureColor;\n    #endif\n\n    #ifdef RENDERER_ENABLE_VERTEXCOLOR\n        baseColor *= v.vertexColor;\n    #endif\n\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    #ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\n        vec4 metalRoughMapColor = texture2D( material_RoughnessMetallicTexture, uv );\n        roughness *= metalRoughMapColor.g;\n        metallic *= metalRoughMapColor.b;\n    #endif\n\n    #ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\n        vec4 specularGlossinessColor = texture2D(material_SpecularGlossinessTexture, uv );\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            specularGlossinessColor = gammaToLinear(specularGlossinessColor);\n        #endif\n        specularColor *= specularGlossinessColor.rgb;\n        glossiness *= specularGlossinessColor.a;\n        roughness =  1.0 - glossiness;\n    #endif\n\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n\n    surfaceData.albedoColor = baseColor.rgb;\n    surfaceData.specularColor = specularColor;\n    surfaceData.emissiveColor = emissiveRadiance;\n    surfaceData.metallic = metallic;\n    surfaceData.roughness = roughness;\n    surfaceData.f0 = f0;\n\n    #ifdef MATERIAL_IS_TRANSPARENT\n        surfaceData.opacity = baseColor.a;\n    #else\n        surfaceData.opacity = 1.0;\n    #endif\n\n\n    // Geometry\n    surfaceData.position = v.positionWS;\n    \n    #ifdef CAMERA_ORTHOGRAPHIC\n        surfaceData.viewDir = -camera_Forward;\n    #else\n        surfaceData.viewDir = normalize(camera_Position - v.positionWS);\n    #endif\n\n    // Normal\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = normalize(v.normalWS);\n    #elif defined(HAS_DERIVATIVES)\n        vec3 pos_dx = dFdx(v.positionWS);\n        vec3 pos_dy = dFdy(v.positionWS);\n        vec3 normal = normalize( cross(pos_dx, pos_dy) );\n        normal *= camera_ProjectionParams.x;\n    #else\n        vec3 normal = vec3(0, 0, 1);\n    #endif\n    \n    normal *= float( isFrontFacing ) * 2.0 - 1.0;\n    surfaceData.normal = normal;\n\n    // Tangent\n    #ifdef NEED_TANGENT\n        #if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT)\n            surfaceData.tangent = v.tangentWS;\n            surfaceData.bitangent = v.bitangentWS;\n            mat3 tbn = mat3(v.tangentWS, v.bitangentWS, v.normalWS);\n        #else\n            mat3 tbn = getTBNByDerivatives(uv, normal, v.positionWS, isFrontFacing);\n            surfaceData.tangent = tbn[0];\n            surfaceData.bitangent = tbn[1];\n        #endif\n\n        #ifdef MATERIAL_HAS_NORMALTEXTURE\n            surfaceData.normal = getNormalByNormalTexture(tbn, material_NormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #endif\n    #endif\n\n    surfaceData.dotNV = saturate( dot(surfaceData.normal, surfaceData.viewDir) );\n\n    // Clear Coat\n     #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        #ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\n            surfaceData.clearCoatNormal = getNormalByNormalTexture(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal), material_ClearCoatNormalTexture, material_NormalIntensity, uv, isFrontFacing);\n        #else\n            surfaceData.clearCoatNormal = normal;\n        #endif\n        surfaceData.clearCoatDotNV = saturate( dot(surfaceData.clearCoatNormal, surfaceData.viewDir) );\n\n        surfaceData.clearCoat = material_ClearCoat;\n        surfaceData.clearCoatRoughness = material_ClearCoatRoughness;\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\n            surfaceData.clearCoat *= (texture2D( material_ClearCoatTexture, uv )).r;\n        #endif\n\n        #ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\n            surfaceData.clearCoatRoughness *= (texture2D( material_ClearCoatRoughnessTexture, uv )).g;\n        #endif\n\n        surfaceData.clearCoat = saturate( surfaceData.clearCoat );\n        surfaceData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n    #endif\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy = material_AnisotropyInfo.z;\n        vec3 anisotropicDirection = vec3(material_AnisotropyInfo.xy, 0.0);\n        #ifdef MATERIAL_HAS_ANISOTROPY_TEXTURE\n            vec3 anisotropyTextureInfo = (texture2D( material_AnisotropyTexture, uv )).rgb;\n            anisotropy *= anisotropyTextureInfo.b;\n            anisotropicDirection.xy *= anisotropyTextureInfo.rg * 2.0 - 1.0;\n        #endif\n\n        surfaceData.anisotropy = anisotropy;\n        surfaceData.anisotropicT = normalize(mat3(surfaceData.tangent, surfaceData.bitangent, surfaceData.normal) * anisotropicDirection);\n        surfaceData.anisotropicB = normalize(cross(surfaceData.normal, surfaceData.anisotropicT));\n        surfaceData.anisotropicN = getAnisotropicBentNormal(surfaceData);\n    #endif\n\n    // AO\n    float diffuseAO = 1.0;\n    float specularAO = 1.0;\n\n    #ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\n        diffuseAO = ((texture2D(material_OcclusionTexture, aoUV)).r - 1.0) * material_OcclusionIntensity + 1.0;\n    #endif\n\n    #if defined(MATERIAL_HAS_OCCLUSION_TEXTURE) && defined(SCENE_USE_SPECULAR_ENV) \n        specularAO = saturate( pow( surfaceData.dotNV + diffuseAO, exp2( - 16.0 * surfaceData.roughness - 1.0 ) ) - 1.0 + diffuseAO );\n    #endif\n\n    surfaceData.diffuseAO = diffuseAO;\n    surfaceData.specularAO = specularAO;\n\n    return surfaceData;\n}\n\n\n\n#endif',includeKey:"FragmentPBR.glsl"},{source:'\n#ifndef LIGHT_DIRECT_PBR_INCLUDED\n#define LIGHT_DIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_SURFACE_SHADING\n    #define FUNCTION_SURFACE_SHADING surfaceShading\n#endif\n#ifndef FUNCTION_DIFFUSE_LOBE\n    #define FUNCTION_DIFFUSE_LOBE diffuseLobe\n#endif\n#ifndef FUNCTION_SPECULAR_LOBE\n    #define FUNCTION_SPECULAR_LOBE specularLobe\n#endif\n#ifndef FUNCTION_CLEAR_COAT_LOBE\n    #define FUNCTION_CLEAR_COAT_LOBE clearCoatLobe\n#endif\n\n#include "BRDF.glsl"\n#include "Light.glsl"\n#include "ReflectionLobe.glsl"\n\nvoid surfaceShading(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 lightColor, inout vec3 color) {\n\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n    float dotNL = saturate( dot( surfaceData.normal, incidentDirection ) );\n    vec3 irradiance = dotNL * lightColor * PI;\n\n    // ClearCoat Lobe\n    float attenuation = FUNCTION_CLEAR_COAT_LOBE(varyings, surfaceData, brdfData, incidentDirection, lightColor, specularColor);\n\n    vec3 attenuationIrradiance = attenuation * irradiance;\n    // Diffuse Lobe\n    FUNCTION_DIFFUSE_LOBE(varyings, surfaceData, brdfData, attenuationIrradiance, diffuseColor);\n    // Specular Lobe\n    FUNCTION_SPECULAR_LOBE(varyings, surfaceData, brdfData, incidentDirection, attenuationIrradiance, specularColor);\n\n    color += diffuseColor + specularColor;\n\n}\n\n#ifdef SCENE_DIRECT_LIGHT_COUNT\n\n    void addDirectionalDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, DirectLight directionalLight, inout vec3 color) {\n        vec3 lightColor = directionalLight.color;\n        vec3 direction = -directionalLight.direction;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n    }\n\n#endif\n\n#ifdef SCENE_POINT_LIGHT_COUNT\n\n	void addPointDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, PointLight pointLight, inout vec3 color) {\n		vec3 lVector = pointLight.position - surfaceData.position;\n		vec3 direction = normalize( lVector );\n		float lightDistance = length( lVector );\n\n		vec3 lightColor = pointLight.color;\n		lightColor *= clamp(1.0 - pow(lightDistance/pointLight.distance, 4.0), 0.0, 1.0);\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n	}\n\n#endif\n\n#ifdef SCENE_SPOT_LIGHT_COUNT\n\n	void addSpotDirectLightRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, SpotLight spotLight, inout vec3 color) {\n\n		vec3 lVector = spotLight.position - surfaceData.position;\n		vec3 direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( direction, -spotLight.direction );\n\n		float spotEffect = smoothstep( spotLight.penumbraCos, spotLight.angleCos, angleCos );\n		float decayEffect = clamp(1.0 - pow(lightDistance/spotLight.distance, 4.0), 0.0, 1.0);\n\n		vec3 lightColor = spotLight.color;\n		lightColor *= spotEffect * decayEffect;\n\n        FUNCTION_SURFACE_SHADING(varyings, surfaceData, brdfData, direction, lightColor, color);\n\n	}\n\n\n#endif\n\nvoid evaluateDirectRadiance(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float shadowAttenuation, inout vec3 color){\n    #ifdef SCENE_DIRECT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_DIRECT_LIGHT_COUNT; i ++ ) {\n            // warning: use `continue` syntax may trigger flickering bug in safri 16.1.\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_DirectLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    DirectLight directionalLight = getDirectLight(i);\n                #else\n                    DirectLight directionalLight;\n                    directionalLight.color = scene_DirectLightColor[i];\n                    directionalLight.direction = scene_DirectLightDirection[i];\n                #endif\n                \n                #ifdef NEED_CALCULATE_SHADOWS\n                    if (i == 0) { // Sun light index is always 0\n                        directionalLight.color *= shadowAttenuation;\n                    }\n                #endif\n                addDirectionalDirectLightRadiance(varyings, surfaceData, brdfData, directionalLight, color );\n            }\n        }\n\n    #endif\n\n    #ifdef SCENE_POINT_LIGHT_COUNT\n\n        for ( int i = 0; i < SCENE_POINT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_PointLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    PointLight pointLight = getPointLight(i);\n                #else\n                    PointLight pointLight;\n                    pointLight.color = scene_PointLightColor[i];\n                    pointLight.position = scene_PointLightPosition[i];\n                    pointLight.distance = scene_PointLightDistance[i];\n                #endif\n                addPointDirectLightRadiance(varyings, surfaceData, brdfData, pointLight, color );\n            } \n        }\n\n    #endif\n\n    #ifdef SCENE_SPOT_LIGHT_COUNT\n      \n        for ( int i = 0; i < SCENE_SPOT_LIGHT_COUNT; i ++ ) {\n            if(!isRendererCulledByLight(renderer_Layer.xy, scene_SpotLightCullingMask[i])){\n                #ifdef GRAPHICS_API_WEBGL2\n                    SpotLight spotLight = getSpotLight(i);\n                #else\n                    SpotLight spotLight;\n                    spotLight.color = scene_SpotLightColor[i];\n                    spotLight.position = scene_SpotLightPosition[i];\n                    spotLight.direction = scene_SpotLightDirection[i];\n                    spotLight.distance = scene_SpotLightDistance[i];\n                    spotLight.angleCos = scene_SpotLightAngleCos[i];\n                    spotLight.penumbraCos = scene_SpotLightPenumbraCos[i];\n                #endif\n                addSpotDirectLightRadiance( varyings, surfaceData, brdfData, spotLight, color );\n            } \n        }\n\n    #endif\n}\n\n\n#endif',includeKey:"LightDirectPBR.glsl"},{source:'\n#ifndef LIGHT_INDIRECT_PBR_INCLUDED\n#define LIGHT_INDIRECT_PBR_INCLUDED\n\n#ifndef FUNCTION_DIFFUSE_IBL\n    #define FUNCTION_DIFFUSE_IBL evaluateDiffuseIBL\n#endif\n#ifndef FUNCTION_SPECULAR_IBL\n    #define FUNCTION_SPECULAR_IBL evaluateSpecularIBL\n#endif\n#ifndef FUNCTION_CLEAR_COAT_IBL\n    #define FUNCTION_CLEAR_COAT_IBL evaluateClearCoatIBL\n#endif\n\n\n#include "BRDF.glsl"\n#include "Light.glsl"\n#include "LightProbe.glsl"\n\n// ------------------------Diffuse------------------------\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeIrradiance(vec3 sh[9], vec3 normal){\n      normal.x = -normal.x;\n      vec3 result = sh[0] +\n\n            sh[1] * (normal.y) +\n            sh[2] * (normal.z) +\n            sh[3] * (normal.x) +\n\n            sh[4] * (normal.y * normal.x) +\n            sh[5] * (normal.y * normal.z) +\n            sh[6] * (3.0 * normal.z * normal.z - 1.0) +\n            sh[7] * (normal.z * normal.x) +\n            sh[8] * (normal.x * normal.x - normal.y * normal.y);\n    \n    return max(result, vec3(0.0));\n\n}\n\n\nvoid evaluateDiffuseIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 diffuseColor){\n    #ifdef SCENE_USE_SH\n        vec3 irradiance = getLightProbeIrradiance(scene_EnvSH, surfaceData.normal);\n        #ifdef ENGINE_IS_COLORSPACE_GAMMA\n            irradiance = (linearToGamma(vec4(irradiance, 1.0))).rgb;\n        #endif\n        irradiance *= scene_EnvMapLight.diffuseIntensity;\n    #else\n       vec3 irradiance = scene_EnvMapLight.diffuse * scene_EnvMapLight.diffuseIntensity;\n       irradiance *= PI;\n    #endif\n\n    diffuseColor += surfaceData.diffuseAO * irradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nfloat evaluateClearCoatIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 specularColor){\n    float radianceAttenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3 clearCoatRadiance = getLightProbeRadiance(surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatRoughness);\n        specularColor += surfaceData.specularAO * clearCoatRadiance * surfaceData.clearCoat * envBRDFApprox(brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness, surfaceData.clearCoatDotNV);\n        radianceAttenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return radianceAttenuation;\n}\n\nvoid evaluateSpecularIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, float radianceAttenuation, inout vec3 specularColor){\n    vec3 radiance = getLightProbeRadiance(surfaceData, surfaceData.normal, brdfData.roughness);\n    specularColor += surfaceData.specularAO * radianceAttenuation * radiance * envBRDFApprox(brdfData.specularColor, brdfData.roughness, surfaceData.dotNV );\n}\n\n\nvoid evaluateIBL(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, inout vec3 color){\n    vec3 diffuseColor = vec3(0);\n    vec3 specularColor = vec3(0);\n\n    // IBL diffuse\n    FUNCTION_DIFFUSE_IBL(varyings, surfaceData, brdfData, diffuseColor);\n\n    // IBL ClearCoat\n    float radianceAttenuation = FUNCTION_CLEAR_COAT_IBL(varyings, surfaceData, brdfData, specularColor);\n\n    // IBL specular\n    FUNCTION_SPECULAR_IBL(varyings, surfaceData, brdfData, radianceAttenuation, specularColor);\n\n    color += diffuseColor + specularColor;\n}\n\n\n#endif',includeKey:"LightIndirectPBR.glsl"},{source:'#ifndef VERTEX_INCLUDE\n#define VERTEX_INCLUDE\n\n#include "Transform.glsl"\n#include "Skin.glsl"\n#include "BlendShape.glsl"\n#include "Shadow.glsl"\n\n\nstruct VertexInputs{\n    vec4 positionOS;\n    vec3 positionWS;\n\n    #if SCENE_FOG_MODE != 0\n        vec3 positionVS;\n    #endif\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normalWS;\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS;\n            vec3 bitangentWS;\n        #endif\n    #endif\n};\n\nvec4 material_TilingOffset;\nvec2 getUV0(Attributes attributes){\n    vec2 uv0 = vec2(0);\n\n    #ifdef RENDERER_HAS_UV\n        uv0 = attributes.TEXCOORD_0;\n    #endif\n\n    return uv0 * material_TilingOffset.xy + material_TilingOffset.zw;\n}\n\nVertexInputs getVertexInputs(Attributes attributes){\n    VertexInputs inputs;\n    vec4 position = vec4(attributes.POSITION, 1.0);\n\n    #ifdef RENDERER_HAS_NORMAL\n        vec3 normal = vec3( attributes.NORMAL );\n        #ifdef RENDERER_HAS_TANGENT\n            vec4 tangent = vec4( attributes.TANGENT );\n        #endif\n    #endif\n\n   \n    // BlendShape\n    #ifdef RENDERER_HAS_BLENDSHAPE\n        calculateBlendShape(attributes, position\n        #ifdef RENDERER_HAS_NORMAL\n            ,normal\n             #ifdef RENDERER_HAS_TANGENT\n                ,tangent\n            #endif\n        #endif\n        );\n    #endif\n\n    // Skin\n    #ifdef RENDERER_HAS_SKIN\n        mat4 skinMatrix = getSkinMatrix(attributes);\n        position = skinMatrix * position;\n\n        #if defined(RENDERER_HAS_NORMAL)\n            mat3 skinNormalMatrix = INVERSE_MAT(mat3(skinMatrix));\n            normal = normal * skinNormalMatrix;\n            #ifdef RENDERER_HAS_TANGENT\n                tangent.xyz = tangent.xyz * skinNormalMatrix;\n            #endif\n        #endif\n    #endif\n\n    // TBN world space\n    #ifdef RENDERER_HAS_NORMAL\n        inputs.normalWS = normalize( mat3(renderer_NormalMat) * normal );\n\n        #ifdef RENDERER_HAS_TANGENT\n            vec3 tangentWS = normalize( mat3(renderer_NormalMat) * tangent.xyz );\n            vec3 bitangentWS = cross( inputs.normalWS, tangentWS ) * tangent.w;\n\n            inputs.tangentWS = tangentWS;\n            inputs.bitangentWS = bitangentWS;\n        #endif\n    #endif\n\n\n    inputs.positionOS = position;\n    vec4 positionWS = renderer_ModelMat * position;\n    inputs.positionWS = positionWS.xyz / positionWS.w;\n\n     #if SCENE_FOG_MODE != 0\n        vec4 positionVS = renderer_MVMat * position;\n        inputs.positionVS = positionVS.xyz / positionVS.w;\n    #endif\n\n    return inputs;\n}\n\n#endif',includeKey:"VertexPBR.glsl"},{source:'\n#ifndef BRDF_INCLUDED\n#define BRDF_INCLUDED\n\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS            0.002025\n\n#if defined(RENDERER_HAS_TANGENT) || defined(MATERIAL_ENABLE_ANISOTROPY) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) || defined(MATERIAL_HAS_NORMALTEXTURE)\n    #define NEED_TANGENT\n#endif\n\n\nstruct SurfaceData{\n    // common\n	vec3  albedoColor;\n    vec3  specularColor;\n	vec3  emissiveColor;\n    float metallic;\n    float roughness;\n    float diffuseAO;\n    float specularAO;\n    float f0;\n    float opacity;\n\n    // geometry\n    vec3 position;\n    vec3 normal;\n\n    #ifdef NEED_TANGENT\n        vec3  tangent;\n        vec3  bitangent;\n    #endif\n\n    vec3  viewDir;\n    float dotNV;\n\n    // Anisotropy\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        float anisotropy;\n        vec3  anisotropicT;\n        vec3  anisotropicB;\n        vec3  anisotropicN;\n    #endif\n\n    // Clear coat\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoat;\n        float clearCoatRoughness;\n        vec3  clearCoatNormal;\n        float clearCoatDotNV;\n    #endif\n};\n\n\nstruct BRDFData{\n    vec3  diffuseColor;\n    vec3  specularColor;\n    float roughness;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        vec3  clearCoatSpecularColor;\n        float clearCoatRoughness;\n    #endif\n};\n\n\nfloat getAARoughnessFactor(vec3 normal) {\n    // Kaplanyan 2016, "Stable specular highlights"\n    // Tokuyoshi 2017, "Error Reduction and Simplification for Shading Anti-Aliasing"\n    // Tokuyoshi and Kaplanyan 2019, "Improved Geometric Specular Antialiasing"\n    #ifdef HAS_DERIVATIVES\n        vec3 dxy = max( abs(dFdx(normal)), abs(dFdy(normal)) );\n        return max( max(dxy.x, dxy.y), dxy.z );\n    #else\n        return 0.0;\n    #endif\n}\n\n\nfloat F_Schlick(float f0, float dotLH) {\n	return f0 + 0.96 * (pow(1.0 - dotLH, 5.0));\n}\n\nvec3 F_Schlick(vec3 specularColor, float dotLH ) {\n\n	// Original approximation by Christophe Schlick \'94\n	// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH \'13)\n	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(float alpha, float dotNL, float dotNV ) {\n\n	float a2 = pow2( alpha );\n\n	// dotNL and dotNV are explicitly swapped. This is not a mistake.\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n	return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"\n    // Heitz http://jcgt.org/published/0003/02/03/paper.pdf\n    float G_GGX_SmithCorrelated_Anisotropic(float at, float ab, float ToV, float BoV, float ToL, float BoL, float NoV, float NoL) {\n        float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n        float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n        return 0.5 / max(lambdaV + lambdaL, EPSILON);\n    }\n#endif\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat D_GGX(float alpha, float dotNH ) {\n\n	float a2 = pow2( alpha );\n\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n	return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    // GGX Distribution Anisotropic\n    // https://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf Addenda\n    float D_GGX_Anisotropic(float at, float ab, float ToH, float BoH, float NoH) {\n        float a2 = at * ab;\n        highp vec3 d = vec3(ab * ToH, at * BoH, a2 * NoH);\n        highp float d2 = dot(d, d);\n        float b2 = a2 / d2;\n        return a2 * b2 * b2 * RECIPROCAL_PI;\n    }\n#endif\n\nvec3 isotropicLobe(vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float D = D_GGX( alpha, dotNH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n	return F * ( G * D );\n}\n\n#ifdef MATERIAL_ENABLE_ANISOTROPY\n    vec3 anisotropicLobe(vec3 h, vec3 l, SurfaceData surfaceData, vec3 specularColor, float alpha, float dotNV, float dotNL, float dotNH, float dotLH) {\n        vec3 t = surfaceData.anisotropicT;\n        vec3 b = surfaceData.anisotropicB;\n        vec3 v = surfaceData.viewDir;\n\n        float dotTV = dot(t, v);\n        float dotBV = dot(b, v);\n        float dotTL = dot(t, l);\n        float dotBL = dot(b, l);\n        float dotTH = dot(t, h);\n        float dotBH = dot(b, h);\n\n        // Aniso parameter remapping\n        // https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf page 24\n        float at = max(alpha * (1.0 + surfaceData.anisotropy), MIN_ROUGHNESS);\n        float ab = max(alpha * (1.0 - surfaceData.anisotropy), MIN_ROUGHNESS);\n\n        // specular anisotropic BRDF\n    	vec3 F = F_Schlick( specularColor, dotLH );\n        float D = D_GGX_Anisotropic(at, ab, dotTH, dotBH, dotNH);\n        float G = G_GGX_SmithCorrelated_Anisotropic(at, ab, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL);\n\n        return F * ( G * D );\n    }\n#endif\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX(vec3 incidentDirection, SurfaceData surfaceData, vec3 normal, vec3 specularColor, float roughness ) {\n\n	float alpha = pow2( roughness ); // UE4\'s roughness\n\n	vec3 halfDir = normalize( incidentDirection + surfaceData.viewDir );\n\n	float dotNL = saturate( dot( normal, incidentDirection ) );\n    float dotNV = saturate( dot( normal, surfaceData.viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentDirection, halfDir ) );\n\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        return anisotropicLobe(halfDir, incidentDirection, surfaceData, specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #else\n        return isotropicLobe(specularColor, alpha, dotNV, dotNL, dotNH, dotLH);\n    #endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n	return RECIPROCAL_PI * diffuseColor;\n}\n\n\nvoid initBRDFData(SurfaceData surfaceData, out BRDFData brdfData){\n    vec3 albedoColor = surfaceData.albedoColor;\n    vec3 specularColor = surfaceData.specularColor;\n    float metallic = surfaceData.metallic;\n    float roughness = surfaceData.roughness;\n    float f0 = surfaceData.f0;\n\n    #ifdef IS_METALLIC_WORKFLOW\n        brdfData.diffuseColor = albedoColor * ( 1.0 - metallic );\n        brdfData.specularColor = mix( vec3(f0), albedoColor, metallic );\n    #else\n        float specularStrength = max( max( specularColor.r, specularColor.g ), specularColor.b );\n        brdfData.diffuseColor = albedoColor * ( 1.0 - specularStrength );\n        brdfData.specularColor = specularColor;\n    #endif\n\n    brdfData.roughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(roughness + getAARoughnessFactor(surfaceData.normal), 1.0));\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        brdfData.clearCoatRoughness = max(MIN_PERCEPTUAL_ROUGHNESS, min(surfaceData.clearCoatRoughness + getAARoughnessFactor(surfaceData.clearCoatNormal), 1.0));\n        brdfData.clearCoatSpecularColor = vec3(0.04);\n    #endif\n}\n\n#endif',includeKey:"BRDF.glsl"},{source:"#ifndef LIGHT_PROBE\n#define LIGHT_PROBE\n\n// ------------------------Specular------------------------\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float dotNV ) {\n\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n    return specularColor * AB.x + AB.y;\n\n}\n\n\nvec3 getReflectedVector(SurfaceData surfaceData, vec3 n) {\n    #ifdef MATERIAL_ENABLE_ANISOTROPY\n        vec3 r = reflect(-surfaceData.viewDir, surfaceData.anisotropicN);\n    #else\n        vec3 r = reflect(-surfaceData.viewDir, n);\n    #endif\n\n    return r;\n}\n\nfloat getSpecularMIPLevel(float roughness, int maxMIPLevel ) {\n    return roughness * float(maxMIPLevel);\n}\n\n// sh need be pre-scaled in CPU.\nvec3 getLightProbeRadiance(SurfaceData surfaceData, vec3 normal, float roughness) {\n\n    #ifndef SCENE_USE_SPECULAR_ENV\n        return vec3(0);\n    #else\n        vec3 reflectVec = getReflectedVector(surfaceData, normal);\n        reflectVec.x = -reflectVec.x; // TextureCube is left-hand,so x need inverse\n        \n        float specularMIPLevel = getSpecularMIPLevel(roughness, int(scene_EnvMapLight.mipMapLevel) );\n\n        #ifdef HAS_TEX_LOD\n            vec4 envMapColor = textureCubeLodEXT( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #else\n            vec4 envMapColor = textureCube( scene_EnvSpecularSampler, reflectVec, specularMIPLevel );\n        #endif\n\n        #ifdef SCENE_IS_DECODE_ENV_RGBM\n            envMapColor.rgb = (RGBMToLinear(envMapColor, 5.0)).rgb;\n            #ifdef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = linearToGamma(envMapColor);\n            #endif\n        #else\n             #ifndef ENGINE_IS_COLORSPACE_GAMMA\n                envMapColor = gammaToLinear(envMapColor);\n            #endif\n        #endif\n        \n        return envMapColor.rgb * scene_EnvMapLight.specularIntensity;\n\n    #endif\n}\n\n#endif",includeKey:"LightProbe.glsl"},{source:"#ifndef REFLECTION_LOBE_INCLUDED\n#define REFLECTION_LOBE_INCLUDED\n\nvoid diffuseLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 attenuationIrradiance, inout vec3 diffuseColor){\n    diffuseColor += attenuationIrradiance * BRDF_Diffuse_Lambert( brdfData.diffuseColor );\n}\n\nvoid specularLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 attenuationIrradiance, inout vec3 specularColor){\n    specularColor += attenuationIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.normal, brdfData.specularColor, brdfData.roughness);\n}\n\nfloat clearCoatLobe(Varyings varyings, SurfaceData surfaceData, BRDFData brdfData, vec3 incidentDirection, vec3 color, inout vec3 specularColor){\n    float attenuation = 1.0;\n\n    #ifdef MATERIAL_ENABLE_CLEAR_COAT\n        float clearCoatDotNL = saturate( dot( surfaceData.clearCoatNormal, incidentDirection ) );\n        vec3 clearCoatIrradiance = clearCoatDotNL * color;\n\n        specularColor += surfaceData.clearCoat * clearCoatIrradiance * BRDF_Specular_GGX( incidentDirection, surfaceData, surfaceData.clearCoatNormal, brdfData.clearCoatSpecularColor, brdfData.clearCoatRoughness );\n        attenuation -= surfaceData.clearCoat * F_Schlick(0.04, surfaceData.clearCoatDotNV);\n    #endif\n\n    return attenuation;\n}\n\n\n\n#endif",includeKey:"ReflectionLobe.glsl"}]);function tz(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}var tk=!1,tG=!1,tW="1.4.0-alpha.1";console.log("galacean engine toolkit version: "+tW),e.BakePBRMaterial=eS,e.BiTangentMaterial=tx,e.BoxSelectionComponent=S,e.BoxSelectionControls=Q,e.BoxSelectionSSHelper=I,e.ControlFreeKeyboard=X,e.ControlFreePointer=J,e.ControlKeyboard=Z,e.ControlPointer=$,e.ControlWheel=ee,e.Core=tL,e.DashLine=eW,e.FreeControl=Y,e.Gizmo=tn,e.GridControl=eC,e.GridMaterial=eg,e.GridShaderSource='Shader "Grid" {\n\n  SubShader "Default" {\n\n    Pass "Forward" {\n      \n      mat4 camera_ViewInvMat;\n\n      VertexShader = vert;\n      FragmentShader = frag;\n\n      struct a2v {\n        vec3 POSITION;\n      }\n\n      struct v2f {\n        vec3 nearPoint;\n        vec3 farPoint;\n      }\n\n      vec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n        vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n        return unprojectedPoint.xyz / unprojectedPoint.w;\n      }\n\n      #ifdef GRAPHICS_API_WEBGL2\n        #define INVERSE_MAT(mat) inverse(mat)\n      #else\n        mat2 inverseMat(mat2 m) {\n          return mat2(m[1][1],-m[0][1],\n              -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n        }\n        mat3 inverseMat(mat3 m) {\n          float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n          float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n          float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n          float b01 = a22 * a11 - a12 * a21;\n          float b11 = -a22 * a10 + a12 * a20;\n          float b21 = a21 * a10 - a11 * a20;\n\n          float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n          return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n                b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n                b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n        }\n        mat4 inverseMat(mat4 m) {\n          float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n            a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n            a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n            a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n            b00 = a00 * a11 - a01 * a10,\n            b01 = a00 * a12 - a02 * a10,\n            b02 = a00 * a13 - a03 * a10,\n            b03 = a01 * a12 - a02 * a11,\n            b04 = a01 * a13 - a03 * a11,\n            b05 = a02 * a13 - a03 * a12,\n            b06 = a20 * a31 - a21 * a30,\n            b07 = a20 * a32 - a22 * a30,\n            b08 = a20 * a33 - a23 * a30,\n            b09 = a21 * a32 - a22 * a31,\n            b10 = a21 * a33 - a23 * a31,\n            b11 = a22 * a33 - a23 * a32,\n\n            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n          return mat4(\n            a11 * b11 - a12 * b10 + a13 * b09,\n            a02 * b10 - a01 * b11 - a03 * b09,\n            a31 * b05 - a32 * b04 + a33 * b03,\n            a22 * b04 - a21 * b05 - a23 * b03,\n            a12 * b08 - a10 * b11 - a13 * b07,\n            a00 * b11 - a02 * b08 + a03 * b07,\n            a32 * b02 - a30 * b05 - a33 * b01,\n            a20 * b05 - a22 * b02 + a23 * b01,\n            a10 * b10 - a11 * b08 + a13 * b06,\n            a01 * b08 - a00 * b10 - a03 * b06,\n            a30 * b04 - a31 * b02 + a33 * b00,\n            a21 * b02 - a20 * b04 - a23 * b00,\n            a11 * b07 - a10 * b09 - a12 * b06,\n            a00 * b09 - a01 * b07 + a02 * b06,\n            a31 * b01 - a30 * b03 - a32 * b00,\n            a20 * b03 - a21 * b01 + a22 * b00) / det;\n        }\n\n        #define INVERSE_MAT(mat) inverseMat(mat)\n      #endif\n\n\n      v2f vert(a2v v) {\n        v2f o;\n\n        float tol = 0.0001;\n        mat4 viewInvMat = camera_ViewInvMat;\n        if (abs(viewInvMat[3][1]) < tol) {\n            viewInvMat[3][1] = tol;\n        }\n        mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n        o.nearPoint = UnprojectPoint(v.POSITION.x, v.POSITION.y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n        o.farPoint = UnprojectPoint(v.POSITION.x, v.POSITION.y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n        gl_Position = vec4(v.POSITION, 1.0);// using directly the clipped coordinates\n      }\n\n      mat4 renderer_LocalMat;\n      mat4 renderer_ModelMat;\n      mat4 camera_ViewMat;\n      mat4 camera_ProjMat;\n      mat4 renderer_MVMat;\n      mat4 renderer_MVPMat;\n      mat4 renderer_NormalMat;\n\n      float u_far;\n      float u_near;\n      float u_primaryScale;\n      float u_secondaryScale;\n      float u_gridIntensity;\n      float u_axisIntensity;\n      float u_flipProgress;\n      float u_fade;\n\n      vec4 grid(vec3 fragPos3D, float scale, float fade) {\n        vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n        vec2 derivative = fwidth(coord);\n        vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n        float line = min(grid.x, grid.y);\n        float minimumz = min(derivative.y, 1.0);\n        float minimumx = min(derivative.x, 1.0);\n        vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n        // z-axis\n        if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx) {\n          color.z = 1.0;\n        }\n        // x-axis or y-axis\n        float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n        if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz) {\n          color.x = 1.0;\n        }\n        return color;\n      }\n\n      float computeDepth(vec3 pos) {\n        vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n        // map to 0-1\n        return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n      }\n\n      float computeLinearDepth(vec3 pos) {\n        vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n        float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n        float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n        return linearDepth / u_far;// normalize\n      }\n\n      void frag(v2f i) {\n        float ty = -i.nearPoint.y / (i.farPoint.y - i.nearPoint.y);\n        float tz = -i.nearPoint.z / (i.farPoint.z - i.nearPoint.z);\n        float t = mix(ty, tz, u_flipProgress);\n        vec3 fragPos3D = i.nearPoint + t * (i.farPoint - i.nearPoint);\n\n        gl_FragDepth = computeDepth(fragPos3D);\n\n        float linearDepth = computeLinearDepth(fragPos3D);\n        float fading = max(0.0, (0.5 - linearDepth));\n\n        // adding multiple resolution for the grid\n        gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n        gl_FragColor.a *= fading;\n      }\n    }\n  }\n}',e.Group=eJ,e.Line=eG,e.NavigationGizmo=t_,e.NormalMaterial=tC,e.OrbitControl=et,e.OrthoControl=en,e.PlainColorMaterial=eM,e.PlanarShadowShaderFactory=ed,e.PlanarShadowShaderSource='Shader "PlanarShadow" {\n\n  SubShader "Default" {\n\n    UsePass "pbr/Default/Forward"\n\n    Pass "planarShadow" {\n      // render states\n      DepthState {\n        WriteEnabled = true;\n      }\n\n      BlendState blendState {\n        Enabled = true;\n        SourceColorBlendFactor = BlendFactor.SourceAlpha;\n        DestinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;\n        SourceAlphaBlendFactor = BlendFactor.One;\n        DestinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;\n      }\n\n      StencilState {\n        Enabled = true;\n        ReferenceValue = 0;\n        CompareFunctionFront = CompareFunction.Equal;\n        CompareFunctionBack = CompareFunction.Equal;\n        FailOperationFront = StencilOperation.Keep;\n        FailOperationBack = StencilOperation.Keep;\n        ZFailOperationFront = StencilOperation.Keep;\n        ZFailOperationBack = StencilOperation.Keep;\n        PassOperationFront = StencilOperation.IncrementWrap;\n        PassOperationBack = StencilOperation.IncrementWrap;\n      }\n\n      BlendState = blendState;\n\n      RenderQueueType = RenderQueueType.Transparent;\n\n      vec3 u_lightDir;\n      float u_planarHeight;\n      vec4 u_planarShadowColor;\n      float u_planarShadowFalloff;\n\n      sampler2D renderer_JointSampler;\n      float renderer_JointCount;\n\n      mat4 renderer_ModelMat;\n      mat4 camera_VPMat;\n\n      #ifdef RENDERER_HAS_SKIN\n\n        #ifdef RENDERER_USE_JOINT_TEXTURE\n          mat4 getJointMatrix(sampler2D smp, float index) {\n              float base = index / renderer_JointCount;\n              float hf = 0.5 / renderer_JointCount;\n              float v = base + hf;\n\n              vec4 m0 = texture2D(smp, vec2(0.125, v ));\n              vec4 m1 = texture2D(smp, vec2(0.375, v ));\n              vec4 m2 = texture2D(smp, vec2(0.625, v ));\n              vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n              return mat4(m0, m1, m2, m3);\n          }\n        #elif defined(RENDERER_BLENDSHAPE_COUNT)\n            mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n        #endif\n      #endif\n\n      vec3 ShadowProjectPos(vec4 vertPos) {\n        vec3 shadowPos;\n\n        // get the world space coordinates of the vertex\n\n        vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n        \n        // world space coordinates of the shadow (the part below the ground is unchanged)\n        shadowPos.y = min(worldPos.y , u_planarHeight);\n        shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n        return shadowPos;\n      }\n\n      struct a2v {\n        vec4 POSITION;\n        vec4 JOINTS_0; \n        vec4 WEIGHTS_0;\n      }\n\n      struct v2f {\n        vec4 color;\n      }\n\n      v2f vert(a2v v) {\n        v2f o;\n\n        vec4 position = vec4(v.POSITION.xyz, 1.0 );\n        #ifdef RENDERER_HAS_SKIN\n            #ifdef RENDERER_USE_JOINT_TEXTURE\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, v.JOINTS_0.x ) +\n                    v.WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, v.JOINTS_0.y ) +\n                    v.WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, v.JOINTS_0.z ) +\n                    v.WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, v.JOINTS_0.w );\n            #else\n                mat4 skinMatrix =\n                    v.WEIGHTS_0.x * renderer_JointMatrix[ int( v.JOINTS_0.x ) ] +\n                    v.WEIGHTS_0.y * renderer_JointMatrix[ int( v.JOINTS_0.y ) ] +\n                    v.WEIGHTS_0.z * renderer_JointMatrix[ int( v.JOINTS_0.z ) ] +\n                    v.WEIGHTS_0.w * renderer_JointMatrix[ int( v.JOINTS_0.w ) ];\n            #endif\n            position = skinMatrix * position;\n        #endif\n\n        // get the shadow\'s world space coordinates\n        vec3 shadowPos = ShadowProjectPos(position);\n\n        // convert to clip space\n        gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n        // get the world coordinates of the center point\n        vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n        // calculate shadow falloff\n        float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n        // shadow color\n        o.color = u_planarShadowColor;\n        o.color.a *= falloff;\n      }\n      \n      VertexShader = vert;\n      FragmentShader = frag;\n\n      void frag(v2f i) {\n        gl_FragColor = i.color;\n      }\n    }\n  }\n}',e.SkeletonViewer=eD,e.SketchRenderer=tS,e.Stats=tH,e.TangentMaterial=ty,e.WaterFallMaterial=eE,e.WaterMaterial=ex,e.WaterRippleMaterial=ey,e.WireframeMaterial=tE,e.WireframePrimitive=es,e.fragmentList=tU,e.registerIncludes=function(){if(!tk){for(var e,n=function(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return tz(e,void 0);var n=Object.prototype.toString.call(e).slice(8,-1);if("Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n)return Array.from(n);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return tz(e,void 0)}}(e))){n&&(e=n);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(tU);!(e=n()).done;){var r=e.value;t.ShaderFactory.registerInclude(r.includeKey,r.source)}tk=!0}},e.registerShader=function(){tG||(t.Shader.create('Shader "PBR.gs" {\n    EditorProperties {\n      Header("Base"){\n        material_IOR("IOR", Range(0, 5, 0.01)) = 1.5;\n        material_BaseColor("BaseColor", Color) = (1, 1, 1, 1);\n        material_BaseTexture("BaseTexture", Texture2D);\n      }\n\n      Header("Metal Roughness") {\n        material_Metal( "Metal", Range(0,1,0.01) ) = 1;\n        material_Roughness( "Roughness", Range( 0, 1, 0.01 ) ) = 1;\n        material_RoughnessMetallicTexture("RoughnessMetallicTexture", Texture2D);\n      }\n\n      Header("Anisotropy") {\n        material_AnisotropyInfo("AnisotropyInfo", Vector3) = (1, 0, 0);\n        material_AnisotropyTexture("AnisotropyTexture", Texture2D);\n      }\n\n      Header("Normal") {\n        material_NormalTexture("NormalTexture", Texture2D);\n        material_NormalIntensity("NormalIntensity", Range(0, 5, 0.01)) = 1;\n      }\n\n      Header("Emissive") {\n        material_EmissiveColor("EmissiveColor", Color ) = (0, 0, 0, 1);\n        material_EmissiveTexture("EmissiveTexture", Texture2D);\n      }\n\n      Header("Occlusion") {\n        material_OcclusionTexture("OcclusionTexture", Texture2D);\n        material_OcclusionIntensity("OcclusionIntensity", Range(0, 5, 0.01)) = 1;\n        material_OcclusionTextureCoord("OcclusionTextureCoord", Float) = 0;\n      }\n      \n      Header("Clear Coat") {\n        material_ClearCoat("ClearCoat", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatTexture("ClearCoatTexture", Texture2D);\n        material_ClearCoatRoughness("ClearCoatRoughness", Range(0, 1, 0.01)) = 0;\n        material_ClearCoatRoughnessTexture("ClearCoatRoughnessTexture", Texture2D);\n        material_ClearCoatNormalTexture("ClearCoatNormalTexture", Texture2D);\n      }\n\n      Header("Common") {\n        material_AlphaCutoff( "AlphaCutoff", Range(0, 1, 0.01) ) = 0;\n        material_TilingOffset("TilingOffset", Vector4) = (1, 1, 0, 0);\n      }\n    }\n\n    EditorMacros {\n      Header("Conditional Macors") {\n        MATERIAL_HAS_BASETEXTURE("HAS_BASETEXTURE");\n        MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE("HAS_ROUGHNESS_METALLIC_TEXTURE");\n        MATERIAL_ENABLE_ANISOTROPY("ENABLE_ANISOTROPY");\n        MATERIAL_HAS_ANISOTROPY_TEXTURE("HAS_ANISOTROPY_TEXTURE")\n        MATERIAL_HAS_NORMALTEXTURE("HAS_NORMALTEXTURE");\n        MATERIAL_HAS_EMISSIVETEXTURE("HAS_EMISSIVETEXTURE");\n        MATERIAL_HAS_OCCLUSION_TEXTURE("HAS_OCCLUSION_TEXTURE");\n        MATERIAL_ENABLE_CLEAR_COAT("ENABLE_CLEAR_COAT");\n        MATERIAL_HAS_CLEAR_COAT_TEXTURE("HAS_CLEAR_COAT_TEXTURE");\n        MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE("HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");\n        MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE("HAS_CLEAR_COAT_NORMAL_TEXTURE");\n        MATERIAL_IS_TRANSPARENT("IS_TRANSPARENT");\n        MATERIAL_IS_ALPHA_CUTOFF("IS_ALPHA_CUTOFF");\n      }\n    }\n    \n    SubShader "Default" {\n      UsePass "pbr/Default/ShadowCaster"\n\n      Pass "Forward Pass" {\n        Tags { pipelineStage = "Forward"} \n\n        #define IS_METALLIC_WORKFLOW\n        \n        VertexShader = PBRVertex;\n        FragmentShader = PBRFragment;\n\n        #include "ForwardPassPBR.glsl"\n      }\n    }\n  }'),tG=!0)},e.version=tW});
