(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@galacean/engine')) :
    typeof define === 'function' && define.amd ? define(['exports', '@galacean/engine'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Galacean = global.Galacean || {}, global.Galacean.PhysicsLite = {}), global.Galacean));
})(this, (function (exports, engine) { 'use strict';

    function _set_prototype_of(o, p) {
        _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
            o.__proto__ = p;

            return o;
        };

        return _set_prototype_of(o, p);
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

        if (superClass) _set_prototype_of(subClass, superClass);
    }

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;

            if ("value" in descriptor) descriptor.writable = true;

            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _create_class(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);

        return Constructor;
    }

    function _instanceof(left, right) {
        if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
            return !!right[Symbol.hasInstance](left);
        } else return left instanceof right;
    }

    /**
     * Used to update tags.
     */ var LiteUpdateFlag = /*#__PURE__*/ function() {
        function LiteUpdateFlag(_flags) {
            if (_flags === void 0) _flags = [];
            this._flags = _flags;
            this./** Flag. */ flag = true;
            this._flags.push(this);
        }
        var _proto = LiteUpdateFlag.prototype;
        /**
       * Destroy.
       */ _proto.destroy = function destroy() {
            engine.Utils.removeFromArray(this._flags, this);
            this._flags = null;
        };
        return LiteUpdateFlag;
    }();

    /**
     * @internal
     */ var LiteUpdateFlagManager = /*#__PURE__*/ function() {
        function LiteUpdateFlagManager() {
            this._updateFlags = [];
        }
        var _proto = LiteUpdateFlagManager.prototype;
        _proto.register = function register() {
            return new LiteUpdateFlag(this._updateFlags);
        };
        _proto.distribute = function distribute() {
            var updateFlags = this._updateFlags;
            for(var i = updateFlags.length - 1; i >= 0; i--){
                updateFlags[i].flag = true;
            }
        };
        return LiteUpdateFlagManager;
    }();

    /**
     * Abstract class for collider shapes.
     */ var LiteColliderShape = /*#__PURE__*/ function() {
        function LiteColliderShape() {
            /** @internal */ this._position = new engine.Vector3();
            /** @internal */ this._worldScale = new engine.Vector3(1, 1, 1);
            /** @internal */ this._transform = new LiteTransform();
            /** @internal */ this._invModelMatrix = new engine.Matrix();
            this._transform.owner = this;
            this._inverseWorldMatFlag = this._transform.registerWorldChangeFlag();
        }
        var _proto = LiteColliderShape.prototype;
        /**
       * {@inheritDoc IColliderShape.setRotation }
       */ _proto.setRotation = function setRotation(rotation) {
            console.log("Physics-lite don't support setRotation. Use Physics-PhysX instead!");
        };
        /**
       * {@inheritDoc IColliderShape.setPosition }
       */ _proto.setPosition = function setPosition(position) {
            if (position !== this._position) {
                this._position.copyFrom(position);
            }
            this._setLocalPose();
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            this._worldScale.copyFrom(scale);
            this._setLocalPose();
        };
        /**
       * {@inheritDoc IColliderShape.setContactOffset }
       */ _proto.setContactOffset = function setContactOffset(offset) {
            console.log("Physics-lite don't support setContactOffset. Use Physics-PhysX instead!");
        };
        /**
       * {@inheritDoc IColliderShape.setMaterial }
       */ _proto.setMaterial = function setMaterial(material) {
            console.log("Physics-lite don't support setMaterial. Use Physics-PhysX instead!");
        };
        /**
       * {@inheritDoc IColliderShape.setUniqueID }
       */ _proto.setUniqueID = function setUniqueID(id) {
            this._id = id;
        };
        /**
       * {@inheritDoc IColliderShape.setIsTrigger }
       */ _proto.setIsTrigger = function setIsTrigger(value) {
            console.log("Physics-lite don't support setIsTrigger. Use Physics-PhysX instead!");
        };
        /**
       * {@inheritDoc IColliderShape.destroy }
       */ _proto.destroy = function destroy() {};
        _proto._updateHitResult = function _updateHitResult(ray, rayDistance, outHit, origin, isWorldRay) {
            if (isWorldRay === void 0) isWorldRay = false;
            var hitPoint = LiteColliderShape._tempPoint;
            ray.getPoint(rayDistance, hitPoint);
            if (!isWorldRay) {
                engine.Vector3.transformCoordinate(hitPoint, this._transform.worldMatrix, hitPoint);
            }
            var distance = engine.Vector3.distance(origin, hitPoint);
            if (distance < outHit.distance) {
                outHit.point.copyFrom(hitPoint);
                outHit.distance = distance;
                outHit.shapeID = this._id;
            }
        };
        _proto._getLocalRay = function _getLocalRay(ray) {
            var worldToLocal = this._getInvModelMatrix();
            var outRay = LiteColliderShape._ray;
            engine.Vector3.transformCoordinate(ray.origin, worldToLocal, outRay.origin);
            engine.Vector3.transformNormal(ray.direction, worldToLocal, outRay.direction);
            outRay.direction.normalize();
            return outRay;
        };
        _proto._getInvModelMatrix = function _getInvModelMatrix() {
            if (this._inverseWorldMatFlag.flag) {
                engine.Matrix.invert(this._transform.worldMatrix, this._invModelMatrix);
                this._inverseWorldMatFlag.flag = false;
            }
            return this._invModelMatrix;
        };
        _proto._setLocalPose = function _setLocalPose() {
            var shapePosition = LiteColliderShape._tempPoint;
            engine.Vector3.multiply(this._position, this._worldScale, shapePosition);
            this._transform.position = shapePosition;
        };
        return LiteColliderShape;
    }();
    LiteColliderShape._ray = new engine.Ray();
    LiteColliderShape._tempPoint = new engine.Vector3();

    /**
     * Used to implement transformation related functions.
     */ var LiteTransform = /*#__PURE__*/ function() {
        function LiteTransform() {
            this._position = new engine.Vector3();
            this._rotation = new engine.Vector3();
            this._rotationQuaternion = new engine.Quaternion();
            this._scale = new engine.Vector3(1, 1, 1);
            this._worldRotationQuaternion = new engine.Quaternion();
            this._localMatrix = new engine.Matrix();
            this._worldMatrix = new engine.Matrix();
            this._updateFlagManager = new LiteUpdateFlagManager();
            this._isParentDirty = true;
            this._parentTransformCache = null;
            this._dirtyFlag = 188;
        }
        var _proto = LiteTransform.prototype;
        /**
       * Set local position by X, Y, Z value.
       * @param x - X coordinate
       * @param y - Y coordinate
       * @param z - Z coordinate
       */ _proto.setPosition = function setPosition(x, y, z) {
            this._position.set(x, y, z);
            this.position = this._position;
        };
        /**
       * Set local rotation by the X, Y, Z, and W components of the quaternion.
       * @param x - X component of quaternion
       * @param y - Y component of quaternion
       * @param z - Z component of quaternion
       * @param w - W component of quaternion
       */ _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
            this._rotationQuaternion.set(x, y, z, w);
            this.rotationQuaternion = this._rotationQuaternion;
        };
        /**
       * Set local scaling by scaling values along X, Y, Z axis.
       * @param x - Scaling along X axis
       * @param y - Scaling along Y axis
       * @param z - Scaling along Z axis
       */ _proto.setScale = function setScale(x, y, z) {
            this._scale.set(x, y, z);
            this.scale = this._scale;
        };
        /**
       * Register world transform change flag.
       * @returns Change flag
       */ _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
            return this._updateFlagManager.register();
        };
        /**
       * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
       * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
       * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
       */ _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
            if (!this._isContainDirtyFlags(132)) {
                this._worldAssociatedChange(132);
                if (_instanceof(this._owner, LiteCollider)) {
                    var shapes = this._owner._shapes;
                    for(var i = 0, n = shapes.length; i < n; i++){
                        shapes[i]._transform._updateWorldPositionFlag();
                    }
                }
            }
        };
        /**
       * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
       * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
       * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
       * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
       * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
       */ _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
            if (!this._isContainDirtyFlags(152)) {
                this._worldAssociatedChange(152);
                if (_instanceof(this._owner, LiteCollider)) {
                    var shapes = this._owner._shapes;
                    for(var i = 0, n = shapes.length; i < n; i++){
                        shapes[i]._transform._updateWorldRotationFlag();
                    }
                }
            }
        };
        /**
       * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
       * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
       * Get worldScale: Will trigger the scaling update of itself and all parent entities.
       * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
       */ _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
            if (!this._isContainDirtyFlags(160)) {
                this._worldAssociatedChange(160);
                if (_instanceof(this._owner, LiteCollider)) {
                    var shapes = this._owner._shapes;
                    for(var i = 0, n = shapes.length; i < n; i++){
                        shapes[i]._transform._updateWorldScaleFlag();
                    }
                }
            }
        };
        /**
       * Update all world transform property dirty flag, the principle is the same as above.
       */ _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
            if (!this._isContainDirtyFlags(188)) {
                this._worldAssociatedChange(188);
                if (_instanceof(this._owner, LiteCollider)) {
                    var shapes = this._owner._shapes;
                    for(var i = 0, n = shapes.length; i < n; i++){
                        shapes[i]._transform._updateAllWorldFlag();
                    }
                }
            }
        };
        _proto._getParentTransform = function _getParentTransform() {
            if (!this._isParentDirty) {
                return this._parentTransformCache;
            }
            var parentCache = null;
            if (_instanceof(this._owner, LiteColliderShape)) {
                var parent = this._owner._collider;
                parentCache = parent._transform;
            }
            this._parentTransformCache = parentCache;
            this._isParentDirty = false;
            return parentCache;
        };
        _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
            return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
        };
        _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
            return (this._dirtyFlag & type) != 0;
        };
        _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
            this._dirtyFlag |= type;
        };
        _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
            this._dirtyFlag &= ~type;
        };
        _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
            this._dirtyFlag |= type;
            this._updateFlagManager.distribute();
        };
        _create_class(LiteTransform, [
            {
                key: "owner",
                set: function set(value) {
                    this._owner = value;
                }
            },
            {
                key: "position",
                get: /**
       * Local position.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    return this._position;
                },
                set: function set(value) {
                    if (this._position !== value) {
                        this._position.copyFrom(value);
                    }
                    this._setDirtyFlagTrue(64);
                    this._updateWorldPositionFlag();
                }
            },
            {
                key: "rotationQuaternion",
                get: /**
       * Local rotation, defining the rotation by using a unit quaternion.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    if (this._isContainDirtyFlag(2)) {
                        engine.Quaternion.rotationEuler(engine.MathUtil.degreeToRadian(this._rotation.x), engine.MathUtil.degreeToRadian(this._rotation.y), engine.MathUtil.degreeToRadian(this._rotation.z), this._rotationQuaternion);
                        this._setDirtyFlagFalse(2);
                    }
                    return this._rotationQuaternion;
                },
                set: function set(value) {
                    if (this._rotationQuaternion !== value) {
                        this._rotationQuaternion.copyFrom(value);
                    }
                    this._setDirtyFlagTrue(64 | 1);
                    this._setDirtyFlagFalse(2);
                    this._updateWorldRotationFlag();
                }
            },
            {
                key: "worldRotationQuaternion",
                get: /**
       * World rotation, defining the rotation by using a unit quaternion.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    if (this._isContainDirtyFlag(16)) {
                        var parent = this._getParentTransform();
                        if (parent != null) {
                            engine.Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, this._worldRotationQuaternion);
                        } else {
                            this._worldRotationQuaternion.copyFrom(this.rotationQuaternion);
                        }
                        this._setDirtyFlagFalse(16);
                    }
                    return this._worldRotationQuaternion;
                },
                set: function set(value) {
                    if (this._worldRotationQuaternion !== value) {
                        this._worldRotationQuaternion.copyFrom(value);
                    }
                    var parent = this._getParentTransform();
                    if (parent) {
                        engine.Quaternion.invert(parent.worldRotationQuaternion, LiteTransform._tempQuat0);
                        engine.Quaternion.multiply(value, LiteTransform._tempQuat0, this._rotationQuaternion);
                    } else {
                        this._rotationQuaternion.copyFrom(value);
                    }
                    this.rotationQuaternion = this._rotationQuaternion;
                    this._setDirtyFlagFalse(16);
                }
            },
            {
                key: "scale",
                get: /**
       * Local scaling.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    return this._scale;
                },
                set: function set(value) {
                    if (this._scale !== value) {
                        this._scale.copyFrom(value);
                    }
                    this._setDirtyFlagTrue(64);
                    this._updateWorldScaleFlag();
                }
            },
            {
                key: "localMatrix",
                get: /**
       * Local matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    if (this._isContainDirtyFlag(64)) {
                        engine.Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
                        this._setDirtyFlagFalse(64);
                    }
                    return this._localMatrix;
                },
                set: function set(value) {
                    if (this._localMatrix !== value) {
                        this._localMatrix.copyFrom(value);
                    }
                    this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
                    this._setDirtyFlagTrue(1);
                    this._setDirtyFlagFalse(64);
                    this._updateAllWorldFlag();
                }
            },
            {
                key: "worldMatrix",
                get: /**
       * World matrix.
       * @remarks Need to re-assign after modification to ensure that the modification takes effect.
       */ function get() {
                    if (this._isContainDirtyFlag(128)) {
                        var parent = this._getParentTransform();
                        if (parent) {
                            engine.Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
                        } else {
                            this._worldMatrix.copyFrom(this.localMatrix);
                        }
                        this._setDirtyFlagFalse(128);
                    }
                    return this._worldMatrix;
                },
                set: function set(value) {
                    if (this._worldMatrix !== value) {
                        this._worldMatrix.copyFrom(value);
                    }
                    var parent = this._getParentTransform();
                    if (parent) {
                        engine.Matrix.invert(parent.worldMatrix, LiteTransform._tempMat42);
                        engine.Matrix.multiply(LiteTransform._tempMat42, value, this._localMatrix);
                    } else {
                        this._localMatrix.copyFrom(value);
                    }
                    this.localMatrix = this._localMatrix;
                    this._setDirtyFlagFalse(128);
                }
            }
        ]);
        return LiteTransform;
    }();
    LiteTransform._tempQuat0 = new engine.Quaternion();
    LiteTransform._tempMat42 = new engine.Matrix();

    /**
     * Abstract class of physical collider.
     */ var LiteCollider = /*#__PURE__*/ function() {
        function LiteCollider() {
            /** @internal */ this._shapes = [];
            /** @internal */ this._transform = new LiteTransform();
            this._transform.owner = this;
        }
        var _proto = LiteCollider.prototype;
        /**
       * {@inheritDoc ICollider.addShape }
       */ _proto.addShape = function addShape(shape) {
            var oldCollider = shape._collider;
            if (oldCollider !== this) {
                if (oldCollider) {
                    oldCollider.removeShape(shape);
                }
                this._shapes.push(shape);
                shape._collider = this;
            }
        };
        /**
       * {@inheritDoc ICollider.removeShape }
       */ _proto.removeShape = function removeShape(shape) {
            var index = this._shapes.indexOf(shape);
            if (index !== -1) {
                this._shapes.splice(index, 1);
                shape._collider = null;
            }
        };
        /**
       * {@inheritDoc ICollider.setWorldTransform }
       */ _proto.setWorldTransform = function setWorldTransform(position, rotation) {
            this._transform.setPosition(position.x, position.y, position.z);
            this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
        };
        /**
       * {@inheritDoc ICollider.getWorldTransform }
       */ _proto.getWorldTransform = function getWorldTransform(outPosition, outRotation) {
            var _this__transform = this._transform, position = _this__transform.position, rotationQuaternion = _this__transform.rotationQuaternion;
            outPosition.set(position.x, position.y, position.z);
            outRotation.set(rotationQuaternion.x, rotationQuaternion.y, rotationQuaternion.z, rotationQuaternion.w);
        };
        /**
       * {@inheritDoc ICollider.destroy }
       */ _proto.destroy = function destroy() {};
        /**
       * @internal
       */ _proto._raycast = function _raycast(ray, onRaycast, hit) {
            hit.distance = Number.MAX_VALUE;
            var shapes = this._shapes;
            for(var i = 0, n = shapes.length; i < n; i++){
                var shape = shapes[i];
                onRaycast(shape._id) && shape._raycast(ray, hit);
            }
            return hit.distance != Number.MAX_VALUE;
        };
        return LiteCollider;
    }();

    /**
     * A dynamic collider can act with self-defined movement or physical force
     */ var LiteDynamicCollider = /*#__PURE__*/ function(LiteCollider) {
        _inherits(LiteDynamicCollider, LiteCollider);
        function LiteDynamicCollider(position, rotation) {
            var _this;
            _this = LiteCollider.call(this) || this, /** @internal */ _this._isStaticCollider = false;
            _this._transform.setPosition(position.x, position.y, position.z);
            _this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
            return _this;
        }
        var _proto = LiteDynamicCollider.prototype;
        /**
       * {@inheritDoc IDynamicCollider.addForce }
       */ _proto.addForce = function addForce(force) {
            throw "Physics-lite don't support addForce. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.addTorque }
       */ _proto.addTorque = function addTorque(torque) {
            throw "Physics-lite don't support addTorque. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.move }
       */ _proto.move = function move(positionOrRotation, rotation) {
            throw "Physics-lite don't support move. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.sleep }
       */ _proto.sleep = function sleep() {
            throw "Physics-lite don't support putToSleep. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setAngularDamping }
       */ _proto.setAngularDamping = function setAngularDamping(value) {
            throw "Physics-lite don't support setAngularDamping. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setAngularVelocity }
       */ _proto.setAngularVelocity = function setAngularVelocity(value) {
            throw "Physics-lite don't support setAngularVelocity. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setCenterOfMass }
       */ _proto.setCenterOfMass = function setCenterOfMass(value) {
            throw "Physics-lite don't support setCenterOfMass. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setCollisionDetectionMode }
       */ _proto.setCollisionDetectionMode = function setCollisionDetectionMode(value) {
            throw "Physics-lite don't support setCollisionDetectionMode. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setConstraints }
       */ _proto.setConstraints = function setConstraints(flags) {
            throw "Physics-lite don't support setConstraints. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setInertiaTensor }
       */ _proto.setInertiaTensor = function setInertiaTensor(value) {
            throw "Physics-lite don't support setInertiaTensor. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setIsKinematic }
       */ _proto.setIsKinematic = function setIsKinematic(value) {
            throw "Physics-lite don't support setIsKinematic. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setLinearDamping }
       */ _proto.setLinearDamping = function setLinearDamping(value) {
            throw "Physics-lite don't support setLinearDamping. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setLinearVelocity }
       */ _proto.setLinearVelocity = function setLinearVelocity(value) {
            throw "Physics-lite don't support setLinearVelocity. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setMass }
       */ _proto.setMass = function setMass(value) {
            throw "Physics-lite don't support setMass. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setMaxAngularVelocity }
       */ _proto.setMaxAngularVelocity = function setMaxAngularVelocity(value) {
            throw "Physics-lite don't support setMaxAngularVelocity. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setMaxDepenetrationVelocity }
       */ _proto.setMaxDepenetrationVelocity = function setMaxDepenetrationVelocity(value) {
            throw "Physics-lite don't support setMaxDepenetrationVelocity. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setSleepThreshold }
       */ _proto.setSleepThreshold = function setSleepThreshold(value) {
            throw "Physics-lite don't support setSleepThreshold. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.setSolverIterations }
       */ _proto.setSolverIterations = function setSolverIterations(value) {
            throw "Physics-lite don't support setSolverIterations. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IDynamicCollider.wakeUp }
       */ _proto.wakeUp = function wakeUp() {
            throw "Physics-lite don't support wakeUp. Use Physics-PhysX instead!";
        };
        return LiteDynamicCollider;
    }(LiteCollider);

    /**
     * Physics material describes how to handle colliding objects (friction, bounciness).
     */ var LitePhysicsMaterial = /*#__PURE__*/ function() {
        function LitePhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {}
        var _proto = LitePhysicsMaterial.prototype;
        /**
       * {@inheritDoc IPhysicsMaterial.setBounciness }
       */ _proto.setBounciness = function setBounciness(value) {
            throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setDynamicFriction }
       */ _proto.setDynamicFriction = function setDynamicFriction(value) {
            throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setStaticFriction }
       */ _proto.setStaticFriction = function setStaticFriction(value) {
            throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setBounceCombine }
       */ _proto.setBounceCombine = function setBounceCombine(value) {
            throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsMaterial.setFrictionCombine }
       */ _proto.setFrictionCombine = function setFrictionCombine(value) {
            throw "Physics-lite don't support physics material. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsMaterial.destroy }
       */ _proto.destroy = function destroy() {};
        return LitePhysicsMaterial;
    }();

    /**
     * Structure used to get information back from a raycast or a sweep.
     * @internal
     */ var LiteHitResult = function LiteHitResult() {
        /** The collider that was hit. */ this.shapeID = -1;
        /** The distance from the origin to the hit point. */ this.distance = 0;
        /** The hit point of the collider that was hit in world space. */ this.point = new engine.Vector3();
        /** The hit normal of the collider that was hit in world space. */ this.normal = new engine.Vector3();
    };

    /**
     * Box collider shape in Lite.
     */ var LiteBoxColliderShape = /*#__PURE__*/ function(LiteColliderShape) {
        _inherits(LiteBoxColliderShape, LiteColliderShape);
        function LiteBoxColliderShape(uniqueID, size, material) {
            var _this;
            _this = LiteColliderShape.call(this) || this, _this._halfSize = new engine.Vector3(), _this._sizeScale = new engine.Vector3(1, 1, 1), /** @internal */ _this._boxMin = new engine.Vector3(-0.5, -0.5, -0.5), /** @internal */ _this._boxMax = new engine.Vector3(0.5, 0.5, 0.5);
            _this._id = uniqueID;
            _this._halfSize.set(size.x * 0.5, size.y * 0.5, size.z * 0.5);
            _this._setBondingBox();
            return _this;
        }
        var _proto = LiteBoxColliderShape.prototype;
        /**
       * {@inheritDoc IColliderShape.setPosition }
       */ _proto.setPosition = function setPosition(position) {
            LiteColliderShape.prototype.setPosition.call(this, position);
            this._setBondingBox();
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            LiteColliderShape.prototype.setWorldScale.call(this, scale);
            this._sizeScale.set(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
            this._setBondingBox();
        };
        /**
       * {@inheritDoc IBoxColliderShape.setSize }
       */ _proto.setSize = function setSize(value) {
            this._halfSize.set(value.x * 0.5, value.y * 0.5, value.z * 0.5);
            this._setBondingBox();
        };
        /**
       * @internal
       */ _proto._raycast = function _raycast(ray, hit) {
            var localRay = this._getLocalRay(ray);
            var sizeScale = this._sizeScale;
            var halfSize = this._halfSize;
            var boundingBox = LiteBoxColliderShape._tempBox;
            boundingBox.min.set(-halfSize.x * sizeScale.x, -halfSize.y * sizeScale.y, -halfSize.z * sizeScale.z);
            boundingBox.max.set(halfSize.x * sizeScale.x, halfSize.y * sizeScale.y, halfSize.z * sizeScale.z);
            var rayDistance = localRay.intersectBox(boundingBox);
            if (rayDistance !== -1) {
                this._updateHitResult(localRay, rayDistance, hit, ray.origin);
                return true;
            } else {
                return false;
            }
        };
        _proto._setBondingBox = function _setBondingBox() {
            var position = this._transform.position;
            var scale = this._sizeScale;
            var halfSize = this._halfSize;
            this._boxMin.set(-halfSize.x * scale.x + position.x, -halfSize.y * scale.y + position.y, -halfSize.z * scale.z + position.z);
            this._boxMax.set(halfSize.x * scale.x + position.x, halfSize.y * scale.y + position.y, halfSize.z * scale.z + position.z);
        };
        return LiteBoxColliderShape;
    }(LiteColliderShape);
    LiteBoxColliderShape._tempBox = new engine.BoundingBox();

    /**
     * Sphere collider shape in Lite.
     */ var LiteSphereColliderShape = /*#__PURE__*/ function(LiteColliderShape) {
        _inherits(LiteSphereColliderShape, LiteColliderShape);
        function LiteSphereColliderShape(uniqueID, radius, material) {
            var _this;
            _this = LiteColliderShape.call(this) || this, _this._radius = 1, _this._maxScale = 1;
            _this._radius = radius;
            _this._id = uniqueID;
            return _this;
        }
        var _proto = LiteSphereColliderShape.prototype;
        /**
       * {@inheritDoc ISphereColliderShape.setRadius }
       */ _proto.setRadius = function setRadius(value) {
            this._radius = value;
        };
        /**
       * {@inheritDoc IColliderShape.setWorldScale }
       */ _proto.setWorldScale = function setWorldScale(scale) {
            LiteColliderShape.prototype.setWorldScale.call(this, scale);
            this._maxScale = Math.max(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
        };
        /**
       * @internal
       */ _proto._raycast = function _raycast(ray, hit) {
            var boundingSphere = LiteSphereColliderShape._tempSphere;
            engine.Vector3.transformCoordinate(this._transform.position, this._collider._transform.worldMatrix, boundingSphere.center);
            boundingSphere.radius = this.worldRadius;
            var rayDistance = ray.intersectSphere(boundingSphere);
            if (rayDistance !== -1) {
                this._updateHitResult(ray, rayDistance, hit, ray.origin, true);
                return true;
            } else {
                return false;
            }
        };
        _create_class(LiteSphereColliderShape, [
            {
                key: "worldRadius",
                get: function get() {
                    return this._radius * this._maxScale;
                }
            }
        ]);
        return LiteSphereColliderShape;
    }(LiteColliderShape);
    LiteSphereColliderShape._tempSphere = new engine.BoundingSphere();

    /**
     * A manager is a collection of colliders and constraints which can interact.
     */ var LitePhysicsScene = /*#__PURE__*/ function() {
        function LitePhysicsScene(onContactEnter, onContactExit, onContactStay, onTriggerEnter, onTriggerExit, onTriggerStay) {
            this._staticColliders = [];
            this._dynamicColliders = [];
            this._sphere = new engine.BoundingSphere();
            this._box = new engine.BoundingBox();
            this._currentEvents = new engine.DisorderedArray();
            this._eventMap = {};
            this._eventPool = [];
            this._onContactEnter = onContactEnter;
            this._onContactExit = onContactExit;
            this._onContactStay = onContactStay;
            this._onTriggerEnter = onTriggerEnter;
            this._onTriggerExit = onTriggerExit;
            this._onTriggerStay = onTriggerStay;
        }
        var _proto = LitePhysicsScene.prototype;
        /**
       * {@inheritDoc IPhysicsManager.setGravity }
       */ _proto.setGravity = function setGravity(value) {
            console.log("Physics-lite don't support gravity. Use Physics-PhysX instead!");
        };
        /**
       * {@inheritDoc IPhysicsManager.addColliderShape }
       */ _proto.addColliderShape = function addColliderShape(colliderShape) {
            this._eventMap[colliderShape._id] = {};
        };
        /**
       * {@inheritDoc IPhysicsManager.removeColliderShape }
       */ _proto.removeColliderShape = function removeColliderShape(colliderShape) {
            var _this = this, eventPool = _this._eventPool, currentEvents = _this._currentEvents, eventMap = _this._eventMap;
            var id = colliderShape._id;
            currentEvents.forEach(function(event, i) {
                if (event.index1 == id) {
                    currentEvents.deleteByIndex(i);
                    eventPool.push(event);
                } else if (event.index2 == id) {
                    currentEvents.deleteByIndex(i);
                    eventPool.push(event);
                    // If the shape is big index, should clear from the small index shape subMap
                    eventMap[event.index1][id] = undefined;
                }
            });
            delete eventMap[id];
        };
        /**
       * {@inheritDoc IPhysicsManager.addCollider }
       */ _proto.addCollider = function addCollider(actor) {
            var colliders = actor._isStaticCollider ? this._staticColliders : this._dynamicColliders;
            colliders.push(actor);
        };
        /**
       * {@inheritDoc IPhysicsManager.removeCollider }
       */ _proto.removeCollider = function removeCollider(collider) {
            var colliders = collider._isStaticCollider ? this._staticColliders : this._dynamicColliders;
            var index = colliders.indexOf(collider);
            if (index !== -1) {
                colliders.splice(index, 1);
            }
        };
        /**
       * {@inheritDoc IPhysicsManager.update }
       */ _proto.update = function update(deltaTime) {
            var dynamicColliders = this._dynamicColliders;
            for(var i = 0, len = dynamicColliders.length; i < len; i++){
                var collider = dynamicColliders[i];
                this._collisionDetection(collider, this._staticColliders);
                this._collisionDetection(collider, dynamicColliders);
            }
            this._fireEvent();
        };
        /**
       * {@inheritDoc IPhysicsManager.raycast }
       */ _proto.raycast = function raycast(ray, distance, onRaycast, hit) {
            if (!hit) {
                return this._raycast(ray, distance, onRaycast, this._staticColliders, hit) || this._raycast(ray, distance, onRaycast, this._dynamicColliders, hit);
            } else {
                var raycastStaticRes = this._raycast(ray, distance, onRaycast, this._staticColliders, hit);
                if (raycastStaticRes) {
                    distance = LitePhysicsScene._currentHit.distance;
                }
                var raycastDynamicRes = this._raycast(ray, distance, onRaycast, this._dynamicColliders, hit);
                var isHit = raycastStaticRes || raycastDynamicRes;
                var hitResult = LitePhysicsScene._hitResult;
                if (!isHit) {
                    hitResult.shapeID = -1;
                    hitResult.distance = 0;
                    hitResult.point.set(0, 0, 0);
                    hitResult.normal.set(0, 0, 0);
                } else {
                    hit(hitResult.shapeID, hitResult.distance, hitResult.point, hitResult.normal);
                }
                return isHit;
            }
        };
        /**
       * {@inheritDoc IPhysicsManager.addCharacterController }
       */ _proto.addCharacterController = function addCharacterController(characterController) {
            throw "Physics-lite don't support addCharacterController. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysicsManager.removeCharacterController }
       */ _proto.removeCharacterController = function removeCharacterController(characterController) {
            throw "Physics-lite don't support removeCharacterController. Use Physics-PhysX instead!";
        };
        _proto._getTrigger = function _getTrigger(index1, index2) {
            var event;
            if (this._eventPool.length) {
                event = this._eventPool.pop();
                event.index1 = index1;
                event.index2 = index2;
            } else {
                event = new TriggerEvent(index1, index2);
            }
            this._eventMap[index1][index2] = event;
            return event;
        };
        _proto._collisionDetection = function _collisionDetection(myCollider, colliders) {
            var myColliderShapes = myCollider._shapes;
            for(var i = 0, len = myColliderShapes.length; i < len; i++){
                var myShape = myColliderShapes[i];
                if (_instanceof(myShape, LiteBoxColliderShape)) {
                    LitePhysicsScene._updateWorldBox(myShape, this._box);
                    for(var j = 0, len1 = colliders.length; j < len1; j++){
                        var colliderShape = colliders[j]._shapes;
                        for(var k = 0, len2 = colliderShape.length; k < len2; k++){
                            var shape = colliderShape[k];
                            var index1 = shape._id;
                            var index2 = myShape._id;
                            var event = index1 < index2 ? this._eventMap[index1][index2] : this._eventMap[index2][index1];
                            if (event !== undefined && !event.alreadyInvoked) {
                                continue;
                            }
                            if (shape != myShape && this._boxCollision(shape)) {
                                if (event === undefined) {
                                    var event1 = index1 < index2 ? this._getTrigger(index1, index2) : this._getTrigger(index2, index1);
                                    event1.state = 0;
                                    event1.alreadyInvoked = false;
                                    this._currentEvents.add(event1);
                                } else if (event.state === 0) {
                                    event.state = 1;
                                    event.alreadyInvoked = false;
                                } else if (event.state === 1) {
                                    event.alreadyInvoked = false;
                                }
                            }
                        }
                    }
                } else if (_instanceof(myShape, LiteSphereColliderShape)) {
                    LitePhysicsScene._upWorldSphere(myShape, this._sphere);
                    for(var j1 = 0, len3 = colliders.length; j1 < len3; j1++){
                        var colliderShape1 = colliders[j1]._shapes;
                        for(var k1 = 0, len4 = colliderShape1.length; k1 < len4; k1++){
                            var shape1 = colliderShape1[k1];
                            var index11 = shape1._id;
                            var index21 = myShape._id;
                            var event2 = index11 < index21 ? this._eventMap[index11][index21] : this._eventMap[index21][index11];
                            if (event2 !== undefined && !event2.alreadyInvoked) {
                                continue;
                            }
                            if (shape1 != myShape && this._sphereCollision(shape1)) {
                                if (event2 === undefined) {
                                    var event3 = index11 < index21 ? this._getTrigger(index11, index21) : this._getTrigger(index21, index11);
                                    event3.state = 0;
                                    event3.alreadyInvoked = false;
                                    this._currentEvents.add(event3);
                                } else if (event2.state === 0) {
                                    event2.state = 1;
                                    event2.alreadyInvoked = false;
                                } else if (event2.state === 1) {
                                    event2.alreadyInvoked = false;
                                }
                            }
                        }
                    }
                }
            }
        };
        _proto._fireEvent = function _fireEvent() {
            var _this = this;
            var _this1 = this, eventPool = _this1._eventPool, currentEvents = _this1._currentEvents;
            currentEvents.forEach(function(event, i) {
                if (!event.alreadyInvoked) {
                    if (event.state == 0) {
                        _this._onTriggerEnter(event.index1, event.index2);
                        event.alreadyInvoked = true;
                    } else if (event.state == 1) {
                        _this._onTriggerStay(event.index1, event.index2);
                        event.alreadyInvoked = true;
                    }
                } else {
                    event.state = 2;
                    _this._eventMap[event.index1][event.index2] = undefined;
                    currentEvents.deleteByIndex(i);
                    _this._onTriggerExit(event.index1, event.index2);
                    eventPool.push(event);
                }
            });
        };
        _proto._boxCollision = function _boxCollision(other) {
            if (_instanceof(other, LiteBoxColliderShape)) {
                var box = LitePhysicsScene._tempBox;
                LitePhysicsScene._updateWorldBox(other, box);
                return engine.CollisionUtil.intersectsBoxAndBox(box, this._box);
            } else if (_instanceof(other, LiteSphereColliderShape)) {
                var sphere = LitePhysicsScene._tempSphere;
                LitePhysicsScene._upWorldSphere(other, sphere);
                return engine.CollisionUtil.intersectsSphereAndBox(sphere, this._box);
            }
            return false;
        };
        _proto._sphereCollision = function _sphereCollision(other) {
            if (_instanceof(other, LiteBoxColliderShape)) {
                var box = LitePhysicsScene._tempBox;
                LitePhysicsScene._updateWorldBox(other, box);
                return engine.CollisionUtil.intersectsSphereAndBox(this._sphere, box);
            } else if (_instanceof(other, LiteSphereColliderShape)) {
                var sphere = LitePhysicsScene._tempSphere;
                LitePhysicsScene._upWorldSphere(other, sphere);
                return engine.CollisionUtil.intersectsSphereAndSphere(sphere, this._sphere);
            }
            return false;
        };
        _proto._raycast = function _raycast(ray, distance, onRaycast, colliders, hit) {
            var isHit = false;
            var curHit = LitePhysicsScene._currentHit;
            for(var i = 0, len = colliders.length; i < len; i++){
                if (colliders[i]._raycast(ray, onRaycast, curHit) && curHit.distance < distance) {
                    if (hit) {
                        isHit = true;
                        var hitResult = LitePhysicsScene._hitResult;
                        hitResult.normal.copyFrom(curHit.normal);
                        hitResult.point.copyFrom(curHit.point);
                        hitResult.distance = distance = curHit.distance;
                        hitResult.shapeID = curHit.shapeID;
                    } else {
                        return true;
                    }
                }
            }
            return isHit;
        };
        /**
       * Calculate the bounding box in world space from boxCollider.
       * @param boxCollider - The boxCollider to calculate
       * @param out - The calculated boundingBox
       */ LitePhysicsScene._updateWorldBox = function _updateWorldBox(boxCollider, out) {
            var mat = boxCollider._transform.worldMatrix;
            out.min.copyFrom(boxCollider._boxMin);
            out.max.copyFrom(boxCollider._boxMax);
            engine.BoundingBox.transform(out, mat, out);
        };
        /**
       * Get the sphere info of the given sphere collider in world space.
       * @param sphereCollider - The given sphere collider
       * @param out - The calculated boundingSphere
       */ LitePhysicsScene._upWorldSphere = function _upWorldSphere(sphereCollider, out) {
            engine.Vector3.transformCoordinate(sphereCollider._transform.position, sphereCollider._transform.worldMatrix, out.center);
            out.radius = sphereCollider.worldRadius;
        };
        return LitePhysicsScene;
    }();
    LitePhysicsScene._tempSphere = new engine.BoundingSphere();
    LitePhysicsScene._tempBox = new engine.BoundingBox();
    LitePhysicsScene._currentHit = new LiteHitResult();
    LitePhysicsScene._hitResult = new LiteHitResult();
    /**
     * Trigger event to store interactive object ids and state.
     */ var TriggerEvent = function TriggerEvent(index1, index2) {
        this.alreadyInvoked = false;
        this.index1 = index1;
        this.index2 = index2;
    };

    /**
     * A static collider component that will not move.
     * @remarks Mostly used for object which always stays at the same place and never moves around.
     */ var LiteStaticCollider = /*#__PURE__*/ function(LiteCollider) {
        _inherits(LiteStaticCollider, LiteCollider);
        function LiteStaticCollider(position, rotation) {
            var _this;
            _this = LiteCollider.call(this) || this, /** @internal */ _this._isStaticCollider = true;
            _this._transform.setPosition(position.x, position.y, position.z);
            _this._transform.setRotationQuaternion(rotation.x, rotation.y, rotation.z, rotation.w);
            return _this;
        }
        return LiteStaticCollider;
    }(LiteCollider);

    var LitePhysics = /*#__PURE__*/ function() {
        function LitePhysics() {}
        var _proto = LitePhysics.prototype;
        /**
       * {@inheritDoc IPhysics.initialize }
       */ _proto.initialize = function initialize() {
            return Promise.resolve();
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsManager }
       */ _proto.createPhysicsManager = function createPhysicsManager() {
            return null;
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsScene }
       */ _proto.createPhysicsScene = function createPhysicsScene(physicsManager, onContactBegin, onContactEnd, onContactPersist, onTriggerBegin, onTriggerEnd, onTriggerPersist) {
            return new LitePhysicsScene(onContactBegin, onContactEnd, onContactPersist, onTriggerBegin, onTriggerEnd, onTriggerPersist);
        };
        /**
       * {@inheritDoc IPhysics.createStaticCollider }
       */ _proto.createStaticCollider = function createStaticCollider(position, rotation) {
            return new LiteStaticCollider(position, rotation);
        };
        /**
       * {@inheritDoc IPhysics.createDynamicCollider }
       */ _proto.createDynamicCollider = function createDynamicCollider(position, rotation) {
            return new LiteDynamicCollider(position, rotation);
        };
        /**
       * {@inheritDoc IPhysics.createCharacterController }
       */ _proto.createCharacterController = function createCharacterController() {
            throw "Physics-lite don't support createCharacterController. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysics.createPhysicsMaterial }
       */ _proto.createPhysicsMaterial = function createPhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine) {
            return new LitePhysicsMaterial(staticFriction, dynamicFriction, bounciness, frictionCombine, bounceCombine);
        };
        /**
       * {@inheritDoc IPhysics.createBoxColliderShape }
       */ _proto.createBoxColliderShape = function createBoxColliderShape(uniqueID, size, material) {
            return new LiteBoxColliderShape(uniqueID, size, material);
        };
        /**
       * {@inheritDoc IPhysics.createSphereColliderShape }
       */ _proto.createSphereColliderShape = function createSphereColliderShape(uniqueID, radius, material) {
            return new LiteSphereColliderShape(uniqueID, radius, material);
        };
        /**
       * {@inheritDoc IPhysics.createPlaneColliderShape }
       */ _proto.createPlaneColliderShape = function createPlaneColliderShape(uniqueID, material) {
            throw "Physics-lite don't support PlaneColliderShape. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysics.createCapsuleColliderShape }
       */ _proto.createCapsuleColliderShape = function createCapsuleColliderShape(uniqueID, radius, height, material) {
            throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysics.createFixedJoint }
       */ _proto.createFixedJoint = function createFixedJoint(collider) {
            throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysics.createHingeJoint }
       */ _proto.createHingeJoint = function createHingeJoint(collider) {
            throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
        };
        /**
       * {@inheritDoc IPhysics.createSpringJoint }
       */ _proto.createSpringJoint = function createSpringJoint(collider) {
            throw "Physics-lite don't support CapsuleColliderShape. Use Physics-PhysX instead!";
        };
        return LitePhysics;
    }();

    //@ts-ignore
    var version = "1.4.0-alpha.0";
    console.log("Galacean PhysicsLite version: " + version);

    exports.LitePhysics = LitePhysics;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=browser.js.map
