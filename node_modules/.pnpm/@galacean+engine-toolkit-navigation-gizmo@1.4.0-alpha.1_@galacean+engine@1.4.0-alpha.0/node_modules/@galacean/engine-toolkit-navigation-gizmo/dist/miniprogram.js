'use strict';

var miniprogram = require('@galacean/engine/dist/miniprogram');

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$1(o, p);
}

function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$1(subClass, superClass);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/** @internal */ var EndScript = /*#__PURE__*/ function(Script1) {
    _inherits$1(EndScript, Script1);
    function EndScript() {
        var _this;
        _this = Script1.apply(this, arguments) || this;
        _this._flipView = false;
        _this._flipSpeed = 3.0;
        _this._progress = 0;
        _this._textColor = new miniprogram.Color();
        _this._target = EndScript._vector;
        _this._normalQuat = new miniprogram.Quaternion();
        _this._tempMat = new miniprogram.Matrix();
        _this._targetMat = new miniprogram.Matrix();
        _this._currentMat = new miniprogram.Matrix();
        _this._startMat = new miniprogram.Matrix();
        _this._tempVect = new miniprogram.Vector3();
        _this._tempEyeVect = new miniprogram.Vector3();
        _this._upVector = new miniprogram.Vector3(0, 1, 0);
        _this._disabledCompArray = [];
        _this.AxisFactor = {
            x: {
                upVector: _this._upVector,
                axis: "x",
                factor: 1,
                unit: new miniprogram.Vector3(0, 0.001, 0)
            },
            y: {
                upVector: _this._upVector,
                axis: "y",
                factor: 1,
                unit: new miniprogram.Vector3(0, 0, 0.001)
            },
            z: {
                upVector: _this._upVector,
                axis: "z",
                factor: 1,
                unit: new miniprogram.Vector3(0, 0.001, 0)
            },
            "-x": {
                upVector: _this._upVector,
                axis: "x",
                factor: -1,
                unit: new miniprogram.Vector3(0, 0.001, 0)
            },
            "-y": {
                upVector: new miniprogram.Vector3(0, -1, 0),
                axis: "y",
                factor: -1,
                unit: new miniprogram.Vector3(0, 0, -0.001)
            },
            "-z": {
                upVector: _this._upVector,
                axis: "z",
                factor: -1,
                unit: new miniprogram.Vector3(0, 0.001, 0)
            }
        };
        return _this;
    }
    var _proto = EndScript.prototype;
    _proto.onAwake = function onAwake() {
        var textEntity = this.entity.findByName("text");
        this._textRenderer = textEntity.getComponent(miniprogram.TextRenderer);
        this._textColor.copyFrom(this._textRenderer.color);
        this._backEntity = this.entity.findByName("back");
    };
    _proto.onPointerEnter = function onPointerEnter() {
        this._textRenderer.color.set(1, 1, 1, 1);
        this._backEntity.isActive = true;
    };
    _proto.onPointerExit = function onPointerExit() {
        this._textRenderer.color.copyFrom(this._textColor);
        this._backEntity.isActive = false;
    };
    _proto.onPointerClick = function onPointerClick() {
        this._disableComponent();
        var currentAxisName = this.entity.name;
        this._startMat = this._sceneCameraEntity.transform.worldMatrix.clone();
        this._currentMat = this._sceneCameraEntity.transform.worldMatrix;
        this._targetMat = this._getTargetMatrix(this._sceneCameraEntity, currentAxisName);
        this._flipView = true;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        this.entity.transform.worldRotationQuaternion = this._normalQuat;
        if (this._flipView) {
            this._progress += deltaTime;
            var t = miniprogram.MathUtil.clamp(this._progress * this._flipSpeed, 0, 1);
            if (t >= 1) {
                this._flipView = false;
                this._progress = 0;
                this._enableComponent();
            }
            miniprogram.Matrix.lerp(this._startMat, this._targetMat, t, this._currentMat);
            this._sceneCameraEntity.transform.worldMatrix = this._currentMat;
        }
    };
    _proto._getTargetMatrix = function _getTargetMatrix(entity, axisName) {
        var _this = this, tempTargetVect = _this._target, tempEyeVect = _this._tempEyeVect, tempVect = _this._tempVect, tempMat = _this._tempMat;
        var _this_AxisFactor_axisName = this.AxisFactor[axisName], upVector = _this_AxisFactor_axisName.upVector, factor = _this_AxisFactor_axisName.factor, axis = _this_AxisFactor_axisName.axis, unit = _this_AxisFactor_axisName.unit;
        miniprogram.Vector3.subtract(entity.transform.worldPosition, tempTargetVect, tempVect);
        var radius = tempVect.length();
        unit[axis] = factor * radius;
        // get eye position
        miniprogram.Vector3.add(unit, tempTargetVect, tempEyeVect);
        // get worldMatrix for scene camera
        miniprogram.Matrix.lookAt(tempEyeVect, tempTargetVect, upVector, tempMat);
        tempMat.invert();
        return tempMat;
    };
    _proto._disableComponent = function _disableComponent() {
        var components = [];
        this._sceneCameraEntity.getComponents(miniprogram.Script, components);
        for(var i = 0; i < components.length; i++){
            var currentComponent = components[i];
            var proto = Object.getPrototypeOf(currentComponent);
            if (proto.onUpdate || proto.onLateUpdate || proto.onPhysicsUpdate) {
                if (currentComponent.enabled) {
                    currentComponent.enabled = false;
                    this._disabledCompArray.push(currentComponent);
                }
            }
        }
    };
    _proto._enableComponent = function _enableComponent() {
        for(var i = 0; i < this._disabledCompArray.length; i++){
            var currentComponent = this._disabledCompArray[i];
            currentComponent.enabled = true;
        }
    };
    _create_class$1(EndScript, [
        {
            key: "camera",
            get: /**
   * @return scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                this._sceneCamera = camera;
                this._sceneCameraEntity = this._sceneCamera.entity;
            }
        },
        {
            key: "target",
            get: /**
   * target point for gizmo, default (0,0,0)
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
            }
        }
    ]);
    return EndScript;
}(miniprogram.Script);
EndScript._vector = new miniprogram.Vector3();

/** @internal */ var SphereScript = /*#__PURE__*/ function(Script1) {
    _inherits$1(SphereScript, Script1);
    function SphereScript() {
        var _this;
        _this = Script1.apply(this, arguments) || this;
        _this._isTriggered = false;
        _this._speedXFactor = 0.02;
        _this._speedYFactor = 0.004;
        _this._textColor = [];
        _this._tempQuat = new miniprogram.Quaternion();
        _this._tempQuat2 = new miniprogram.Quaternion();
        _this._deltaPointer = new miniprogram.Vector2();
        _this._tempMat = new miniprogram.Matrix();
        _this._upVec = new miniprogram.Vector3(0, 1, 0);
        _this._topVec = new miniprogram.Vector3(0, 1, 0);
        _this._bottomVec = new miniprogram.Vector3(0, -1, 0);
        _this._target = SphereScript._vector;
        _this._currentPos = new miniprogram.Vector3();
        _this._rotateVec = new miniprogram.Vector3();
        _this._tempUpVec = new miniprogram.Vector3();
        _this._startRadian = 0;
        _this._ray = new miniprogram.Ray();
        _this._isBack = false;
        _this._disabledCompArray = [];
        return _this;
    }
    var _proto = SphereScript.prototype;
    _proto.onAwake = function onAwake() {
        var gizmoEntity = this.entity.parent;
        this._directionEntity = gizmoEntity.findByName("direction");
        this._roundEntity = this.entity.findByName("round");
        this._endEntity = this._directionEntity.findByName("end");
        this._gizmoCameraEntity = gizmoEntity.findByName("gizmo-camera");
        this._gizmoCamera = this._gizmoCameraEntity.getComponent(miniprogram.Camera);
        this._xEntity = this._endEntity.findByName("-x").findByName("back");
        this._yEntity = this._endEntity.findByName("-y").findByName("back");
        this._zEntity = this._endEntity.findByName("-z").findByName("back");
        // original text color
        this._getTextColor();
    };
    _proto.onPointerEnter = function onPointerEnter() {
        this._roundEntity.isActive = true;
        this._xEntity.isActive = true;
        this._yEntity.isActive = true;
        this._zEntity.isActive = true;
    };
    _proto.onPointerExit = function onPointerExit() {
        if (!this._isTriggered) {
            this._roundEntity.isActive = false;
            this._xEntity.isActive = false;
            this._yEntity.isActive = false;
            this._zEntity.isActive = false;
        }
    };
    _proto.onPointerDown = function onPointerDown(pointer) {
        this._disableComponent();
        this._recoverTextColor();
        // get targetPoint
        SphereScript._startPos.copyFrom(this._sceneCameraEntity.transform.worldPosition);
        SphereScript._startQuat.copyFrom(this._directionEntity.transform.worldRotationQuaternion);
        SphereScript._startPointer.copyFrom(pointer.position);
        this._tempUpVec.copyFrom(this._sceneCameraEntity.transform.worldUp);
        this._isBack = this._tempUpVec.y <= 0;
        this._upVec.copyFrom(this._isBack ? this._bottomVec : this._topVec);
        SphereScript._startAxis.copyFrom(this._sceneCameraEntity.transform.worldForward);
        miniprogram.Vector3.cross(SphereScript._startAxis, this._upVec, SphereScript._startAxis);
        miniprogram.Vector3.subtract(SphereScript._startPos, this._target, this._tempUpVec);
        var radius = this._tempUpVec.length();
        var dot = miniprogram.Vector3.dot(this._tempUpVec, this._upVec);
        if (this._isBack) {
            this._startRadian = Math.PI + Math.acos(miniprogram.MathUtil.clamp(dot / radius, -1, 1));
        } else {
            this._startRadian = Math.acos(miniprogram.MathUtil.clamp(dot / radius, -1, 1));
        }
        this._isTriggered = true;
        this._navigateCamera(pointer);
    };
    _proto.onPointerDrag = function onPointerDrag(pointer) {
        this._navigateCamera(pointer);
    };
    _proto.onPointerUp = function onPointerUp(pointer) {
        if (this._isTriggered) {
            this._gizmoCamera.screenPointToRay(pointer.position, this._ray);
            var result = this.engine.physicsManager.raycast(this._ray, Number.MAX_VALUE, miniprogram.Layer.Everything);
            if (!result) {
                this._roundEntity.isActive = false;
                this._xEntity.isActive = false;
                this._yEntity.isActive = false;
                this._zEntity.isActive = false;
            }
            this._isTriggered = false;
            this._enableComponent();
        }
    };
    _proto.onUpdate = function onUpdate() {
        if (this._isTriggered) {
            this._upVec.copyFrom(this._isBack ? this._bottomVec : this._topVec);
            miniprogram.Matrix.lookAt(this._currentPos, this._target, this._upVec, this._tempMat);
            this._tempMat.invert();
            this._sceneCameraEntity.transform.worldMatrix = this._tempMat;
        }
        SphereScript._tempMat.copyFrom(this._sceneCamera.viewMatrix);
        var _SphereScript__tempMat = SphereScript._tempMat, ele = _SphereScript__tempMat.elements;
        // ignore translate
        ele[12] = ele[13] = ele[14] = 0;
        this._directionEntity.transform.worldMatrix = SphereScript._tempMat;
    };
    // delta x translate to rotation around axis y
    // delta y translate to rotation around axis vertical to scene camera
    _proto._navigateCamera = function _navigateCamera(pointer) {
        var movePointer = pointer.position;
        miniprogram.Vector2.subtract(SphereScript._startPointer, movePointer, this._deltaPointer);
        var x = -this._deltaPointer.x * this._speedXFactor;
        var y = -this._deltaPointer.y * this._speedYFactor;
        var isBetween = this._startRadian - y > Math.PI && this._startRadian - y < 2 * Math.PI;
        this._isBack = this._startRadian - y <= 0 || isBetween;
        var _this = this, tempQuat = _this._tempQuat, tempQuat2 = _this._tempQuat2;
        miniprogram.Quaternion.rotationAxisAngle(SphereScript._startAxis, y, tempQuat);
        miniprogram.Quaternion.rotationYawPitchRoll(x, 0, 0, tempQuat2);
        miniprogram.Quaternion.multiply(tempQuat, tempQuat2, tempQuat);
        miniprogram.Vector3.subtract(SphereScript._startPos, this._target, this._rotateVec);
        miniprogram.Vector3.transformByQuat(this._rotateVec, tempQuat.invert(), this._currentPos);
        miniprogram.Vector3.add(this._target, this._currentPos, this._currentPos);
    };
    _proto._getTextColor = function _getTextColor() {
        var entities = this._endEntity.children;
        for(var i = 0; i < entities.length; i++){
            var textEntity = entities[i].findByName("text");
            var textRenderer = textEntity.getComponent(miniprogram.TextRenderer);
            var textColor = textRenderer.color.clone();
            this._textColor.push(textColor);
        }
    };
    _proto._recoverTextColor = function _recoverTextColor() {
        var entities = this._endEntity.children;
        for(var i = 0; i < entities.length; i++){
            var textEntity = entities[i].findByName("text");
            var textRenderer = textEntity.getComponent(miniprogram.TextRenderer);
            textRenderer.color.copyFrom(this._textColor[i]);
        }
    };
    _proto._disableComponent = function _disableComponent() {
        var components = [];
        this._sceneCameraEntity.getComponents(miniprogram.Script, components);
        for(var i = 0; i < components.length; i++){
            var currentComponent = components[i];
            var proto = Object.getPrototypeOf(currentComponent);
            if (proto.onUpdate || proto.onLateUpdate || proto.onPhysicsUpdate) {
                if (currentComponent.enabled) {
                    currentComponent.enabled = false;
                    this._disabledCompArray.push(currentComponent);
                }
            }
        }
    };
    _proto._enableComponent = function _enableComponent() {
        for(var i = 0; i < this._disabledCompArray.length; i++){
            var currentComponent = this._disabledCompArray[i];
            currentComponent.enabled = true;
        }
    };
    _create_class$1(SphereScript, [
        {
            key: "camera",
            get: /**
   * @return scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                this._sceneCamera = camera;
                this._sceneCameraEntity = this._sceneCamera.entity;
            }
        },
        {
            key: "target",
            get: /**
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
            }
        }
    ]);
    return SphereScript;
}(miniprogram.Script);
SphereScript._startQuat = new miniprogram.Quaternion();
SphereScript._startPointer = new miniprogram.Vector2();
SphereScript._startPos = new miniprogram.Vector3();
SphereScript._startAxis = new miniprogram.Vector3();
SphereScript._tempMat = new miniprogram.Matrix();
SphereScript._vector = new miniprogram.Vector3();

/**
 * create a circle mesh
 * @param engine - Engine
 * @param radius - Circle radius
 * @param segments - Number of segments
 * @param center - Circle center
 * @param normal - Circle direction
 * @returns Circle model mesh
 */ function createCircleMesh(engine, radius, segments, center, normal) {
    if (radius === void 0) radius = 1;
    if (segments === void 0) segments = 48;
    if (center === void 0) center = new miniprogram.Vector3(0, 0, 0);
    if (normal === void 0) normal = new miniprogram.Vector3(0, 0, 1);
    var mesh = new miniprogram.ModelMesh(engine);
    var indices = new Uint16Array(segments * 3);
    var vertices = [];
    var startPoint = new miniprogram.Vector3(1, 0, 0).scale(radius);
    var tempQuat = new miniprogram.Quaternion();
    var tempVect = new miniprogram.Vector3();
    for(var i = 1; i <= segments; i++){
        var start = (i - 1) * 3;
        indices[start] = i;
        indices[start + 1] = i + 1;
        indices[start + 2] = 0;
    }
    vertices.push(center);
    for(var s = 0; s <= segments; s++){
        var segment = s / segments * Math.PI * 2;
        miniprogram.Quaternion.rotationAxisAngle(normal, segment, tempQuat);
        miniprogram.Vector3.transformByQuat(startPoint, tempQuat, tempVect);
        vertices[s + 1] = tempVect.clone();
    }
    mesh.setPositions(vertices);
    mesh.setIndices(indices);
    mesh.addSubMesh(0, indices.length, miniprogram.MeshTopology.Triangles);
    mesh.uploadData(false);
    return mesh;
}

miniprogram.ShaderProperty.getByName("u_lightDir");
miniprogram.ShaderProperty.getByName("u_planarHeight");
miniprogram.ShaderProperty.getByName("u_planarShadowColor");
miniprogram.ShaderProperty.getByName("u_planarShadowFalloff");
var planarShadow = new miniprogram.ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ", "\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");
miniprogram.Shader.create("planarShadowShader", [
    miniprogram.Shader.find("pbr").subShaders[0].passes[0],
    planarShadow
]);

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}

miniprogram.ShaderProperty.getByName("u_far");
miniprogram.ShaderProperty.getByName("u_near");
miniprogram.ShaderProperty.getByName("u_primaryScale");
miniprogram.ShaderProperty.getByName("u_secondaryScale");
miniprogram.ShaderProperty.getByName("u_gridIntensity");
miniprogram.ShaderProperty.getByName("u_axisIntensity");
miniprogram.ShaderProperty.getByName("u_flipProgress");
miniprogram.ShaderProperty.getByName("u_fade");
miniprogram.Shader.create("grid", "\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}", "\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");

var vertexSource$2 = "\n  attribute vec3 POSITION;\n  attribute vec2 TEXCOORD_0;\n  attribute vec4 COLOR_0;\n  uniform mat4 renderer_MVPMat;\n  \n  uniform float u_time;\n  uniform vec2 u_foam_speed; \n  uniform vec2 u_distorsion_speed; \n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  varying vec4 v_color;\n      \n  void main() {\n    gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    waterTexCoords = TEXCOORD_0 + vec2(u_foam_speed.x * u_time, u_foam_speed.y * u_time);\n    normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));\n    v_color = COLOR_0; \n  }\n  ";
var fragmentSource$2 = "\n  #include <common>\n  varying vec4 v_color;\n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  uniform sampler2D material_NormalTexture;\n  uniform sampler2D u_foamTex;\n  uniform vec3 u_foamColor;\n  uniform vec2 u_foam_param;\n  uniform float u_distorsion_amount;\n  void main() {  \n    vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n    vec4 waterTex = texture2D(u_foamTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n    float alphaComp = v_color.r * waterTex.r * u_foam_param.x;\n    float alpha = pow(alphaComp,2.0);\n    alpha = smoothstep(0.5 - u_foam_param.y, 0.5+ u_foam_param.y, alpha);\n    alpha = saturate(alpha);\n    \n    gl_FragColor = vec4(u_foamColor.rgb, alpha);\n  }\n  ";
miniprogram.Shader.create("water-ripple", vertexSource$2, fragmentSource$2);
miniprogram.ShaderProperty.getByName("u_foamColor");
miniprogram.ShaderProperty.getByName("u_foam_speed");
miniprogram.ShaderProperty.getByName("u_foam_param");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_foamTex");

var vertexSource$1 = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n\n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_distorsion_speed; \n    \n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * sin(u_time), u_water_speed.y * cos(u_time));\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));     \n      \n      v_color = COLOR_0;\n    }\n    ";
var fragmentSource$1 = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_edgeTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {\n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 edgeTex = texture2D(u_edgeTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      float edge = pow((v_color.r + edgeTex.r) * v_color.r, 2.0);\n      edge = saturate(1.0 - smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edge));\n      vec4 finalCol = mix(waterTex, u_edgeColor, edge);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water", vertexSource$1, fragmentSource$1);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_edgeTex");

var vertexSource = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ";
var fragmentSource = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water-fall", vertexSource, fragmentSource);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_waterfall_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_waterfallTex");
miniprogram.ShaderProperty.getByName("u_edgeNoiseTex");

var fragment = "\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n";

var vertex = "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n";

miniprogram.Shader.create("bake-pbr", vertex, fragment);
miniprogram.ShaderProperty.getByName("u_lightMapTexture");
miniprogram.ShaderProperty.getByName("u_lightMapIntensity");

/**
 * plain color Material. don't effected by light and fog.
 */ var PlainColorMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits(PlainColorMaterial, BaseMaterial);
    function PlainColorMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, miniprogram.Shader.find("plain-color")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.setColor(PlainColorMaterial._baseColorProp, new miniprogram.Color(1, 1, 1, 1));
        _this.renderState.rasterState.cullMode = miniprogram.CullMode.Off;
        return _this;
    }
    var _proto = PlainColorMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new PlainColorMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class(PlainColorMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PlainColorMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PlainColorMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return PlainColorMaterial;
}(miniprogram.BaseMaterial);
miniprogram.Shader.create("plain-color", "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n\nvoid main() {\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n}\n", "\n#include <common>\n\nuniform vec4 material_BaseColor;\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n     #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n}\n");

/** @internal */ var Utils = function Utils(engine) {
    this.radius = 9.2;
    this.endRadius = 1.6;
    this.axisLength = this.radius - 2 * this.endRadius;
    this.endDist = this.radius - this.endRadius;
    this.xRotateVector = new miniprogram.Vector3();
    this.yRotateVector = new miniprogram.Vector3();
    this.zRotateVector = new miniprogram.Vector3();
    this.xTranslateVector = new miniprogram.Vector3();
    this.yTranslateVector = new miniprogram.Vector3();
    this.zTranslateVector = new miniprogram.Vector3();
    this.xEndTranslateVector = new miniprogram.Vector3();
    this.yEndTranslateVector = new miniprogram.Vector3();
    this.zEndTranslateVector = new miniprogram.Vector3();
    var redMaterial = new PlainColorMaterial(engine);
    redMaterial.isTransparent = true;
    redMaterial.baseColor.set(1.0, 0.25, 0.25, 1.0);
    this.redMaterial = redMaterial;
    var greenMaterial = new PlainColorMaterial(engine);
    greenMaterial.isTransparent = true;
    greenMaterial.baseColor.set(0.5, 0.8, 0.2, 1.0);
    this.greenMaterial = greenMaterial;
    var blueMaterial = new PlainColorMaterial(engine);
    blueMaterial.isTransparent = true;
    blueMaterial.baseColor.set(0.3, 0.5, 1.0, 1.0);
    this.blueMaterial = blueMaterial;
    var bgMaterial = new PlainColorMaterial(engine);
    bgMaterial.isTransparent = true;
    bgMaterial.baseColor.set(1, 1, 1, 0.1);
    this.bgMaterial = bgMaterial;
    var greyMaterial = new PlainColorMaterial(engine);
    greyMaterial.isTransparent = true;
    greyMaterial.baseColor.set(0.5, 0.5, 0.5, 1);
    this.greyMaterial = greyMaterial;
    this.axisMesh = miniprogram.PrimitiveMesh.createCylinder(engine, 0.12, 0.12, this.axisLength);
    this.bgMesh = createCircleMesh(engine, this.radius, 144);
    this.endMesh = createCircleMesh(engine, this.endRadius - 0.2);
    this.xRotateVector = new miniprogram.Vector3(0, 0, 90);
    this.yRotateVector = new miniprogram.Vector3(0, 90, 0);
    this.zRotateVector = new miniprogram.Vector3(90, 0, 0);
    this.xTranslateVector = new miniprogram.Vector3(this.axisLength * 0.5, 0, 0);
    this.yTranslateVector = new miniprogram.Vector3(0, this.axisLength * 0.5, 0);
    this.zTranslateVector = new miniprogram.Vector3(0, 0, this.axisLength * 0.5);
    this.xEndTranslateVector = new miniprogram.Vector3(this.endDist, 0, 0);
    this.yEndTranslateVector = new miniprogram.Vector3(0, this.endDist, 0);
    this.zEndTranslateVector = new miniprogram.Vector3(0, 0, this.endDist);
};

function traverseEntity(entity, callback) {
    callback(entity);
    for(var _iterator = _create_for_of_iterator_helper_loose(entity.children), _step; !(_step = _iterator()).done;){
        var child = _step.value;
        traverseEntity(child, callback);
    }
}
var NavigationGizmo = /*#__PURE__*/ function(Script) {
    _inherits$1(NavigationGizmo, Script);
    function NavigationGizmo(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this._gizmoLayer = miniprogram.Layer.Layer30;
        _this._target = new miniprogram.Vector3();
        _this._endScript = {
            X: EndScript,
            Y: EndScript,
            Z: EndScript,
            "-X": EndScript,
            "-Y": EndScript,
            "-Z": EndScript
        };
        /**
   * @position - gizmo position, the left upper point of the gizmo area, default (0, 0).
   * Normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
   */ _this.position = new miniprogram.Vector2(0, 0);
        /**
   * @size gizmo size, the length and width of the gizmo area, default (0.12,0.12).
   */ _this.size = new miniprogram.Vector2(0.12, 0.12);
        if (!entity.engine.physicsManager) {
            throw new Error("PhysicsManager is not initialized");
        }
        _this._utils = new Utils(_this.engine);
        _this._gizmoEntity = entity.createChild("navigation-gizmo");
        _this._gizmoEntity.layer = _this._gizmoLayer;
        var gizmoCameraEntity = _this._gizmoEntity.createChild("gizmo-camera");
        gizmoCameraEntity.transform.setPosition(0, 0, 10);
        var gizmoCamera = gizmoCameraEntity.addComponent(miniprogram.Camera);
        gizmoCamera.isOrthographic = true;
        gizmoCamera.cullingMask = _this._gizmoLayer;
        gizmoCamera.clearFlags = miniprogram.CameraClearFlags.Depth;
        gizmoCamera.priority = 100;
        _this._gizmoCamera = gizmoCamera;
        _this._createGizmo();
        _this._setTarget = _this._setTarget.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._target._onValueChanged = _this._setTarget;
        return _this;
    }
    var _proto = NavigationGizmo.prototype;
    _proto.onUpdate = function onUpdate() {
        this._gizmoCamera.viewport.set(this.position.x, this.position.y, this.size.x, this.size.y);
    };
    _proto._createGizmo = function _createGizmo() {
        var utils = this._utils;
        // setup gizmo shape
        var directionEntity = this._gizmoEntity.createChild("direction");
        var axisEntity = directionEntity.createChild("axis");
        // axis
        var axisXEntity = axisEntity.createChild("x");
        var axisYEntity = axisEntity.createChild("y");
        var axisZEntity = axisEntity.createChild("z");
        this._createAxis(axisXEntity, utils.xRotateVector, utils.xTranslateVector, utils.redMaterial);
        this._createAxis(axisYEntity, utils.yRotateVector, utils.yTranslateVector, utils.greenMaterial);
        this._createAxis(axisZEntity, utils.zRotateVector, utils.zTranslateVector, utils.blueMaterial);
        // end
        var endEntity = directionEntity.createChild("end");
        var endXEntity = endEntity.createChild("x");
        var endYEntity = endEntity.createChild("y");
        var endZEntity = endEntity.createChild("z");
        this._createEnd(endXEntity, utils.xEndTranslateVector, utils.redMaterial, "X", new miniprogram.Color(1.0, 0.25, 0.25, 1.0));
        this._createEnd(endYEntity, utils.yEndTranslateVector, utils.greenMaterial, "Y", new miniprogram.Color(0.5, 0.8, 0.2, 1.0));
        this._createEnd(endZEntity, utils.zEndTranslateVector, utils.blueMaterial, "Z", new miniprogram.Color(0.3, 0.5, 1.0, 1.0));
        var endNegativeXEntity = endEntity.createChild("-x");
        var endNegativeYEntity = endEntity.createChild("-y");
        var endNegativeZEntity = endEntity.createChild("-z");
        this._createEnd(endNegativeXEntity, utils.xEndTranslateVector.negate(), utils.greyMaterial, "-X", new miniprogram.Color(1, 1, 1, 0));
        this._createEnd(endNegativeYEntity, utils.yEndTranslateVector.negate(), utils.greyMaterial, "-Y", new miniprogram.Color(1, 1, 1, 0));
        this._createEnd(endNegativeZEntity, utils.zEndTranslateVector.negate(), utils.greyMaterial, "-Z", new miniprogram.Color(1, 1, 1, 0));
        // sphere behind
        var sphereEntity = this._gizmoEntity.createChild("sphere");
        sphereEntity.transform.setPosition(0, 0, -(utils.radius + 0.5));
        var sphereCollider = sphereEntity.addComponent(miniprogram.StaticCollider);
        var sphereColliderShape = new miniprogram.SphereColliderShape();
        sphereColliderShape.radius = utils.radius;
        sphereCollider.addShape(sphereColliderShape);
        var roundEntity = sphereEntity.createChild("round");
        var roundRenderer = roundEntity.addComponent(miniprogram.MeshRenderer);
        roundRenderer.receiveShadows = false;
        roundRenderer.castShadows = false;
        roundRenderer.mesh = utils.bgMesh;
        roundRenderer.setMaterial(utils.bgMaterial);
        roundEntity.isActive = false;
        this._sphereScript = sphereEntity.addComponent(SphereScript);
    };
    _proto._createAxis = function _createAxis(entity, rotation, position, material) {
        entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
        entity.transform.setPosition(position.x, position.y, position.z);
        var axisXRenderer = entity.addComponent(miniprogram.MeshRenderer);
        axisXRenderer.receiveShadows = false;
        axisXRenderer.castShadows = false;
        axisXRenderer.mesh = this._utils.axisMesh;
        axisXRenderer.setMaterial(material);
    };
    _proto._createEnd = function _createEnd(entity, position, material, axisName, fontColor) {
        var utils = this._utils;
        entity.transform.setPosition(position.x, position.y, position.z);
        var sphereCollider = entity.addComponent(miniprogram.StaticCollider);
        var colliderShape = new miniprogram.SphereColliderShape();
        colliderShape.radius = utils.endRadius;
        sphereCollider.addShape(colliderShape);
        var renderEntity = entity.createChild("back");
        var axisRenderer = renderEntity.addComponent(miniprogram.MeshRenderer);
        axisRenderer.receiveShadows = false;
        axisRenderer.castShadows = false;
        axisRenderer.mesh = utils.endMesh;
        axisRenderer.setMaterial(material);
        renderEntity.isActive = false;
        var textEntity = entity.createChild("text");
        textEntity.transform.setPosition(0, 0, 0.05);
        var axisXTextRenderer = textEntity.addComponent(miniprogram.TextRenderer);
        axisXTextRenderer.receiveShadows = false;
        axisXTextRenderer.castShadows = false;
        axisXTextRenderer.font = miniprogram.Font.createFromOS(this.engine, "Arial");
        axisXTextRenderer.text = axisName;
        axisXTextRenderer.fontStyle = miniprogram.FontStyle.Bold;
        axisXTextRenderer.fontSize = 200;
        axisXTextRenderer.color.copyFrom(fontColor);
        axisXTextRenderer.horizontalAlignment = miniprogram.TextHorizontalAlignment.Center;
        this._endScript[axisName] = entity.addComponent(EndScript);
    };
    _proto._setTarget = function _setTarget() {
        var _this = this;
        this._sphereScript.target.copyFrom(this._target);
        Object.keys(this._endScript).forEach(function(key) {
            _this._endScript[key].target.copyFrom(_this._target);
        });
    };
    _create_class$1(NavigationGizmo, [
        {
            key: "camera",
            get: /** scene camera
   * @return current scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                var _this = this;
                var sceneCamera = this._sceneCamera;
                if (sceneCamera !== camera) {
                    if (camera) {
                        sceneCamera = this._sceneCamera = camera;
                        this._sphereScript.camera = camera;
                        Object.keys(this._endScript).forEach(function(key) {
                            _this._endScript[key].camera = camera;
                        });
                    } else {
                        throw new Error("navigation gizmo needs scene camera");
                    }
                }
            }
        },
        {
            key: "target",
            get: /**
   * target point for gizmo, default (0,0,0)
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                if (value !== this._target) {
                    this._target.copyFrom(value);
                }
            }
        },
        {
            key: "layer",
            get: /**
   * gizmo layer, default Layer30
   */ function get() {
                return this._gizmoLayer;
            },
            set: function set(layer) {
                if (this._gizmoLayer !== layer) {
                    this._gizmoLayer = layer;
                    this._gizmoCamera.cullingMask = layer;
                    traverseEntity(this._gizmoEntity, function(entity) {
                        entity.layer = layer;
                    });
                }
            }
        },
        {
            key: "priority",
            get: /**
   * @return gizmo camera's priority, larger than any other camera in scene, default 100
   */ function get() {
                return this._gizmoCamera.priority;
            },
            set: function set(priority) {
                this._gizmoCamera.priority = priority;
            }
        }
    ]);
    return NavigationGizmo;
}(miniprogram.Script);

exports.NavigationGizmo = NavigationGizmo;
