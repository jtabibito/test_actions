'use strict';

var engine = require('@galacean/engine');
var engineToolkitCustomMaterial = require('@galacean/engine-toolkit-custom-material');

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/** @internal */ var EndScript = /*#__PURE__*/ function(Script1) {
    _inherits(EndScript, Script1);
    function EndScript() {
        var _this;
        _this = Script1.apply(this, arguments) || this;
        _this._flipView = false;
        _this._flipSpeed = 3.0;
        _this._progress = 0;
        _this._textColor = new engine.Color();
        _this._target = EndScript._vector;
        _this._normalQuat = new engine.Quaternion();
        _this._tempMat = new engine.Matrix();
        _this._targetMat = new engine.Matrix();
        _this._currentMat = new engine.Matrix();
        _this._startMat = new engine.Matrix();
        _this._tempVect = new engine.Vector3();
        _this._tempEyeVect = new engine.Vector3();
        _this._upVector = new engine.Vector3(0, 1, 0);
        _this._disabledCompArray = [];
        _this.AxisFactor = {
            x: {
                upVector: _this._upVector,
                axis: "x",
                factor: 1,
                unit: new engine.Vector3(0, 0.001, 0)
            },
            y: {
                upVector: _this._upVector,
                axis: "y",
                factor: 1,
                unit: new engine.Vector3(0, 0, 0.001)
            },
            z: {
                upVector: _this._upVector,
                axis: "z",
                factor: 1,
                unit: new engine.Vector3(0, 0.001, 0)
            },
            "-x": {
                upVector: _this._upVector,
                axis: "x",
                factor: -1,
                unit: new engine.Vector3(0, 0.001, 0)
            },
            "-y": {
                upVector: new engine.Vector3(0, -1, 0),
                axis: "y",
                factor: -1,
                unit: new engine.Vector3(0, 0, -0.001)
            },
            "-z": {
                upVector: _this._upVector,
                axis: "z",
                factor: -1,
                unit: new engine.Vector3(0, 0.001, 0)
            }
        };
        return _this;
    }
    var _proto = EndScript.prototype;
    _proto.onAwake = function onAwake() {
        var textEntity = this.entity.findByName("text");
        this._textRenderer = textEntity.getComponent(engine.TextRenderer);
        this._textColor.copyFrom(this._textRenderer.color);
        this._backEntity = this.entity.findByName("back");
    };
    _proto.onPointerEnter = function onPointerEnter() {
        this._textRenderer.color.set(1, 1, 1, 1);
        this._backEntity.isActive = true;
    };
    _proto.onPointerExit = function onPointerExit() {
        this._textRenderer.color.copyFrom(this._textColor);
        this._backEntity.isActive = false;
    };
    _proto.onPointerClick = function onPointerClick() {
        this._disableComponent();
        var currentAxisName = this.entity.name;
        this._startMat = this._sceneCameraEntity.transform.worldMatrix.clone();
        this._currentMat = this._sceneCameraEntity.transform.worldMatrix;
        this._targetMat = this._getTargetMatrix(this._sceneCameraEntity, currentAxisName);
        this._flipView = true;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        this.entity.transform.worldRotationQuaternion = this._normalQuat;
        if (this._flipView) {
            this._progress += deltaTime;
            var t = engine.MathUtil.clamp(this._progress * this._flipSpeed, 0, 1);
            if (t >= 1) {
                this._flipView = false;
                this._progress = 0;
                this._enableComponent();
            }
            engine.Matrix.lerp(this._startMat, this._targetMat, t, this._currentMat);
            this._sceneCameraEntity.transform.worldMatrix = this._currentMat;
        }
    };
    _proto._getTargetMatrix = function _getTargetMatrix(entity, axisName) {
        var _this = this, tempTargetVect = _this._target, tempEyeVect = _this._tempEyeVect, tempVect = _this._tempVect, tempMat = _this._tempMat;
        var _this_AxisFactor_axisName = this.AxisFactor[axisName], upVector = _this_AxisFactor_axisName.upVector, factor = _this_AxisFactor_axisName.factor, axis = _this_AxisFactor_axisName.axis, unit = _this_AxisFactor_axisName.unit;
        engine.Vector3.subtract(entity.transform.worldPosition, tempTargetVect, tempVect);
        var radius = tempVect.length();
        unit[axis] = factor * radius;
        // get eye position
        engine.Vector3.add(unit, tempTargetVect, tempEyeVect);
        // get worldMatrix for scene camera
        engine.Matrix.lookAt(tempEyeVect, tempTargetVect, upVector, tempMat);
        tempMat.invert();
        return tempMat;
    };
    _proto._disableComponent = function _disableComponent() {
        var components = [];
        this._sceneCameraEntity.getComponents(engine.Script, components);
        for(var i = 0; i < components.length; i++){
            var currentComponent = components[i];
            var proto = Object.getPrototypeOf(currentComponent);
            if (proto.onUpdate || proto.onLateUpdate || proto.onPhysicsUpdate) {
                if (currentComponent.enabled) {
                    currentComponent.enabled = false;
                    this._disabledCompArray.push(currentComponent);
                }
            }
        }
    };
    _proto._enableComponent = function _enableComponent() {
        for(var i = 0; i < this._disabledCompArray.length; i++){
            var currentComponent = this._disabledCompArray[i];
            currentComponent.enabled = true;
        }
    };
    _create_class(EndScript, [
        {
            key: "camera",
            get: /**
   * @return scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                this._sceneCamera = camera;
                this._sceneCameraEntity = this._sceneCamera.entity;
            }
        },
        {
            key: "target",
            get: /**
   * target point for gizmo, default (0,0,0)
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
            }
        }
    ]);
    return EndScript;
}(engine.Script);
EndScript._vector = new engine.Vector3();

/** @internal */ var SphereScript = /*#__PURE__*/ function(Script1) {
    _inherits(SphereScript, Script1);
    function SphereScript() {
        var _this;
        _this = Script1.apply(this, arguments) || this;
        _this._isTriggered = false;
        _this._speedXFactor = 0.02;
        _this._speedYFactor = 0.004;
        _this._textColor = [];
        _this._tempQuat = new engine.Quaternion();
        _this._tempQuat2 = new engine.Quaternion();
        _this._deltaPointer = new engine.Vector2();
        _this._tempMat = new engine.Matrix();
        _this._upVec = new engine.Vector3(0, 1, 0);
        _this._topVec = new engine.Vector3(0, 1, 0);
        _this._bottomVec = new engine.Vector3(0, -1, 0);
        _this._target = SphereScript._vector;
        _this._currentPos = new engine.Vector3();
        _this._rotateVec = new engine.Vector3();
        _this._tempUpVec = new engine.Vector3();
        _this._startRadian = 0;
        _this._ray = new engine.Ray();
        _this._isBack = false;
        _this._disabledCompArray = [];
        return _this;
    }
    var _proto = SphereScript.prototype;
    _proto.onAwake = function onAwake() {
        var gizmoEntity = this.entity.parent;
        this._directionEntity = gizmoEntity.findByName("direction");
        this._roundEntity = this.entity.findByName("round");
        this._endEntity = this._directionEntity.findByName("end");
        this._gizmoCameraEntity = gizmoEntity.findByName("gizmo-camera");
        this._gizmoCamera = this._gizmoCameraEntity.getComponent(engine.Camera);
        this._xEntity = this._endEntity.findByName("-x").findByName("back");
        this._yEntity = this._endEntity.findByName("-y").findByName("back");
        this._zEntity = this._endEntity.findByName("-z").findByName("back");
        // original text color
        this._getTextColor();
    };
    _proto.onPointerEnter = function onPointerEnter() {
        this._roundEntity.isActive = true;
        this._xEntity.isActive = true;
        this._yEntity.isActive = true;
        this._zEntity.isActive = true;
    };
    _proto.onPointerExit = function onPointerExit() {
        if (!this._isTriggered) {
            this._roundEntity.isActive = false;
            this._xEntity.isActive = false;
            this._yEntity.isActive = false;
            this._zEntity.isActive = false;
        }
    };
    _proto.onPointerDown = function onPointerDown(pointer) {
        this._disableComponent();
        this._recoverTextColor();
        // get targetPoint
        SphereScript._startPos.copyFrom(this._sceneCameraEntity.transform.worldPosition);
        SphereScript._startQuat.copyFrom(this._directionEntity.transform.worldRotationQuaternion);
        SphereScript._startPointer.copyFrom(pointer.position);
        this._tempUpVec.copyFrom(this._sceneCameraEntity.transform.worldUp);
        this._isBack = this._tempUpVec.y <= 0;
        this._upVec.copyFrom(this._isBack ? this._bottomVec : this._topVec);
        SphereScript._startAxis.copyFrom(this._sceneCameraEntity.transform.worldForward);
        engine.Vector3.cross(SphereScript._startAxis, this._upVec, SphereScript._startAxis);
        engine.Vector3.subtract(SphereScript._startPos, this._target, this._tempUpVec);
        var radius = this._tempUpVec.length();
        var dot = engine.Vector3.dot(this._tempUpVec, this._upVec);
        if (this._isBack) {
            this._startRadian = Math.PI + Math.acos(engine.MathUtil.clamp(dot / radius, -1, 1));
        } else {
            this._startRadian = Math.acos(engine.MathUtil.clamp(dot / radius, -1, 1));
        }
        this._isTriggered = true;
        this._navigateCamera(pointer);
    };
    _proto.onPointerDrag = function onPointerDrag(pointer) {
        this._navigateCamera(pointer);
    };
    _proto.onPointerUp = function onPointerUp(pointer) {
        if (this._isTriggered) {
            this._gizmoCamera.screenPointToRay(pointer.position, this._ray);
            var result = this.engine.physicsManager.raycast(this._ray, Number.MAX_VALUE, engine.Layer.Everything);
            if (!result) {
                this._roundEntity.isActive = false;
                this._xEntity.isActive = false;
                this._yEntity.isActive = false;
                this._zEntity.isActive = false;
            }
            this._isTriggered = false;
            this._enableComponent();
        }
    };
    _proto.onUpdate = function onUpdate() {
        if (this._isTriggered) {
            this._upVec.copyFrom(this._isBack ? this._bottomVec : this._topVec);
            engine.Matrix.lookAt(this._currentPos, this._target, this._upVec, this._tempMat);
            this._tempMat.invert();
            this._sceneCameraEntity.transform.worldMatrix = this._tempMat;
        }
        SphereScript._tempMat.copyFrom(this._sceneCamera.viewMatrix);
        var _SphereScript__tempMat = SphereScript._tempMat, ele = _SphereScript__tempMat.elements;
        // ignore translate
        ele[12] = ele[13] = ele[14] = 0;
        this._directionEntity.transform.worldMatrix = SphereScript._tempMat;
    };
    // delta x translate to rotation around axis y
    // delta y translate to rotation around axis vertical to scene camera
    _proto._navigateCamera = function _navigateCamera(pointer) {
        var movePointer = pointer.position;
        engine.Vector2.subtract(SphereScript._startPointer, movePointer, this._deltaPointer);
        var x = -this._deltaPointer.x * this._speedXFactor;
        var y = -this._deltaPointer.y * this._speedYFactor;
        var isBetween = this._startRadian - y > Math.PI && this._startRadian - y < 2 * Math.PI;
        this._isBack = this._startRadian - y <= 0 || isBetween;
        var _this = this, tempQuat = _this._tempQuat, tempQuat2 = _this._tempQuat2;
        engine.Quaternion.rotationAxisAngle(SphereScript._startAxis, y, tempQuat);
        engine.Quaternion.rotationYawPitchRoll(x, 0, 0, tempQuat2);
        engine.Quaternion.multiply(tempQuat, tempQuat2, tempQuat);
        engine.Vector3.subtract(SphereScript._startPos, this._target, this._rotateVec);
        engine.Vector3.transformByQuat(this._rotateVec, tempQuat.invert(), this._currentPos);
        engine.Vector3.add(this._target, this._currentPos, this._currentPos);
    };
    _proto._getTextColor = function _getTextColor() {
        var entities = this._endEntity.children;
        for(var i = 0; i < entities.length; i++){
            var textEntity = entities[i].findByName("text");
            var textRenderer = textEntity.getComponent(engine.TextRenderer);
            var textColor = textRenderer.color.clone();
            this._textColor.push(textColor);
        }
    };
    _proto._recoverTextColor = function _recoverTextColor() {
        var entities = this._endEntity.children;
        for(var i = 0; i < entities.length; i++){
            var textEntity = entities[i].findByName("text");
            var textRenderer = textEntity.getComponent(engine.TextRenderer);
            textRenderer.color.copyFrom(this._textColor[i]);
        }
    };
    _proto._disableComponent = function _disableComponent() {
        var components = [];
        this._sceneCameraEntity.getComponents(engine.Script, components);
        for(var i = 0; i < components.length; i++){
            var currentComponent = components[i];
            var proto = Object.getPrototypeOf(currentComponent);
            if (proto.onUpdate || proto.onLateUpdate || proto.onPhysicsUpdate) {
                if (currentComponent.enabled) {
                    currentComponent.enabled = false;
                    this._disabledCompArray.push(currentComponent);
                }
            }
        }
    };
    _proto._enableComponent = function _enableComponent() {
        for(var i = 0; i < this._disabledCompArray.length; i++){
            var currentComponent = this._disabledCompArray[i];
            currentComponent.enabled = true;
        }
    };
    _create_class(SphereScript, [
        {
            key: "camera",
            get: /**
   * @return scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                this._sceneCamera = camera;
                this._sceneCameraEntity = this._sceneCamera.entity;
            }
        },
        {
            key: "target",
            get: /**
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
            }
        }
    ]);
    return SphereScript;
}(engine.Script);
SphereScript._startQuat = new engine.Quaternion();
SphereScript._startPointer = new engine.Vector2();
SphereScript._startPos = new engine.Vector3();
SphereScript._startAxis = new engine.Vector3();
SphereScript._tempMat = new engine.Matrix();
SphereScript._vector = new engine.Vector3();

/**
 * create a circle mesh
 * @param engine - Engine
 * @param radius - Circle radius
 * @param segments - Number of segments
 * @param center - Circle center
 * @param normal - Circle direction
 * @returns Circle model mesh
 */ function createCircleMesh(engine$1, radius, segments, center, normal) {
    if (radius === void 0) radius = 1;
    if (segments === void 0) segments = 48;
    if (center === void 0) center = new engine.Vector3(0, 0, 0);
    if (normal === void 0) normal = new engine.Vector3(0, 0, 1);
    var mesh = new engine.ModelMesh(engine$1);
    var indices = new Uint16Array(segments * 3);
    var vertices = [];
    var startPoint = new engine.Vector3(1, 0, 0).scale(radius);
    var tempQuat = new engine.Quaternion();
    var tempVect = new engine.Vector3();
    for(var i = 1; i <= segments; i++){
        var start = (i - 1) * 3;
        indices[start] = i;
        indices[start + 1] = i + 1;
        indices[start + 2] = 0;
    }
    vertices.push(center);
    for(var s = 0; s <= segments; s++){
        var segment = s / segments * Math.PI * 2;
        engine.Quaternion.rotationAxisAngle(normal, segment, tempQuat);
        engine.Vector3.transformByQuat(startPoint, tempQuat, tempVect);
        vertices[s + 1] = tempVect.clone();
    }
    mesh.setPositions(vertices);
    mesh.setIndices(indices);
    mesh.addSubMesh(0, indices.length, engine.MeshTopology.Triangles);
    mesh.uploadData(false);
    return mesh;
}

/** @internal */ var Utils = function Utils(engine$1) {
    this.radius = 9.2;
    this.endRadius = 1.6;
    this.axisLength = this.radius - 2 * this.endRadius;
    this.endDist = this.radius - this.endRadius;
    this.xRotateVector = new engine.Vector3();
    this.yRotateVector = new engine.Vector3();
    this.zRotateVector = new engine.Vector3();
    this.xTranslateVector = new engine.Vector3();
    this.yTranslateVector = new engine.Vector3();
    this.zTranslateVector = new engine.Vector3();
    this.xEndTranslateVector = new engine.Vector3();
    this.yEndTranslateVector = new engine.Vector3();
    this.zEndTranslateVector = new engine.Vector3();
    var redMaterial = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
    redMaterial.isTransparent = true;
    redMaterial.baseColor.set(1.0, 0.25, 0.25, 1.0);
    this.redMaterial = redMaterial;
    var greenMaterial = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
    greenMaterial.isTransparent = true;
    greenMaterial.baseColor.set(0.5, 0.8, 0.2, 1.0);
    this.greenMaterial = greenMaterial;
    var blueMaterial = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
    blueMaterial.isTransparent = true;
    blueMaterial.baseColor.set(0.3, 0.5, 1.0, 1.0);
    this.blueMaterial = blueMaterial;
    var bgMaterial = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
    bgMaterial.isTransparent = true;
    bgMaterial.baseColor.set(1, 1, 1, 0.1);
    this.bgMaterial = bgMaterial;
    var greyMaterial = new engineToolkitCustomMaterial.PlainColorMaterial(engine$1);
    greyMaterial.isTransparent = true;
    greyMaterial.baseColor.set(0.5, 0.5, 0.5, 1);
    this.greyMaterial = greyMaterial;
    this.axisMesh = engine.PrimitiveMesh.createCylinder(engine$1, 0.12, 0.12, this.axisLength);
    this.bgMesh = createCircleMesh(engine$1, this.radius, 144);
    this.endMesh = createCircleMesh(engine$1, this.endRadius - 0.2);
    this.xRotateVector = new engine.Vector3(0, 0, 90);
    this.yRotateVector = new engine.Vector3(0, 90, 0);
    this.zRotateVector = new engine.Vector3(90, 0, 0);
    this.xTranslateVector = new engine.Vector3(this.axisLength * 0.5, 0, 0);
    this.yTranslateVector = new engine.Vector3(0, this.axisLength * 0.5, 0);
    this.zTranslateVector = new engine.Vector3(0, 0, this.axisLength * 0.5);
    this.xEndTranslateVector = new engine.Vector3(this.endDist, 0, 0);
    this.yEndTranslateVector = new engine.Vector3(0, this.endDist, 0);
    this.zEndTranslateVector = new engine.Vector3(0, 0, this.endDist);
};

function traverseEntity(entity, callback) {
    callback(entity);
    for(var _iterator = _create_for_of_iterator_helper_loose(entity.children), _step; !(_step = _iterator()).done;){
        var child = _step.value;
        traverseEntity(child, callback);
    }
}
var NavigationGizmo = /*#__PURE__*/ function(Script) {
    _inherits(NavigationGizmo, Script);
    function NavigationGizmo(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this._gizmoLayer = engine.Layer.Layer30;
        _this._target = new engine.Vector3();
        _this._endScript = {
            X: EndScript,
            Y: EndScript,
            Z: EndScript,
            "-X": EndScript,
            "-Y": EndScript,
            "-Z": EndScript
        };
        /**
   * @position - gizmo position, the left upper point of the gizmo area, default (0, 0).
   * Normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
   */ _this.position = new engine.Vector2(0, 0);
        /**
   * @size gizmo size, the length and width of the gizmo area, default (0.12,0.12).
   */ _this.size = new engine.Vector2(0.12, 0.12);
        if (!entity.engine.physicsManager) {
            throw new Error("PhysicsManager is not initialized");
        }
        _this._utils = new Utils(_this.engine);
        _this._gizmoEntity = entity.createChild("navigation-gizmo");
        _this._gizmoEntity.layer = _this._gizmoLayer;
        var gizmoCameraEntity = _this._gizmoEntity.createChild("gizmo-camera");
        gizmoCameraEntity.transform.setPosition(0, 0, 10);
        var gizmoCamera = gizmoCameraEntity.addComponent(engine.Camera);
        gizmoCamera.isOrthographic = true;
        gizmoCamera.cullingMask = _this._gizmoLayer;
        gizmoCamera.clearFlags = engine.CameraClearFlags.Depth;
        gizmoCamera.priority = 100;
        _this._gizmoCamera = gizmoCamera;
        _this._createGizmo();
        _this._setTarget = _this._setTarget.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._target._onValueChanged = _this._setTarget;
        return _this;
    }
    var _proto = NavigationGizmo.prototype;
    _proto.onUpdate = function onUpdate() {
        this._gizmoCamera.viewport.set(this.position.x, this.position.y, this.size.x, this.size.y);
    };
    _proto._createGizmo = function _createGizmo() {
        var utils = this._utils;
        // setup gizmo shape
        var directionEntity = this._gizmoEntity.createChild("direction");
        var axisEntity = directionEntity.createChild("axis");
        // axis
        var axisXEntity = axisEntity.createChild("x");
        var axisYEntity = axisEntity.createChild("y");
        var axisZEntity = axisEntity.createChild("z");
        this._createAxis(axisXEntity, utils.xRotateVector, utils.xTranslateVector, utils.redMaterial);
        this._createAxis(axisYEntity, utils.yRotateVector, utils.yTranslateVector, utils.greenMaterial);
        this._createAxis(axisZEntity, utils.zRotateVector, utils.zTranslateVector, utils.blueMaterial);
        // end
        var endEntity = directionEntity.createChild("end");
        var endXEntity = endEntity.createChild("x");
        var endYEntity = endEntity.createChild("y");
        var endZEntity = endEntity.createChild("z");
        this._createEnd(endXEntity, utils.xEndTranslateVector, utils.redMaterial, "X", new engine.Color(1.0, 0.25, 0.25, 1.0));
        this._createEnd(endYEntity, utils.yEndTranslateVector, utils.greenMaterial, "Y", new engine.Color(0.5, 0.8, 0.2, 1.0));
        this._createEnd(endZEntity, utils.zEndTranslateVector, utils.blueMaterial, "Z", new engine.Color(0.3, 0.5, 1.0, 1.0));
        var endNegativeXEntity = endEntity.createChild("-x");
        var endNegativeYEntity = endEntity.createChild("-y");
        var endNegativeZEntity = endEntity.createChild("-z");
        this._createEnd(endNegativeXEntity, utils.xEndTranslateVector.negate(), utils.greyMaterial, "-X", new engine.Color(1, 1, 1, 0));
        this._createEnd(endNegativeYEntity, utils.yEndTranslateVector.negate(), utils.greyMaterial, "-Y", new engine.Color(1, 1, 1, 0));
        this._createEnd(endNegativeZEntity, utils.zEndTranslateVector.negate(), utils.greyMaterial, "-Z", new engine.Color(1, 1, 1, 0));
        // sphere behind
        var sphereEntity = this._gizmoEntity.createChild("sphere");
        sphereEntity.transform.setPosition(0, 0, -(utils.radius + 0.5));
        var sphereCollider = sphereEntity.addComponent(engine.StaticCollider);
        var sphereColliderShape = new engine.SphereColliderShape();
        sphereColliderShape.radius = utils.radius;
        sphereCollider.addShape(sphereColliderShape);
        var roundEntity = sphereEntity.createChild("round");
        var roundRenderer = roundEntity.addComponent(engine.MeshRenderer);
        roundRenderer.receiveShadows = false;
        roundRenderer.castShadows = false;
        roundRenderer.mesh = utils.bgMesh;
        roundRenderer.setMaterial(utils.bgMaterial);
        roundEntity.isActive = false;
        this._sphereScript = sphereEntity.addComponent(SphereScript);
    };
    _proto._createAxis = function _createAxis(entity, rotation, position, material) {
        entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
        entity.transform.setPosition(position.x, position.y, position.z);
        var axisXRenderer = entity.addComponent(engine.MeshRenderer);
        axisXRenderer.receiveShadows = false;
        axisXRenderer.castShadows = false;
        axisXRenderer.mesh = this._utils.axisMesh;
        axisXRenderer.setMaterial(material);
    };
    _proto._createEnd = function _createEnd(entity, position, material, axisName, fontColor) {
        var utils = this._utils;
        entity.transform.setPosition(position.x, position.y, position.z);
        var sphereCollider = entity.addComponent(engine.StaticCollider);
        var colliderShape = new engine.SphereColliderShape();
        colliderShape.radius = utils.endRadius;
        sphereCollider.addShape(colliderShape);
        var renderEntity = entity.createChild("back");
        var axisRenderer = renderEntity.addComponent(engine.MeshRenderer);
        axisRenderer.receiveShadows = false;
        axisRenderer.castShadows = false;
        axisRenderer.mesh = utils.endMesh;
        axisRenderer.setMaterial(material);
        renderEntity.isActive = false;
        var textEntity = entity.createChild("text");
        textEntity.transform.setPosition(0, 0, 0.05);
        var axisXTextRenderer = textEntity.addComponent(engine.TextRenderer);
        axisXTextRenderer.receiveShadows = false;
        axisXTextRenderer.castShadows = false;
        axisXTextRenderer.font = engine.Font.createFromOS(this.engine, "Arial");
        axisXTextRenderer.text = axisName;
        axisXTextRenderer.fontStyle = engine.FontStyle.Bold;
        axisXTextRenderer.fontSize = 200;
        axisXTextRenderer.color.copyFrom(fontColor);
        axisXTextRenderer.horizontalAlignment = engine.TextHorizontalAlignment.Center;
        this._endScript[axisName] = entity.addComponent(EndScript);
    };
    _proto._setTarget = function _setTarget() {
        var _this = this;
        this._sphereScript.target.copyFrom(this._target);
        Object.keys(this._endScript).forEach(function(key) {
            _this._endScript[key].target.copyFrom(_this._target);
        });
    };
    _create_class(NavigationGizmo, [
        {
            key: "camera",
            get: /** scene camera
   * @return current scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                var _this = this;
                var sceneCamera = this._sceneCamera;
                if (sceneCamera !== camera) {
                    if (camera) {
                        sceneCamera = this._sceneCamera = camera;
                        this._sphereScript.camera = camera;
                        Object.keys(this._endScript).forEach(function(key) {
                            _this._endScript[key].camera = camera;
                        });
                    } else {
                        throw new Error("navigation gizmo needs scene camera");
                    }
                }
            }
        },
        {
            key: "target",
            get: /**
   * target point for gizmo, default (0,0,0)
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                if (value !== this._target) {
                    this._target.copyFrom(value);
                }
            }
        },
        {
            key: "layer",
            get: /**
   * gizmo layer, default Layer30
   */ function get() {
                return this._gizmoLayer;
            },
            set: function set(layer) {
                if (this._gizmoLayer !== layer) {
                    this._gizmoLayer = layer;
                    this._gizmoCamera.cullingMask = layer;
                    traverseEntity(this._gizmoEntity, function(entity) {
                        entity.layer = layer;
                    });
                }
            }
        },
        {
            key: "priority",
            get: /**
   * @return gizmo camera's priority, larger than any other camera in scene, default 100
   */ function get() {
                return this._gizmoCamera.priority;
            },
            set: function set(priority) {
                this._gizmoCamera.priority = priority;
            }
        }
    ]);
    return NavigationGizmo;
}(engine.Script);

exports.NavigationGizmo = NavigationGizmo;
//# sourceMappingURL=browser.js.map
