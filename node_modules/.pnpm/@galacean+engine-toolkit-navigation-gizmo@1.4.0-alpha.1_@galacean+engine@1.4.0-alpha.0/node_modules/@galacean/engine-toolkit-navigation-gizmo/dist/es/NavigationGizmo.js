import { _ as _inherits, a as _create_class } from './_inherits-ae42bcd9.js';
import { Color, StaticCollider, SphereColliderShape, MeshRenderer, TextRenderer, Font, FontStyle, TextHorizontalAlignment, Layer, Vector3, Vector2, Camera, CameraClearFlags, Script } from '@galacean/engine';
import { EndScript } from './EndScript.js';
import { SphereScript } from './SphereScript.js';
import { Utils } from './Utils.js';
import './CircleMesh.js';
import '@galacean/engine-toolkit-custom-material';

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function traverseEntity(entity, callback) {
    callback(entity);
    for(var _iterator = _create_for_of_iterator_helper_loose(entity.children), _step; !(_step = _iterator()).done;){
        var child = _step.value;
        traverseEntity(child, callback);
    }
}
var NavigationGizmo = /*#__PURE__*/ function(Script) {
    _inherits(NavigationGizmo, Script);
    function NavigationGizmo(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this._gizmoLayer = Layer.Layer30;
        _this._target = new Vector3();
        _this._endScript = {
            X: EndScript,
            Y: EndScript,
            Z: EndScript,
            "-X": EndScript,
            "-Y": EndScript,
            "-Z": EndScript
        };
        /**
   * @position - gizmo position, the left upper point of the gizmo area, default (0, 0).
   * Normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
   */ _this.position = new Vector2(0, 0);
        /**
   * @size gizmo size, the length and width of the gizmo area, default (0.12,0.12).
   */ _this.size = new Vector2(0.12, 0.12);
        if (!entity.engine.physicsManager) {
            throw new Error("PhysicsManager is not initialized");
        }
        _this._utils = new Utils(_this.engine);
        _this._gizmoEntity = entity.createChild("navigation-gizmo");
        _this._gizmoEntity.layer = _this._gizmoLayer;
        var gizmoCameraEntity = _this._gizmoEntity.createChild("gizmo-camera");
        gizmoCameraEntity.transform.setPosition(0, 0, 10);
        var gizmoCamera = gizmoCameraEntity.addComponent(Camera);
        gizmoCamera.isOrthographic = true;
        gizmoCamera.cullingMask = _this._gizmoLayer;
        gizmoCamera.clearFlags = CameraClearFlags.Depth;
        gizmoCamera.priority = 100;
        _this._gizmoCamera = gizmoCamera;
        _this._createGizmo();
        _this._setTarget = _this._setTarget.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._target._onValueChanged = _this._setTarget;
        return _this;
    }
    var _proto = NavigationGizmo.prototype;
    _proto.onUpdate = function onUpdate() {
        this._gizmoCamera.viewport.set(this.position.x, this.position.y, this.size.x, this.size.y);
    };
    _proto._createGizmo = function _createGizmo() {
        var utils = this._utils;
        // setup gizmo shape
        var directionEntity = this._gizmoEntity.createChild("direction");
        var axisEntity = directionEntity.createChild("axis");
        // axis
        var axisXEntity = axisEntity.createChild("x");
        var axisYEntity = axisEntity.createChild("y");
        var axisZEntity = axisEntity.createChild("z");
        this._createAxis(axisXEntity, utils.xRotateVector, utils.xTranslateVector, utils.redMaterial);
        this._createAxis(axisYEntity, utils.yRotateVector, utils.yTranslateVector, utils.greenMaterial);
        this._createAxis(axisZEntity, utils.zRotateVector, utils.zTranslateVector, utils.blueMaterial);
        // end
        var endEntity = directionEntity.createChild("end");
        var endXEntity = endEntity.createChild("x");
        var endYEntity = endEntity.createChild("y");
        var endZEntity = endEntity.createChild("z");
        this._createEnd(endXEntity, utils.xEndTranslateVector, utils.redMaterial, "X", new Color(1.0, 0.25, 0.25, 1.0));
        this._createEnd(endYEntity, utils.yEndTranslateVector, utils.greenMaterial, "Y", new Color(0.5, 0.8, 0.2, 1.0));
        this._createEnd(endZEntity, utils.zEndTranslateVector, utils.blueMaterial, "Z", new Color(0.3, 0.5, 1.0, 1.0));
        var endNegativeXEntity = endEntity.createChild("-x");
        var endNegativeYEntity = endEntity.createChild("-y");
        var endNegativeZEntity = endEntity.createChild("-z");
        this._createEnd(endNegativeXEntity, utils.xEndTranslateVector.negate(), utils.greyMaterial, "-X", new Color(1, 1, 1, 0));
        this._createEnd(endNegativeYEntity, utils.yEndTranslateVector.negate(), utils.greyMaterial, "-Y", new Color(1, 1, 1, 0));
        this._createEnd(endNegativeZEntity, utils.zEndTranslateVector.negate(), utils.greyMaterial, "-Z", new Color(1, 1, 1, 0));
        // sphere behind
        var sphereEntity = this._gizmoEntity.createChild("sphere");
        sphereEntity.transform.setPosition(0, 0, -(utils.radius + 0.5));
        var sphereCollider = sphereEntity.addComponent(StaticCollider);
        var sphereColliderShape = new SphereColliderShape();
        sphereColliderShape.radius = utils.radius;
        sphereCollider.addShape(sphereColliderShape);
        var roundEntity = sphereEntity.createChild("round");
        var roundRenderer = roundEntity.addComponent(MeshRenderer);
        roundRenderer.receiveShadows = false;
        roundRenderer.castShadows = false;
        roundRenderer.mesh = utils.bgMesh;
        roundRenderer.setMaterial(utils.bgMaterial);
        roundEntity.isActive = false;
        this._sphereScript = sphereEntity.addComponent(SphereScript);
    };
    _proto._createAxis = function _createAxis(entity, rotation, position, material) {
        entity.transform.setRotation(rotation.x, rotation.y, rotation.z);
        entity.transform.setPosition(position.x, position.y, position.z);
        var axisXRenderer = entity.addComponent(MeshRenderer);
        axisXRenderer.receiveShadows = false;
        axisXRenderer.castShadows = false;
        axisXRenderer.mesh = this._utils.axisMesh;
        axisXRenderer.setMaterial(material);
    };
    _proto._createEnd = function _createEnd(entity, position, material, axisName, fontColor) {
        var utils = this._utils;
        entity.transform.setPosition(position.x, position.y, position.z);
        var sphereCollider = entity.addComponent(StaticCollider);
        var colliderShape = new SphereColliderShape();
        colliderShape.radius = utils.endRadius;
        sphereCollider.addShape(colliderShape);
        var renderEntity = entity.createChild("back");
        var axisRenderer = renderEntity.addComponent(MeshRenderer);
        axisRenderer.receiveShadows = false;
        axisRenderer.castShadows = false;
        axisRenderer.mesh = utils.endMesh;
        axisRenderer.setMaterial(material);
        renderEntity.isActive = false;
        var textEntity = entity.createChild("text");
        textEntity.transform.setPosition(0, 0, 0.05);
        var axisXTextRenderer = textEntity.addComponent(TextRenderer);
        axisXTextRenderer.receiveShadows = false;
        axisXTextRenderer.castShadows = false;
        axisXTextRenderer.font = Font.createFromOS(this.engine, "Arial");
        axisXTextRenderer.text = axisName;
        axisXTextRenderer.fontStyle = FontStyle.Bold;
        axisXTextRenderer.fontSize = 200;
        axisXTextRenderer.color.copyFrom(fontColor);
        axisXTextRenderer.horizontalAlignment = TextHorizontalAlignment.Center;
        this._endScript[axisName] = entity.addComponent(EndScript);
    };
    _proto._setTarget = function _setTarget() {
        var _this = this;
        this._sphereScript.target.copyFrom(this._target);
        Object.keys(this._endScript).forEach(function(key) {
            _this._endScript[key].target.copyFrom(_this._target);
        });
    };
    _create_class(NavigationGizmo, [
        {
            key: "camera",
            get: /** scene camera
   * @return current scene camera
   */ function get() {
                return this._sceneCamera;
            },
            set: function set(camera) {
                var _this = this;
                var sceneCamera = this._sceneCamera;
                if (sceneCamera !== camera) {
                    if (camera) {
                        sceneCamera = this._sceneCamera = camera;
                        this._sphereScript.camera = camera;
                        Object.keys(this._endScript).forEach(function(key) {
                            _this._endScript[key].camera = camera;
                        });
                    } else {
                        throw new Error("navigation gizmo needs scene camera");
                    }
                }
            }
        },
        {
            key: "target",
            get: /**
   * target point for gizmo, default (0,0,0)
   * @return target point
   */ function get() {
                return this._target;
            },
            set: function set(value) {
                if (value !== this._target) {
                    this._target.copyFrom(value);
                }
            }
        },
        {
            key: "layer",
            get: /**
   * gizmo layer, default Layer30
   */ function get() {
                return this._gizmoLayer;
            },
            set: function set(layer) {
                if (this._gizmoLayer !== layer) {
                    this._gizmoLayer = layer;
                    this._gizmoCamera.cullingMask = layer;
                    traverseEntity(this._gizmoEntity, function(entity) {
                        entity.layer = layer;
                    });
                }
            }
        },
        {
            key: "priority",
            get: /**
   * @return gizmo camera's priority, larger than any other camera in scene, default 100
   */ function get() {
                return this._gizmoCamera.priority;
            },
            set: function set(priority) {
                this._gizmoCamera.priority = priority;
            }
        }
    ]);
    return NavigationGizmo;
}(Script);

export { NavigationGizmo };
//# sourceMappingURL=NavigationGizmo.js.map
