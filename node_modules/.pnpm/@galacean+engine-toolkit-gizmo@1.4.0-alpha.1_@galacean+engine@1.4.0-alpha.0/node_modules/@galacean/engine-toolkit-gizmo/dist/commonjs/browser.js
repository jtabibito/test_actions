'use strict';

var engine = require('@galacean/engine');
var engineToolkitCustomMaterial = require('@galacean/engine-toolkit-custom-material');
var engineToolkitFramebufferPicker = require('@galacean/engine-toolkit-framebuffer-picker');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Axis = /*#__PURE__*/ function(Component) {
    _inherits(Axis, Component);
    function Axis(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        _this._color = new engine.Color();
        _this._highLightColor = new engine.Color();
        _this._yellowColor = new engine.Color(1.0, 0.95, 0.0, 1.0);
        _this._grayColor = new engine.Color(0.75, 0.75, 0.75, 0.6);
        return _this;
    }
    var _proto = Axis.prototype;
    /** setup axis geometry */ _proto.initAxis = function initAxis(value) {
        this._material = value.axisMaterial;
        this._color.copyFrom(value.axisMaterial.baseColor);
        this._highLightColor.copyFrom(this._color);
        this._highLightColor.r = this._highLightColor.r + 0.3;
        this._highLightColor.g = this._highLightColor.g + 0.3;
        this._highLightColor.b = this._highLightColor.b + 0.3;
        this._highLightColor.a = this._highLightColor.a + 0.1;
        // setup visible axis
        for(var i = 0; i < value.axisMesh.length; i++){
            var axisEntity = this.entity.createChild(value.name);
            axisEntity.transform.rotate(value.axisRotation[i]);
            axisEntity.transform.translate(value.axisTranslation[i], false);
            var axisRenderer = axisEntity.addComponent(engine.MeshRenderer);
            axisRenderer.receiveShadows = false;
            axisRenderer.castShadows = false;
            axisRenderer.priority = value.priority ? value.priority : 100;
            axisRenderer.mesh = value.axisMesh[i];
            axisRenderer.setMaterial(this._material);
        }
        // setup invisible axis
        var gizmoHelperEntity = this.entity.parent.parent.findByName("invisible");
        for(var i1 = 0; i1 < value.axisHelperMesh.length; i1++){
            var temp = gizmoHelperEntity.createChild(value.name);
            var axisHelperEntity = temp.createChild(value.name);
            axisHelperEntity.transform.rotate(value.axisRotation[i1]);
            axisHelperEntity.transform.translate(value.axisTranslation[i1], false);
            var axisHelperRenderer = axisHelperEntity.addComponent(engine.MeshRenderer);
            axisHelperRenderer.receiveShadows = false;
            axisHelperRenderer.castShadows = false;
            axisHelperRenderer.priority = value.priority ? value.priority : 100;
            axisHelperRenderer.mesh = value.axisHelperMesh[i1];
            axisHelperRenderer.setMaterial(value.axisHelperMaterial);
        }
    };
    /** highlight axis */ _proto.highLight = function highLight() {
        this._material.baseColor.copyFrom(this._highLightColor);
    };
    /** unhighligh axis */ _proto.unLight = function unLight() {
        this._material.baseColor.copyFrom(this._color);
    };
    /** change axis color into yellow */ _proto.yellow = function yellow() {
        this._material.baseColor.copyFrom(this._yellowColor);
    };
    /** change axis color into gray */ _proto.gray = function gray() {
        this._material.baseColor.copyFrom(this._grayColor);
    };
    /** recover axis color */ _proto.recover = function recover() {
        this._material.baseColor.copyFrom(this._color);
    };
    /** change axis alpha */ _proto.alpha = function alpha(v) {
        this._material.baseColor.a = v;
    };
    return Axis;
}(engine.Component);

/**
 * Gizmo State
 */ exports.State = void 0;
(function(State) {
    /**
   * translate state
   */ State[State["translate"] = 1] = "translate";
    /**
   * rotate state
   */ State[State["rotate"] = 2] = "rotate";
    /**
   * scale state
   */ State[State["scale"] = 4] = "scale";
    /**
   * all state
   */ State[State["all"] = 15] = "all";
})(exports.State || (exports.State = {}));

/**
 * @internal
 */ var GizmoMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GizmoMeshRestorer, ContentRestorer);
    function GizmoMeshRestorer(resource, primitiveInfo) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.primitiveInfo = primitiveInfo;
        return _this;
    }
    var _proto = GizmoMeshRestorer.prototype;
    /**
   * @override
   */ _proto.restoreContent = function restoreContent() {
        var primitiveInfo = this.primitiveInfo;
        switch(primitiveInfo.type){
            case 0:
                var circleInfo = primitiveInfo;
                GizmoMesh.updateCircle(this.resource, circleInfo.startPoint, circleInfo.normal, circleInfo.thetaLength, circleInfo.center);
                break;
            case 2:
                var tubeInfo = primitiveInfo;
                GizmoMesh.updateCircleTube(this.resource, tubeInfo.arc, tubeInfo.radius, tubeInfo.tubeRadius, tubeInfo.tubularSegments, tubeInfo.radialSegments);
                break;
            case 1:
                var lineInfo = primitiveInfo;
                GizmoMesh.updateLine(this.resource, lineInfo.points);
                break;
        }
    };
    return GizmoMeshRestorer;
}(engine.ContentRestorer);
var GizmoMeshType;
(function(GizmoMeshType) {
    GizmoMeshType[GizmoMeshType["Circle"] = 0] = "Circle";
    GizmoMeshType[GizmoMeshType["Line"] = 1] = "Line";
    GizmoMeshType[GizmoMeshType["CircleTube"] = 2] = "CircleTube";
})(GizmoMeshType || (GizmoMeshType = {}));
/**
 * @internal
 */ var GizmoMeshRestoreInfo = function GizmoMeshRestoreInfo(type) {
    this.type = type;
};
/**
 * @internal
 */ var CircleRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(CircleRestoreInfo, GizmoMeshRestoreInfo);
    function CircleRestoreInfo(startPoint, normal, thetaLength, center) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 0) || this;
        _this.startPoint = startPoint;
        _this.normal = normal;
        _this.thetaLength = thetaLength;
        _this.center = center;
        return _this;
    }
    return CircleRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var CircleTubeRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(CircleTubeRestoreInfo, GizmoMeshRestoreInfo);
    function CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 2) || this;
        _this.arc = arc;
        _this.radius = radius;
        _this.tubeRadius = tubeRadius;
        _this.tubularSegments = tubularSegments;
        _this.radialSegments = radialSegments;
        return _this;
    }
    return CircleTubeRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var LineRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(LineRestoreInfo, GizmoMeshRestoreInfo);
    function LineRestoreInfo(points) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 1) || this;
        _this.points = points;
        return _this;
    }
    return LineRestoreInfo;
}(GizmoMeshRestoreInfo);

var GizmoMesh = /*#__PURE__*/ function() {
    function GizmoMesh() {}
    GizmoMesh.createCircle = function createCircle(engine$1, center, normal, startPoint, thetaLength) {
        if (center === void 0) center = new engine.Vector3();
        if (normal === void 0) normal = new engine.Vector3(0, 0, 1);
        if (startPoint === void 0) startPoint = new engine.Vector3(1.6, 0, 0);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        var mesh = new engine.ModelMesh(engine$1);
        GizmoMesh.updateCircle(mesh, startPoint, normal, thetaLength, center);
        engine$1.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleRestoreInfo(startPoint, normal, thetaLength, center)));
        return mesh;
    };
    GizmoMesh.updateCircle = function updateCircle(mesh, startPoint, normal, thetaLength, center, /**
     * segments per half Pi
     */ segmentFactor) {
        if (startPoint === void 0) startPoint = new engine.Vector3(1.6, 0, 0);
        if (normal === void 0) normal = new engine.Vector3(0, 0, 1);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        if (center === void 0) center = new engine.Vector3();
        if (segmentFactor === void 0) segmentFactor = 16;
        var newSegments = Math.abs(Math.ceil(segmentFactor * thetaLength / Math.PI));
        var segments = Math.max(6, newSegments);
        var indices = new Uint16Array(segments * 3);
        var vertices = [];
        // indices
        for(var i = 1; i <= segments; i++){
            var start = (i - 1) * 3;
            indices[start] = i;
            indices[start + 1] = i + 1;
            indices[start + 2] = 0;
        }
        // vertices
        vertices.push(center);
        for(var s = 0; s <= segments; s++){
            var segment = s / segments * thetaLength;
            engine.Quaternion.rotationAxisAngle(normal, segment, GizmoMesh._tempQuat);
            engine.Vector3.transformByQuat(startPoint, GizmoMesh._tempQuat, GizmoMesh._tempVect);
            vertices[s + 1] = GizmoMesh._tempVect.clone();
        }
        GizmoMesh._initialize(mesh, vertices, indices, engine.MeshTopology.Triangles);
    };
    GizmoMesh.createCircleTube = function createCircleTube(engine$1, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var mesh = new engine.ModelMesh(engine$1);
        GizmoMesh.updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments);
        engine$1.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments)));
        return mesh;
    };
    GizmoMesh.updateCircleTube = function updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = new Uint16Array(rectangleCount * 6);
        var vertices = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        var offset = 0;
        for(var i = 0; i <= radialSegments; i++){
            for(var j = 0; j <= tubularSegments; j++){
                var u = j / tubularSegments * arc;
                var v = i / radialSegments * Math.PI * 2;
                var cosV = Math.cos(v);
                var sinV = Math.sin(v);
                var cosU = Math.cos(u);
                var sinU = Math.sin(u);
                var position = new engine.Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
                vertices[offset] = position;
                var centerX = radius * cosU;
                var centerY = radius * sinU;
                normals[offset] = new engine.Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
                uvs[offset++] = new engine.Vector2(j / tubularSegments, i / radialSegments);
            }
        }
        offset = 0;
        for(var i1 = 1; i1 <= radialSegments; i1++){
            for(var j1 = 1; j1 <= tubularSegments; j1++){
                var a = (tubularSegments + 1) * i1 + j1 - 1;
                var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
                var c = (tubularSegments + 1) * (i1 - 1) + j1;
                var d = (tubularSegments + 1) * i1 + j1;
                indices[offset++] = a;
                indices[offset++] = b;
                indices[offset++] = d;
                indices[offset++] = b;
                indices[offset++] = c;
                indices[offset++] = d;
            }
        }
        var bounds = mesh.bounds;
        var outerRadius = radius + tubeRadius;
        bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
        bounds.max.set(outerRadius, outerRadius, tubeRadius);
        GizmoMesh._initialize(mesh, vertices, indices, engine.MeshTopology.Triangles, normals, uvs);
    };
    GizmoMesh.createLine = function createLine(engine$1, points) {
        var mesh = new engine.ModelMesh(engine$1);
        GizmoMesh.updateLine(mesh, points);
        engine$1.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new LineRestoreInfo(points)));
        return mesh;
    };
    GizmoMesh.updateLine = function updateLine(mesh, points) {
        var vertices = points;
        var indices = new Uint8Array(vertices.length);
        for(var i = 0; i < vertices.length; i++){
            indices[i] = i;
        }
        GizmoMesh._initialize(mesh, vertices, indices, engine.MeshTopology.Lines);
    };
    GizmoMesh._initialize = function _initialize(mesh, vertices, indices, meshTopology, normals, uvs) {
        mesh.setPositions(vertices);
        mesh.setIndices(indices);
        normals && mesh.setNormals(normals);
        uvs && mesh.setUVs(uvs);
        mesh.clearSubMesh();
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length, meshTopology);
    };
    return GizmoMesh;
}();
GizmoMesh._tempQuat = new engine.Quaternion();
GizmoMesh._tempVect = new engine.Vector3();

var Utils = /*#__PURE__*/ function() {
    function Utils() {}
    Utils.init = function init(engine$1) {
        // translate material
        Utils.redMaterialTrans = this._createPlainColorMaterial(engine$1, exports.State.translate, 1.0, 0.25, 0.25, 1.0);
        Utils.lightRedMaterial = this._createPlainColorMaterial(engine$1, exports.State.translate, 1.0, 0.25, 0.25, 0.9);
        Utils.greenMaterialTrans = this._createPlainColorMaterial(engine$1, exports.State.translate, 0.5, 0.8, 0.2, 1.0);
        Utils.lightGreenMaterial = this._createPlainColorMaterial(engine$1, exports.State.translate, 0.5, 0.8, 0.2, 0.9);
        Utils.blueMaterialTrans = this._createPlainColorMaterial(engine$1, exports.State.translate, 0.3, 0.5, 1.0, 1.0);
        Utils.lightBlueMaterial = this._createPlainColorMaterial(engine$1, exports.State.translate, 0.3, 0.5, 1.0, 0.9);
        Utils.invisibleMaterialTrans = this._createPlainColorMaterial(engine$1, exports.State.translate, 0, 0, 0, 0);
        // rotate material
        Utils.redArcMaterial = this._createPlainColorMaterial(engine$1, exports.State.rotate, 1.0, 0.25, 0.25);
        Utils.greenArcMaterial = this._createPlainColorMaterial(engine$1, exports.State.rotate, 0.5, 0.8, 0.2);
        Utils.blueArcMaterial = this._createPlainColorMaterial(engine$1, exports.State.rotate, 0.3, 0.5, 1.0);
        Utils.yellowMaterial = this._createPlainColorMaterial(engine$1, exports.State.rotate, 1.0, 0.95, 0.0, 1.0);
        Utils.rotatePlaneMaterial = this._createPlainColorMaterial(engine$1, exports.State.rotate, 1.0, 0.95, 0.0, 0.2);
        Utils.rotatePlaneMaterial.renderState.rasterState.cullMode = engine.CullMode.Off;
        Utils.invisibleMaterialRotate = this._createPlainColorMaterial(engine$1, exports.State.rotate, 0, 0, 0, 0);
        Utils.invisibleMaterialRotate.renderState.rasterState.cullMode = engine.CullMode.Off;
        Utils.invisibleMaterialCircle = this._createPlainColorMaterial(engine$1, exports.State.rotate, 0, 0, 0, 0);
        // scale material
        Utils.redMaterialScale = this._createPlainColorMaterial(engine$1, exports.State.scale, 1.0, 0.25, 0.25, 1.0);
        Utils.greenMaterialScale = this._createPlainColorMaterial(engine$1, exports.State.scale, 0.5, 0.8, 0.2, 1.0);
        Utils.blueMaterialScale = this._createPlainColorMaterial(engine$1, exports.State.scale, 0.3, 0.5, 1.0, 1.0);
        Utils.greyMaterial = this._createPlainColorMaterial(engine$1, exports.State.scale, 0.75, 0.75, 0.75, 1.0);
        Utils.lightMaterial = this._createPlainColorMaterial(engine$1, exports.State.scale, 0.7, 0.7, 0.7, 1.0);
        Utils.invisibleMaterialScale = this._createPlainColorMaterial(engine$1, exports.State.scale, 0, 0, 0, 0);
        Utils.lineMesh = engine.PrimitiveMesh.createCylinder(engine$1, 0.02, 0.02, 1.5);
        Utils.lineMeshShort = engine.PrimitiveMesh.createCylinder(engine$1, 0.02, 0.02, 1.3);
        Utils.axisArrowMesh = engine.PrimitiveMesh.createCone(engine$1, 0.08, 0.3);
        Utils.axisPlaneMesh = engine.PrimitiveMesh.createPlane(engine$1, 0.35, 0.35);
        Utils.axisCubeMesh = engine.PrimitiveMesh.createCuboid(engine$1, 0.32, 0.32, 0.32);
        Utils.axisSphereMesh = engine.PrimitiveMesh.createSphere(engine$1, 1.8, 48);
        Utils.axisEndCubeMesh = engine.PrimitiveMesh.createCuboid(engine$1, 0.25, 0.25, 0.25);
        Utils.axisXTorusMesh = GizmoMesh.createCircleTube(engine$1, Math.PI, 1.6, 0.02);
        Utils.axisYTorusMesh = GizmoMesh.createCircleTube(engine$1, Math.PI, 1.6, 0.02);
        Utils.axisZTorusMesh = GizmoMesh.createCircleTube(engine$1, Math.PI, 1.6, 0.02);
        Utils.axisXYZTorusMesh = GizmoMesh.createCircleTube(engine$1, 2 * Math.PI, 1.8, 0.02);
        Utils.axisHelperLineMesh = engine.PrimitiveMesh.createCylinder(engine$1, 0.15, 0.15, 1.75);
        Utils.axisHelperPlaneMesh = engine.PrimitiveMesh.createPlane(engine$1, 0.75, 0.75);
        Utils.axisHelpertorusMesh = GizmoMesh.createCircleTube(engine$1, Math.PI, 1.6, 0.24);
        Utils.xAxisPositive = new engine.Vector3(-1, 0, 0);
        Utils.yAxisPositive = new engine.Vector3(0, -1, 0);
        Utils.zAxisPositive = new engine.Vector3(0, 0, -1);
    };
    Utils._createPlainColorMaterial = function _createPlainColorMaterial(engine, name, r, g, b, a) {
        if (r === void 0) r = 1.0;
        if (g === void 0) g = 1.0;
        if (b === void 0) b = 1.0;
        if (a === void 0) a = 1.0;
        var material = new engineToolkitCustomMaterial.PlainColorMaterial(engine);
        material.isTransparent = true;
        material.renderState.depthState.enabled = false;
        material.baseColor.set(r, g, b, a);
        material.name = name.toString();
        return material;
    };
    return Utils;
}();
Utils.rotateCircleRadius = 1.6;
Utils.scaleFactor = 0.05773502691896257;

/**
 * @internal
 * Gizmo Component
 */ var GizmoComponent = /*#__PURE__*/ function(Component) {
    _inherits(GizmoComponent, Component);
    function GizmoComponent() {
        return Component.apply(this, arguments);
    }
    return GizmoComponent;
}(engine.Component);
var axisType;
(function(axisType) {
    axisType[axisType["x"] = 0] = "x";
    axisType[axisType["y"] = 1] = "y";
    axisType[axisType["z"] = 2] = "z";
    axisType[axisType["xyz"] = 3] = "xyz";
    axisType[axisType["xy"] = 4] = "xy";
    axisType[axisType["yz"] = 5] = "yz";
    axisType[axisType["xz"] = 6] = "xz";
})(axisType || (axisType = {}));
var axisVector = [
    new engine.Vector3(1, 0, 0),
    new engine.Vector3(0, 1, 0),
    new engine.Vector3(0, 0, 1),
    new engine.Vector3(1, 1, 1),
    new engine.Vector3(1, 1, 0),
    new engine.Vector3(0, 1, 1),
    new engine.Vector3(1, 0, 1)
];
var axisPlane = [
    new engine.Plane(new engine.Vector3(1, 0, 0), 0),
    new engine.Plane(new engine.Vector3(0, 1, 0), 0),
    new engine.Plane(new engine.Vector3(0, 0, 1), 0),
    new engine.Plane(new engine.Vector3(0, 0, 0), 0),
    new engine.Plane(new engine.Vector3(0, 0, 1), 0),
    new engine.Plane(new engine.Vector3(1, 0, 0), 0),
    new engine.Plane(new engine.Vector3(0, 1, 0), 0)
];

/** @internal */ var ScaleControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(ScaleControl, GizmoComponent);
    function ScaleControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scaleFactor = 1;
        _this._scaleAxisComponent = [];
        _this._scaleControlMap = [];
        _this._preMatrix = new engine.Matrix();
        _this._startGroupMatrix = new engine.Matrix();
        _this._startInvMatrix = new engine.Matrix();
        _this._startPoint = new engine.Vector3();
        _this._factorVec = new engine.Vector3();
        _this._currPoint = new engine.Vector3();
        _this._plane = new engine.Plane();
        _this._tempVec0 = new engine.Vector3();
        _this._tempVec1 = new engine.Vector3();
        _this._tempVec2 = new engine.Vector3();
        _this._tempMat = new engine.Matrix();
        _this.type = exports.State.scale;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = ScaleControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        engine.Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        var _this = this, _startPoint = _this._startPoint, _scaleFactor = _this._scaleFactor;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        var localAxis = axisVector[this._selectedAxis];
        this._factorVec.set(_startPoint.x === 0 ? 0 : _scaleFactor * localAxis.x / _startPoint.x, _startPoint.y === 0 ? 0 : _scaleFactor * localAxis.y / _startPoint.y, _startPoint.z === 0 ? 0 : _scaleFactor * localAxis.z / _startPoint.z);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var _this = this, factorVec = _this._factorVec, scaleVec = _this._tempVec0, mat = _this._tempMat;
        engine.Vector3.subtract(this._currPoint, this._startPoint, scaleVec);
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                scaleVec.x = scaleVec.x * factorVec.x + 1;
                scaleVec.y = scaleVec.y * factorVec.y + 1;
                scaleVec.z = scaleVec.z * factorVec.z + 1;
                break;
            case axisType.xyz:
                var start = this._startPoint.length();
                var end = this._currPoint.length();
                scaleVec.x = end / start;
                scaleVec.y = end / start;
                scaleVec.z = end / start;
                break;
        }
        engine.Matrix.scale(this._startGroupMatrix, scaleVec, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "scale");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    _proto._initAxis = function _initAxis() {
        this._scaleControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.redMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new engine.Vector3(0, 0, -90),
                    new engine.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new engine.Vector3(0.75, 0, 0),
                    new engine.Vector3(1.5, 0, 0)
                ],
                priority: 102
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.greenMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new engine.Vector3(0, 90, 0),
                    new engine.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0.75, 0),
                    new engine.Vector3(0, 1.5, 0)
                ],
                priority: 102
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.blueMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new engine.Vector3(0, 90, 90),
                    new engine.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0.75),
                    new engine.Vector3(0, 0, 1.5)
                ],
                priority: 102
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisCubeMesh
                ],
                axisMaterial: Utils.greyMaterial,
                axisHelperMesh: [
                    Utils.axisCubeMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new engine.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0)
                ],
                priority: 105
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXYZ = this.gizmoEntity.createChild("xyz");
        this._scaleAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._scaleControlMap.length; i++){
            var currentComponent = this._scaleAxisComponent[i];
            var currentGeometry = this._scaleControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
            case axisType.xyz:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                engine.Vector3.cross(cameraP, localAxis, crossP);
                engine.Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        engine.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        engine.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        var _this = this, _tempVec0 = _this._tempVec0, _tempMat = _this._tempMat;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            var s = isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.75 : this._camera.orthographicSize * Utils.scaleFactor * 3;
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(s, s, s));
        } else {
            var ele = _tempMat.elements;
            _tempVec0.set(ele[12], ele[13], ele[14]);
            var s1 = isModified ? engine.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor * 0.75 : engine.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
            var sx = s1 / Math.sqrt(Math.pow(ele[0], 2) + Math.pow(ele[1], 2) + Math.pow(ele[2], 2));
            var sy = s1 / Math.sqrt(Math.pow(ele[4], 2) + Math.pow(ele[5], 2) + Math.pow(ele[6], 2));
            var sz = s1 / Math.sqrt(Math.pow(ele[8], 2) + Math.pow(ele[9], 2) + Math.pow(ele[10], 2));
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(sx, sy, sz));
        }
    };
    return ScaleControl;
}(GizmoComponent);

/** @internal */ var TranslateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(TranslateControl, GizmoComponent);
    function TranslateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scale = 1;
        _this._preMatrix = new engine.Matrix();
        _this._startGroupMatrix = new engine.Matrix();
        _this._startInvMatrix = new engine.Matrix();
        _this._startScale = 1;
        _this._startPoint = new engine.Vector3();
        _this._currPoint = new engine.Vector3();
        _this._plane = new engine.Plane();
        _this._tempVec0 = new engine.Vector3();
        _this._tempVec1 = new engine.Vector3();
        _this._tempVec2 = new engine.Vector3();
        _this._tempMat = new engine.Matrix();
        _this._tempScale = 1;
        _this.type = exports.State.translate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = TranslateControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        engine.Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        // get start scale
        this._startScale = this._scale;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var currScale = this._scale;
        var _this = this, mat = _this._tempMat, subVec = _this._tempVec0, _startScale = _this._startScale;
        // eliminate the side effect of gizmo's scaling
        subVec.x = this._currPoint.x - this._startPoint.x / _startScale * currScale;
        subVec.y = this._currPoint.y - this._startPoint.y / _startScale * currScale;
        subVec.z = this._currPoint.z - this._startPoint.z / _startScale * currScale;
        var localAxis = axisVector[this._selectedAxis];
        mat.identity();
        mat.elements[12] = subVec.x * localAxis.x;
        mat.elements[13] = subVec.y * localAxis.y;
        mat.elements[14] = subVec.z * localAxis.z;
        engine.Matrix.multiply(this._startGroupMatrix, mat, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "translate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        // recover axis cover
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch() {
        this._resizeControl();
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        switch(axisName){
            case "x":
                this._changeAxisAlpha("x", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "y":
                this._changeAxisAlpha("y", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "z":
                this._changeAxisAlpha("z", value);
                this._changeAxisAlpha("xz", value);
                this._changeAxisAlpha("yz", value);
                break;
        }
    };
    _proto._initAxis = function _initAxis() {
        this._translateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.redMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(0, 0, -90),
                    new engine.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new engine.Vector3(0.75, 0, 0),
                    new engine.Vector3(1.5, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.greenMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(0, 90, 0),
                    new engine.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0.75, 0),
                    new engine.Vector3(0, 1.5, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.blueMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(0, 90, 90),
                    new engine.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0.75),
                    new engine.Vector3(0, 0, 1.5)
                ]
            },
            {
                name: "xy",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightBlueMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new engine.Vector3(0.5, 0.5, 0)
                ]
            },
            {
                name: "yz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightRedMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(90, 90, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0.5, 0.5)
                ]
            },
            {
                name: "xz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightGreenMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new engine.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0.5, 0, 0.5)
                ]
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXY = this.gizmoEntity.createChild("xy");
        var axisYZ = this.gizmoEntity.createChild("yz");
        var axisXZ = this.gizmoEntity.createChild("xz");
        this._translateAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXY.addComponent(Axis),
            axisYZ.addComponent(Axis),
            axisXZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._translateControlMap.length; i++){
            var currentComponent = this._translateAxisComponent[i];
            var currentGeometry = this._translateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                engine.Vector3.cross(cameraP, localAxis, crossP);
                engine.Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
            case axisType.xy:
            case axisType.yz:
            case axisType.xz:
                this._plane.copyFrom(axisPlane[this._selectedAxis]);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        engine.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        engine.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        var _this = this, _tempMat = _this._tempMat, _tempVec0 = _this._tempVec0;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            this._tempScale = this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            _tempVec0.set(_tempMat.elements[12], _tempMat.elements[13], _tempMat.elements[14]);
            this._tempScale = this._scale = engine.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
        }
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = _tempMat.scale(_tempVec0.set(this._tempScale, this._tempScale, this._tempScale));
    };
    _proto._changeAxisAlpha = function _changeAxisAlpha(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    return TranslateControl;
}(GizmoComponent);

/** @internal */ var RotateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(RotateControl, GizmoComponent);
    function RotateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._rotateAxisComponent = [];
        _this._rotateControlMap = [];
        _this._isModified = false;
        _this._startLineMesh = GizmoMesh.createLine(_this.engine, [
            new engine.Vector3(0, 0, 0),
            new engine.Vector3(0, 0, 0)
        ]);
        _this._endLineMesh = GizmoMesh.createLine(_this.engine, [
            new engine.Vector3(0, 0, 0),
            new engine.Vector3(0, 0, 0)
        ]);
        _this._rotateHelperPlaneMesh = GizmoMesh.createCircle(_this.engine);
        _this._preMatrix = new engine.Matrix();
        _this._startMatrix = new engine.Matrix();
        _this._startInvMatrix = new engine.Matrix();
        _this._startPointUnit = new engine.Vector3();
        _this._currPointUnit = new engine.Vector3();
        _this._cameraPos = new engine.Vector3();
        _this._previousRad = 0;
        _this._finalRad = 0;
        _this._verticalAxis = new engine.Vector3(0, 1, 0);
        _this._horizontalAxis = new engine.Vector3();
        _this._speedFactor = 0.01;
        _this._tempMat = new engine.Matrix();
        _this._tempMat2 = new engine.Matrix();
        _this._tempVec = new engine.Vector3();
        _this._tempVec2 = new engine.Vector3();
        _this._tempVec30 = new engine.Vector3();
        _this._tempVec31 = new engine.Vector3();
        _this._tempVec32 = new engine.Vector3();
        _this._tempMat41 = new engine.Matrix();
        _this._isAtBack = false;
        _this.type = exports.State.rotate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = RotateControl.prototype;
    /** init axis geometry */ _proto._initAxis = function _initAxis() {
        this._rotateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.axisXTorusMesh
                ],
                axisMaterial: Utils.redArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new engine.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.axisYTorusMesh
                ],
                axisMaterial: Utils.greenArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new engine.Vector3(90, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.axisZTorusMesh
                ],
                axisMaterial: Utils.blueArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new engine.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0)
                ]
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisXYZTorusMesh
                ],
                axisMaterial: Utils.lightMaterial,
                axisHelperMesh: [
                    Utils.axisSphereMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialCircle,
                axisRotation: [
                    new engine.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new engine.Vector3(0, 0, 0)
                ],
                priority: 99
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        // visible gizmo entity
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        this._axisX = this.gizmoEntity.createChild("x");
        this._axisY = this.gizmoEntity.createChild("y");
        this._axisZ = this.gizmoEntity.createChild("z");
        this._axisXYZ = this.gizmoEntity.createChild("xyz");
        this._rotateAxisComponent = [
            this._axisX.addComponent(Axis),
            this._axisY.addComponent(Axis),
            this._axisZ.addComponent(Axis),
            this._axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._rotateControlMap.length; i++){
            var currentComponent = this._rotateAxisComponent[i];
            var currentGeometry = this._rotateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
        var axisHelpers = this.gizmoHelperEntity.children;
        this._axisXHelper = axisHelpers[0];
        this._axisYHelper = axisHelpers[1];
        this._axisZHelper = axisHelpers[2];
        this._axisXYZHelper = axisHelpers[3];
        // rotate gizmo in-process debug helper entity
        this._gizmoRotateHelperEntity = entity.createChild("helper");
        // rotate start line
        this._startLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperS");
        var startHelperRenderer = this._startLineHelperEntity.addComponent(engine.MeshRenderer);
        startHelperRenderer.receiveShadows = false;
        startHelperRenderer.castShadows = false;
        startHelperRenderer.mesh = this._startLineMesh;
        startHelperRenderer.setMaterial(Utils.yellowMaterial);
        startHelperRenderer.priority = 90;
        // rotate end line
        this._endLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperE");
        var endHelperRenderer = this._endLineHelperEntity.addComponent(engine.MeshRenderer);
        endHelperRenderer.receiveShadows = false;
        endHelperRenderer.castShadows = false;
        endHelperRenderer.mesh = this._endLineMesh;
        endHelperRenderer.setMaterial(Utils.yellowMaterial);
        endHelperRenderer.priority = 90;
        // rotate plane
        this._rotateHelperPlaneEntity = this._gizmoRotateHelperEntity.createChild("rotateHelperPlane");
        var planeHelperRenderer = this._rotateHelperPlaneEntity.addComponent(engine.MeshRenderer);
        planeHelperRenderer.receiveShadows = false;
        planeHelperRenderer.castShadows = false;
        planeHelperRenderer.mesh = this._rotateHelperPlaneMesh;
        // @ts-ignore
        this._rotateHelperPlaneMesh._enableVAO = false;
        planeHelperRenderer.setMaterial(Utils.rotatePlaneMaterial);
        planeHelperRenderer.priority = 90;
        this._rotateHelperPlaneEntity.isActive = false;
    };
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        var _this = this, group = _this._group, startP = _this._startPointUnit, startMat = _this._startMatrix, tempVec = _this._tempVec, tempMat = _this._tempMat;
        group.getWorldMatrix(startMat);
        this._preMatrix.copyFrom(startMat);
        engine.Matrix.invert(startMat, this._startInvMatrix);
        var s = this._getGizmoScale();
        this._tempMat.copyFrom(startMat).scale(tempVec.set(s, s, s));
        this.gizmoEntity.transform.worldMatrix = tempMat;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._gizmoRotateHelperEntity.transform.worldMatrix = tempMat;
                this._calRayIntersection(ray, startP);
                this._setAxisSelected(this._selectedAxis, true);
                GizmoMesh.updateLine(this._startLineMesh, [
                    new engine.Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateLine(this._endLineMesh, [
                    new engine.Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, axisVector[axisName], 0);
                this._startLineHelperEntity.isActive = true;
                this._endLineHelperEntity.isActive = true;
                this._rotateHelperPlaneEntity.isActive = true;
                this._startLineHelperEntity.transform.setRotation(0, 0, 0);
                this._endLineHelperEntity.transform.setRotation(0, 0, 0);
                this._rotateHelperPlaneEntity.transform.setRotation(0, 0, 0);
                break;
            case axisType.xyz:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._setAxisSelected(this._selectedAxis, true);
                this._isAtBack = this.gizmoEntity.transform.worldUp.y < 0;
                this._isAtBack ? this._verticalAxis.set(0, -1, 0) : this._verticalAxis.set(0, 1, 0);
                break;
        }
    };
    _proto.onMove = function onMove(ray, pointer) {
        var _this = this, startP = _this._startPointUnit, currP = _this._currPointUnit, startMat = _this._startMatrix, mat = _this._tempMat2, group = _this._group, tempVec = _this._tempVec;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var localAxis = axisVector[this._selectedAxis];
                this._calRayIntersection(ray, currP);
                var rad = this._getFinalRad(startP, currP, localAxis);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, localAxis, rad);
                engine.Matrix.rotateAxisAngle(startMat, localAxis, rad, mat);
                group.applyTransform(this._preMatrix, mat);
                this._preMatrix.copyFrom(mat);
                var d = rad / Math.PI * 180;
                this._endLineHelperEntity.transform.setRotation(d * localAxis.x, d * localAxis.y, d * localAxis.z);
                break;
            case axisType.xyz:
                var _pointer_deltaPosition = pointer.deltaPosition, x = _pointer_deltaPosition.x, y = _pointer_deltaPosition.y;
                var _this1 = this, hAxis = _this1._horizontalAxis, vAxis = _this1._verticalAxis;
                hAxis.copyFrom(this._camera.entity.transform.worldUp);
                engine.Vector3.cross(hAxis, vAxis, hAxis);
                this._isAtBack ? hAxis.scale(-y) : hAxis.scale(y);
                tempVec.copyFrom(vAxis);
                this._isAtBack ? tempVec.scale(-x) : tempVec.scale(x);
                engine.Vector3.add(hAxis, tempVec, tempVec);
                engine.Vector3.transformNormal(tempVec, this._startInvMatrix, tempVec);
                var angle = pointer.deltaPosition.length() * this._speedFactor;
                engine.Matrix.rotateAxisAngle(startMat, tempVec, angle, startMat);
                group.applyTransform(this._preMatrix, startMat);
                this._preMatrix.copyFrom(startMat);
                engine.Matrix.invert(startMat, this._startInvMatrix);
                break;
        }
        this.engine.dispatch("gizmo-move", "rotate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        this._finalRad = 0;
        this._previousRad = 0;
        // recover axis color
        this._setAxisSelected(this._selectedAxis, false);
        // recover arc line
        var axisMesh = this._rotateControlMap[this._selectedAxis].axisMesh[0];
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                GizmoMesh.updateCircleTube(axisMesh, Math.PI);
                // hide helper entity
                this._endLineHelperEntity.isActive = false;
                this._startLineHelperEntity.isActive = false;
                this._rotateHelperPlaneEntity.isActive = false;
                break;
            case axisType.xyz:
                GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI, 1.8);
                break;
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
        this._updateAxisTransform();
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {};
    _proto._setAxisSelected = function _setAxisSelected(axis, isSelected) {
        var axisMesh = this._rotateControlMap[axis].axisMesh[0];
        GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI);
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === axis) {
                if (isSelected) {
                    currComponent.yellow && currComponent.yellow();
                } else {
                    currComponent.recover && currComponent.recover();
                }
            }
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        // transform ray to local space
        var worldToLocal = this._startInvMatrix;
        engine.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        engine.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(axisPlane[this._selectedAxis]), out);
        out.normalize().scale(Utils.rotateCircleRadius);
    };
    _proto._getFinalRad = function _getFinalRad(p1, p2, rotateAxis) {
        var dot = engine.Vector3.dot(p1, p2);
        engine.Vector3.cross(p1, p2, this._tempVec);
        var direction = engine.Vector3.dot(this._tempVec, rotateAxis);
        var currentRad = Math.sign(direction) * Math.acos(dot / Math.pow(Utils.rotateCircleRadius, 2));
        var incrementRad = currentRad - this._previousRad;
        if (this._previousRad * currentRad < 0) {
            Math.abs(currentRad) < Math.PI / 2 ? this._finalRad += incrementRad : this._finalRad += -Math.sign(incrementRad) * (2 * Math.PI - Math.abs(incrementRad));
        } else {
            this._finalRad += incrementRad;
        }
        this._previousRad = currentRad;
        return this._finalRad;
    };
    _proto._getGizmoScale = function _getGizmoScale() {
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldPosition(this._tempVec);
        if (this._camera.isOrthographic) {
            return this._isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.8 : this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            return this._isModified ? engine.Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor * 0.8 : engine.Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor;
        }
    };
    _proto._updateAxisTransform = function _updateAxisTransform() {
        var _this = this, _tempMat = _this._tempMat, _tempVec = _this._tempVec, _tempVec2 = _this._tempVec2, _cameraPos = _this._cameraPos;
        // 相机位置
        _cameraPos.copyFrom(this._camera.entity.transform.worldPosition);
        var gizmoTrans = this.gizmoEntity.transform;
        // 获取参照向量(Gizmo 中点 -> 相机)（世界坐标）
        engine.Vector3.subtract(_cameraPos, gizmoTrans.worldPosition, _tempVec);
        // 逆矩阵（世界 -> Gizmo）
        engine.Matrix.invert(gizmoTrans.worldMatrix, _tempMat);
        // 将向量(Gizmo 中点 -> 相机)映射到 Gizmo 坐标系中，此处 XYZ 局部向量是相同的
        engine.Vector3.transformNormal(_tempVec, _tempMat, _tempVec2);
        var factor = engine.MathUtil.radToDegreeFactor;
        var x = _tempVec2.x, y = _tempVec2.y, z = _tempVec2.z;
        // 用 yoz 投影计算 X 轴的局部旋转
        this._axisX.transform.rotation.x = this._axisXHelper.transform.rotation.x = -Math.atan2(y, z) * factor;
        // 用 xoz 投影计算 Y 轴的局部旋转
        this._axisY.transform.rotation.y = this._axisYHelper.transform.rotation.y = Math.atan2(x, z) * factor;
        // 用 yox 投影计算 Z 轴的局部旋转
        this._axisZ.transform.rotation.z = this._axisZHelper.transform.rotation.z = Math.atan2(y, x) * factor;
        // xyz 投影
        this._localLookAt(this._axisXYZ.transform, _tempVec2);
        this._axisXYZHelper.transform.rotationQuaternion = this._axisXYZ.transform.rotationQuaternion;
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        this._group.getWorldMatrix(this._tempMat);
        this._isModified = isModified;
        var s = this._getGizmoScale();
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = this._tempMat.scale(this._tempVec.set(s, s, s));
    };
    _proto._localLookAt = function _localLookAt(transform, targetPosition) {
        var zAxis = this._tempVec30;
        engine.Vector3.subtract(transform.position, targetPosition, zAxis);
        zAxis.normalize();
        var xAxis = this._tempVec31.set(zAxis.z, 0, -zAxis.x).normalize();
        var yAxis = this._tempVec32;
        engine.Vector3.cross(zAxis, xAxis, yAxis);
        yAxis.normalize();
        var rotMat = this._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(transform.rotationQuaternion);
    };
    return RotateControl;
}(GizmoComponent);

/**
 * Gizmo Anchor State
 */ exports.AnchorType = void 0;
(function(AnchorType) {
    /**
   * positions the Gizmo at the actual pivot point
   */ AnchorType[AnchorType["Pivot"] = 0] = "Pivot";
    /**
   * positions the Gizmo at the center of the selected entity or entities rendered bounds
   */ AnchorType[AnchorType["Center"] = 1] = "Center";
})(exports.AnchorType || (exports.AnchorType = {}));
exports.CoordinateType = void 0;
(function(CoordinateType) {
    /**
   * aligns to the selected entity or entities local space
   */ CoordinateType[CoordinateType["Local"] = 0] = "Local";
    /**
   * aligns to the world space orientation
   */ CoordinateType[CoordinateType["Global"] = 1] = "Global";
})(exports.CoordinateType || (exports.CoordinateType = {}));

var GroupDirtyFlag;
(function(GroupDirtyFlag) {
    /**
   * none
   */ GroupDirtyFlag[GroupDirtyFlag["None"] = 0] = "None";
    /**
   * anchor changed
   */ GroupDirtyFlag[GroupDirtyFlag["AnchorDirty"] = 1] = "AnchorDirty";
    /**
   * coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["CoordinateDirty"] = 2] = "CoordinateDirty";
    /**
   * anchor & coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["All"] = 3] = "All";
})(GroupDirtyFlag || (GroupDirtyFlag = {}));
/**
 * Group
 */ var Group = /*#__PURE__*/ function() {
    function Group() {
        // @internal
        this._gizmoTransformDirty = true;
        this._entities = [];
        this._listeners = [];
        this._worldMatrix = new engine.Matrix();
        this._anchorType = exports.AnchorType.Pivot;
        this._coordinateType = exports.CoordinateType.Local;
        this._dirtyFlag = 3;
    }
    var _proto = Group.prototype;
    /**
   * add entity to the group
   * @param addEntity - entity to add
   */ _proto.addEntity = function addEntity(addEntity) {
        var _this = this, entities = _this._entities;
        var canAdd = true;
        for(var j = entities.length - 1; j >= 0; j--){
            var compareEntity = entities[j];
            if (compareEntity === addEntity) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(compareEntity, addEntity)) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(addEntity, compareEntity)) {
                this._applyDel(j);
            }
        }
        if (canAdd) {
            this._applyAdd(addEntity);
        }
        return canAdd;
    };
    /**
   * add entities to the group
   * @param addEntities - entities to add, in array
   */ _proto.addEntities = function addEntities(addEntities) {
        for(var i = addEntities.length - 1; i >= 0; i--){
            this.addEntity(addEntities[i]);
        }
    };
    /**
   * remove entity from the group
   * @param delEntity - entity to delete
   */ _proto.deleteEntity = function deleteEntity(delEntity) {
        this._applyDel(delEntity);
    };
    /**
   * remove entities from the group
   * @param delEntities - entities to delete, in array
   */ _proto.deleteEntities = function deleteEntities(delEntities) {
        for(var i = delEntities.length - 1; i >= 0; i--){
            this.deleteEntity(delEntities[i]);
        }
    };
    /**
   * get entity index in group
   * @param entity
   * @return number, -1 if not in group
   */ _proto.getIndexOf = function getIndexOf(entity) {
        var _this = this, entities = _this._entities;
        return entities.findIndex(function(ele) {
            return entity === ele;
        });
    };
    /**
   * clear the group
   */ _proto.reset = function reset() {
        this._entities.length = 0;
        var _this = this, listeners = _this._listeners;
        for(var i = listeners.length - 1; i >= 0; i--){
            var listener = listeners[i];
            listener.flagManager.removeListener(listener.fun);
        }
        listeners.length = 0;
        this._dirtyFlag = 3;
    };
    /**
   * get group's world matrix
   * @param out - updated world matrix for the group
   * @return boolean, true if group's world matrix needs update
   */ _proto.getWorldMatrix = function getWorldMatrix(out) {
        if (this._entities.length <= 0) {
            return false;
        } else {
            this._updateAnchor();
            this._updateCoordinate();
            out && out.copyFrom(this._worldMatrix);
            return true;
        }
    };
    /**
   * get group's world position
   * @param out - updated world position for the group
   */ _proto.getWorldPosition = function getWorldPosition(out) {
        if (this.getWorldMatrix()) {
            var _this__worldMatrix = this._worldMatrix, ele = _this__worldMatrix.elements;
            out.set(ele[12], ele[13], ele[14]);
        }
    };
    /**
   * 从上个状态的矩阵变换到目标矩阵
   * from 矩阵计算所有节点的在本次变换中的 local 姿态
   * to 矩阵计算所有节点的在本次变换后的 world 姿态
   * @param from - 初始矩阵
   * @param to - 目标矩阵
   */ _proto.applyTransform = function applyTransform(from, to) {
        var _this = this, entities = _this._entities;
        if (this._entities.length <= 0) {
            return;
        }
        if (engine.Matrix.equals(from, to)) {
            return;
        }
        // old worldMatrix.
        var groupWorldInvMat = Group._tempMat0, nodeMat = Group._tempMat1;
        engine.Matrix.invert(from, groupWorldInvMat);
        // update entities worldMatrix
        for(var i = entities.length - 1; i >= 0; i--){
            var nodeTrans = entities[i].transform;
            // get entity's localMatrix.
            engine.Matrix.multiply(groupWorldInvMat, nodeTrans.worldMatrix, nodeMat);
            // update entity's worldMatrix.
            engine.Matrix.multiply(to, nodeMat, nodeMat);
            nodeTrans.worldMatrix = nodeMat;
        }
    };
    /**
   * force update group dirty flag
   * @param flag - group dirty flag
   */ _proto.setDirtyFlagTrue = function setDirtyFlagTrue(flag) {
        this._dirtyFlag |= flag;
        this._gizmoTransformDirty = true;
    };
    _proto._applyAdd = function _applyAdd(entity) {
        this._entities.push(entity);
        var fun = this._onEntityWorldTransformChange(entity);
        // @ts-ignore
        var flagManager = entity.transform._updateFlagManager;
        flagManager.addListener(fun);
        this._listeners.push({
            flagManager: flagManager,
            fun: fun
        });
        fun();
    };
    _proto._applyDel = function _applyDel(value) {
        var index = typeof value === "number" ? value : this._entities.indexOf(value);
        if (index === 0) {
            if (this._coordinateType === exports.CoordinateType.Local) {
                this.setDirtyFlagTrue(3);
            } else {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener = this._listeners[index];
            listener.flagManager.removeListener(listener.fun);
            this._listeners.splice(index, 1);
        } else if (index > 0) {
            if (this._anchorType === exports.AnchorType.Center) {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener1 = this._listeners[index];
            listener1.flagManager.removeListener(listener1.fun);
            this._listeners.splice(index, 1);
        }
    };
    _proto._onEntityWorldTransformChange = function _onEntityWorldTransformChange(entity) {
        var _this = this;
        return function() {
            if (_this._entities.indexOf(entity) === 0) {
                if (_this._coordinateType === exports.CoordinateType.Local) {
                    _this.setDirtyFlagTrue(3);
                } else {
                    _this.setDirtyFlagTrue(1);
                }
            } else {
                if (_this._anchorType === exports.AnchorType.Center) {
                    _this.setDirtyFlagTrue(1);
                }
            }
        };
    };
    _proto._hasRelationship = function _hasRelationship(parent, compareChild) {
        while(compareChild.parent){
            if (parent === compareChild.parent) {
                return true;
            } else {
                compareChild = compareChild.parent;
            }
        }
        return false;
    };
    _proto._updateAnchor = function _updateAnchor() {
        if (this._dirtyFlag & 1) {
            var _this = this, worldMatrix = _this._worldMatrix;
            var tempVec3 = Group._tempVec30;
            var e = worldMatrix.elements;
            switch(this._anchorType){
                case exports.AnchorType.Center:
                    this._getCenter(tempVec3);
                    e[12] = tempVec3.x, e[13] = tempVec3.y, e[14] = tempVec3.z;
                    break;
                case exports.AnchorType.Pivot:
                    // align to the first entity
                    var worldE = this._entities[0].transform.worldMatrix.elements;
                    e[12] = worldE[12], e[13] = worldE[13], e[14] = worldE[14];
                    break;
            }
            this._dirtyFlag &= ~1;
        }
    };
    _proto._updateCoordinate = function _updateCoordinate() {
        if (this._dirtyFlag & 2) {
            var _this__worldMatrix = this._worldMatrix, e = _this__worldMatrix.elements;
            switch(this._coordinateType){
                case exports.CoordinateType.Local:
                    // align to the first entity
                    var wE = this._entities[0].transform.worldMatrix.elements;
                    var sx = 1 / Math.sqrt(Math.pow(wE[0], 2) + Math.pow(wE[1], 2) + Math.pow(wE[2], 2));
                    var sy = 1 / Math.sqrt(Math.pow(wE[4], 2) + Math.pow(wE[5], 2) + Math.pow(wE[6], 2));
                    var sz = 1 / Math.sqrt(Math.pow(wE[8], 2) + Math.pow(wE[9], 2) + Math.pow(wE[10], 2));
                    e[0] = wE[0] * sx, e[4] = wE[4] * sy, e[8] = wE[8] * sz;
                    e[1] = wE[1] * sx, e[5] = wE[5] * sy, e[9] = wE[9] * sz;
                    e[2] = wE[2] * sx, e[6] = wE[6] * sy, e[10] = wE[10] * sz;
                    break;
                case exports.CoordinateType.Global:
                    e[0] = 1, e[4] = 0, e[8] = 0;
                    e[1] = 0, e[5] = 1, e[9] = 0;
                    e[2] = 0, e[6] = 0, e[10] = 1;
                    break;
            }
            this._dirtyFlag &= ~2;
        }
    };
    _proto._getCenter = function _getCenter(out) {
        var tempBoundBox = Group._tempBoundBox;
        tempBoundBox.min.set(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        tempBoundBox.max.set(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        var _this = this, entities = _this._entities;
        var isEffective = false;
        for(var i = entities.length - 1; i >= 0; i--){
            var entity = entities[i];
            var renderers = entity.getComponentsIncludeChildren(engine.Renderer, []);
            isEffective || (isEffective = renderers.length > 0);
            for(var j = renderers.length - 1; j >= 0; j--){
                var renderer = renderers[j];
                if (renderer.entity.isActiveInHierarchy) {
                    engine.BoundingBox.merge(tempBoundBox, renderers[j].bounds, tempBoundBox);
                }
            }
        }
        var length = tempBoundBox.getExtent(out).length();
        if (length <= 0 || length >= Number.MAX_VALUE) {
            isEffective = false;
        }
        if (isEffective) {
            tempBoundBox.getCenter(out);
        } else {
            out.set(0, 0, 0);
            for(var i1 = entities.length - 1; i1 >= 0; i1--){
                out.add(entities[i1].transform.worldPosition);
            }
            out.scale(1 / entities.length);
        }
    };
    _create_class(Group, [
        {
            key: "anchorType",
            get: /**
   * get anchor type
   * @return anchor type, pivot or center
   */ function get() {
                return this._anchorType;
            },
            set: function set(value) {
                if (this._anchorType !== value) {
                    this._anchorType = value;
                    this.setDirtyFlagTrue(1);
                }
            }
        },
        {
            key: "coordinateType",
            get: /**
   * get coordinate type
   * @return coordinate type, world or local
   */ function get() {
                return this._coordinateType;
            },
            set: function set(value) {
                if (this._coordinateType !== value) {
                    this._coordinateType = value;
                    this.setDirtyFlagTrue(2);
                }
            }
        }
    ]);
    return Group;
}();
Group._tempVec30 = new engine.Vector3();
Group._tempMat0 = new engine.Matrix();
Group._tempMat1 = new engine.Matrix();
Group._tempBoundBox = new engine.BoundingBox();

/**
 * Gizmo controls, including translate, rotate, scale
 */ var Gizmo = /*#__PURE__*/ function(Script) {
    _inherits(Gizmo, Script);
    function Gizmo(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.epsilon = 0.05;
        _this._initialized = false;
        _this._isStarted = false;
        _this._lastDistance = -1;
        _this._lastOrthoSize = -1;
        _this._lastIsOrtho = false;
        _this._controlMap = [];
        _this._group = new Group();
        _this._tempVec30 = new engine.Vector3();
        _this._tempVec31 = new engine.Vector3();
        _this._worldMat = new engine.Matrix();
        _this._tempRay = new engine.Ray();
        _this._tempRay2 = new engine.Ray();
        _this._type = null;
        _this._scalar = 1;
        if (!_this.entity.engine.physicsManager) {
            throw new Error("PhysicsManager is not initialized");
        }
        Utils.init(_this.engine);
        // setup mesh
        _this._createGizmoControl(exports.State.translate, TranslateControl);
        _this._createGizmoControl(exports.State.rotate, RotateControl);
        _this._createGizmoControl(exports.State.scale, ScaleControl);
        _this.layer = engine.Layer.Layer31;
        _this.state = _this._type;
        return _this;
    }
    var _proto = Gizmo.prototype;
    /**
   * initial scene camera & select group in gizmo
   */ _proto.init = function init(camera, group) {
        var _this = this;
        if (camera !== this._sceneCamera) {
            if (camera) {
                this._group = group;
                this._sceneCamera = camera;
                this._framebufferPicker = camera.entity.addComponent(engineToolkitFramebufferPicker.FramebufferPicker);
                this._framebufferPicker.frameBufferSize = new engine.Vector2(256, 256);
                this._controlMap.forEach(function(gizmoControl) {
                    gizmoControl.init(camera, _this._group);
                });
                this._initialized = true;
            } else {
                this._initialized = false;
            }
        }
    };
    _proto.onUpdate = function onUpdate() {
        var _this = this;
        if (!this._initialized) {
            return;
        }
        var inputManager = this.engine.inputManager;
        var pointers = inputManager.pointers;
        var pointer = pointers.find(function(pointer) {
            return pointer.phase !== engine.PointerPhase.Up && pointer.phase !== engine.PointerPhase.Leave;
        });
        if (this._lastIsOrtho !== this._sceneCamera.isOrthographic) {
            this._lastIsOrtho = this._sceneCamera.isOrthographic;
            this._traverseControl(this._type, function(control) {
                _this._type === exports.State.all ? control.onSwitch(true) : control.onSwitch(false);
            });
        }
        this._group.getWorldPosition(this._tempVec30);
        if (this._isStarted) {
            if (pointer && (pointer.pressedButtons & engine.PointerButton.Primary) !== 0) {
                if (pointer.deltaPosition.x !== 0 || pointer.deltaPosition.y !== 0) {
                    this._triggerGizmoMove();
                }
            } else {
                this._triggerGizmoEnd();
            }
            if (this._group._gizmoTransformDirty) {
                this._traverseControl(this._type, function(control) {
                    _this._type === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                });
                this._group._gizmoTransformDirty = false;
            }
        } else {
            this._group.getWorldPosition(this._tempVec30);
            var cameraPosition = this._sceneCamera.entity.transform.worldPosition;
            var currDistance = engine.Vector3.distance(cameraPosition, this._tempVec30);
            var distanceDirty = false;
            if (Math.abs(this._lastDistance - currDistance) > engine.MathUtil.zeroTolerance) {
                distanceDirty = true;
                this._lastDistance = currDistance;
            }
            var orthoSizeDirty = false;
            if (this._sceneCamera.isOrthographic && Math.abs(this._lastOrthoSize - this._sceneCamera.orthographicSize) > engine.MathUtil.zeroTolerance) {
                orthoSizeDirty = true;
                this._lastOrthoSize = this._sceneCamera.orthographicSize;
            }
            if (this._group._gizmoTransformDirty || distanceDirty || orthoSizeDirty) {
                this._traverseControl(this._type, function(control) {
                    _this._type === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                });
                this._group._gizmoTransformDirty = false;
            }
            if (pointer) {
                var _pointer_position = pointer.position, x = _pointer_position.x, y = _pointer_position.y;
                var canvas = this.engine.canvas;
                if (x <= 0 || y <= 0 || x > canvas.width || y > canvas.height) {
                    return;
                }
                if (inputManager.isPointerDown(engine.PointerButton.Primary)) {
                    this._framebufferPicker.pick(pointer.position.x, pointer.position.y).then(function(result) {
                        if (result) {
                            _this._selectHandler(result, pointer.position);
                        }
                    });
                } else {
                    var originLayer = this._sceneCamera.cullingMask;
                    this._sceneCamera.cullingMask = this._layer;
                    var result = this._framebufferPicker.pick(pointer.position.x, pointer.position.y);
                    this._sceneCamera.cullingMask = originLayer;
                    result.then(function(result) {
                        _this._overHandler(result);
                    });
                }
            }
        }
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        this._adjustAxisAlpha();
    };
    _proto._createGizmoControl = function _createGizmoControl(type, gizmoComponent) {
        var control = this.entity.createChild(type.toString()).addComponent(gizmoComponent);
        this._controlMap.push(control);
    };
    _proto._onGizmoHoverStart = function _onGizmoHoverStart(currentType, axisName) {
        var _this = this;
        this._traverseControl(currentType, function(control) {
            _this._currentControl = control;
        });
        this._currentControl.onHoverStart(axisName);
    };
    _proto._onGizmoHoverEnd = function _onGizmoHoverEnd() {
        this._currentControl && this._currentControl.onHoverEnd();
    };
    _proto._triggerGizmoStart = function _triggerGizmoStart(currentType, axisName) {
        var _this = this;
        this._isStarted = true;
        this._onGizmoHoverEnd();
        var pointer = this.engine.inputManager.pointers.find(function(pointer) {
            return pointer.phase !== engine.PointerPhase.Up && pointer.phase !== engine.PointerPhase.Leave;
        });
        if (pointer) {
            this._sceneCamera.screenPointToRay(pointer.position, this._tempRay);
            this._traverseControl(currentType, function(control) {
                _this._currentControl = control;
            }, function(control) {
                control.entity.isActive = false;
            });
            this._currentControl.onMoveStart(this._tempRay, axisName);
            this.engine.dispatch("gizmo-move-start", axisName);
        }
    };
    _proto._triggerGizmoMove = function _triggerGizmoMove() {
        var pointer = this.engine.inputManager.pointers.find(function(pointer) {
            return pointer.phase !== engine.PointerPhase.Up && pointer.phase !== engine.PointerPhase.Leave;
        });
        this._sceneCamera.screenPointToRay(pointer.position, this._tempRay2);
        this._currentControl.onMove(this._tempRay2, pointer);
    };
    _proto._triggerGizmoEnd = function _triggerGizmoEnd() {
        this._currentControl && this._currentControl.onMoveEnd();
        this._group.setDirtyFlagTrue(GroupDirtyFlag.CoordinateDirty);
        this._traverseControl(this._type, function(control) {
            control.entity.isActive = true;
        });
        this._isStarted = false;
        this.engine.dispatch("gizmo-move-end");
    };
    _proto._selectHandler = function _selectHandler(result, pointerPosition) {
        var material = result.getMaterial();
        var currentControl = parseInt(material.name);
        var selectedEntity = result.entity;
        switch(selectedEntity.layer){
            case this._layer:
                this._triggerGizmoStart(currentControl, selectedEntity.name);
                break;
        }
    };
    _proto._overHandler = function _overHandler(result) {
        if (result) {
            var material = result.getMaterial();
            var currentControl = parseInt(material.name);
            var hoverEntity = result.entity;
            this._onGizmoHoverStart(currentControl, hoverEntity.name);
        } else {
            this._onGizmoHoverEnd();
        }
    };
    _proto._traverseEntity = function _traverseEntity(entity, callback) {
        callback(entity);
        for(var _iterator = _create_for_of_iterator_helper_loose(entity.children), _step; !(_step = _iterator()).done;){
            var child = _step.value;
            this._traverseEntity(child, callback);
        }
    };
    _proto._traverseControl = function _traverseControl(targetType, callbackForTarget, callbackForOther) {
        if (targetType === void 0) targetType = this._type;
        this._controlMap.forEach(function(control) {
            if ((targetType & control.type) != 0) {
                callbackForTarget(control);
            } else {
                if (callbackForOther) {
                    callbackForOther(control);
                }
            }
        });
    };
    _proto._adjustAxisAlpha = function _adjustAxisAlpha() {
        var _this = this;
        var xAxisPositive = Utils.xAxisPositive, yAxisPositive = Utils.yAxisPositive, zAxisPositive = Utils.zAxisPositive;
        this._traverseControl(this._type, function(control) {
            control.onAlphaChange("x", _this._getAlphaFactor(xAxisPositive));
            control.onAlphaChange("y", _this._getAlphaFactor(yAxisPositive));
            control.onAlphaChange("z", _this._getAlphaFactor(zAxisPositive));
        });
    };
    _proto._getAlphaFactor = function _getAlphaFactor(axis) {
        var _this = this, worldMat = _this._worldMat, cameraDir = _this._tempVec30, tempVec = _this._tempVec31, epsilon = _this.epsilon;
        cameraDir.copyFrom(this._sceneCamera.entity.transform.worldForward).normalize();
        this._group.getWorldMatrix(worldMat);
        // angel between camera direction and gizmo axis direction
        engine.Vector3.transformNormal(axis, worldMat, tempVec);
        var cosThetaDir = Math.abs(engine.Vector3.dot(tempVec, cameraDir));
        if (this._sceneCamera.isOrthographic) {
            return 1 - cosThetaDir < epsilon ? engine.MathUtil.clamp((1 - cosThetaDir) / epsilon, 0, 1) : 1;
        } else {
            // perspective camera needs to consider position
            // angle between camera direction and camera-entity position
            this._group.getWorldPosition(tempVec);
            engine.Vector3.subtract(this._sceneCamera.entity.transform.worldPosition, tempVec, tempVec);
            var cosThetaPos = Math.abs(engine.Vector3.dot(tempVec.normalize(), cameraDir));
            var minFactor = Math.min(cosThetaDir, cosThetaPos);
            var maxFactor = Math.max(cosThetaDir, cosThetaPos);
            return 1 - maxFactor < epsilon ? engine.MathUtil.clamp((1 - minFactor) / epsilon, 0, 1) : 1;
        }
    };
    _create_class(Gizmo, [
        {
            key: "layer",
            get: /**
   * gizmo layer, default Layer31
   * @return the layer for gizmo entity and gizmo's inner framebuffer picker
   * @remarks Layer duplicate warning, check whether this layer is taken
   */ function get() {
                return this._layer;
            },
            set: function set(layer) {
                if (this._layer !== layer) {
                    this._layer = layer;
                    this._traverseEntity(this.entity, function(entity) {
                        entity.layer = layer;
                    });
                }
            }
        },
        {
            key: "state",
            get: /**
   * change gizmo type
   * @return current gizmo type - translate, or rotate, scale, null, all, default null
   */ function get() {
                return this._type;
            },
            set: function set(targetState) {
                this._type = targetState;
                this._traverseControl(targetState, function(control) {
                    control.entity.isActive = true;
                    targetState === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                }, function(control) {
                    control.entity.isActive = false;
                });
            }
        },
        {
            key: "size",
            get: /**
   * change gizmo size
   * @return current gizmo size - min 0.01, default 1
   */ function get() {
                return this._scalar;
            },
            set: function set(value) {
                this._scalar = engine.MathUtil.clamp(value, 0.01, Infinity);
                Utils.scaleFactor = this._scalar * 0.05773502691896257;
            }
        }
    ]);
    return Gizmo;
}(engine.Script);

exports.Gizmo = Gizmo;
exports.Group = Group;
//# sourceMappingURL=browser.js.map
