'use strict';

var miniprogram = require('@galacean/engine/dist/miniprogram');

function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of$2(o, p) {
    _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$2(o, p);
}

function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$2(subClass, superClass);
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Axis = /*#__PURE__*/ function(Component) {
    _inherits$2(Axis, Component);
    function Axis(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        _this._color = new miniprogram.Color();
        _this._highLightColor = new miniprogram.Color();
        _this._yellowColor = new miniprogram.Color(1.0, 0.95, 0.0, 1.0);
        _this._grayColor = new miniprogram.Color(0.75, 0.75, 0.75, 0.6);
        return _this;
    }
    var _proto = Axis.prototype;
    /** setup axis geometry */ _proto.initAxis = function initAxis(value) {
        this._material = value.axisMaterial;
        this._color.copyFrom(value.axisMaterial.baseColor);
        this._highLightColor.copyFrom(this._color);
        this._highLightColor.r = this._highLightColor.r + 0.3;
        this._highLightColor.g = this._highLightColor.g + 0.3;
        this._highLightColor.b = this._highLightColor.b + 0.3;
        this._highLightColor.a = this._highLightColor.a + 0.1;
        // setup visible axis
        for(var i = 0; i < value.axisMesh.length; i++){
            var axisEntity = this.entity.createChild(value.name);
            axisEntity.transform.rotate(value.axisRotation[i]);
            axisEntity.transform.translate(value.axisTranslation[i], false);
            var axisRenderer = axisEntity.addComponent(miniprogram.MeshRenderer);
            axisRenderer.receiveShadows = false;
            axisRenderer.castShadows = false;
            axisRenderer.priority = value.priority ? value.priority : 100;
            axisRenderer.mesh = value.axisMesh[i];
            axisRenderer.setMaterial(this._material);
        }
        // setup invisible axis
        var gizmoHelperEntity = this.entity.parent.parent.findByName("invisible");
        for(var i1 = 0; i1 < value.axisHelperMesh.length; i1++){
            var temp = gizmoHelperEntity.createChild(value.name);
            var axisHelperEntity = temp.createChild(value.name);
            axisHelperEntity.transform.rotate(value.axisRotation[i1]);
            axisHelperEntity.transform.translate(value.axisTranslation[i1], false);
            var axisHelperRenderer = axisHelperEntity.addComponent(miniprogram.MeshRenderer);
            axisHelperRenderer.receiveShadows = false;
            axisHelperRenderer.castShadows = false;
            axisHelperRenderer.priority = value.priority ? value.priority : 100;
            axisHelperRenderer.mesh = value.axisHelperMesh[i1];
            axisHelperRenderer.setMaterial(value.axisHelperMaterial);
        }
    };
    /** highlight axis */ _proto.highLight = function highLight() {
        this._material.baseColor.copyFrom(this._highLightColor);
    };
    /** unhighligh axis */ _proto.unLight = function unLight() {
        this._material.baseColor.copyFrom(this._color);
    };
    /** change axis color into yellow */ _proto.yellow = function yellow() {
        this._material.baseColor.copyFrom(this._yellowColor);
    };
    /** change axis color into gray */ _proto.gray = function gray() {
        this._material.baseColor.copyFrom(this._grayColor);
    };
    /** recover axis color */ _proto.recover = function recover() {
        this._material.baseColor.copyFrom(this._color);
    };
    /** change axis alpha */ _proto.alpha = function alpha(v) {
        this._material.baseColor.a = v;
    };
    return Axis;
}(miniprogram.Component);

/**
 * Gizmo State
 */ exports.State = void 0;
(function(State) {
    /**
   * translate state
   */ State[State["translate"] = 1] = "translate";
    /**
   * rotate state
   */ State[State["rotate"] = 2] = "rotate";
    /**
   * scale state
   */ State[State["scale"] = 4] = "scale";
    /**
   * all state
   */ State[State["all"] = 15] = "all";
})(exports.State || (exports.State = {}));

/**
 * @internal
 */ var GizmoMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits$2(GizmoMeshRestorer, ContentRestorer);
    function GizmoMeshRestorer(resource, primitiveInfo) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.primitiveInfo = primitiveInfo;
        return _this;
    }
    var _proto = GizmoMeshRestorer.prototype;
    /**
   * @override
   */ _proto.restoreContent = function restoreContent() {
        var primitiveInfo = this.primitiveInfo;
        switch(primitiveInfo.type){
            case 0:
                var circleInfo = primitiveInfo;
                GizmoMesh.updateCircle(this.resource, circleInfo.startPoint, circleInfo.normal, circleInfo.thetaLength, circleInfo.center);
                break;
            case 2:
                var tubeInfo = primitiveInfo;
                GizmoMesh.updateCircleTube(this.resource, tubeInfo.arc, tubeInfo.radius, tubeInfo.tubeRadius, tubeInfo.tubularSegments, tubeInfo.radialSegments);
                break;
            case 1:
                var lineInfo = primitiveInfo;
                GizmoMesh.updateLine(this.resource, lineInfo.points);
                break;
        }
    };
    return GizmoMeshRestorer;
}(miniprogram.ContentRestorer);
var GizmoMeshType;
(function(GizmoMeshType) {
    GizmoMeshType[GizmoMeshType["Circle"] = 0] = "Circle";
    GizmoMeshType[GizmoMeshType["Line"] = 1] = "Line";
    GizmoMeshType[GizmoMeshType["CircleTube"] = 2] = "CircleTube";
})(GizmoMeshType || (GizmoMeshType = {}));
/**
 * @internal
 */ var GizmoMeshRestoreInfo = function GizmoMeshRestoreInfo(type) {
    this.type = type;
};
/**
 * @internal
 */ var CircleRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits$2(CircleRestoreInfo, GizmoMeshRestoreInfo);
    function CircleRestoreInfo(startPoint, normal, thetaLength, center) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 0) || this;
        _this.startPoint = startPoint;
        _this.normal = normal;
        _this.thetaLength = thetaLength;
        _this.center = center;
        return _this;
    }
    return CircleRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var CircleTubeRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits$2(CircleTubeRestoreInfo, GizmoMeshRestoreInfo);
    function CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 2) || this;
        _this.arc = arc;
        _this.radius = radius;
        _this.tubeRadius = tubeRadius;
        _this.tubularSegments = tubularSegments;
        _this.radialSegments = radialSegments;
        return _this;
    }
    return CircleTubeRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var LineRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits$2(LineRestoreInfo, GizmoMeshRestoreInfo);
    function LineRestoreInfo(points) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 1) || this;
        _this.points = points;
        return _this;
    }
    return LineRestoreInfo;
}(GizmoMeshRestoreInfo);

var GizmoMesh = /*#__PURE__*/ function() {
    function GizmoMesh() {}
    GizmoMesh.createCircle = function createCircle(engine, center, normal, startPoint, thetaLength) {
        if (center === void 0) center = new miniprogram.Vector3();
        if (normal === void 0) normal = new miniprogram.Vector3(0, 0, 1);
        if (startPoint === void 0) startPoint = new miniprogram.Vector3(1.6, 0, 0);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        var mesh = new miniprogram.ModelMesh(engine);
        GizmoMesh.updateCircle(mesh, startPoint, normal, thetaLength, center);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleRestoreInfo(startPoint, normal, thetaLength, center)));
        return mesh;
    };
    GizmoMesh.updateCircle = function updateCircle(mesh, startPoint, normal, thetaLength, center, /**
     * segments per half Pi
     */ segmentFactor) {
        if (startPoint === void 0) startPoint = new miniprogram.Vector3(1.6, 0, 0);
        if (normal === void 0) normal = new miniprogram.Vector3(0, 0, 1);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        if (center === void 0) center = new miniprogram.Vector3();
        if (segmentFactor === void 0) segmentFactor = 16;
        var newSegments = Math.abs(Math.ceil(segmentFactor * thetaLength / Math.PI));
        var segments = Math.max(6, newSegments);
        var indices = new Uint16Array(segments * 3);
        var vertices = [];
        // indices
        for(var i = 1; i <= segments; i++){
            var start = (i - 1) * 3;
            indices[start] = i;
            indices[start + 1] = i + 1;
            indices[start + 2] = 0;
        }
        // vertices
        vertices.push(center);
        for(var s = 0; s <= segments; s++){
            var segment = s / segments * thetaLength;
            miniprogram.Quaternion.rotationAxisAngle(normal, segment, GizmoMesh._tempQuat);
            miniprogram.Vector3.transformByQuat(startPoint, GizmoMesh._tempQuat, GizmoMesh._tempVect);
            vertices[s + 1] = GizmoMesh._tempVect.clone();
        }
        GizmoMesh._initialize(mesh, vertices, indices, miniprogram.MeshTopology.Triangles);
    };
    GizmoMesh.createCircleTube = function createCircleTube(engine, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var mesh = new miniprogram.ModelMesh(engine);
        GizmoMesh.updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments)));
        return mesh;
    };
    GizmoMesh.updateCircleTube = function updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = new Uint16Array(rectangleCount * 6);
        var vertices = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        var offset = 0;
        for(var i = 0; i <= radialSegments; i++){
            for(var j = 0; j <= tubularSegments; j++){
                var u = j / tubularSegments * arc;
                var v = i / radialSegments * Math.PI * 2;
                var cosV = Math.cos(v);
                var sinV = Math.sin(v);
                var cosU = Math.cos(u);
                var sinU = Math.sin(u);
                var position = new miniprogram.Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
                vertices[offset] = position;
                var centerX = radius * cosU;
                var centerY = radius * sinU;
                normals[offset] = new miniprogram.Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
                uvs[offset++] = new miniprogram.Vector2(j / tubularSegments, i / radialSegments);
            }
        }
        offset = 0;
        for(var i1 = 1; i1 <= radialSegments; i1++){
            for(var j1 = 1; j1 <= tubularSegments; j1++){
                var a = (tubularSegments + 1) * i1 + j1 - 1;
                var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
                var c = (tubularSegments + 1) * (i1 - 1) + j1;
                var d = (tubularSegments + 1) * i1 + j1;
                indices[offset++] = a;
                indices[offset++] = b;
                indices[offset++] = d;
                indices[offset++] = b;
                indices[offset++] = c;
                indices[offset++] = d;
            }
        }
        var bounds = mesh.bounds;
        var outerRadius = radius + tubeRadius;
        bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
        bounds.max.set(outerRadius, outerRadius, tubeRadius);
        GizmoMesh._initialize(mesh, vertices, indices, miniprogram.MeshTopology.Triangles, normals, uvs);
    };
    GizmoMesh.createLine = function createLine(engine, points) {
        var mesh = new miniprogram.ModelMesh(engine);
        GizmoMesh.updateLine(mesh, points);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new LineRestoreInfo(points)));
        return mesh;
    };
    GizmoMesh.updateLine = function updateLine(mesh, points) {
        var vertices = points;
        var indices = new Uint8Array(vertices.length);
        for(var i = 0; i < vertices.length; i++){
            indices[i] = i;
        }
        GizmoMesh._initialize(mesh, vertices, indices, miniprogram.MeshTopology.Lines);
    };
    GizmoMesh._initialize = function _initialize(mesh, vertices, indices, meshTopology, normals, uvs) {
        mesh.setPositions(vertices);
        mesh.setIndices(indices);
        normals && mesh.setNormals(normals);
        uvs && mesh.setUVs(uvs);
        mesh.clearSubMesh();
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length, meshTopology);
    };
    return GizmoMesh;
}();
GizmoMesh._tempQuat = new miniprogram.Quaternion();
GizmoMesh._tempVect = new miniprogram.Vector3();

miniprogram.ShaderProperty.getByName("u_lightDir");
miniprogram.ShaderProperty.getByName("u_planarHeight");
miniprogram.ShaderProperty.getByName("u_planarShadowColor");
miniprogram.ShaderProperty.getByName("u_planarShadowFalloff");
var planarShadow = new miniprogram.ShaderPass("\n    attribute vec4 POSITION;\n    varying vec4 color;\n\n    uniform vec3 u_lightDir;\n    uniform float u_planarHeight;\n    uniform vec4 u_planarShadowColor;\n    uniform float u_planarShadowFalloff;\n\n    uniform mat4 renderer_ModelMat;\n    uniform mat4 camera_VPMat;\n\n    #ifdef RENDERER_HAS_SKIN\n      attribute vec4 JOINTS_0;\n      attribute vec4 WEIGHTS_0;\n\n      #ifdef RENDERER_USE_JOINT_TEXTURE\n        uniform sampler2D renderer_JointSampler;\n        uniform float renderer_JointCount;\n        mat4 getJointMatrix(sampler2D smp, float index) {\n            float base = index / renderer_JointCount;\n            float hf = 0.5 / renderer_JointCount;\n            float v = base + hf;\n\n            vec4 m0 = texture2D(smp, vec2(0.125, v ));\n            vec4 m1 = texture2D(smp, vec2(0.375, v ));\n            vec4 m2 = texture2D(smp, vec2(0.625, v ));\n            vec4 m3 = texture2D(smp, vec2(0.875, v ));\n\n            return mat4(m0, m1, m2, m3);\n        }\n      #else\n          uniform mat4 renderer_JointMatrix[ RENDERER_JOINTS_NUM ];\n      #endif\n    #endif\n\n    vec3 ShadowProjectPos(vec4 vertPos) {\n      vec3 shadowPos;\n\n      // get the world space coordinates of the vertex\n      vec3 worldPos = (renderer_ModelMat * vertPos).xyz;\n      \n      // world space coordinates of the shadow (the part below the ground is unchanged)\n      shadowPos.y = min(worldPos.y , u_planarHeight);\n      shadowPos.xz = worldPos.xz - u_lightDir.xz * max(0.0, worldPos.y - u_planarHeight) / u_lightDir.y;\n\n      return shadowPos;\n    }\n\n    void main() {\n     vec4 position = vec4(POSITION.xyz, 1.0 );\n      #ifdef RENDERER_HAS_SKIN\n          #ifdef RENDERER_USE_JOINT_TEXTURE\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * getJointMatrix(renderer_JointSampler, JOINTS_0.x ) +\n                  WEIGHTS_0.y * getJointMatrix(renderer_JointSampler, JOINTS_0.y ) +\n                  WEIGHTS_0.z * getJointMatrix(renderer_JointSampler, JOINTS_0.z ) +\n                  WEIGHTS_0.w * getJointMatrix(renderer_JointSampler, JOINTS_0.w );\n          #else\n              mat4 skinMatrix =\n                  WEIGHTS_0.x * renderer_JointMatrix[ int( JOINTS_0.x ) ] +\n                  WEIGHTS_0.y * renderer_JointMatrix[ int( JOINTS_0.y ) ] +\n                  WEIGHTS_0.z * renderer_JointMatrix[ int( JOINTS_0.z ) ] +\n                  WEIGHTS_0.w * renderer_JointMatrix[ int( JOINTS_0.w ) ];\n          #endif\n          position = skinMatrix * position;\n      #endif\n\n      // get the shadow's world space coordinates\n      vec3 shadowPos = ShadowProjectPos(position);\n\n      // convert to clip space\n      gl_Position = camera_VPMat * vec4(shadowPos, 1.0);\n\n      // get the world coordinates of the center point\n      vec3 center = vec3(renderer_ModelMat[3].x, u_planarHeight, renderer_ModelMat[3].z);\n      // calculate shadow falloff\n      float falloff = 0.5 - clamp(distance(shadowPos , center) * u_planarShadowFalloff, 0.0, 1.0);\n\n      // shadow color\n      color = u_planarShadowColor;\n      color.a *= falloff;\n    }\n    ", "\n    varying vec4 color;\n    void main() {\n       gl_FragColor = color;\n    }\n    ");
miniprogram.Shader.create("planarShadowShader", [
    miniprogram.Shader.find("pbr").subShaders[0].passes[0],
    planarShadow
]);

function _defineProperties$1(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
}

function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of$1(o, p);
}
function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of$1(subClass, superClass);
}

miniprogram.ShaderProperty.getByName("u_far");
miniprogram.ShaderProperty.getByName("u_near");
miniprogram.ShaderProperty.getByName("u_primaryScale");
miniprogram.ShaderProperty.getByName("u_secondaryScale");
miniprogram.ShaderProperty.getByName("u_gridIntensity");
miniprogram.ShaderProperty.getByName("u_axisIntensity");
miniprogram.ShaderProperty.getByName("u_flipProgress");
miniprogram.ShaderProperty.getByName("u_fade");
miniprogram.Shader.create("grid", "\n#include <common>\n\nattribute vec4 POSITION_FLIP;\n\nuniform mat4 camera_ViewInvMat;\nuniform mat4 camera_ProjMat;\nuniform vec4 camera_ProjectionParams;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n\n\nvec3 UnprojectPoint(float x, float y, float z, mat4 viewInvMat, mat4 projInvMat) {\n    vec4 unprojectedPoint =  viewInvMat * projInvMat * vec4(x, y, z, 1.0);\n    return unprojectedPoint.xyz / unprojectedPoint.w;\n}\n\n\nvoid main() {\n    float tol = 0.0001;\n    mat4 viewInvMat = camera_ViewInvMat;\n    if (abs(viewInvMat[3][1]) < tol) {\n        viewInvMat[3][1] = tol;\n    }\n    mat4 projInvMat = INVERSE_MAT(camera_ProjMat);\n\n    bool flipY = camera_ProjectionParams.x < 0.0;\n    float x = flipY? POSITION_FLIP.z : POSITION_FLIP.x;\n    float y = flipY? POSITION_FLIP.w : POSITION_FLIP.y;\n\n    nearPoint = UnprojectPoint(x, y, -1.0, viewInvMat, projInvMat);// unprojecting on the near plane\n    farPoint = UnprojectPoint(x, y, 1.0, viewInvMat, projInvMat);// unprojecting on the far plane\n    gl_Position = vec4(x, y, 0.0, 1.0);// using directly the clipped coordinates\n}", "\n#include <transform_declare>\n\nuniform float u_far;\nuniform float u_near;\nuniform float u_primaryScale;\nuniform float u_secondaryScale;\nuniform float u_gridIntensity;\nuniform float u_axisIntensity;\nuniform float u_flipProgress;\nuniform float u_fade;\n\nvarying vec3 nearPoint;\nvarying vec3 farPoint;\n  \nvec4 grid(vec3 fragPos3D, float scale, float fade) {\n    vec2 coord = mix(fragPos3D.xz, fragPos3D.xy, u_flipProgress) * scale;\n    vec2 derivative = fwidth(coord);\n    vec2 grid = abs(fract(coord - 0.5) - 0.5) / derivative;\n    float line = min(grid.x, grid.y);\n    float minimumz = min(derivative.y, 1.0);\n    float minimumx = min(derivative.x, 1.0);\n    vec4 color = vec4(u_gridIntensity, u_gridIntensity, u_gridIntensity, fade * (1.0 - min(line, 1.0)));\n    // z-axis\n    if (fragPos3D.x > -u_axisIntensity * minimumx && fragPos3D.x < u_axisIntensity * minimumx)\n        color.z = 1.0;\n    // x-axis or y-axis\n    float xy = mix(fragPos3D.z, fragPos3D.y, u_flipProgress);\n    if (xy > -u_axisIntensity * minimumz && xy < u_axisIntensity * minimumz)\n        color.x = 1.0;\n    return color;\n}\n\nfloat computeDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    // map to 0-1\n    return (clip_space_pos.z / clip_space_pos.w) * 0.5 + 0.5;\n}\n\nfloat computeLinearDepth(vec3 pos) {\n    vec4 clip_space_pos = camera_ProjMat * camera_ViewMat * vec4(pos.xyz, 1.0);\n    float clip_space_depth = clip_space_pos.z / clip_space_pos.w;\n    float linearDepth = (2.0 * u_near * u_far) / (u_far + u_near - clip_space_depth * (u_far - u_near));\n    return linearDepth / u_far;// normalize\n}\n\nvoid main() {\n    float ty = -nearPoint.y / (farPoint.y - nearPoint.y);\n    float tz = -nearPoint.z / (farPoint.z - nearPoint.z);\n    float t = mix(ty, tz, u_flipProgress);\n    vec3 fragPos3D = nearPoint + t * (farPoint - nearPoint);\n\n    gl_FragDepth = computeDepth(fragPos3D);\n\n    float linearDepth = computeLinearDepth(fragPos3D);\n    float fading = max(0.0, (0.5 - linearDepth));\n\n    // adding multiple resolution for the grid\n    gl_FragColor = (grid(fragPos3D, u_primaryScale, u_fade) + grid(fragPos3D, u_secondaryScale, 1.0 - u_fade));\n    gl_FragColor.a *= fading;\n}\n");

var vertexSource$2 = "\n  attribute vec3 POSITION;\n  attribute vec2 TEXCOORD_0;\n  attribute vec4 COLOR_0;\n  uniform mat4 renderer_MVPMat;\n  \n  uniform float u_time;\n  uniform vec2 u_foam_speed; \n  uniform vec2 u_distorsion_speed; \n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  varying vec4 v_color;\n      \n  void main() {\n    gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n    waterTexCoords = TEXCOORD_0 + vec2(u_foam_speed.x * u_time, u_foam_speed.y * u_time);\n    normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));\n    v_color = COLOR_0; \n  }\n  ";
var fragmentSource$2 = "\n  #include <common>\n  varying vec4 v_color;\n  varying vec2 waterTexCoords;\n  varying vec2 normalTexCoords;\n  uniform sampler2D material_NormalTexture;\n  uniform sampler2D u_foamTex;\n  uniform vec3 u_foamColor;\n  uniform vec2 u_foam_param;\n  uniform float u_distorsion_amount;\n  void main() {  \n    vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n    vec4 waterTex = texture2D(u_foamTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n    float alphaComp = v_color.r * waterTex.r * u_foam_param.x;\n    float alpha = pow(alphaComp,2.0);\n    alpha = smoothstep(0.5 - u_foam_param.y, 0.5+ u_foam_param.y, alpha);\n    alpha = saturate(alpha);\n    \n    gl_FragColor = vec4(u_foamColor.rgb, alpha);\n  }\n  ";
miniprogram.Shader.create("water-ripple", vertexSource$2, fragmentSource$2);
miniprogram.ShaderProperty.getByName("u_foamColor");
miniprogram.ShaderProperty.getByName("u_foam_speed");
miniprogram.ShaderProperty.getByName("u_foam_param");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_foamTex");

var vertexSource$1 = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n\n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_distorsion_speed; \n    \n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * sin(u_time), u_water_speed.y * cos(u_time));\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));     \n      \n      v_color = COLOR_0;\n    }\n    ";
var fragmentSource$1 = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_edgeTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {\n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 edgeTex = texture2D(u_edgeTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      float edge = pow((v_color.r + edgeTex.r) * v_color.r, 2.0);\n      edge = saturate(1.0 - smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edge));\n      vec4 finalCol = mix(waterTex, u_edgeColor, edge);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water", vertexSource$1, fragmentSource$1);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_edgeTex");

var vertexSource = "\n    attribute vec3 POSITION;\n    attribute vec2 TEXCOORD_0;\n    attribute vec4 COLOR_0;\n  \n    uniform mat4 renderer_MVPMat;\n    \n    uniform float u_time;\n    uniform vec2 u_water_speed; \n    uniform vec2 u_waterfall_speed; \n    uniform vec2 u_distorsion_speed; \n  \n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n    varying vec4 v_color;\n\n    void main() {\n      gl_Position = renderer_MVPMat * vec4(POSITION, 1.0);\n  \n      waterTexCoords = TEXCOORD_0 + vec2(u_water_speed.x * u_time, u_water_speed.y * u_time);\n      waterfallTexCoords = TEXCOORD_0 + vec2(u_waterfall_speed.x * u_time, u_waterfall_speed.y * u_time);\n      normalTexCoords = TEXCOORD_0 + vec2(u_distorsion_speed.x * cos(u_time), u_distorsion_speed.y * sin(u_time));    \n      \n      v_color = COLOR_0; \n    }\n    ";
var fragmentSource = "\n    #include <common>\n    varying vec4 v_color;\n    varying vec2 waterTexCoords;\n    varying vec2 waterfallTexCoords;\n    varying vec2 normalTexCoords;\n  \n    uniform sampler2D material_NormalTexture;\n    uniform sampler2D u_waterTex;\n    uniform sampler2D u_waterfallTex;\n    uniform sampler2D u_edgeNoiseTex;\n  \n    uniform vec4 u_edgeColor;\n    uniform vec2 u_edgeParam;\n    uniform float u_distorsion_amount;\n  \n    void main() {      \n      vec4 normalTex = texture2D(material_NormalTexture, normalTexCoords) * 2.0 - 1.0;\n      \n      vec4 waterTex = texture2D(u_waterTex, waterTexCoords + (normalTex.rg * u_distorsion_amount));\n      vec4 waterfallTex = texture2D(u_waterfallTex, waterfallTexCoords + (normalTex.rg * u_distorsion_amount));\n  \n      vec4 streamEdge = texture2D(u_edgeNoiseTex, waterTexCoords);\n      vec4 fallEdge = texture2D(u_edgeNoiseTex, waterfallTexCoords);\n  \n      float edgeShape = mix(fallEdge.r, streamEdge.r, v_color.r);\n      edgeShape = saturate(edgeShape * v_color.g);\n      edgeShape = saturate(smoothstep(u_edgeParam.x - u_edgeParam.y, u_edgeParam.x + u_edgeParam.y, edgeShape));\n  \n      vec4 waterAll = mix(waterfallTex, waterTex, v_color.r);\n      vec4 finalCol = mix(waterAll, u_edgeColor, edgeShape);\n  \n      gl_FragColor = finalCol;\n    }\n    ";
miniprogram.Shader.create("water-fall", vertexSource, fragmentSource);
miniprogram.ShaderProperty.getByName("u_water_speed");
miniprogram.ShaderProperty.getByName("u_waterfall_speed");
miniprogram.ShaderProperty.getByName("u_distorsion_speed");
miniprogram.ShaderProperty.getByName("u_edgeColor");
miniprogram.ShaderProperty.getByName("u_edgeParam");
miniprogram.ShaderProperty.getByName("u_distorsion_amount");
miniprogram.ShaderProperty.getByName("u_waterTex");
miniprogram.ShaderProperty.getByName("u_waterfallTex");
miniprogram.ShaderProperty.getByName("u_edgeNoiseTex");

var fragment = "\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n\n#include <FogFragmentDeclaration>\n\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\n\n#ifdef LIGHTMAP_TEXTURE\n    uniform sampler2D u_lightMapTexture;\n    uniform float u_lightMapIntensity;\n#endif\n\n\nvoid main() {\n    Geometry geometry;\n    Material material;\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n    initGeometry(geometry, gl_FrontFacing);\n    initMaterial(material, geometry);\n    \n    addTotalDirectRadiance(geometry, material, reflectedLight);\n    \n    \n    // IBL diffuse\n    #ifdef LIGHTMAP_TEXTURE\n        vec2 lightMapUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            lightMapUV = v_uv1;\n        #endif\n        reflectedLight.indirectDiffuse += texture2D(u_lightMapTexture, lightMapUV).rgb * u_lightMapIntensity * BRDF_Diffuse_Lambert( material.diffuseColor );\n    #endif\n    \n    // IBL specular\n    vec3 radiance = getLightProbeRadiance(geometry, geometry.normal, material.roughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity);\n    float radianceAttenuation = 1.0;\n    \n    #ifdef MATERIAL_CLEARCOAT\n        vec3 clearCoatRadiance = getLightProbeRadiance( geometry, geometry.clearCoatNormal, material.clearCoatRoughness, int(scene_EnvMapLight.mipMapLevel), scene_EnvMapLight.specularIntensity );\n    \n        reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * envBRDFApprox(vec3( 0.04 ), material.clearCoatRoughness, geometry.clearCoatDotNV);\n        radianceAttenuation -= material.clearCoat * F_Schlick(geometry.clearCoatDotNV);\n    #endif\n    \n    reflectedLight.indirectSpecular += radianceAttenuation * radiance * envBRDFApprox(material.specularColor, material.roughness, geometry.dotNV );\n    \n    \n    // Occlusion\n    #ifdef MATERIAL_OCCLUSIONTEXTURE\n        vec2 aoUV = v_uv;\n        #ifdef RENDERER_HAS_UV1\n            if(material_OcclusionTextureCoord == 1.0){\n                aoUV = v_uv1;\n            }\n        #endif\n        float ambientOcclusion = (texture2D(material_OcclusionTexture, aoUV).r - 1.0) * material_OcclusionIntensity + 1.0;\n        reflectedLight.indirectDiffuse *= ambientOcclusion;\n        #ifdef SCENE_USE_SPECULAR_ENV\n            reflectedLight.indirectSpecular *= computeSpecularOcclusion(ambientOcclusion, material.roughness, geometry.dotNV);\n        #endif\n    #endif\n        \n        \n    // Emissive\n    vec3 emissiveRadiance = material_EmissiveColor;\n    #ifdef MATERIAL_HAS_EMISSIVETEXTURE\n        vec4 emissiveColor = texture2D(material_EmissiveTexture, v_uv);\n        #ifndef ENGINE_IS_COLORSPACE_GAMMA\n            emissiveColor = gammaToLinear(emissiveColor);\n        #endif\n        emissiveRadiance *= emissiveColor.rgb;\n    #endif\n        \n    // Total\n    vec3 totalRadiance =    reflectedLight.directDiffuse + \n                            reflectedLight.indirectDiffuse + \n                            reflectedLight.directSpecular + \n                            reflectedLight.indirectSpecular + \n                            emissiveRadiance;\n                            \n        \n    gl_FragColor = vec4(totalRadiance, material.opacity);\n        \n    #include <FogFragment>\n        \n    #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n\n}\n";

var vertex = "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\n\nvoid main() {\n\n    #include <begin_position_vert>\n    #include <begin_normal_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <uv_vert>\n    #include <color_vert>\n    #include <normal_vert>\n    #include <worldpos_vert>\n    #include <position_vert>\n\n    #include <ShadowVertex>\n    #include <FogVertex>\n}\n";

miniprogram.Shader.create("bake-pbr", vertex, fragment);
miniprogram.ShaderProperty.getByName("u_lightMapTexture");
miniprogram.ShaderProperty.getByName("u_lightMapIntensity");

/**
 * plain color Material. don't effected by light and fog.
 */ var PlainColorMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$1(PlainColorMaterial, BaseMaterial);
    function PlainColorMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, miniprogram.Shader.find("plain-color")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.setColor(PlainColorMaterial._baseColorProp, new miniprogram.Color(1, 1, 1, 1));
        _this.renderState.rasterState.cullMode = miniprogram.CullMode.Off;
        return _this;
    }
    var _proto = PlainColorMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new PlainColorMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$1(PlainColorMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PlainColorMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PlainColorMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        }
    ]);
    return PlainColorMaterial;
}(miniprogram.BaseMaterial);
miniprogram.Shader.create("plain-color", "\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n\nvoid main() {\n    #include <begin_position_vert>\n    #include <blendShape_vert>\n    #include <skinning_vert>\n    #include <position_vert>\n}\n", "\n#include <common>\n\nuniform vec4 material_BaseColor;\n\nvoid main() {\n     vec4 baseColor = material_BaseColor;\n\n    #ifdef MATERIAL_IS_ALPHA_CUTOFF\n        if( baseColor.a < material_AlphaCutoff ) {\n            discard;\n        }\n    #endif\n\n    gl_FragColor = baseColor;\n\n     #ifndef ENGINE_IS_COLORSPACE_GAMMA\n        gl_FragColor = linearToGamma(gl_FragColor);\n    #endif\n}\n");

var Utils = /*#__PURE__*/ function() {
    function Utils() {}
    Utils.init = function init(engine) {
        // translate material
        Utils.redMaterialTrans = this._createPlainColorMaterial(engine, exports.State.translate, 1.0, 0.25, 0.25, 1.0);
        Utils.lightRedMaterial = this._createPlainColorMaterial(engine, exports.State.translate, 1.0, 0.25, 0.25, 0.9);
        Utils.greenMaterialTrans = this._createPlainColorMaterial(engine, exports.State.translate, 0.5, 0.8, 0.2, 1.0);
        Utils.lightGreenMaterial = this._createPlainColorMaterial(engine, exports.State.translate, 0.5, 0.8, 0.2, 0.9);
        Utils.blueMaterialTrans = this._createPlainColorMaterial(engine, exports.State.translate, 0.3, 0.5, 1.0, 1.0);
        Utils.lightBlueMaterial = this._createPlainColorMaterial(engine, exports.State.translate, 0.3, 0.5, 1.0, 0.9);
        Utils.invisibleMaterialTrans = this._createPlainColorMaterial(engine, exports.State.translate, 0, 0, 0, 0);
        // rotate material
        Utils.redArcMaterial = this._createPlainColorMaterial(engine, exports.State.rotate, 1.0, 0.25, 0.25);
        Utils.greenArcMaterial = this._createPlainColorMaterial(engine, exports.State.rotate, 0.5, 0.8, 0.2);
        Utils.blueArcMaterial = this._createPlainColorMaterial(engine, exports.State.rotate, 0.3, 0.5, 1.0);
        Utils.yellowMaterial = this._createPlainColorMaterial(engine, exports.State.rotate, 1.0, 0.95, 0.0, 1.0);
        Utils.rotatePlaneMaterial = this._createPlainColorMaterial(engine, exports.State.rotate, 1.0, 0.95, 0.0, 0.2);
        Utils.rotatePlaneMaterial.renderState.rasterState.cullMode = miniprogram.CullMode.Off;
        Utils.invisibleMaterialRotate = this._createPlainColorMaterial(engine, exports.State.rotate, 0, 0, 0, 0);
        Utils.invisibleMaterialRotate.renderState.rasterState.cullMode = miniprogram.CullMode.Off;
        Utils.invisibleMaterialCircle = this._createPlainColorMaterial(engine, exports.State.rotate, 0, 0, 0, 0);
        // scale material
        Utils.redMaterialScale = this._createPlainColorMaterial(engine, exports.State.scale, 1.0, 0.25, 0.25, 1.0);
        Utils.greenMaterialScale = this._createPlainColorMaterial(engine, exports.State.scale, 0.5, 0.8, 0.2, 1.0);
        Utils.blueMaterialScale = this._createPlainColorMaterial(engine, exports.State.scale, 0.3, 0.5, 1.0, 1.0);
        Utils.greyMaterial = this._createPlainColorMaterial(engine, exports.State.scale, 0.75, 0.75, 0.75, 1.0);
        Utils.lightMaterial = this._createPlainColorMaterial(engine, exports.State.scale, 0.7, 0.7, 0.7, 1.0);
        Utils.invisibleMaterialScale = this._createPlainColorMaterial(engine, exports.State.scale, 0, 0, 0, 0);
        Utils.lineMesh = miniprogram.PrimitiveMesh.createCylinder(engine, 0.02, 0.02, 1.5);
        Utils.lineMeshShort = miniprogram.PrimitiveMesh.createCylinder(engine, 0.02, 0.02, 1.3);
        Utils.axisArrowMesh = miniprogram.PrimitiveMesh.createCone(engine, 0.08, 0.3);
        Utils.axisPlaneMesh = miniprogram.PrimitiveMesh.createPlane(engine, 0.35, 0.35);
        Utils.axisCubeMesh = miniprogram.PrimitiveMesh.createCuboid(engine, 0.32, 0.32, 0.32);
        Utils.axisSphereMesh = miniprogram.PrimitiveMesh.createSphere(engine, 1.8, 48);
        Utils.axisEndCubeMesh = miniprogram.PrimitiveMesh.createCuboid(engine, 0.25, 0.25, 0.25);
        Utils.axisXTorusMesh = GizmoMesh.createCircleTube(engine, Math.PI, 1.6, 0.02);
        Utils.axisYTorusMesh = GizmoMesh.createCircleTube(engine, Math.PI, 1.6, 0.02);
        Utils.axisZTorusMesh = GizmoMesh.createCircleTube(engine, Math.PI, 1.6, 0.02);
        Utils.axisXYZTorusMesh = GizmoMesh.createCircleTube(engine, 2 * Math.PI, 1.8, 0.02);
        Utils.axisHelperLineMesh = miniprogram.PrimitiveMesh.createCylinder(engine, 0.15, 0.15, 1.75);
        Utils.axisHelperPlaneMesh = miniprogram.PrimitiveMesh.createPlane(engine, 0.75, 0.75);
        Utils.axisHelpertorusMesh = GizmoMesh.createCircleTube(engine, Math.PI, 1.6, 0.24);
        Utils.xAxisPositive = new miniprogram.Vector3(-1, 0, 0);
        Utils.yAxisPositive = new miniprogram.Vector3(0, -1, 0);
        Utils.zAxisPositive = new miniprogram.Vector3(0, 0, -1);
    };
    Utils._createPlainColorMaterial = function _createPlainColorMaterial(engine, name, r, g, b, a) {
        if (r === void 0) r = 1.0;
        if (g === void 0) g = 1.0;
        if (b === void 0) b = 1.0;
        if (a === void 0) a = 1.0;
        var material = new PlainColorMaterial(engine);
        material.isTransparent = true;
        material.renderState.depthState.enabled = false;
        material.baseColor.set(r, g, b, a);
        material.name = name.toString();
        return material;
    };
    return Utils;
}();
Utils.rotateCircleRadius = 1.6;
Utils.scaleFactor = 0.05773502691896257;

/**
 * @internal
 * Gizmo Component
 */ var GizmoComponent = /*#__PURE__*/ function(Component) {
    _inherits$2(GizmoComponent, Component);
    function GizmoComponent() {
        return Component.apply(this, arguments);
    }
    return GizmoComponent;
}(miniprogram.Component);
var axisType;
(function(axisType) {
    axisType[axisType["x"] = 0] = "x";
    axisType[axisType["y"] = 1] = "y";
    axisType[axisType["z"] = 2] = "z";
    axisType[axisType["xyz"] = 3] = "xyz";
    axisType[axisType["xy"] = 4] = "xy";
    axisType[axisType["yz"] = 5] = "yz";
    axisType[axisType["xz"] = 6] = "xz";
})(axisType || (axisType = {}));
var axisVector = [
    new miniprogram.Vector3(1, 0, 0),
    new miniprogram.Vector3(0, 1, 0),
    new miniprogram.Vector3(0, 0, 1),
    new miniprogram.Vector3(1, 1, 1),
    new miniprogram.Vector3(1, 1, 0),
    new miniprogram.Vector3(0, 1, 1),
    new miniprogram.Vector3(1, 0, 1)
];
var axisPlane = [
    new miniprogram.Plane(new miniprogram.Vector3(1, 0, 0), 0),
    new miniprogram.Plane(new miniprogram.Vector3(0, 1, 0), 0),
    new miniprogram.Plane(new miniprogram.Vector3(0, 0, 1), 0),
    new miniprogram.Plane(new miniprogram.Vector3(0, 0, 0), 0),
    new miniprogram.Plane(new miniprogram.Vector3(0, 0, 1), 0),
    new miniprogram.Plane(new miniprogram.Vector3(1, 0, 0), 0),
    new miniprogram.Plane(new miniprogram.Vector3(0, 1, 0), 0)
];

/** @internal */ var ScaleControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits$2(ScaleControl, GizmoComponent);
    function ScaleControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scaleFactor = 1;
        _this._scaleAxisComponent = [];
        _this._scaleControlMap = [];
        _this._preMatrix = new miniprogram.Matrix();
        _this._startGroupMatrix = new miniprogram.Matrix();
        _this._startInvMatrix = new miniprogram.Matrix();
        _this._startPoint = new miniprogram.Vector3();
        _this._factorVec = new miniprogram.Vector3();
        _this._currPoint = new miniprogram.Vector3();
        _this._plane = new miniprogram.Plane();
        _this._tempVec0 = new miniprogram.Vector3();
        _this._tempVec1 = new miniprogram.Vector3();
        _this._tempVec2 = new miniprogram.Vector3();
        _this._tempMat = new miniprogram.Matrix();
        _this.type = exports.State.scale;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = ScaleControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        miniprogram.Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        var _this = this, _startPoint = _this._startPoint, _scaleFactor = _this._scaleFactor;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        var localAxis = axisVector[this._selectedAxis];
        this._factorVec.set(_startPoint.x === 0 ? 0 : _scaleFactor * localAxis.x / _startPoint.x, _startPoint.y === 0 ? 0 : _scaleFactor * localAxis.y / _startPoint.y, _startPoint.z === 0 ? 0 : _scaleFactor * localAxis.z / _startPoint.z);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var _this = this, factorVec = _this._factorVec, scaleVec = _this._tempVec0, mat = _this._tempMat;
        miniprogram.Vector3.subtract(this._currPoint, this._startPoint, scaleVec);
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                scaleVec.x = scaleVec.x * factorVec.x + 1;
                scaleVec.y = scaleVec.y * factorVec.y + 1;
                scaleVec.z = scaleVec.z * factorVec.z + 1;
                break;
            case axisType.xyz:
                var start = this._startPoint.length();
                var end = this._currPoint.length();
                scaleVec.x = end / start;
                scaleVec.y = end / start;
                scaleVec.z = end / start;
                break;
        }
        miniprogram.Matrix.scale(this._startGroupMatrix, scaleVec, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "scale");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    _proto._initAxis = function _initAxis() {
        this._scaleControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.redMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, -90),
                    new miniprogram.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0.75, 0, 0),
                    new miniprogram.Vector3(1.5, 0, 0)
                ],
                priority: 102
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.greenMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 0),
                    new miniprogram.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0.75, 0),
                    new miniprogram.Vector3(0, 1.5, 0)
                ],
                priority: 102
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.blueMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 90),
                    new miniprogram.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0.75),
                    new miniprogram.Vector3(0, 0, 1.5)
                ],
                priority: 102
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisCubeMesh
                ],
                axisMaterial: Utils.greyMaterial,
                axisHelperMesh: [
                    Utils.axisCubeMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0)
                ],
                priority: 105
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXYZ = this.gizmoEntity.createChild("xyz");
        this._scaleAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._scaleControlMap.length; i++){
            var currentComponent = this._scaleAxisComponent[i];
            var currentGeometry = this._scaleControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
            case axisType.xyz:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                miniprogram.Vector3.cross(cameraP, localAxis, crossP);
                miniprogram.Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        miniprogram.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        miniprogram.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        var _this = this, _tempVec0 = _this._tempVec0, _tempMat = _this._tempMat;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            var s = isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.75 : this._camera.orthographicSize * Utils.scaleFactor * 3;
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(s, s, s));
        } else {
            var ele = _tempMat.elements;
            _tempVec0.set(ele[12], ele[13], ele[14]);
            var s1 = isModified ? miniprogram.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor * 0.75 : miniprogram.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
            var sx = s1 / Math.sqrt(Math.pow(ele[0], 2) + Math.pow(ele[1], 2) + Math.pow(ele[2], 2));
            var sy = s1 / Math.sqrt(Math.pow(ele[4], 2) + Math.pow(ele[5], 2) + Math.pow(ele[6], 2));
            var sz = s1 / Math.sqrt(Math.pow(ele[8], 2) + Math.pow(ele[9], 2) + Math.pow(ele[10], 2));
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(sx, sy, sz));
        }
    };
    return ScaleControl;
}(GizmoComponent);

/** @internal */ var TranslateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits$2(TranslateControl, GizmoComponent);
    function TranslateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scale = 1;
        _this._preMatrix = new miniprogram.Matrix();
        _this._startGroupMatrix = new miniprogram.Matrix();
        _this._startInvMatrix = new miniprogram.Matrix();
        _this._startScale = 1;
        _this._startPoint = new miniprogram.Vector3();
        _this._currPoint = new miniprogram.Vector3();
        _this._plane = new miniprogram.Plane();
        _this._tempVec0 = new miniprogram.Vector3();
        _this._tempVec1 = new miniprogram.Vector3();
        _this._tempVec2 = new miniprogram.Vector3();
        _this._tempMat = new miniprogram.Matrix();
        _this._tempScale = 1;
        _this.type = exports.State.translate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = TranslateControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        miniprogram.Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        // get start scale
        this._startScale = this._scale;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var currScale = this._scale;
        var _this = this, mat = _this._tempMat, subVec = _this._tempVec0, _startScale = _this._startScale;
        // eliminate the side effect of gizmo's scaling
        subVec.x = this._currPoint.x - this._startPoint.x / _startScale * currScale;
        subVec.y = this._currPoint.y - this._startPoint.y / _startScale * currScale;
        subVec.z = this._currPoint.z - this._startPoint.z / _startScale * currScale;
        var localAxis = axisVector[this._selectedAxis];
        mat.identity();
        mat.elements[12] = subVec.x * localAxis.x;
        mat.elements[13] = subVec.y * localAxis.y;
        mat.elements[14] = subVec.z * localAxis.z;
        miniprogram.Matrix.multiply(this._startGroupMatrix, mat, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "translate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        // recover axis cover
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch() {
        this._resizeControl();
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        switch(axisName){
            case "x":
                this._changeAxisAlpha("x", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "y":
                this._changeAxisAlpha("y", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "z":
                this._changeAxisAlpha("z", value);
                this._changeAxisAlpha("xz", value);
                this._changeAxisAlpha("yz", value);
                break;
        }
    };
    _proto._initAxis = function _initAxis() {
        this._translateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.redMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, -90),
                    new miniprogram.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0.75, 0, 0),
                    new miniprogram.Vector3(1.5, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.greenMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 0),
                    new miniprogram.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0.75, 0),
                    new miniprogram.Vector3(0, 1.5, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.blueMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 90),
                    new miniprogram.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0.75),
                    new miniprogram.Vector3(0, 0, 1.5)
                ]
            },
            {
                name: "xy",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightBlueMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0.5, 0.5, 0)
                ]
            },
            {
                name: "yz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightRedMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(90, 90, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0.5, 0.5)
                ]
            },
            {
                name: "xz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightGreenMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0.5, 0, 0.5)
                ]
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXY = this.gizmoEntity.createChild("xy");
        var axisYZ = this.gizmoEntity.createChild("yz");
        var axisXZ = this.gizmoEntity.createChild("xz");
        this._translateAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXY.addComponent(Axis),
            axisYZ.addComponent(Axis),
            axisXZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._translateControlMap.length; i++){
            var currentComponent = this._translateAxisComponent[i];
            var currentGeometry = this._translateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                miniprogram.Vector3.cross(cameraP, localAxis, crossP);
                miniprogram.Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
            case axisType.xy:
            case axisType.yz:
            case axisType.xz:
                this._plane.copyFrom(axisPlane[this._selectedAxis]);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        miniprogram.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        miniprogram.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        var _this = this, _tempMat = _this._tempMat, _tempVec0 = _this._tempVec0;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            this._tempScale = this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            _tempVec0.set(_tempMat.elements[12], _tempMat.elements[13], _tempMat.elements[14]);
            this._tempScale = this._scale = miniprogram.Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
        }
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = _tempMat.scale(_tempVec0.set(this._tempScale, this._tempScale, this._tempScale));
    };
    _proto._changeAxisAlpha = function _changeAxisAlpha(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    return TranslateControl;
}(GizmoComponent);

/** @internal */ var RotateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits$2(RotateControl, GizmoComponent);
    function RotateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._rotateAxisComponent = [];
        _this._rotateControlMap = [];
        _this._isModified = false;
        _this._startLineMesh = GizmoMesh.createLine(_this.engine, [
            new miniprogram.Vector3(0, 0, 0),
            new miniprogram.Vector3(0, 0, 0)
        ]);
        _this._endLineMesh = GizmoMesh.createLine(_this.engine, [
            new miniprogram.Vector3(0, 0, 0),
            new miniprogram.Vector3(0, 0, 0)
        ]);
        _this._rotateHelperPlaneMesh = GizmoMesh.createCircle(_this.engine);
        _this._preMatrix = new miniprogram.Matrix();
        _this._startMatrix = new miniprogram.Matrix();
        _this._startInvMatrix = new miniprogram.Matrix();
        _this._startPointUnit = new miniprogram.Vector3();
        _this._currPointUnit = new miniprogram.Vector3();
        _this._cameraPos = new miniprogram.Vector3();
        _this._previousRad = 0;
        _this._finalRad = 0;
        _this._verticalAxis = new miniprogram.Vector3(0, 1, 0);
        _this._horizontalAxis = new miniprogram.Vector3();
        _this._speedFactor = 0.01;
        _this._tempMat = new miniprogram.Matrix();
        _this._tempMat2 = new miniprogram.Matrix();
        _this._tempVec = new miniprogram.Vector3();
        _this._tempVec2 = new miniprogram.Vector3();
        _this._tempVec30 = new miniprogram.Vector3();
        _this._tempVec31 = new miniprogram.Vector3();
        _this._tempVec32 = new miniprogram.Vector3();
        _this._tempMat41 = new miniprogram.Matrix();
        _this._isAtBack = false;
        _this.type = exports.State.rotate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = RotateControl.prototype;
    /** init axis geometry */ _proto._initAxis = function _initAxis() {
        this._rotateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.axisXTorusMesh
                ],
                axisMaterial: Utils.redArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new miniprogram.Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.axisYTorusMesh
                ],
                axisMaterial: Utils.greenArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new miniprogram.Vector3(90, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.axisZTorusMesh
                ],
                axisMaterial: Utils.blueArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0)
                ]
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisXYZTorusMesh
                ],
                axisMaterial: Utils.lightMaterial,
                axisHelperMesh: [
                    Utils.axisSphereMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialCircle,
                axisRotation: [
                    new miniprogram.Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new miniprogram.Vector3(0, 0, 0)
                ],
                priority: 99
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        // visible gizmo entity
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        this._axisX = this.gizmoEntity.createChild("x");
        this._axisY = this.gizmoEntity.createChild("y");
        this._axisZ = this.gizmoEntity.createChild("z");
        this._axisXYZ = this.gizmoEntity.createChild("xyz");
        this._rotateAxisComponent = [
            this._axisX.addComponent(Axis),
            this._axisY.addComponent(Axis),
            this._axisZ.addComponent(Axis),
            this._axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._rotateControlMap.length; i++){
            var currentComponent = this._rotateAxisComponent[i];
            var currentGeometry = this._rotateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
        var axisHelpers = this.gizmoHelperEntity.children;
        this._axisXHelper = axisHelpers[0];
        this._axisYHelper = axisHelpers[1];
        this._axisZHelper = axisHelpers[2];
        this._axisXYZHelper = axisHelpers[3];
        // rotate gizmo in-process debug helper entity
        this._gizmoRotateHelperEntity = entity.createChild("helper");
        // rotate start line
        this._startLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperS");
        var startHelperRenderer = this._startLineHelperEntity.addComponent(miniprogram.MeshRenderer);
        startHelperRenderer.receiveShadows = false;
        startHelperRenderer.castShadows = false;
        startHelperRenderer.mesh = this._startLineMesh;
        startHelperRenderer.setMaterial(Utils.yellowMaterial);
        startHelperRenderer.priority = 90;
        // rotate end line
        this._endLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperE");
        var endHelperRenderer = this._endLineHelperEntity.addComponent(miniprogram.MeshRenderer);
        endHelperRenderer.receiveShadows = false;
        endHelperRenderer.castShadows = false;
        endHelperRenderer.mesh = this._endLineMesh;
        endHelperRenderer.setMaterial(Utils.yellowMaterial);
        endHelperRenderer.priority = 90;
        // rotate plane
        this._rotateHelperPlaneEntity = this._gizmoRotateHelperEntity.createChild("rotateHelperPlane");
        var planeHelperRenderer = this._rotateHelperPlaneEntity.addComponent(miniprogram.MeshRenderer);
        planeHelperRenderer.receiveShadows = false;
        planeHelperRenderer.castShadows = false;
        planeHelperRenderer.mesh = this._rotateHelperPlaneMesh;
        // @ts-ignore
        this._rotateHelperPlaneMesh._enableVAO = false;
        planeHelperRenderer.setMaterial(Utils.rotatePlaneMaterial);
        planeHelperRenderer.priority = 90;
        this._rotateHelperPlaneEntity.isActive = false;
    };
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        var _this = this, group = _this._group, startP = _this._startPointUnit, startMat = _this._startMatrix, tempVec = _this._tempVec, tempMat = _this._tempMat;
        group.getWorldMatrix(startMat);
        this._preMatrix.copyFrom(startMat);
        miniprogram.Matrix.invert(startMat, this._startInvMatrix);
        var s = this._getGizmoScale();
        this._tempMat.copyFrom(startMat).scale(tempVec.set(s, s, s));
        this.gizmoEntity.transform.worldMatrix = tempMat;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._gizmoRotateHelperEntity.transform.worldMatrix = tempMat;
                this._calRayIntersection(ray, startP);
                this._setAxisSelected(this._selectedAxis, true);
                GizmoMesh.updateLine(this._startLineMesh, [
                    new miniprogram.Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateLine(this._endLineMesh, [
                    new miniprogram.Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, axisVector[axisName], 0);
                this._startLineHelperEntity.isActive = true;
                this._endLineHelperEntity.isActive = true;
                this._rotateHelperPlaneEntity.isActive = true;
                this._startLineHelperEntity.transform.setRotation(0, 0, 0);
                this._endLineHelperEntity.transform.setRotation(0, 0, 0);
                this._rotateHelperPlaneEntity.transform.setRotation(0, 0, 0);
                break;
            case axisType.xyz:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._setAxisSelected(this._selectedAxis, true);
                this._isAtBack = this.gizmoEntity.transform.worldUp.y < 0;
                this._isAtBack ? this._verticalAxis.set(0, -1, 0) : this._verticalAxis.set(0, 1, 0);
                break;
        }
    };
    _proto.onMove = function onMove(ray, pointer) {
        var _this = this, startP = _this._startPointUnit, currP = _this._currPointUnit, startMat = _this._startMatrix, mat = _this._tempMat2, group = _this._group, tempVec = _this._tempVec;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var localAxis = axisVector[this._selectedAxis];
                this._calRayIntersection(ray, currP);
                var rad = this._getFinalRad(startP, currP, localAxis);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, localAxis, rad);
                miniprogram.Matrix.rotateAxisAngle(startMat, localAxis, rad, mat);
                group.applyTransform(this._preMatrix, mat);
                this._preMatrix.copyFrom(mat);
                var d = rad / Math.PI * 180;
                this._endLineHelperEntity.transform.setRotation(d * localAxis.x, d * localAxis.y, d * localAxis.z);
                break;
            case axisType.xyz:
                var _pointer_deltaPosition = pointer.deltaPosition, x = _pointer_deltaPosition.x, y = _pointer_deltaPosition.y;
                var _this1 = this, hAxis = _this1._horizontalAxis, vAxis = _this1._verticalAxis;
                hAxis.copyFrom(this._camera.entity.transform.worldUp);
                miniprogram.Vector3.cross(hAxis, vAxis, hAxis);
                this._isAtBack ? hAxis.scale(-y) : hAxis.scale(y);
                tempVec.copyFrom(vAxis);
                this._isAtBack ? tempVec.scale(-x) : tempVec.scale(x);
                miniprogram.Vector3.add(hAxis, tempVec, tempVec);
                miniprogram.Vector3.transformNormal(tempVec, this._startInvMatrix, tempVec);
                var angle = pointer.deltaPosition.length() * this._speedFactor;
                miniprogram.Matrix.rotateAxisAngle(startMat, tempVec, angle, startMat);
                group.applyTransform(this._preMatrix, startMat);
                this._preMatrix.copyFrom(startMat);
                miniprogram.Matrix.invert(startMat, this._startInvMatrix);
                break;
        }
        this.engine.dispatch("gizmo-move", "rotate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        this._finalRad = 0;
        this._previousRad = 0;
        // recover axis color
        this._setAxisSelected(this._selectedAxis, false);
        // recover arc line
        var axisMesh = this._rotateControlMap[this._selectedAxis].axisMesh[0];
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                GizmoMesh.updateCircleTube(axisMesh, Math.PI);
                // hide helper entity
                this._endLineHelperEntity.isActive = false;
                this._startLineHelperEntity.isActive = false;
                this._rotateHelperPlaneEntity.isActive = false;
                break;
            case axisType.xyz:
                GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI, 1.8);
                break;
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
        this._updateAxisTransform();
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {};
    _proto._setAxisSelected = function _setAxisSelected(axis, isSelected) {
        var axisMesh = this._rotateControlMap[axis].axisMesh[0];
        GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI);
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === axis) {
                if (isSelected) {
                    currComponent.yellow && currComponent.yellow();
                } else {
                    currComponent.recover && currComponent.recover();
                }
            }
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        // transform ray to local space
        var worldToLocal = this._startInvMatrix;
        miniprogram.Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        miniprogram.Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(axisPlane[this._selectedAxis]), out);
        out.normalize().scale(Utils.rotateCircleRadius);
    };
    _proto._getFinalRad = function _getFinalRad(p1, p2, rotateAxis) {
        var dot = miniprogram.Vector3.dot(p1, p2);
        miniprogram.Vector3.cross(p1, p2, this._tempVec);
        var direction = miniprogram.Vector3.dot(this._tempVec, rotateAxis);
        var currentRad = Math.sign(direction) * Math.acos(dot / Math.pow(Utils.rotateCircleRadius, 2));
        var incrementRad = currentRad - this._previousRad;
        if (this._previousRad * currentRad < 0) {
            Math.abs(currentRad) < Math.PI / 2 ? this._finalRad += incrementRad : this._finalRad += -Math.sign(incrementRad) * (2 * Math.PI - Math.abs(incrementRad));
        } else {
            this._finalRad += incrementRad;
        }
        this._previousRad = currentRad;
        return this._finalRad;
    };
    _proto._getGizmoScale = function _getGizmoScale() {
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldPosition(this._tempVec);
        if (this._camera.isOrthographic) {
            return this._isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.8 : this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            return this._isModified ? miniprogram.Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor * 0.8 : miniprogram.Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor;
        }
    };
    _proto._updateAxisTransform = function _updateAxisTransform() {
        var _this = this, _tempMat = _this._tempMat, _tempVec = _this._tempVec, _tempVec2 = _this._tempVec2, _cameraPos = _this._cameraPos;
        // 
        _cameraPos.copyFrom(this._camera.entity.transform.worldPosition);
        var gizmoTrans = this.gizmoEntity.transform;
        // (Gizmo  -> )
        miniprogram.Vector3.subtract(_cameraPos, gizmoTrans.worldPosition, _tempVec);
        //  -> Gizmo
        miniprogram.Matrix.invert(gizmoTrans.worldMatrix, _tempMat);
        // (Gizmo  -> ) Gizmo  XYZ 
        miniprogram.Vector3.transformNormal(_tempVec, _tempMat, _tempVec2);
        var factor = miniprogram.MathUtil.radToDegreeFactor;
        var x = _tempVec2.x, y = _tempVec2.y, z = _tempVec2.z;
        //  yoz  X 
        this._axisX.transform.rotation.x = this._axisXHelper.transform.rotation.x = -Math.atan2(y, z) * factor;
        //  xoz  Y 
        this._axisY.transform.rotation.y = this._axisYHelper.transform.rotation.y = Math.atan2(x, z) * factor;
        //  yox  Z 
        this._axisZ.transform.rotation.z = this._axisZHelper.transform.rotation.z = Math.atan2(y, x) * factor;
        // xyz 
        this._localLookAt(this._axisXYZ.transform, _tempVec2);
        this._axisXYZHelper.transform.rotationQuaternion = this._axisXYZ.transform.rotationQuaternion;
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        this._group.getWorldMatrix(this._tempMat);
        this._isModified = isModified;
        var s = this._getGizmoScale();
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = this._tempMat.scale(this._tempVec.set(s, s, s));
    };
    _proto._localLookAt = function _localLookAt(transform, targetPosition) {
        var zAxis = this._tempVec30;
        miniprogram.Vector3.subtract(transform.position, targetPosition, zAxis);
        zAxis.normalize();
        var xAxis = this._tempVec31.set(zAxis.z, 0, -zAxis.x).normalize();
        var yAxis = this._tempVec32;
        miniprogram.Vector3.cross(zAxis, xAxis, yAxis);
        yAxis.normalize();
        var rotMat = this._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(transform.rotationQuaternion);
    };
    return RotateControl;
}(GizmoComponent);

/**
 * Gizmo Anchor State
 */ exports.AnchorType = void 0;
(function(AnchorType) {
    /**
   * positions the Gizmo at the actual pivot point
   */ AnchorType[AnchorType["Pivot"] = 0] = "Pivot";
    /**
   * positions the Gizmo at the center of the selected entity or entities rendered bounds
   */ AnchorType[AnchorType["Center"] = 1] = "Center";
})(exports.AnchorType || (exports.AnchorType = {}));
exports.CoordinateType = void 0;
(function(CoordinateType) {
    /**
   * aligns to the selected entity or entities local space
   */ CoordinateType[CoordinateType["Local"] = 0] = "Local";
    /**
   * aligns to the world space orientation
   */ CoordinateType[CoordinateType["Global"] = 1] = "Global";
})(exports.CoordinateType || (exports.CoordinateType = {}));

var GroupDirtyFlag;
(function(GroupDirtyFlag) {
    /**
   * none
   */ GroupDirtyFlag[GroupDirtyFlag["None"] = 0] = "None";
    /**
   * anchor changed
   */ GroupDirtyFlag[GroupDirtyFlag["AnchorDirty"] = 1] = "AnchorDirty";
    /**
   * coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["CoordinateDirty"] = 2] = "CoordinateDirty";
    /**
   * anchor & coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["All"] = 3] = "All";
})(GroupDirtyFlag || (GroupDirtyFlag = {}));
/**
 * Group
 */ var Group = /*#__PURE__*/ function() {
    function Group() {
        // @internal
        this._gizmoTransformDirty = true;
        this._entities = [];
        this._listeners = [];
        this._worldMatrix = new miniprogram.Matrix();
        this._anchorType = exports.AnchorType.Pivot;
        this._coordinateType = exports.CoordinateType.Local;
        this._dirtyFlag = 3;
    }
    var _proto = Group.prototype;
    /**
   * add entity to the group
   * @param addEntity - entity to add
   */ _proto.addEntity = function addEntity(addEntity) {
        var _this = this, entities = _this._entities;
        var canAdd = true;
        for(var j = entities.length - 1; j >= 0; j--){
            var compareEntity = entities[j];
            if (compareEntity === addEntity) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(compareEntity, addEntity)) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(addEntity, compareEntity)) {
                this._applyDel(j);
            }
        }
        if (canAdd) {
            this._applyAdd(addEntity);
        }
        return canAdd;
    };
    /**
   * add entities to the group
   * @param addEntities - entities to add, in array
   */ _proto.addEntities = function addEntities(addEntities) {
        for(var i = addEntities.length - 1; i >= 0; i--){
            this.addEntity(addEntities[i]);
        }
    };
    /**
   * remove entity from the group
   * @param delEntity - entity to delete
   */ _proto.deleteEntity = function deleteEntity(delEntity) {
        this._applyDel(delEntity);
    };
    /**
   * remove entities from the group
   * @param delEntities - entities to delete, in array
   */ _proto.deleteEntities = function deleteEntities(delEntities) {
        for(var i = delEntities.length - 1; i >= 0; i--){
            this.deleteEntity(delEntities[i]);
        }
    };
    /**
   * get entity index in group
   * @param entity
   * @return number, -1 if not in group
   */ _proto.getIndexOf = function getIndexOf(entity) {
        var _this = this, entities = _this._entities;
        return entities.findIndex(function(ele) {
            return entity === ele;
        });
    };
    /**
   * clear the group
   */ _proto.reset = function reset() {
        this._entities.length = 0;
        var _this = this, listeners = _this._listeners;
        for(var i = listeners.length - 1; i >= 0; i--){
            var listener = listeners[i];
            listener.flagManager.removeListener(listener.fun);
        }
        listeners.length = 0;
        this._dirtyFlag = 3;
    };
    /**
   * get group's world matrix
   * @param out - updated world matrix for the group
   * @return boolean, true if group's world matrix needs update
   */ _proto.getWorldMatrix = function getWorldMatrix(out) {
        if (this._entities.length <= 0) {
            return false;
        } else {
            this._updateAnchor();
            this._updateCoordinate();
            out && out.copyFrom(this._worldMatrix);
            return true;
        }
    };
    /**
   * get group's world position
   * @param out - updated world position for the group
   */ _proto.getWorldPosition = function getWorldPosition(out) {
        if (this.getWorldMatrix()) {
            var _this__worldMatrix = this._worldMatrix, ele = _this__worldMatrix.elements;
            out.set(ele[12], ele[13], ele[14]);
        }
    };
    /**
   * 
   * from  local 
   * to  world 
   * @param from - 
   * @param to - 
   */ _proto.applyTransform = function applyTransform(from, to) {
        var _this = this, entities = _this._entities;
        if (this._entities.length <= 0) {
            return;
        }
        if (miniprogram.Matrix.equals(from, to)) {
            return;
        }
        // old worldMatrix.
        var groupWorldInvMat = Group._tempMat0, nodeMat = Group._tempMat1;
        miniprogram.Matrix.invert(from, groupWorldInvMat);
        // update entities worldMatrix
        for(var i = entities.length - 1; i >= 0; i--){
            var nodeTrans = entities[i].transform;
            // get entity's localMatrix.
            miniprogram.Matrix.multiply(groupWorldInvMat, nodeTrans.worldMatrix, nodeMat);
            // update entity's worldMatrix.
            miniprogram.Matrix.multiply(to, nodeMat, nodeMat);
            nodeTrans.worldMatrix = nodeMat;
        }
    };
    /**
   * force update group dirty flag
   * @param flag - group dirty flag
   */ _proto.setDirtyFlagTrue = function setDirtyFlagTrue(flag) {
        this._dirtyFlag |= flag;
        this._gizmoTransformDirty = true;
    };
    _proto._applyAdd = function _applyAdd(entity) {
        this._entities.push(entity);
        var fun = this._onEntityWorldTransformChange(entity);
        // @ts-ignore
        var flagManager = entity.transform._updateFlagManager;
        flagManager.addListener(fun);
        this._listeners.push({
            flagManager: flagManager,
            fun: fun
        });
        fun();
    };
    _proto._applyDel = function _applyDel(value) {
        var index = typeof value === "number" ? value : this._entities.indexOf(value);
        if (index === 0) {
            if (this._coordinateType === exports.CoordinateType.Local) {
                this.setDirtyFlagTrue(3);
            } else {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener = this._listeners[index];
            listener.flagManager.removeListener(listener.fun);
            this._listeners.splice(index, 1);
        } else if (index > 0) {
            if (this._anchorType === exports.AnchorType.Center) {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener1 = this._listeners[index];
            listener1.flagManager.removeListener(listener1.fun);
            this._listeners.splice(index, 1);
        }
    };
    _proto._onEntityWorldTransformChange = function _onEntityWorldTransformChange(entity) {
        var _this = this;
        return function() {
            if (_this._entities.indexOf(entity) === 0) {
                if (_this._coordinateType === exports.CoordinateType.Local) {
                    _this.setDirtyFlagTrue(3);
                } else {
                    _this.setDirtyFlagTrue(1);
                }
            } else {
                if (_this._anchorType === exports.AnchorType.Center) {
                    _this.setDirtyFlagTrue(1);
                }
            }
        };
    };
    _proto._hasRelationship = function _hasRelationship(parent, compareChild) {
        while(compareChild.parent){
            if (parent === compareChild.parent) {
                return true;
            } else {
                compareChild = compareChild.parent;
            }
        }
        return false;
    };
    _proto._updateAnchor = function _updateAnchor() {
        if (this._dirtyFlag & 1) {
            var _this = this, worldMatrix = _this._worldMatrix;
            var tempVec3 = Group._tempVec30;
            var e = worldMatrix.elements;
            switch(this._anchorType){
                case exports.AnchorType.Center:
                    this._getCenter(tempVec3);
                    e[12] = tempVec3.x, e[13] = tempVec3.y, e[14] = tempVec3.z;
                    break;
                case exports.AnchorType.Pivot:
                    // align to the first entity
                    var worldE = this._entities[0].transform.worldMatrix.elements;
                    e[12] = worldE[12], e[13] = worldE[13], e[14] = worldE[14];
                    break;
            }
            this._dirtyFlag &= ~1;
        }
    };
    _proto._updateCoordinate = function _updateCoordinate() {
        if (this._dirtyFlag & 2) {
            var _this__worldMatrix = this._worldMatrix, e = _this__worldMatrix.elements;
            switch(this._coordinateType){
                case exports.CoordinateType.Local:
                    // align to the first entity
                    var wE = this._entities[0].transform.worldMatrix.elements;
                    var sx = 1 / Math.sqrt(Math.pow(wE[0], 2) + Math.pow(wE[1], 2) + Math.pow(wE[2], 2));
                    var sy = 1 / Math.sqrt(Math.pow(wE[4], 2) + Math.pow(wE[5], 2) + Math.pow(wE[6], 2));
                    var sz = 1 / Math.sqrt(Math.pow(wE[8], 2) + Math.pow(wE[9], 2) + Math.pow(wE[10], 2));
                    e[0] = wE[0] * sx, e[4] = wE[4] * sy, e[8] = wE[8] * sz;
                    e[1] = wE[1] * sx, e[5] = wE[5] * sy, e[9] = wE[9] * sz;
                    e[2] = wE[2] * sx, e[6] = wE[6] * sy, e[10] = wE[10] * sz;
                    break;
                case exports.CoordinateType.Global:
                    e[0] = 1, e[4] = 0, e[8] = 0;
                    e[1] = 0, e[5] = 1, e[9] = 0;
                    e[2] = 0, e[6] = 0, e[10] = 1;
                    break;
            }
            this._dirtyFlag &= ~2;
        }
    };
    _proto._getCenter = function _getCenter(out) {
        var tempBoundBox = Group._tempBoundBox;
        tempBoundBox.min.set(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        tempBoundBox.max.set(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        var _this = this, entities = _this._entities;
        var isEffective = false;
        for(var i = entities.length - 1; i >= 0; i--){
            var entity = entities[i];
            var renderers = entity.getComponentsIncludeChildren(miniprogram.Renderer, []);
            isEffective || (isEffective = renderers.length > 0);
            for(var j = renderers.length - 1; j >= 0; j--){
                var renderer = renderers[j];
                if (renderer.entity.isActiveInHierarchy) {
                    miniprogram.BoundingBox.merge(tempBoundBox, renderers[j].bounds, tempBoundBox);
                }
            }
        }
        var length = tempBoundBox.getExtent(out).length();
        if (length <= 0 || length >= Number.MAX_VALUE) {
            isEffective = false;
        }
        if (isEffective) {
            tempBoundBox.getCenter(out);
        } else {
            out.set(0, 0, 0);
            for(var i1 = entities.length - 1; i1 >= 0; i1--){
                out.add(entities[i1].transform.worldPosition);
            }
            out.scale(1 / entities.length);
        }
    };
    _create_class$2(Group, [
        {
            key: "anchorType",
            get: /**
   * get anchor type
   * @return anchor type, pivot or center
   */ function get() {
                return this._anchorType;
            },
            set: function set(value) {
                if (this._anchorType !== value) {
                    this._anchorType = value;
                    this.setDirtyFlagTrue(1);
                }
            }
        },
        {
            key: "coordinateType",
            get: /**
   * get coordinate type
   * @return coordinate type, world or local
   */ function get() {
                return this._coordinateType;
            },
            set: function set(value) {
                if (this._coordinateType !== value) {
                    this._coordinateType = value;
                    this.setDirtyFlagTrue(2);
                }
            }
        }
    ]);
    return Group;
}();
Group._tempVec30 = new miniprogram.Vector3();
Group._tempMat0 = new miniprogram.Matrix();
Group._tempMat1 = new miniprogram.Matrix();
Group._tempBoundBox = new miniprogram.BoundingBox();

function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var fs = "#define GLSLIFY 1\n#include <common>\nuniform vec3 u_pickColor;void main(){gl_FragColor=vec4(u_pickColor,1.0);}"; // eslint-disable-line
var vs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <position_vert>\n}"; // eslint-disable-line
var pickShader = miniprogram.Shader.create("framebuffer-picker-color", vs, fs);
pickShader.subShaders.forEach(function(subShader) {
    subShader.passes.forEach(function(pass) {
        pass.setTag("spriteDisableBatching", true);
    });
});
var FramebufferPicker = /*#__PURE__*/ function(Script) {
    _inherits(FramebufferPicker, Script);
    function FramebufferPicker() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this._renderersMap = [];
        _this._frameBufferSize = new miniprogram.Vector2(1024, 1024);
        return _this;
    }
    var _proto = FramebufferPicker.prototype;
    _proto.onAwake = function onAwake() {
        this._camera = this.entity.getComponent(miniprogram.Camera);
    };
    /**
   * Pick up renderer at screen coordinate.
   * @param x - The x coordinate of screen
   * @param y - The y coordinate of screen
   * @returns Promise<Renderer>
   */ _proto.pick = function pick(x, y) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this._setupRenderTarget();
            // Pick up renderer
            var pickedPixel = _this._readPixelFromRenderTarget(x, y);
            var renderer = _this._getRendererByPixel(pickedPixel);
            resolve(renderer);
        });
    };
    /**
   * Pick up renderers in a rectangular region of the screen.
   * @param startX - The start x coordinate of screen
   * @param startY - The start y coordinate of screen
   * @param endX - The end x coordinate of screen
   * @param endY - The end y coordinate of screen
   * @returns Promise<Array<Renderer>>
   */ _proto.regionPick = function regionPick(startX, startY, endX, endY) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            _this._setupRenderTarget();
            var pickedPixel = _this._readPixelFromRenderTarget(startX, startY, endX, endY);
            var renderer = _this._getRenderersByPixel(pickedPixel);
            resolve(renderer);
        });
    };
    _proto._checkFrameBufferSize = function _checkFrameBufferSize() {
        var pickRenderTarget = this._pickRenderTarget;
        var engine = this.engine;
        var size = this._frameBufferSize;
        if (!pickRenderTarget || size.x != pickRenderTarget.width || size.y != pickRenderTarget.height) {
            pickRenderTarget && pickRenderTarget.destroy();
            this._pickRenderTarget = new miniprogram.RenderTarget(engine, size.x, size.y, new miniprogram.Texture2D(engine, size.x, size.y, miniprogram.TextureFormat.R8G8B8A8, false));
        }
    };
    _proto._updateRenderersPickColor = function _updateRenderersPickColor(scene) {
        var currentRendererIndex = 0;
        var renderersMap = this._renderersMap;
        var rootEntityRenderers = FramebufferPicker._rootEntityRenderers;
        var rootEntities = scene.rootEntities;
        var pickColorProperty = FramebufferPicker._pickColorProperty;
        for(var i = 0, n = rootEntities.length; i < n; i++){
            rootEntities[i].getComponentsIncludeChildren(miniprogram.Renderer, rootEntityRenderers);
            for(var j = 0, m = rootEntityRenderers.length; j < m; j++){
                var renderer = rootEntityRenderers[j];
                var shaderData = renderer.shaderData;
                // Init pick color
                var pickColor = shaderData.getVector3(pickColorProperty);
                if (!pickColor) {
                    pickColor = new miniprogram.Vector3();
                    shaderData.setVector3(pickColorProperty, pickColor);
                }
                // Set pick color
                this._uniqueId2Color(++currentRendererIndex, pickColor);
                renderersMap[currentRendererIndex] = renderer;
            }
        }
    };
    _proto._setupRenderTarget = function _setupRenderTarget() {
        // Check frame buffer size
        this._checkFrameBufferSize();
        var camera = this._camera;
        var originalPostProcessEnabled = camera.enablePostProcess;
        var originalHDR = camera.enableHDR;
        var originalDepthMode = camera.depthTextureMode;
        var originalOpaqueTextureEnabled = camera.opaqueTextureEnabled;
        this._updateRenderersPickColor(camera.scene);
        // Prepare render target and shader
        var lastRenderTarget = camera.renderTarget;
        var lastRatio = camera.aspectRatio;
        camera.renderTarget = this._pickRenderTarget;
        camera.setReplacementShader(pickShader);
        camera.aspectRatio = lastRatio;
        // Reset internal RT and useless pass
        camera.enablePostProcess = false;
        camera.enableHDR = false;
        camera.depthTextureMode = miniprogram.DepthTextureMode.None;
        camera.opaqueTextureEnabled = false;
        camera.render();
        // Revert render target and shader
        camera.resetReplacementShader();
        camera.renderTarget = lastRenderTarget;
        camera.resetAspectRatio();
        // Revert internal RT and original pass
        camera.enablePostProcess = originalPostProcessEnabled;
        camera.enableHDR = originalHDR;
        camera.depthTextureMode = originalDepthMode;
        camera.opaqueTextureEnabled = originalOpaqueTextureEnabled;
    };
    _proto._readPixelFromRenderTarget = function _readPixelFromRenderTarget(x, y, xEnd, yEnd) {
        var pickPixel, width, height;
        var startCoord = this._getCoordOnRenderTarget(x, y);
        var argsLength = arguments.length;
        if (argsLength === 2) {
            pickPixel = FramebufferPicker._pickPixel;
            width = height = 1;
        } else if (argsLength === 4) {
            var endCoord = this._getCoordOnRenderTarget(xEnd, yEnd);
            width = Math.abs(startCoord.x - endCoord.x);
            height = Math.abs(startCoord.y - endCoord.y);
            startCoord.x = startCoord.x < endCoord.x ? startCoord.x : endCoord.x;
            startCoord.y = startCoord.y < endCoord.y ? startCoord.y : endCoord.y;
            pickPixel = new Uint8Array(width * height * 4);
        }
        this._pickRenderTarget.getColorTexture().getPixelBuffer(startCoord.x, startCoord.y, width, height, 0, pickPixel);
        return pickPixel;
    };
    _proto._getCoordOnRenderTarget = function _getCoordOnRenderTarget(x, y) {
        var pickRenderTarget = this._pickRenderTarget;
        var canvas = this.engine.canvas;
        var viewport = this._camera.viewport;
        var viewWidth = (viewport.z - viewport.x) * canvas.width;
        var viewHeight = (viewport.w - viewport.y) * canvas.height;
        return {
            x: Math.floor((x - viewport.x) / viewWidth * (pickRenderTarget.width - 1)),
            y: Math.floor((y - viewport.y) / viewHeight * (pickRenderTarget.height - 1))
        };
    };
    _proto._getRendererByPixel = function _getRendererByPixel(color) {
        return this._renderersMap[this._color2UniqueId(color)];
    };
    _proto._getRenderersByPixel = function _getRenderersByPixel(color) {
        var _this = this;
        var pickedRenderers = [];
        var rendererIds = this._color2UniqueIds(color);
        rendererIds.forEach(function(value) {
            _this._renderersMap[value] && pickedRenderers.push(_this._renderersMap[value]);
        });
        return pickedRenderers;
    };
    _proto._uniqueId2Color = function _uniqueId2Color(uniqueId, outColor) {
        if (uniqueId >= 0xffffff) {
            miniprogram.Logger.warn("Framebuffer Picker encounter primitive's id greater than " + 0xffffff);
            outColor.set(0, 0, 0);
        }
        outColor.set((uniqueId & 0xff) / 255, ((uniqueId & 0xff00) >> 8) / 255, ((uniqueId & 0xff0000) >> 16) / 255);
    };
    _proto._color2UniqueId = function _color2UniqueId(color) {
        return color[0] | color[1] << 8 | color[2] << 16;
    };
    _proto._color2UniqueIds = function _color2UniqueIds(color) {
        FramebufferPicker._pickIds.clear();
        for(var i = 0; i < color.length; i += 4){
            var a = color[i] | color[i + 1] << 8 | color[i + 2] << 16;
            FramebufferPicker._pickIds.add(a);
        }
        return FramebufferPicker._pickIds;
    };
    _create_class(FramebufferPicker, [
        {
            key: "frameBufferSize",
            get: function get() {
                return this._frameBufferSize;
            },
            set: function set(value) {
                this._frameBufferSize = value;
            }
        }
    ]);
    return FramebufferPicker;
}(miniprogram.Script);
FramebufferPicker._rootEntityRenderers = [];
FramebufferPicker._pickPixel = new Uint8Array(4);
FramebufferPicker._pickIds = new Set();
FramebufferPicker._pickColorProperty = miniprogram.ShaderProperty.getByName("u_pickColor");
FramebufferPicker = __decorate([
    miniprogram.dependentComponents(miniprogram.Camera, miniprogram.DependentMode.CheckOnly)
], FramebufferPicker);

/**
 * Gizmo controls, including translate, rotate, scale
 */ var Gizmo = /*#__PURE__*/ function(Script) {
    _inherits$2(Gizmo, Script);
    function Gizmo(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.epsilon = 0.05;
        _this._initialized = false;
        _this._isStarted = false;
        _this._lastDistance = -1;
        _this._lastOrthoSize = -1;
        _this._lastIsOrtho = false;
        _this._controlMap = [];
        _this._group = new Group();
        _this._tempVec30 = new miniprogram.Vector3();
        _this._tempVec31 = new miniprogram.Vector3();
        _this._worldMat = new miniprogram.Matrix();
        _this._tempRay = new miniprogram.Ray();
        _this._tempRay2 = new miniprogram.Ray();
        _this._type = null;
        _this._scalar = 1;
        if (!_this.entity.engine.physicsManager) {
            throw new Error("PhysicsManager is not initialized");
        }
        Utils.init(_this.engine);
        // setup mesh
        _this._createGizmoControl(exports.State.translate, TranslateControl);
        _this._createGizmoControl(exports.State.rotate, RotateControl);
        _this._createGizmoControl(exports.State.scale, ScaleControl);
        _this.layer = miniprogram.Layer.Layer31;
        _this.state = _this._type;
        return _this;
    }
    var _proto = Gizmo.prototype;
    /**
   * initial scene camera & select group in gizmo
   */ _proto.init = function init(camera, group) {
        var _this = this;
        if (camera !== this._sceneCamera) {
            if (camera) {
                this._group = group;
                this._sceneCamera = camera;
                this._framebufferPicker = camera.entity.addComponent(FramebufferPicker);
                this._framebufferPicker.frameBufferSize = new miniprogram.Vector2(256, 256);
                this._controlMap.forEach(function(gizmoControl) {
                    gizmoControl.init(camera, _this._group);
                });
                this._initialized = true;
            } else {
                this._initialized = false;
            }
        }
    };
    _proto.onUpdate = function onUpdate() {
        var _this = this;
        if (!this._initialized) {
            return;
        }
        var inputManager = this.engine.inputManager;
        var pointers = inputManager.pointers;
        var pointer = pointers.find(function(pointer) {
            return pointer.phase !== miniprogram.PointerPhase.Up && pointer.phase !== miniprogram.PointerPhase.Leave;
        });
        if (this._lastIsOrtho !== this._sceneCamera.isOrthographic) {
            this._lastIsOrtho = this._sceneCamera.isOrthographic;
            this._traverseControl(this._type, function(control) {
                _this._type === exports.State.all ? control.onSwitch(true) : control.onSwitch(false);
            });
        }
        this._group.getWorldPosition(this._tempVec30);
        if (this._isStarted) {
            if (pointer && (pointer.pressedButtons & miniprogram.PointerButton.Primary) !== 0) {
                if (pointer.deltaPosition.x !== 0 || pointer.deltaPosition.y !== 0) {
                    this._triggerGizmoMove();
                }
            } else {
                this._triggerGizmoEnd();
            }
            if (this._group._gizmoTransformDirty) {
                this._traverseControl(this._type, function(control) {
                    _this._type === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                });
                this._group._gizmoTransformDirty = false;
            }
        } else {
            this._group.getWorldPosition(this._tempVec30);
            var cameraPosition = this._sceneCamera.entity.transform.worldPosition;
            var currDistance = miniprogram.Vector3.distance(cameraPosition, this._tempVec30);
            var distanceDirty = false;
            if (Math.abs(this._lastDistance - currDistance) > miniprogram.MathUtil.zeroTolerance) {
                distanceDirty = true;
                this._lastDistance = currDistance;
            }
            var orthoSizeDirty = false;
            if (this._sceneCamera.isOrthographic && Math.abs(this._lastOrthoSize - this._sceneCamera.orthographicSize) > miniprogram.MathUtil.zeroTolerance) {
                orthoSizeDirty = true;
                this._lastOrthoSize = this._sceneCamera.orthographicSize;
            }
            if (this._group._gizmoTransformDirty || distanceDirty || orthoSizeDirty) {
                this._traverseControl(this._type, function(control) {
                    _this._type === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                });
                this._group._gizmoTransformDirty = false;
            }
            if (pointer) {
                var _pointer_position = pointer.position, x = _pointer_position.x, y = _pointer_position.y;
                var canvas = this.engine.canvas;
                if (x <= 0 || y <= 0 || x > canvas.width || y > canvas.height) {
                    return;
                }
                if (inputManager.isPointerDown(miniprogram.PointerButton.Primary)) {
                    this._framebufferPicker.pick(pointer.position.x, pointer.position.y).then(function(result) {
                        if (result) {
                            _this._selectHandler(result, pointer.position);
                        }
                    });
                } else {
                    var originLayer = this._sceneCamera.cullingMask;
                    this._sceneCamera.cullingMask = this._layer;
                    var result = this._framebufferPicker.pick(pointer.position.x, pointer.position.y);
                    this._sceneCamera.cullingMask = originLayer;
                    result.then(function(result) {
                        _this._overHandler(result);
                    });
                }
            }
        }
    };
    _proto.onLateUpdate = function onLateUpdate(deltaTime) {
        this._adjustAxisAlpha();
    };
    _proto._createGizmoControl = function _createGizmoControl(type, gizmoComponent) {
        var control = this.entity.createChild(type.toString()).addComponent(gizmoComponent);
        this._controlMap.push(control);
    };
    _proto._onGizmoHoverStart = function _onGizmoHoverStart(currentType, axisName) {
        var _this = this;
        this._traverseControl(currentType, function(control) {
            _this._currentControl = control;
        });
        this._currentControl.onHoverStart(axisName);
    };
    _proto._onGizmoHoverEnd = function _onGizmoHoverEnd() {
        this._currentControl && this._currentControl.onHoverEnd();
    };
    _proto._triggerGizmoStart = function _triggerGizmoStart(currentType, axisName) {
        var _this = this;
        this._isStarted = true;
        this._onGizmoHoverEnd();
        var pointer = this.engine.inputManager.pointers.find(function(pointer) {
            return pointer.phase !== miniprogram.PointerPhase.Up && pointer.phase !== miniprogram.PointerPhase.Leave;
        });
        if (pointer) {
            this._sceneCamera.screenPointToRay(pointer.position, this._tempRay);
            this._traverseControl(currentType, function(control) {
                _this._currentControl = control;
            }, function(control) {
                control.entity.isActive = false;
            });
            this._currentControl.onMoveStart(this._tempRay, axisName);
            this.engine.dispatch("gizmo-move-start", axisName);
        }
    };
    _proto._triggerGizmoMove = function _triggerGizmoMove() {
        var pointer = this.engine.inputManager.pointers.find(function(pointer) {
            return pointer.phase !== miniprogram.PointerPhase.Up && pointer.phase !== miniprogram.PointerPhase.Leave;
        });
        this._sceneCamera.screenPointToRay(pointer.position, this._tempRay2);
        this._currentControl.onMove(this._tempRay2, pointer);
    };
    _proto._triggerGizmoEnd = function _triggerGizmoEnd() {
        this._currentControl && this._currentControl.onMoveEnd();
        this._group.setDirtyFlagTrue(GroupDirtyFlag.CoordinateDirty);
        this._traverseControl(this._type, function(control) {
            control.entity.isActive = true;
        });
        this._isStarted = false;
        this.engine.dispatch("gizmo-move-end");
    };
    _proto._selectHandler = function _selectHandler(result, pointerPosition) {
        var material = result.getMaterial();
        var currentControl = parseInt(material.name);
        var selectedEntity = result.entity;
        switch(selectedEntity.layer){
            case this._layer:
                this._triggerGizmoStart(currentControl, selectedEntity.name);
                break;
        }
    };
    _proto._overHandler = function _overHandler(result) {
        if (result) {
            var material = result.getMaterial();
            var currentControl = parseInt(material.name);
            var hoverEntity = result.entity;
            this._onGizmoHoverStart(currentControl, hoverEntity.name);
        } else {
            this._onGizmoHoverEnd();
        }
    };
    _proto._traverseEntity = function _traverseEntity(entity, callback) {
        callback(entity);
        for(var _iterator = _create_for_of_iterator_helper_loose(entity.children), _step; !(_step = _iterator()).done;){
            var child = _step.value;
            this._traverseEntity(child, callback);
        }
    };
    _proto._traverseControl = function _traverseControl(targetType, callbackForTarget, callbackForOther) {
        if (targetType === void 0) targetType = this._type;
        this._controlMap.forEach(function(control) {
            if ((targetType & control.type) != 0) {
                callbackForTarget(control);
            } else {
                if (callbackForOther) {
                    callbackForOther(control);
                }
            }
        });
    };
    _proto._adjustAxisAlpha = function _adjustAxisAlpha() {
        var _this = this;
        var xAxisPositive = Utils.xAxisPositive, yAxisPositive = Utils.yAxisPositive, zAxisPositive = Utils.zAxisPositive;
        this._traverseControl(this._type, function(control) {
            control.onAlphaChange("x", _this._getAlphaFactor(xAxisPositive));
            control.onAlphaChange("y", _this._getAlphaFactor(yAxisPositive));
            control.onAlphaChange("z", _this._getAlphaFactor(zAxisPositive));
        });
    };
    _proto._getAlphaFactor = function _getAlphaFactor(axis) {
        var _this = this, worldMat = _this._worldMat, cameraDir = _this._tempVec30, tempVec = _this._tempVec31, epsilon = _this.epsilon;
        cameraDir.copyFrom(this._sceneCamera.entity.transform.worldForward).normalize();
        this._group.getWorldMatrix(worldMat);
        // angel between camera direction and gizmo axis direction
        miniprogram.Vector3.transformNormal(axis, worldMat, tempVec);
        var cosThetaDir = Math.abs(miniprogram.Vector3.dot(tempVec, cameraDir));
        if (this._sceneCamera.isOrthographic) {
            return 1 - cosThetaDir < epsilon ? miniprogram.MathUtil.clamp((1 - cosThetaDir) / epsilon, 0, 1) : 1;
        } else {
            // perspective camera needs to consider position
            // angle between camera direction and camera-entity position
            this._group.getWorldPosition(tempVec);
            miniprogram.Vector3.subtract(this._sceneCamera.entity.transform.worldPosition, tempVec, tempVec);
            var cosThetaPos = Math.abs(miniprogram.Vector3.dot(tempVec.normalize(), cameraDir));
            var minFactor = Math.min(cosThetaDir, cosThetaPos);
            var maxFactor = Math.max(cosThetaDir, cosThetaPos);
            return 1 - maxFactor < epsilon ? miniprogram.MathUtil.clamp((1 - minFactor) / epsilon, 0, 1) : 1;
        }
    };
    _create_class$2(Gizmo, [
        {
            key: "layer",
            get: /**
   * gizmo layer, default Layer31
   * @return the layer for gizmo entity and gizmo's inner framebuffer picker
   * @remarks Layer duplicate warning, check whether this layer is taken
   */ function get() {
                return this._layer;
            },
            set: function set(layer) {
                if (this._layer !== layer) {
                    this._layer = layer;
                    this._traverseEntity(this.entity, function(entity) {
                        entity.layer = layer;
                    });
                }
            }
        },
        {
            key: "state",
            get: /**
   * change gizmo type
   * @return current gizmo type - translate, or rotate, scale, null, all, default null
   */ function get() {
                return this._type;
            },
            set: function set(targetState) {
                this._type = targetState;
                this._traverseControl(targetState, function(control) {
                    control.entity.isActive = true;
                    targetState === exports.State.all ? control.onUpdate(true) : control.onUpdate(false);
                }, function(control) {
                    control.entity.isActive = false;
                });
            }
        },
        {
            key: "size",
            get: /**
   * change gizmo size
   * @return current gizmo size - min 0.01, default 1
   */ function get() {
                return this._scalar;
            },
            set: function set(value) {
                this._scalar = miniprogram.MathUtil.clamp(value, 0.01, Infinity);
                Utils.scaleFactor = this._scalar * 0.05773502691896257;
            }
        }
    ]);
    return Gizmo;
}(miniprogram.Script);

exports.Gizmo = Gizmo;
exports.Group = Group;
