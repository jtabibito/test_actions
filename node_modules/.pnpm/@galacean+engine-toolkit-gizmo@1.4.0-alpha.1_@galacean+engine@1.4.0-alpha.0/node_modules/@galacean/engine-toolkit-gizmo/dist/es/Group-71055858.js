import { Vector3, Matrix, BoundingBox, Renderer } from '@galacean/engine';
import { CoordinateType, AnchorType } from './enums/GroupState.js';

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

var GroupDirtyFlag;
(function(GroupDirtyFlag) {
    /**
   * none
   */ GroupDirtyFlag[GroupDirtyFlag["None"] = 0] = "None";
    /**
   * anchor changed
   */ GroupDirtyFlag[GroupDirtyFlag["AnchorDirty"] = 1] = "AnchorDirty";
    /**
   * coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["CoordinateDirty"] = 2] = "CoordinateDirty";
    /**
   * anchor & coordinate changed
   */ GroupDirtyFlag[GroupDirtyFlag["All"] = 3] = "All";
})(GroupDirtyFlag || (GroupDirtyFlag = {}));
/**
 * Group
 */ var Group = /*#__PURE__*/ function() {
    function Group() {
        // @internal
        this._gizmoTransformDirty = true;
        this._entities = [];
        this._listeners = [];
        this._worldMatrix = new Matrix();
        this._anchorType = AnchorType.Pivot;
        this._coordinateType = CoordinateType.Local;
        this._dirtyFlag = 3;
    }
    var _proto = Group.prototype;
    /**
   * add entity to the group
   * @param addEntity - entity to add
   */ _proto.addEntity = function addEntity(addEntity) {
        var _this = this, entities = _this._entities;
        var canAdd = true;
        for(var j = entities.length - 1; j >= 0; j--){
            var compareEntity = entities[j];
            if (compareEntity === addEntity) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(compareEntity, addEntity)) {
                canAdd = false;
                break;
            } else if (this._hasRelationship(addEntity, compareEntity)) {
                this._applyDel(j);
            }
        }
        if (canAdd) {
            this._applyAdd(addEntity);
        }
        return canAdd;
    };
    /**
   * add entities to the group
   * @param addEntities - entities to add, in array
   */ _proto.addEntities = function addEntities(addEntities) {
        for(var i = addEntities.length - 1; i >= 0; i--){
            this.addEntity(addEntities[i]);
        }
    };
    /**
   * remove entity from the group
   * @param delEntity - entity to delete
   */ _proto.deleteEntity = function deleteEntity(delEntity) {
        this._applyDel(delEntity);
    };
    /**
   * remove entities from the group
   * @param delEntities - entities to delete, in array
   */ _proto.deleteEntities = function deleteEntities(delEntities) {
        for(var i = delEntities.length - 1; i >= 0; i--){
            this.deleteEntity(delEntities[i]);
        }
    };
    /**
   * get entity index in group
   * @param entity
   * @return number, -1 if not in group
   */ _proto.getIndexOf = function getIndexOf(entity) {
        var _this = this, entities = _this._entities;
        return entities.findIndex(function(ele) {
            return entity === ele;
        });
    };
    /**
   * clear the group
   */ _proto.reset = function reset() {
        this._entities.length = 0;
        var _this = this, listeners = _this._listeners;
        for(var i = listeners.length - 1; i >= 0; i--){
            var listener = listeners[i];
            listener.flagManager.removeListener(listener.fun);
        }
        listeners.length = 0;
        this._dirtyFlag = 3;
    };
    /**
   * get group's world matrix
   * @param out - updated world matrix for the group
   * @return boolean, true if group's world matrix needs update
   */ _proto.getWorldMatrix = function getWorldMatrix(out) {
        if (this._entities.length <= 0) {
            return false;
        } else {
            this._updateAnchor();
            this._updateCoordinate();
            out && out.copyFrom(this._worldMatrix);
            return true;
        }
    };
    /**
   * get group's world position
   * @param out - updated world position for the group
   */ _proto.getWorldPosition = function getWorldPosition(out) {
        if (this.getWorldMatrix()) {
            var _this__worldMatrix = this._worldMatrix, ele = _this__worldMatrix.elements;
            out.set(ele[12], ele[13], ele[14]);
        }
    };
    /**
   * 从上个状态的矩阵变换到目标矩阵
   * from 矩阵计算所有节点的在本次变换中的 local 姿态
   * to 矩阵计算所有节点的在本次变换后的 world 姿态
   * @param from - 初始矩阵
   * @param to - 目标矩阵
   */ _proto.applyTransform = function applyTransform(from, to) {
        var _this = this, entities = _this._entities;
        if (this._entities.length <= 0) {
            return;
        }
        if (Matrix.equals(from, to)) {
            return;
        }
        // old worldMatrix.
        var groupWorldInvMat = Group._tempMat0, nodeMat = Group._tempMat1;
        Matrix.invert(from, groupWorldInvMat);
        // update entities worldMatrix
        for(var i = entities.length - 1; i >= 0; i--){
            var nodeTrans = entities[i].transform;
            // get entity's localMatrix.
            Matrix.multiply(groupWorldInvMat, nodeTrans.worldMatrix, nodeMat);
            // update entity's worldMatrix.
            Matrix.multiply(to, nodeMat, nodeMat);
            nodeTrans.worldMatrix = nodeMat;
        }
    };
    /**
   * force update group dirty flag
   * @param flag - group dirty flag
   */ _proto.setDirtyFlagTrue = function setDirtyFlagTrue(flag) {
        this._dirtyFlag |= flag;
        this._gizmoTransformDirty = true;
    };
    _proto._applyAdd = function _applyAdd(entity) {
        this._entities.push(entity);
        var fun = this._onEntityWorldTransformChange(entity);
        // @ts-ignore
        var flagManager = entity.transform._updateFlagManager;
        flagManager.addListener(fun);
        this._listeners.push({
            flagManager: flagManager,
            fun: fun
        });
        fun();
    };
    _proto._applyDel = function _applyDel(value) {
        var index = typeof value === "number" ? value : this._entities.indexOf(value);
        if (index === 0) {
            if (this._coordinateType === CoordinateType.Local) {
                this.setDirtyFlagTrue(3);
            } else {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener = this._listeners[index];
            listener.flagManager.removeListener(listener.fun);
            this._listeners.splice(index, 1);
        } else if (index > 0) {
            if (this._anchorType === AnchorType.Center) {
                this.setDirtyFlagTrue(1);
            }
            this._entities.splice(index, 1);
            var listener1 = this._listeners[index];
            listener1.flagManager.removeListener(listener1.fun);
            this._listeners.splice(index, 1);
        }
    };
    _proto._onEntityWorldTransformChange = function _onEntityWorldTransformChange(entity) {
        var _this = this;
        return function() {
            if (_this._entities.indexOf(entity) === 0) {
                if (_this._coordinateType === CoordinateType.Local) {
                    _this.setDirtyFlagTrue(3);
                } else {
                    _this.setDirtyFlagTrue(1);
                }
            } else {
                if (_this._anchorType === AnchorType.Center) {
                    _this.setDirtyFlagTrue(1);
                }
            }
        };
    };
    _proto._hasRelationship = function _hasRelationship(parent, compareChild) {
        while(compareChild.parent){
            if (parent === compareChild.parent) {
                return true;
            } else {
                compareChild = compareChild.parent;
            }
        }
        return false;
    };
    _proto._updateAnchor = function _updateAnchor() {
        if (this._dirtyFlag & 1) {
            var _this = this, worldMatrix = _this._worldMatrix;
            var tempVec3 = Group._tempVec30;
            var e = worldMatrix.elements;
            switch(this._anchorType){
                case AnchorType.Center:
                    this._getCenter(tempVec3);
                    e[12] = tempVec3.x, e[13] = tempVec3.y, e[14] = tempVec3.z;
                    break;
                case AnchorType.Pivot:
                    // align to the first entity
                    var worldE = this._entities[0].transform.worldMatrix.elements;
                    e[12] = worldE[12], e[13] = worldE[13], e[14] = worldE[14];
                    break;
            }
            this._dirtyFlag &= ~1;
        }
    };
    _proto._updateCoordinate = function _updateCoordinate() {
        if (this._dirtyFlag & 2) {
            var _this__worldMatrix = this._worldMatrix, e = _this__worldMatrix.elements;
            switch(this._coordinateType){
                case CoordinateType.Local:
                    // align to the first entity
                    var wE = this._entities[0].transform.worldMatrix.elements;
                    var sx = 1 / Math.sqrt(Math.pow(wE[0], 2) + Math.pow(wE[1], 2) + Math.pow(wE[2], 2));
                    var sy = 1 / Math.sqrt(Math.pow(wE[4], 2) + Math.pow(wE[5], 2) + Math.pow(wE[6], 2));
                    var sz = 1 / Math.sqrt(Math.pow(wE[8], 2) + Math.pow(wE[9], 2) + Math.pow(wE[10], 2));
                    e[0] = wE[0] * sx, e[4] = wE[4] * sy, e[8] = wE[8] * sz;
                    e[1] = wE[1] * sx, e[5] = wE[5] * sy, e[9] = wE[9] * sz;
                    e[2] = wE[2] * sx, e[6] = wE[6] * sy, e[10] = wE[10] * sz;
                    break;
                case CoordinateType.Global:
                    e[0] = 1, e[4] = 0, e[8] = 0;
                    e[1] = 0, e[5] = 1, e[9] = 0;
                    e[2] = 0, e[6] = 0, e[10] = 1;
                    break;
            }
            this._dirtyFlag &= ~2;
        }
    };
    _proto._getCenter = function _getCenter(out) {
        var tempBoundBox = Group._tempBoundBox;
        tempBoundBox.min.set(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
        tempBoundBox.max.set(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
        var _this = this, entities = _this._entities;
        var isEffective = false;
        for(var i = entities.length - 1; i >= 0; i--){
            var entity = entities[i];
            var renderers = entity.getComponentsIncludeChildren(Renderer, []);
            isEffective || (isEffective = renderers.length > 0);
            for(var j = renderers.length - 1; j >= 0; j--){
                var renderer = renderers[j];
                if (renderer.entity.isActiveInHierarchy) {
                    BoundingBox.merge(tempBoundBox, renderers[j].bounds, tempBoundBox);
                }
            }
        }
        var length = tempBoundBox.getExtent(out).length();
        if (length <= 0 || length >= Number.MAX_VALUE) {
            isEffective = false;
        }
        if (isEffective) {
            tempBoundBox.getCenter(out);
        } else {
            out.set(0, 0, 0);
            for(var i1 = entities.length - 1; i1 >= 0; i1--){
                out.add(entities[i1].transform.worldPosition);
            }
            out.scale(1 / entities.length);
        }
    };
    _create_class(Group, [
        {
            key: "anchorType",
            get: /**
   * get anchor type
   * @return anchor type, pivot or center
   */ function get() {
                return this._anchorType;
            },
            set: function set(value) {
                if (this._anchorType !== value) {
                    this._anchorType = value;
                    this.setDirtyFlagTrue(1);
                }
            }
        },
        {
            key: "coordinateType",
            get: /**
   * get coordinate type
   * @return coordinate type, world or local
   */ function get() {
                return this._coordinateType;
            },
            set: function set(value) {
                if (this._coordinateType !== value) {
                    this._coordinateType = value;
                    this.setDirtyFlagTrue(2);
                }
            }
        }
    ]);
    return Group;
}();
Group._tempVec30 = new Vector3();
Group._tempMat0 = new Matrix();
Group._tempMat1 = new Matrix();
Group._tempBoundBox = new BoundingBox();

export { GroupDirtyFlag as G, _create_class as _, Group as a };
//# sourceMappingURL=Group-71055858.js.map
