import { _ as _inherits } from './_inherits-5a51c3d0.js';
import { _ as _create_for_of_iterator_helper_loose } from './_create_for_of_iterator_helper_loose-e17e7001.js';
import { Matrix, Vector3, Plane } from '@galacean/engine';
import { Axis } from './Axis.js';
import { Utils } from './Utils.js';
import { axisType, axisVector, GizmoComponent } from './Type.js';
import { State } from './enums/GizmoState.js';
import './GizmoMesh-b318dff0.js';
import '@galacean/engine-toolkit-custom-material';

/** @internal */ var ScaleControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(ScaleControl, GizmoComponent);
    function ScaleControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scaleFactor = 1;
        _this._scaleAxisComponent = [];
        _this._scaleControlMap = [];
        _this._preMatrix = new Matrix();
        _this._startGroupMatrix = new Matrix();
        _this._startInvMatrix = new Matrix();
        _this._startPoint = new Vector3();
        _this._factorVec = new Vector3();
        _this._currPoint = new Vector3();
        _this._plane = new Plane();
        _this._tempVec0 = new Vector3();
        _this._tempVec1 = new Vector3();
        _this._tempVec2 = new Vector3();
        _this._tempMat = new Matrix();
        _this.type = State.scale;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = ScaleControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        var _this = this, _startPoint = _this._startPoint, _scaleFactor = _this._scaleFactor;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        var localAxis = axisVector[this._selectedAxis];
        this._factorVec.set(_startPoint.x === 0 ? 0 : _scaleFactor * localAxis.x / _startPoint.x, _startPoint.y === 0 ? 0 : _scaleFactor * localAxis.y / _startPoint.y, _startPoint.z === 0 ? 0 : _scaleFactor * localAxis.z / _startPoint.z);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var _this = this, factorVec = _this._factorVec, scaleVec = _this._tempVec0, mat = _this._tempMat;
        Vector3.subtract(this._currPoint, this._startPoint, scaleVec);
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                scaleVec.x = scaleVec.x * factorVec.x + 1;
                scaleVec.y = scaleVec.y * factorVec.y + 1;
                scaleVec.z = scaleVec.z * factorVec.z + 1;
                break;
            case axisType.xyz:
                var start = this._startPoint.length();
                var end = this._currPoint.length();
                scaleVec.x = end / start;
                scaleVec.y = end / start;
                scaleVec.z = end / start;
                break;
        }
        Matrix.scale(this._startGroupMatrix, scaleVec, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "scale");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    _proto._initAxis = function _initAxis() {
        this._scaleControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.redMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new Vector3(0, 0, -90),
                    new Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new Vector3(0.75, 0, 0),
                    new Vector3(1.5, 0, 0)
                ],
                priority: 102
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.greenMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new Vector3(0, 90, 0),
                    new Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0.75, 0),
                    new Vector3(0, 1.5, 0)
                ],
                priority: 102
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMeshShort,
                    Utils.axisEndCubeMesh
                ],
                axisMaterial: Utils.blueMaterialScale,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new Vector3(0, 90, 90),
                    new Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0.75),
                    new Vector3(0, 0, 1.5)
                ],
                priority: 102
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisCubeMesh
                ],
                axisMaterial: Utils.greyMaterial,
                axisHelperMesh: [
                    Utils.axisCubeMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialScale,
                axisRotation: [
                    new Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0)
                ],
                priority: 105
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXYZ = this.gizmoEntity.createChild("xyz");
        this._scaleAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._scaleControlMap.length; i++){
            var currentComponent = this._scaleAxisComponent[i];
            var currentGeometry = this._scaleControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
            case axisType.xyz:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                Vector3.cross(cameraP, localAxis, crossP);
                Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        var _this = this, _tempVec0 = _this._tempVec0, _tempMat = _this._tempMat;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            var s = isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.75 : this._camera.orthographicSize * Utils.scaleFactor * 3;
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(s, s, s));
        } else {
            var ele = _tempMat.elements;
            _tempVec0.set(ele[12], ele[13], ele[14]);
            var s1 = isModified ? Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor * 0.75 : Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
            var sx = s1 / Math.sqrt(Math.pow(ele[0], 2) + Math.pow(ele[1], 2) + Math.pow(ele[2], 2));
            var sy = s1 / Math.sqrt(Math.pow(ele[4], 2) + Math.pow(ele[5], 2) + Math.pow(ele[6], 2));
            var sz = s1 / Math.sqrt(Math.pow(ele[8], 2) + Math.pow(ele[9], 2) + Math.pow(ele[10], 2));
            this.entity.transform.worldMatrix = this._tempMat.scale(this._tempVec0.set(sx, sy, sz));
        }
    };
    return ScaleControl;
}(GizmoComponent);

export { ScaleControl };
//# sourceMappingURL=Scale.js.map
