import { ContentRestorer, Quaternion, Vector3, ModelMesh, MeshTopology, Vector2 } from '@galacean/engine';
import { _ as _inherits } from './_inherits-5a51c3d0.js';

/**
 * @internal
 */ var GizmoMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GizmoMeshRestorer, ContentRestorer);
    function GizmoMeshRestorer(resource, primitiveInfo) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.primitiveInfo = primitiveInfo;
        return _this;
    }
    var _proto = GizmoMeshRestorer.prototype;
    /**
   * @override
   */ _proto.restoreContent = function restoreContent() {
        var primitiveInfo = this.primitiveInfo;
        switch(primitiveInfo.type){
            case 0:
                var circleInfo = primitiveInfo;
                GizmoMesh.updateCircle(this.resource, circleInfo.startPoint, circleInfo.normal, circleInfo.thetaLength, circleInfo.center);
                break;
            case 2:
                var tubeInfo = primitiveInfo;
                GizmoMesh.updateCircleTube(this.resource, tubeInfo.arc, tubeInfo.radius, tubeInfo.tubeRadius, tubeInfo.tubularSegments, tubeInfo.radialSegments);
                break;
            case 1:
                var lineInfo = primitiveInfo;
                GizmoMesh.updateLine(this.resource, lineInfo.points);
                break;
        }
    };
    return GizmoMeshRestorer;
}(ContentRestorer);
var GizmoMeshType;
(function(GizmoMeshType) {
    GizmoMeshType[GizmoMeshType["Circle"] = 0] = "Circle";
    GizmoMeshType[GizmoMeshType["Line"] = 1] = "Line";
    GizmoMeshType[GizmoMeshType["CircleTube"] = 2] = "CircleTube";
})(GizmoMeshType || (GizmoMeshType = {}));
/**
 * @internal
 */ var GizmoMeshRestoreInfo = function GizmoMeshRestoreInfo(type) {
    this.type = type;
};
/**
 * @internal
 */ var CircleRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(CircleRestoreInfo, GizmoMeshRestoreInfo);
    function CircleRestoreInfo(startPoint, normal, thetaLength, center) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 0) || this;
        _this.startPoint = startPoint;
        _this.normal = normal;
        _this.thetaLength = thetaLength;
        _this.center = center;
        return _this;
    }
    return CircleRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var CircleTubeRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(CircleTubeRestoreInfo, GizmoMeshRestoreInfo);
    function CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 2) || this;
        _this.arc = arc;
        _this.radius = radius;
        _this.tubeRadius = tubeRadius;
        _this.tubularSegments = tubularSegments;
        _this.radialSegments = radialSegments;
        return _this;
    }
    return CircleTubeRestoreInfo;
}(GizmoMeshRestoreInfo);
/**
 * @internal
 */ var LineRestoreInfo = /*#__PURE__*/ function(GizmoMeshRestoreInfo) {
    _inherits(LineRestoreInfo, GizmoMeshRestoreInfo);
    function LineRestoreInfo(points) {
        var _this;
        _this = GizmoMeshRestoreInfo.call(this, 1) || this;
        _this.points = points;
        return _this;
    }
    return LineRestoreInfo;
}(GizmoMeshRestoreInfo);

var GizmoMesh = /*#__PURE__*/ function() {
    function GizmoMesh() {}
    GizmoMesh.createCircle = function createCircle(engine, center, normal, startPoint, thetaLength) {
        if (center === void 0) center = new Vector3();
        if (normal === void 0) normal = new Vector3(0, 0, 1);
        if (startPoint === void 0) startPoint = new Vector3(1.6, 0, 0);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        var mesh = new ModelMesh(engine);
        GizmoMesh.updateCircle(mesh, startPoint, normal, thetaLength, center);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleRestoreInfo(startPoint, normal, thetaLength, center)));
        return mesh;
    };
    GizmoMesh.updateCircle = function updateCircle(mesh, startPoint, normal, thetaLength, center, /**
     * segments per half Pi
     */ segmentFactor) {
        if (startPoint === void 0) startPoint = new Vector3(1.6, 0, 0);
        if (normal === void 0) normal = new Vector3(0, 0, 1);
        if (thetaLength === void 0) thetaLength = Math.PI / 2;
        if (center === void 0) center = new Vector3();
        if (segmentFactor === void 0) segmentFactor = 16;
        var newSegments = Math.abs(Math.ceil(segmentFactor * thetaLength / Math.PI));
        var segments = Math.max(6, newSegments);
        var indices = new Uint16Array(segments * 3);
        var vertices = [];
        // indices
        for(var i = 1; i <= segments; i++){
            var start = (i - 1) * 3;
            indices[start] = i;
            indices[start + 1] = i + 1;
            indices[start + 2] = 0;
        }
        // vertices
        vertices.push(center);
        for(var s = 0; s <= segments; s++){
            var segment = s / segments * thetaLength;
            Quaternion.rotationAxisAngle(normal, segment, GizmoMesh._tempQuat);
            Vector3.transformByQuat(startPoint, GizmoMesh._tempQuat, GizmoMesh._tempVect);
            vertices[s + 1] = GizmoMesh._tempVect.clone();
        }
        GizmoMesh._initialize(mesh, vertices, indices, MeshTopology.Triangles);
    };
    GizmoMesh.createCircleTube = function createCircleTube(engine, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var mesh = new ModelMesh(engine);
        GizmoMesh.updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new CircleTubeRestoreInfo(arc, radius, tubeRadius, tubularSegments, radialSegments)));
        return mesh;
    };
    GizmoMesh.updateCircleTube = function updateCircleTube(mesh, arc, radius, tubeRadius, tubularSegments, radialSegments) {
        if (arc === void 0) arc = Math.PI;
        if (radius === void 0) radius = 1.6;
        if (tubeRadius === void 0) tubeRadius = 0.02;
        if (tubularSegments === void 0) tubularSegments = 48;
        if (radialSegments === void 0) radialSegments = 6;
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = new Uint16Array(rectangleCount * 6);
        var vertices = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        var offset = 0;
        for(var i = 0; i <= radialSegments; i++){
            for(var j = 0; j <= tubularSegments; j++){
                var u = j / tubularSegments * arc;
                var v = i / radialSegments * Math.PI * 2;
                var cosV = Math.cos(v);
                var sinV = Math.sin(v);
                var cosU = Math.cos(u);
                var sinU = Math.sin(u);
                var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
                vertices[offset] = position;
                var centerX = radius * cosU;
                var centerY = radius * sinU;
                normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
                uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);
            }
        }
        offset = 0;
        for(var i1 = 1; i1 <= radialSegments; i1++){
            for(var j1 = 1; j1 <= tubularSegments; j1++){
                var a = (tubularSegments + 1) * i1 + j1 - 1;
                var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
                var c = (tubularSegments + 1) * (i1 - 1) + j1;
                var d = (tubularSegments + 1) * i1 + j1;
                indices[offset++] = a;
                indices[offset++] = b;
                indices[offset++] = d;
                indices[offset++] = b;
                indices[offset++] = c;
                indices[offset++] = d;
            }
        }
        var bounds = mesh.bounds;
        var outerRadius = radius + tubeRadius;
        bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
        bounds.max.set(outerRadius, outerRadius, tubeRadius);
        GizmoMesh._initialize(mesh, vertices, indices, MeshTopology.Triangles, normals, uvs);
    };
    GizmoMesh.createLine = function createLine(engine, points) {
        var mesh = new ModelMesh(engine);
        GizmoMesh.updateLine(mesh, points);
        engine.resourceManager.addContentRestorer(new GizmoMeshRestorer(mesh, new LineRestoreInfo(points)));
        return mesh;
    };
    GizmoMesh.updateLine = function updateLine(mesh, points) {
        var vertices = points;
        var indices = new Uint8Array(vertices.length);
        for(var i = 0; i < vertices.length; i++){
            indices[i] = i;
        }
        GizmoMesh._initialize(mesh, vertices, indices, MeshTopology.Lines);
    };
    GizmoMesh._initialize = function _initialize(mesh, vertices, indices, meshTopology, normals, uvs) {
        mesh.setPositions(vertices);
        mesh.setIndices(indices);
        normals && mesh.setNormals(normals);
        uvs && mesh.setUVs(uvs);
        mesh.clearSubMesh();
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length, meshTopology);
    };
    return GizmoMesh;
}();
GizmoMesh._tempQuat = new Quaternion();
GizmoMesh._tempVect = new Vector3();

export { CircleRestoreInfo as C, GizmoMesh as G, LineRestoreInfo as L, GizmoMeshRestorer as a, GizmoMeshRestoreInfo as b, CircleTubeRestoreInfo as c };
//# sourceMappingURL=GizmoMesh-b318dff0.js.map
