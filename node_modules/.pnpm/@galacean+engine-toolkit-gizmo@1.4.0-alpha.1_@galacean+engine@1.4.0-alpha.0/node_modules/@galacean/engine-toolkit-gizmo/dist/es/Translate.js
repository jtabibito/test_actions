import { _ as _inherits } from './_inherits-5a51c3d0.js';
import { _ as _create_for_of_iterator_helper_loose } from './_create_for_of_iterator_helper_loose-e17e7001.js';
import { Matrix, Vector3, Plane } from '@galacean/engine';
import { Axis } from './Axis.js';
import { Utils } from './Utils.js';
import { axisType, axisVector, axisPlane, GizmoComponent } from './Type.js';
import { State } from './enums/GizmoState.js';
import './GizmoMesh-b318dff0.js';
import '@galacean/engine-toolkit-custom-material';

/** @internal */ var TranslateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(TranslateControl, GizmoComponent);
    function TranslateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._scale = 1;
        _this._preMatrix = new Matrix();
        _this._startGroupMatrix = new Matrix();
        _this._startInvMatrix = new Matrix();
        _this._startScale = 1;
        _this._startPoint = new Vector3();
        _this._currPoint = new Vector3();
        _this._plane = new Plane();
        _this._tempVec0 = new Vector3();
        _this._tempVec1 = new Vector3();
        _this._tempVec2 = new Vector3();
        _this._tempMat = new Matrix();
        _this._tempScale = 1;
        _this.type = State.translate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = TranslateControl.prototype;
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        // get gizmo start worldPosition
        this._group.getWorldMatrix(this._startGroupMatrix);
        this._preMatrix.copyFrom(this._startGroupMatrix);
        Matrix.invert(this._startGroupMatrix, this._startInvMatrix);
        // get start scale
        this._startScale = this._scale;
        // get start point
        this._getHitPlane();
        this._calRayIntersection(ray, this._startPoint);
        // change axis color
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === this._selectedAxis) {
                currComponent.yellow && currComponent.yellow();
            } else {
                currComponent.gray && currComponent.gray();
            }
        }
    };
    _proto.onMove = function onMove(ray) {
        // transform ray to local space
        this._calRayIntersection(ray, this._currPoint);
        var currScale = this._scale;
        var _this = this, mat = _this._tempMat, subVec = _this._tempVec0, _startScale = _this._startScale;
        // eliminate the side effect of gizmo's scaling
        subVec.x = this._currPoint.x - this._startPoint.x / _startScale * currScale;
        subVec.y = this._currPoint.y - this._startPoint.y / _startScale * currScale;
        subVec.z = this._currPoint.z - this._startPoint.z / _startScale * currScale;
        var localAxis = axisVector[this._selectedAxis];
        mat.identity();
        mat.elements[12] = subVec.x * localAxis.x;
        mat.elements[13] = subVec.y * localAxis.y;
        mat.elements[14] = subVec.z * localAxis.z;
        Matrix.multiply(this._startGroupMatrix, mat, mat);
        this._group.applyTransform(this._preMatrix, mat);
        this._preMatrix.copyFrom(mat);
        this.engine.dispatch("gizmo-move", "translate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        // recover axis cover
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            currComponent.recover && currComponent.recover();
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onSwitch = function onSwitch() {
        this._resizeControl();
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {
        switch(axisName){
            case "x":
                this._changeAxisAlpha("x", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "y":
                this._changeAxisAlpha("y", value);
                this._changeAxisAlpha("xy", value);
                this._changeAxisAlpha("xz", value);
                break;
            case "z":
                this._changeAxisAlpha("z", value);
                this._changeAxisAlpha("xz", value);
                this._changeAxisAlpha("yz", value);
                break;
        }
    };
    _proto._initAxis = function _initAxis() {
        this._translateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.redMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(0, 0, -90),
                    new Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new Vector3(0.75, 0, 0),
                    new Vector3(1.5, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.greenMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(0, 90, 0),
                    new Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0.75, 0),
                    new Vector3(0, 1.5, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.lineMesh,
                    Utils.axisArrowMesh
                ],
                axisMaterial: Utils.blueMaterialTrans,
                axisHelperMesh: [
                    Utils.axisHelperLineMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(0, 90, 90),
                    new Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0.75),
                    new Vector3(0, 0, 1.5)
                ]
            },
            {
                name: "xy",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightBlueMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new Vector3(0.5, 0.5, 0)
                ]
            },
            {
                name: "yz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightRedMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(90, 90, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0.5, 0.5)
                ]
            },
            {
                name: "xz",
                axisMesh: [
                    Utils.axisPlaneMesh
                ],
                axisMaterial: Utils.lightGreenMaterial,
                axisHelperMesh: [
                    Utils.axisHelperPlaneMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialTrans,
                axisRotation: [
                    new Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0.5, 0, 0.5)
                ]
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        var axisX = this.gizmoEntity.createChild("x");
        var axisY = this.gizmoEntity.createChild("y");
        var axisZ = this.gizmoEntity.createChild("z");
        var axisXY = this.gizmoEntity.createChild("xy");
        var axisYZ = this.gizmoEntity.createChild("yz");
        var axisXZ = this.gizmoEntity.createChild("xz");
        this._translateAxisComponent = [
            axisX.addComponent(Axis),
            axisY.addComponent(Axis),
            axisZ.addComponent(Axis),
            axisXY.addComponent(Axis),
            axisYZ.addComponent(Axis),
            axisXZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._translateControlMap.length; i++){
            var currentComponent = this._translateAxisComponent[i];
            var currentGeometry = this._translateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
    };
    _proto._getHitPlane = function _getHitPlane() {
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var _this = this, centerP = _this._tempVec0, crossP = _this._tempVec1, cameraP = _this._tempVec2;
                cameraP.copyFrom(this._camera.entity.transform.worldPosition);
                cameraP.transformToVec3(this._startInvMatrix);
                var localAxis = axisVector[this._selectedAxis];
                Vector3.cross(cameraP, localAxis, crossP);
                Plane.fromPoints(localAxis, centerP.set(0, 0, 0), crossP, this._plane);
                break;
            case axisType.xy:
            case axisType.yz:
            case axisType.xz:
                this._plane.copyFrom(axisPlane[this._selectedAxis]);
                break;
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        var worldToLocal = this._startInvMatrix;
        Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(this._plane), out);
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        var _this = this, _tempMat = _this._tempMat, _tempVec0 = _this._tempVec0;
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldMatrix(_tempMat);
        if (this._camera.isOrthographic) {
            this._tempScale = this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            _tempVec0.set(_tempMat.elements[12], _tempMat.elements[13], _tempMat.elements[14]);
            this._tempScale = this._scale = Vector3.distance(cameraPosition, _tempVec0) * Utils.scaleFactor;
        }
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = _tempMat.scale(_tempVec0.set(this._tempScale, this._tempScale, this._tempScale));
    };
    _proto._changeAxisAlpha = function _changeAxisAlpha(axisName, value) {
        var entity = this.gizmoEntity.findByName(axisName);
        if (entity) {
            var component = entity.getComponent(Axis);
            component.alpha(value);
        }
    };
    return TranslateControl;
}(GizmoComponent);

export { TranslateControl };
//# sourceMappingURL=Translate.js.map
