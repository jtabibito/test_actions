import { _ as _inherits } from './_inherits-5a51c3d0.js';
import { _ as _create_for_of_iterator_helper_loose } from './_create_for_of_iterator_helper_loose-e17e7001.js';
import { Vector3, MeshRenderer, Matrix, MathUtil } from '@galacean/engine';
import { Axis } from './Axis.js';
import { Utils } from './Utils.js';
import { axisType, axisVector, axisPlane, GizmoComponent } from './Type.js';
import { G as GizmoMesh } from './GizmoMesh-b318dff0.js';
import { State } from './enums/GizmoState.js';
import '@galacean/engine-toolkit-custom-material';

/** @internal */ var RotateControl = /*#__PURE__*/ function(GizmoComponent) {
    _inherits(RotateControl, GizmoComponent);
    function RotateControl(entity) {
        var _this;
        _this = GizmoComponent.call(this, entity) || this;
        _this._rotateAxisComponent = [];
        _this._rotateControlMap = [];
        _this._isModified = false;
        _this._startLineMesh = GizmoMesh.createLine(_this.engine, [
            new Vector3(0, 0, 0),
            new Vector3(0, 0, 0)
        ]);
        _this._endLineMesh = GizmoMesh.createLine(_this.engine, [
            new Vector3(0, 0, 0),
            new Vector3(0, 0, 0)
        ]);
        _this._rotateHelperPlaneMesh = GizmoMesh.createCircle(_this.engine);
        _this._preMatrix = new Matrix();
        _this._startMatrix = new Matrix();
        _this._startInvMatrix = new Matrix();
        _this._startPointUnit = new Vector3();
        _this._currPointUnit = new Vector3();
        _this._cameraPos = new Vector3();
        _this._previousRad = 0;
        _this._finalRad = 0;
        _this._verticalAxis = new Vector3(0, 1, 0);
        _this._horizontalAxis = new Vector3();
        _this._speedFactor = 0.01;
        _this._tempMat = new Matrix();
        _this._tempMat2 = new Matrix();
        _this._tempVec = new Vector3();
        _this._tempVec2 = new Vector3();
        _this._tempVec30 = new Vector3();
        _this._tempVec31 = new Vector3();
        _this._tempVec32 = new Vector3();
        _this._tempMat41 = new Matrix();
        _this._isAtBack = false;
        _this.type = State.rotate;
        _this._initAxis();
        _this._createAxis(entity);
        return _this;
    }
    var _proto = RotateControl.prototype;
    /** init axis geometry */ _proto._initAxis = function _initAxis() {
        this._rotateControlMap = [
            {
                name: "x",
                axisMesh: [
                    Utils.axisXTorusMesh
                ],
                axisMaterial: Utils.redArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new Vector3(0, 90, 90)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0)
                ]
            },
            {
                name: "y",
                axisMesh: [
                    Utils.axisYTorusMesh
                ],
                axisMaterial: Utils.greenArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new Vector3(90, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0)
                ]
            },
            {
                name: "z",
                axisMesh: [
                    Utils.axisZTorusMesh
                ],
                axisMaterial: Utils.blueArcMaterial,
                axisHelperMesh: [
                    Utils.axisHelpertorusMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialRotate,
                axisRotation: [
                    new Vector3(0, 0, -90)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0)
                ]
            },
            {
                name: "xyz",
                axisMesh: [
                    Utils.axisXYZTorusMesh
                ],
                axisMaterial: Utils.lightMaterial,
                axisHelperMesh: [
                    Utils.axisSphereMesh
                ],
                axisHelperMaterial: Utils.invisibleMaterialCircle,
                axisRotation: [
                    new Vector3(0, 0, 0)
                ],
                axisTranslation: [
                    new Vector3(0, 0, 0)
                ],
                priority: 99
            }
        ];
    };
    _proto._createAxis = function _createAxis(entity) {
        // visible gizmo entity
        this.gizmoEntity = entity.createChild("visible");
        this.gizmoHelperEntity = entity.createChild("invisible");
        this._axisX = this.gizmoEntity.createChild("x");
        this._axisY = this.gizmoEntity.createChild("y");
        this._axisZ = this.gizmoEntity.createChild("z");
        this._axisXYZ = this.gizmoEntity.createChild("xyz");
        this._rotateAxisComponent = [
            this._axisX.addComponent(Axis),
            this._axisY.addComponent(Axis),
            this._axisZ.addComponent(Axis),
            this._axisXYZ.addComponent(Axis)
        ];
        for(var i = 0; i < this._rotateControlMap.length; i++){
            var currentComponent = this._rotateAxisComponent[i];
            var currentGeometry = this._rotateControlMap[i];
            currentComponent.initAxis(currentGeometry);
        }
        var axisHelpers = this.gizmoHelperEntity.children;
        this._axisXHelper = axisHelpers[0];
        this._axisYHelper = axisHelpers[1];
        this._axisZHelper = axisHelpers[2];
        this._axisXYZHelper = axisHelpers[3];
        // rotate gizmo in-process debug helper entity
        this._gizmoRotateHelperEntity = entity.createChild("helper");
        // rotate start line
        this._startLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperS");
        var startHelperRenderer = this._startLineHelperEntity.addComponent(MeshRenderer);
        startHelperRenderer.receiveShadows = false;
        startHelperRenderer.castShadows = false;
        startHelperRenderer.mesh = this._startLineMesh;
        startHelperRenderer.setMaterial(Utils.yellowMaterial);
        startHelperRenderer.priority = 90;
        // rotate end line
        this._endLineHelperEntity = this._gizmoRotateHelperEntity.createChild("lineHelperE");
        var endHelperRenderer = this._endLineHelperEntity.addComponent(MeshRenderer);
        endHelperRenderer.receiveShadows = false;
        endHelperRenderer.castShadows = false;
        endHelperRenderer.mesh = this._endLineMesh;
        endHelperRenderer.setMaterial(Utils.yellowMaterial);
        endHelperRenderer.priority = 90;
        // rotate plane
        this._rotateHelperPlaneEntity = this._gizmoRotateHelperEntity.createChild("rotateHelperPlane");
        var planeHelperRenderer = this._rotateHelperPlaneEntity.addComponent(MeshRenderer);
        planeHelperRenderer.receiveShadows = false;
        planeHelperRenderer.castShadows = false;
        planeHelperRenderer.mesh = this._rotateHelperPlaneMesh;
        // @ts-ignore
        this._rotateHelperPlaneMesh._enableVAO = false;
        planeHelperRenderer.setMaterial(Utils.rotatePlaneMaterial);
        planeHelperRenderer.priority = 90;
        this._rotateHelperPlaneEntity.isActive = false;
    };
    _proto.init = function init(camera, group) {
        this._camera = camera;
        this._group = group;
    };
    _proto.onHoverStart = function onHoverStart(axisName) {
        if (this._selectedAxis === axisType[axisName]) return;
        this.onHoverEnd();
        this._selectedAxis = axisType[axisName];
        var currEntity = this.gizmoEntity.findByName(axisName);
        var currComponent = currEntity.getComponent(Axis);
        currComponent.highLight && currComponent.highLight();
    };
    _proto.onHoverEnd = function onHoverEnd() {
        var axesEntity = this.gizmoEntity.children;
        for(var _iterator = _create_for_of_iterator_helper_loose(axesEntity), _step; !(_step = _iterator()).done;){
            var entity = _step.value;
            var component = entity.getComponent(Axis);
            component.unLight && component.unLight();
        }
        this._selectedAxis = null;
    };
    _proto.onMoveStart = function onMoveStart(ray, axisName) {
        this._selectedAxis = axisType[axisName];
        var _this = this, group = _this._group, startP = _this._startPointUnit, startMat = _this._startMatrix, tempVec = _this._tempVec, tempMat = _this._tempMat;
        group.getWorldMatrix(startMat);
        this._preMatrix.copyFrom(startMat);
        Matrix.invert(startMat, this._startInvMatrix);
        var s = this._getGizmoScale();
        this._tempMat.copyFrom(startMat).scale(tempVec.set(s, s, s));
        this.gizmoEntity.transform.worldMatrix = tempMat;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._gizmoRotateHelperEntity.transform.worldMatrix = tempMat;
                this._calRayIntersection(ray, startP);
                this._setAxisSelected(this._selectedAxis, true);
                GizmoMesh.updateLine(this._startLineMesh, [
                    new Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateLine(this._endLineMesh, [
                    new Vector3(0, 0, 0),
                    startP
                ]);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, axisVector[axisName], 0);
                this._startLineHelperEntity.isActive = true;
                this._endLineHelperEntity.isActive = true;
                this._rotateHelperPlaneEntity.isActive = true;
                this._startLineHelperEntity.transform.setRotation(0, 0, 0);
                this._endLineHelperEntity.transform.setRotation(0, 0, 0);
                this._rotateHelperPlaneEntity.transform.setRotation(0, 0, 0);
                break;
            case axisType.xyz:
                this.gizmoHelperEntity.transform.worldMatrix = tempMat;
                this._setAxisSelected(this._selectedAxis, true);
                this._isAtBack = this.gizmoEntity.transform.worldUp.y < 0;
                this._isAtBack ? this._verticalAxis.set(0, -1, 0) : this._verticalAxis.set(0, 1, 0);
                break;
        }
    };
    _proto.onMove = function onMove(ray, pointer) {
        var _this = this, startP = _this._startPointUnit, currP = _this._currPointUnit, startMat = _this._startMatrix, mat = _this._tempMat2, group = _this._group, tempVec = _this._tempVec;
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                var localAxis = axisVector[this._selectedAxis];
                this._calRayIntersection(ray, currP);
                var rad = this._getFinalRad(startP, currP, localAxis);
                GizmoMesh.updateCircle(this._rotateHelperPlaneMesh, startP, localAxis, rad);
                Matrix.rotateAxisAngle(startMat, localAxis, rad, mat);
                group.applyTransform(this._preMatrix, mat);
                this._preMatrix.copyFrom(mat);
                var d = rad / Math.PI * 180;
                this._endLineHelperEntity.transform.setRotation(d * localAxis.x, d * localAxis.y, d * localAxis.z);
                break;
            case axisType.xyz:
                var _pointer_deltaPosition = pointer.deltaPosition, x = _pointer_deltaPosition.x, y = _pointer_deltaPosition.y;
                var _this1 = this, hAxis = _this1._horizontalAxis, vAxis = _this1._verticalAxis;
                hAxis.copyFrom(this._camera.entity.transform.worldUp);
                Vector3.cross(hAxis, vAxis, hAxis);
                this._isAtBack ? hAxis.scale(-y) : hAxis.scale(y);
                tempVec.copyFrom(vAxis);
                this._isAtBack ? tempVec.scale(-x) : tempVec.scale(x);
                Vector3.add(hAxis, tempVec, tempVec);
                Vector3.transformNormal(tempVec, this._startInvMatrix, tempVec);
                var angle = pointer.deltaPosition.length() * this._speedFactor;
                Matrix.rotateAxisAngle(startMat, tempVec, angle, startMat);
                group.applyTransform(this._preMatrix, startMat);
                this._preMatrix.copyFrom(startMat);
                Matrix.invert(startMat, this._startInvMatrix);
                break;
        }
        this.engine.dispatch("gizmo-move", "rotate");
    };
    _proto.onMoveEnd = function onMoveEnd() {
        this._finalRad = 0;
        this._previousRad = 0;
        // recover axis color
        this._setAxisSelected(this._selectedAxis, false);
        // recover arc line
        var axisMesh = this._rotateControlMap[this._selectedAxis].axisMesh[0];
        switch(this._selectedAxis){
            case axisType.x:
            case axisType.y:
            case axisType.z:
                GizmoMesh.updateCircleTube(axisMesh, Math.PI);
                // hide helper entity
                this._endLineHelperEntity.isActive = false;
                this._startLineHelperEntity.isActive = false;
                this._rotateHelperPlaneEntity.isActive = false;
                break;
            case axisType.xyz:
                GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI, 1.8);
                break;
        }
    };
    _proto.onUpdate = function onUpdate(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
        this._updateAxisTransform();
    };
    _proto.onSwitch = function onSwitch(isModified) {
        if (isModified === void 0) isModified = false;
        this._resizeControl(isModified);
    };
    _proto.onAlphaChange = function onAlphaChange(axisName, value) {};
    _proto._setAxisSelected = function _setAxisSelected(axis, isSelected) {
        var axisMesh = this._rotateControlMap[axis].axisMesh[0];
        GizmoMesh.updateCircleTube(axisMesh, 2 * Math.PI);
        var entityArray = this.gizmoEntity.children;
        for(var i = 0; i < entityArray.length; i++){
            var currEntity = entityArray[i];
            var currComponent = currEntity.getComponent(Axis);
            if (axisType[currEntity.name] === axis) {
                if (isSelected) {
                    currComponent.yellow && currComponent.yellow();
                } else {
                    currComponent.recover && currComponent.recover();
                }
            }
        }
    };
    _proto._calRayIntersection = function _calRayIntersection(ray, out) {
        // transform ray to local space
        var worldToLocal = this._startInvMatrix;
        Vector3.transformCoordinate(ray.origin, worldToLocal, ray.origin);
        Vector3.transformNormal(ray.direction, worldToLocal, ray.direction);
        ray.getPoint(ray.intersectPlane(axisPlane[this._selectedAxis]), out);
        out.normalize().scale(Utils.rotateCircleRadius);
    };
    _proto._getFinalRad = function _getFinalRad(p1, p2, rotateAxis) {
        var dot = Vector3.dot(p1, p2);
        Vector3.cross(p1, p2, this._tempVec);
        var direction = Vector3.dot(this._tempVec, rotateAxis);
        var currentRad = Math.sign(direction) * Math.acos(dot / Math.pow(Utils.rotateCircleRadius, 2));
        var incrementRad = currentRad - this._previousRad;
        if (this._previousRad * currentRad < 0) {
            Math.abs(currentRad) < Math.PI / 2 ? this._finalRad += incrementRad : this._finalRad += -Math.sign(incrementRad) * (2 * Math.PI - Math.abs(incrementRad));
        } else {
            this._finalRad += incrementRad;
        }
        this._previousRad = currentRad;
        return this._finalRad;
    };
    _proto._getGizmoScale = function _getGizmoScale() {
        var cameraPosition = this._camera.entity.transform.worldPosition;
        this._group.getWorldPosition(this._tempVec);
        if (this._camera.isOrthographic) {
            return this._isModified ? this._camera.orthographicSize * Utils.scaleFactor * 3 * 0.8 : this._camera.orthographicSize * Utils.scaleFactor * 3;
        } else {
            return this._isModified ? Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor * 0.8 : Vector3.distance(cameraPosition, this._tempVec) * Utils.scaleFactor;
        }
    };
    _proto._updateAxisTransform = function _updateAxisTransform() {
        var _this = this, _tempMat = _this._tempMat, _tempVec = _this._tempVec, _tempVec2 = _this._tempVec2, _cameraPos = _this._cameraPos;
        // 相机位置
        _cameraPos.copyFrom(this._camera.entity.transform.worldPosition);
        var gizmoTrans = this.gizmoEntity.transform;
        // 获取参照向量(Gizmo 中点 -> 相机)（世界坐标）
        Vector3.subtract(_cameraPos, gizmoTrans.worldPosition, _tempVec);
        // 逆矩阵（世界 -> Gizmo）
        Matrix.invert(gizmoTrans.worldMatrix, _tempMat);
        // 将向量(Gizmo 中点 -> 相机)映射到 Gizmo 坐标系中，此处 XYZ 局部向量是相同的
        Vector3.transformNormal(_tempVec, _tempMat, _tempVec2);
        var factor = MathUtil.radToDegreeFactor;
        var x = _tempVec2.x, y = _tempVec2.y, z = _tempVec2.z;
        // 用 yoz 投影计算 X 轴的局部旋转
        this._axisX.transform.rotation.x = this._axisXHelper.transform.rotation.x = -Math.atan2(y, z) * factor;
        // 用 xoz 投影计算 Y 轴的局部旋转
        this._axisY.transform.rotation.y = this._axisYHelper.transform.rotation.y = Math.atan2(x, z) * factor;
        // 用 yox 投影计算 Z 轴的局部旋转
        this._axisZ.transform.rotation.z = this._axisZHelper.transform.rotation.z = Math.atan2(y, x) * factor;
        // xyz 投影
        this._localLookAt(this._axisXYZ.transform, _tempVec2);
        this._axisXYZHelper.transform.rotationQuaternion = this._axisXYZ.transform.rotationQuaternion;
    };
    _proto._resizeControl = function _resizeControl(isModified) {
        if (isModified === void 0) isModified = false;
        this._group.getWorldMatrix(this._tempMat);
        this._isModified = isModified;
        var s = this._getGizmoScale();
        this.gizmoEntity.transform.worldMatrix = this.gizmoHelperEntity.transform.worldMatrix = this._tempMat.scale(this._tempVec.set(s, s, s));
    };
    _proto._localLookAt = function _localLookAt(transform, targetPosition) {
        var zAxis = this._tempVec30;
        Vector3.subtract(transform.position, targetPosition, zAxis);
        zAxis.normalize();
        var xAxis = this._tempVec31.set(zAxis.z, 0, -zAxis.x).normalize();
        var yAxis = this._tempVec32;
        Vector3.cross(zAxis, xAxis, yAxis);
        yAxis.normalize();
        var rotMat = this._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(transform.rotationQuaternion);
    };
    return RotateControl;
}(GizmoComponent);

export { RotateControl };
//# sourceMappingURL=Rotate.js.map
